{"text":"CHAPTER 1\nBasics of Python Programming\nowadays, Python is one of the most popular programming languages. There\nN\nare many reasons for this, but simply it is easy to read and write Python\ncode. Python provides vast libraries for which you can efficiently make your\nprogram. In this chapter, you will see various features, installation, and the\nmaking of a simple program of Python.\nStructure\nIn this chapter, we will cover the following topics:\nBasic features and history of Python\nInstalling Python and running Python program to IDE\nWriting and executing first Python program\nBrief description about various concepts used in Python\nObjective\nThe objective of this chapter is to introduce the concept of Python, its features,\nand the Installation procedure in Windows and Linux. After completing this\nchapter, you should be familiar with Python IDE and editors. Also, you will be\nable to write simple Python programs.\nUnderstanding Python\nPython is one of the high-level languages. There are various advantages of high-\nlevel languages:\nProgram is easier and understandable which is written in a high-level\nlanguage\nProgram is shorter in a high-level language\nThe code written in a high-level language is portable, which means it can\nrun on different computers with some modifications. Due to these preceding advantages, almost all programs are written in high-level\nlanguages. Guido van Rossum designed Python in 1991; after that, Python\nreleased various versions as shown in table 1.1:\nPython Version Released Year\n3.9 2020\n3.8 2019\n3.7 2018\n3.6 2016\n2.7 2010\nTable 1.1: Python versions with released year\nThe compiler completes the task which is involved in the compilation process.\nMoreover, it converts a source code to object code, and after that, the program\nwill be converted to machine understandable code. But an interpreter reads a\nhigh-level program and executes it. Python does not follow the compilation\nprocess; it is used only as an interpreter. That's why from a computation point of\nview, Python is very fast. The figures can easily understand it.\nHere figure 1.1 shows the structure of the compiler. A compiler translates\nsource code into an object code, which a hardware executor runs: Figure 1.1: Structure of Compiler\nHere figure 1.2, shows the structure of the interpreter. An interpreter processes\nthe program in less time, and it also takes less time to read lines and perform\ncomputations: Figure 1.2: Structure of Interpreter\nPython is an interpreted language because an interpreter executes Python\nprograms, but the compilation process is also done in Python. The compilation\npart is hidden from the programmer that is why it is known as an interpreted\nlanguage.\nThere are various reasons Python has become more popular:\nIt is easy to use because its coding is written in a simple English language.\nUsers can easily understand and write code into Python, so it takes less\ntime to write a program.\nIt is a very powerful language because it has many libraries where you can\neasily make a program. An inbuilt library has lots of inbuilt functions\nwhere you can insert as per your need.\nIt is an object-oriented programming language that is why it follows all the\nobject-oriented concepts.\nIt is integrated with other programming languages such as C, C++, Java,\netc.\nIt is platform-independent, which means if you created a program in one\noperating system, you could also run that program in another operating\nsystem.\nIt is free and open-source, which means you can install it on your computer\nwithout any cost. It can be copied or modified and resold accordingly. This\nis a solid reason why Python has become more popular. Installing Python\nIt works with various operating systems Windows, Linux, macOS, etc. If you\nwant to work in Python, it needs permission from the Python interpreter. Python\nis available on the website Python.org. Download the right installer for your\noperating system and run it on the computer. This figure shows a clear\nunderstanding of the installer of Python. You can choose the Python installer\naccording to the operating system:\nFigure 1.3: Installation Page of Python\nWindows\nThere are various steps for installing Python in Windows. Python does not come\npreinstalled in Windows systems. However, installing Python is a\nstraightforward process. All you need to do is to download the Python installer\nfrom the website, https:\/\/www.python.org\/, and then run the program. Here are\nthe steps to install it on Windows:\nDownloading the Python installer from https:\/\/www.python.org\/,\n1. Select a Python version: Figure 1.4: Python versions\n2. Select Windows 64-bit or 32-bit Windows:\nFigure 1.5: Installation Setup of Python\n3. Run the Installer.\nDon't forget to click the box that indicates Add Python Version to PATH\nthis will confirm that the interpreter is added to the execution path. The\nfinal step is to click Install now, and these are all the required steps: Figure 1.6: Running the Installer\nThe figure 1.6 shows various optional features during installation. We can\nselect these features as required:\nFigure 1.7: Various Options in Python setup 4. After selecting various features next window shows advanced options,\nwhich are shown in figure 1.7. Here, installation location also needs to be\nselected:\nFigure 1.8: Processing of Python Setup\nThe figure 1.8 shows the installation setup progress; after completion of\nthis step, Python will be successfully installed in the system: Figure 1.9: Completion of Python setup\n5. The figure 1.9 shows the completion of the Python setup in the system.\nNow the system is ready to use Python. Python application can be opened\nby searching from the taskbar; it is shown in figure 1.10: Figure 1.10: Open Python application\nUbuntu\nThere are different versions of the Ubuntu distribution, and the installations are\ndifferent. Moreover, most factory versions of Ubuntu 18.04 or Ubuntu 20.04\ncome with Python preinstalled; first of all, check your version with the following\ncommands and enter this command on the terminal:\npython -version\nUpdate and refresh repository lists\nThe next step is to update and refresh the list of the repository with the following\ncommand:\nsudo apt update\nInstallation of supporting software\nThere is a following command:\nsudo apt install software-properties-common\nAdd Deadsnakes PPA ((Personal Package Archive)) There is a following command:\nsudo add-apt-repository ppa:deadsnakes\/ppa\nThe system will prompt you to press Enter to continue. Do so, and allow it to\nfinish. Refresh the package lists again:\nsudo apt update\nInstall Python 3\nNow you can start the installation of Python 3.9 with the command:\nsudo apt install python3.9\nAllow the process to complete and verify if the Python version was installed\nsuccessfully:\npython -version\nThe preceding command shows the current version of Python:\nFigure 1.11: Python installation through sudo command on Ubuntu\nLinux Mint\nInstallation of Mint is similar to Ubuntu, and installation instruction for Ubuntu\ncan also be used in Mint. A deadsnakes\/ppa working well with Mint.\nPython IDLE\nPython introduces IDLE, which means Integrated Development and Learning\nEnvironment. By default, Python contains the IDLE module for windows, and it\nis not contained in Linux. A development environment provides an interactive platform that contains various tools that makes a program straightforward. There\nare two types of modes in IDLE which is interactive mode and script mode:\nFigure 1.12: Python on Search Bar\nThe preceding figure 1.12 shows how Python IDE can search through the search\nbar: Figure 1.13: Python Shell\nThere are various types of IDEs are available for Python. Various kinds of IDEs\nare commercial and freely available such as PyCharm, Kite, Spyder, DLE,\nVisual Studio Code, Atom, Jupyter, Pydev, Thonny, and many more. Here, we\nwill learn how to use some open-source editors to execute Python scripts or\nstatements.\nAnaconda open-source distribution\nIt is for Python and R programming languages. This distribution is freely\navailable. It contains various applications such as JupyterLab, Jupyter\nNotebook, QtConsole, Spyder, Glue, Orange, RStudio, and Visual Studio Code.\nThis distribution is for large-scale data processing, predictive analytics, and\nscientific computing. The advantage of Anaconda is the massive amount of\npackages inside it. It would be very easier to make a program and handle huge\ndata under time and space constraints. Figure 1.14: Anaconda Navigator\nWriting and executing first Python program\nThere are three ways to write and execute a Python program.\n1. Starting Python through Command Line\n2. Starting Python IDLE\n3. Starting Python through Spyder\/Jupyter Notebook in Anaconda Prompt\nStarting Python through command line\nIt can be writing a Python code through a command-line approach. When we can\nexecute Python expressions, statements, or instructions from the command line\nthen this type of mode is called interactive mode or interactive prompt. There\nare the following steps to start a Python code through the command line.\n1. Click the Start button as shown in figure 1.15: Figure 1.15: Start button\n2. Type Python 3.9 in the search space bar beside the Start button, as shown\nin figure 1.16: Figure 1.16: Python 3.9 (64-bit)\n3. Click to open Python 3.9 (64-bit). After that, a command prompt will be\nopen, as shown in figure 1.17: Figure 1.17: Python 3.9 (64-bit) Command prompt\n4. We can write any expression or statements over here. This is an interactive\nmode of Python command prompt. Here, we are writing our names through\nthe command prompt, as shown in figure 1.18:\nFigure 1.18: Python code through command prompt To exit the command line of Python 3.9, you can press Ctrl + z and press Enter\nkey or type then press Enter key.\nexit()\nStarting Python IDLE\nPython IDLE is another way to write and execute a Python program. It provides\nan interactive platform that contains various tools that can be used to write a\nprogram.\nThere are the following steps to start a Python through Python IDLE.\n1. Type in the search space bar beside the start button, as shown in\nIDLE\nfigure 1.19:\nFigure 1.19: IDLE (Python 3.9 64 bit)\n2. Click to open an IDLE (Python 3.9 64 bit). After that, an IDLE Shell will\nopen, as shown in figure 1.20: Figure 1.20: IDLE Shell\n3. We can write any expression or statement over here. This is an interactive\nmode of Python IDLE. Here, we are writing our names and some basic\nexpressions through this prompt, as shown in figure 1.21: Figure 1.21: Python code through IDLE Shell\nTo exit from an IDLE (Python 3.9 64 bit), type and press Ctrl + q.\nexit()\nStarting Python through Spyder in Anaconda\nPrompt\nIn this section, we are writing the first program on one of the IDE names Spyder.\nYou can install Spyder separately or through an anaconda prompt. Here we are\nusing Spyder through an anaconda prompt. There are the following steps to start Python through Spyder in Anaconda\nprompt.\n1. First of all, we have to install an anaconda prompt, then we simply type\nanaconda download on Google, as shown in figure 1.22:\nFigure 1.22: Anaconda search on Google\n2. Click Individual Edition-Anaconda link, or you can go through the\nfollowing URL www.anaconda.com\/products\/individual. The webpage\nwill open, and you can download and install Anaconda, as shown in figure\n1.23: Figure 1.23: Download Anaconda\n3. After installing Anaconda, you can type Anaconda Navigator in the search\nbar beside the start button, as shown in figure 1.24: Figure 1.24: Anaconda Navigator\n4. Click to open Anaconda Navigator. After that, the Anaconda Navigator\nwill be open, as shown in figure 1.25: Figure 1.25: Anaconda Navigator Snippet\n5. Click on the Spyder icon; after that, the Spyder application will be\nlaunched, as shown in figure 1.26:\nFigure 1.26: Spyder in Anaconda Navigator\n6. After clicking on Spyder applications, Spyder IDE will open, as shown in\nfigure 1.27:\nFigure 1.27: Spyder Home 7. In the Spyder IDE, the left window is used for writing codes. Here we can\nwrite python codes as shown in figure 1.28:\nFigure 1.28: Code on Spyder\nStarting Python through Jupyter Notebook\nThe following steps will be used to write a program in Jupyter notebook.\n1. Search Jupyter notebook from start menu as shown in the figure 1.29: Figure 1.29: Searching Jupyter Notebook\n2. After clicking on Jupyter Notebook, it will open as shown in figure 1.30:\nFigure 1.30: Jupyter Notebook\n3. Now, we will start a new notebook. For this, we will click on the new\nPython 3 notebook. The new option is available at the top-right corner of this window. The following figure 1.31 shows an example of a new\nnotebook:\nFigure 1.31: Opening a Notebook in Jupyter\n4. We can write Python codes in the notebook cells and execute them by\nclicking the Run button. The following figure 1.32, gives an example of\nwriting and executing Python codes: Figure 1.32: Writing codes in Jupyter\nWriting and saving Python programs\nThe following examples show how we create Python scripts, save and execute\nthem in different Python editors.\nExample 1.1:\n# Display a Name\nprint (\"Dr. Brijesh Bakariya\")\n#Function displaying a name\nOutput:\nDr. Brijesh Bakariya\nThe Python file's file extension is , so it must be saved by the extension\n.py .py\nand the code should be executed.\nExample 1.2:\n# Program for the addition of two numbers\nnum1 = 10\nnum2 = 20\n# Add two numbers\nsum = num1 + num2\n# Display the sum\nprint ('The sum of {0} and {1} is {2}'.format(num1, num2, sum))\nOutput:\nThe sum of 10 and 20 is 30\nExample 1.3:\n# Program for addition of two numbers with user input\n# input() for taking input from user\nnum1 = input('Enter first number: ')\nnum2 = input('Enter second number: ')\n# Add two numbers\nsum = float(num1) + float(num2) # Display the sum\nprint ('The sum of {0} and {1} is {2}'.format(num1, num2, sum))\nOutput:\nThe sum of 12.6 and 66.2 is 78.8\nValue and types\nA value is a small part of the program. It could be a number or a letter. For\nexample, we have an integer number 10, 20 that means this is a value and letter\n, is a letter or a string. It is also called a string of letters, this\nBrijesh Bakariya\nis enclosed in quotation marks.\nThe function tells the type of a value. Let us take some examples where\ntype()\nit could be clearly understood.\nExample 1.4:\na=type('Amit Kumar')\nprint (a)\nb=type(17)\nprint (b)\nc= type(10.5)\nprint (c)\nOutput:\n<class 'str'>\n<class 'int'>\n<class 'float'>\nNumbers\nThis is one of the data types which contain numeric values. This is an immutable\ndata type, which means you can change the value of a number data type, and the\nresult will change.\nPython supports integers, floating-point numbers, and complex numbers. There\nare the following representations of a number data type in Python.\nThe integer represents as\nint Floating-point numbers represent\nfloat\nComplex numbers represent\ncomplex\nLet us take an example.\nExample 1.5:\na = 5\nprint (a)\nprint (type(a))\nb=15.2\nprint (b)\nprint (type(b))\nc = 3 + 2j\nprint (c + 3)\nprint (type(c))\nOutput:\n5\n<class 'int'>\n15.2\n<class 'float'>\n(6+2j)\n<class 'complex'>\nGetting input\nSomewhere we have to interact with the user, the method is used to get\ninput()\ninput from the user.\nWhen you use method, then this method uses a dialog box. It is a way\ninput()\nof asking the user to provide some type of input. There are two types of methods\nfor getting input from the user:\ninput (prompt)\nraw_input (prompt)\n: This function first takes the input from the user and then\ninput()\nevaluates the expression.\nThis method's beauty is that it is automatically identified whether the user\nentered a string or a number or list. If the input provided is not correct, then either syntax error or exception is raised by Python.\nLet's understand how the function works?\ninput()\nfunction executes and waits until the user has given input. The text or\ninput()\nmessage displays on the output screen. Whatever you enter as an input, the\nfunction converts it into a string. If you enter an integer value, still the\ninput()\nfunction converts it into a string. You need to explicitly convert it into\ninput()\nan integer in your code using typecasting.\nPython 3.6 uses the method, and here we are taking an example of\ninput()\nPython 3.6 or higher version.\nExample 1.6:\n# input() for taking input from user\nname = input('Enter your name: ')\nage = input('Enter your age: ')\nprint (name)\nprint (age)\nOutput:\nEnter your Name: Dr. Brijesh Bakariya\nEnter your age: 36\nDr. Brijesh Bakariya\n36\nExample 1.7:\n# get input from a user\nstr1 = input()\n# Getting input from a user without a prompt\nprint ('The inputted string 1 is: ', str1)\nstr2 = input('Enter a string: ')\n#Getting input from the user with a prompt\nprint ('The inputted string is:', str2)\nOutput:\nDr. Brijesh Bakariya\nThe inputted string 1 is: Dr. Brijesh Bakariya\nEnter a string:Dr. Krishna Kumar Mohbey The inputted string 2is: Dr. Krishna Kumar Mohbey\nPrinting\nIt is the simplest way to display the output on the screen. Python has a\nprint()\nmethod for output printing. We can pass zero or more function\nprint()\nexpression, but commas should separate the expressions. The function\nprint()\nconverts the expressions into a string before writing on the screen.\nThere is the following system of function.\nprint()\nSyntax: print(value(s), sep= ' ', end = '\\n', file=file,\nflush=flush)\nThe , , , , and are the parameters in which we can\nvalue(s) sep end file flush\npass it. There are the following descriptions of these parameters:\n: Any value, and as many as you like. It will be converted to a\nvalue(s)\nstring before printing.\n: (Optional) Specify how to separate the objects if there\nsep='separator'\nis more than .\none.Default:''\n: (Optional) Specify what to print at the .\nend='end' end.Default: '\\n'\n: (Optional) An object with a write method.\nfile Default:sys.stdout\n: (Optional) A Boolean, specifying if the output is flushed ( ) or\nflush True\nbuffered ( ).\nFalse\n: It returns output to the screen.\nreturns\nExample 1.8:\n# Use of print() function\nprint(\"Python is a programming language\")\nn1 = 10\n# Two objects are passed\nprint (\"n1 =\", 10)\nn2 = n1\n# Three objects are passed\nprint ('n1 =', n1, '= n2')\nOutput:\nPython is a programming language n1 = 10\nn1 = 10 = n2\nExample 1.9: The function with separator and end parameters:\nprint()\nn1 = 50\nprint (\"n1 =\", n1, sep='000', end='\\n\\n')\nprint (\"n1 =\", n1, sep='0', end='')\nOutput:\nn1 =00050\nn1 =050\nBoolean\nThe method is used to return or convert a value to a Boolean value, that\nbool()\nis, or , using the standard truth testing procedure.\nTrue False\nThis method generally takes one parameter based on the truth testing procedure.\nBy default, this returns , that is, no argument is passing. It returns if\nFalse True\nthe parameter or value is passed.\nThere are various ways in which Python's method returns . Except\nbool() False\nfor these, all other values return .\nTrue\nIf a False value is passed.\nIf None is passed.\nIf an empty sequence is passed, such as , , , etc.\n() [] \"\nIf Zero is passed in any numeric type, such as 0, 0.0, etc.\nIf an empty mapping is passed, such as .\n{}\nIf objects of classes having or method, returning 0\n__bool__() __len()__\nor False\nExample 1.10:\n# Different ways for printing Boolean values\n# Returns False as a is False\na = False\nprint(bool(a))\n# Returns True asa is True a= True\nprint(bool(a))\n# Returns False as a is not equal to b\na= 7\nb = 6\nprint (bool(a==b))\n# Returns False as a is None\na = None\nprint (bool(a))\n# Returns False as a is an empty sequence\na = ()\nprint (bool(a))\n# Returns False as a is an empty mapping\na = {}\nprint (bool(a))\n# Returns False as a is 0\na = 0.0\nprint(bool(a))\n# Returns True as a is a non-empty string\na = 'Brijesh'\nprint (bool(a))\nOutput:\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nLists\nA list is for placing all the data items in one place. Moreover, it is capable of\nstoring different data items in a single variable. All the variables in the list are contained in square brackets , separated by commas. Three more built-in data\n[]\ntypes work as a list, but there are some differences among them. Such data types\nare Tuple, Set, and Dictionary.\nThe list is a collection that is ordered and changeable. It allows duplicate\nmembers.\nA tuple is a collection that is ordered and unchangeable. It also allows\nduplicate members.\nSet is a collection that is unordered and unindexed. It does not allow\nduplicate members.\nDictionary is a collection that is unordered and changeable. It does allow\nNo duplicate members.\nWe will discuss the details of every data type in further chapters.\nExample 1.11:\n# Creating a simple list\nlist_var1 = [\"Brijesh\", \"Krishna\", \"Ram\", \"Amit\", \"Rohit\"]\nprint (list_var1)\nlist_var2 = [\"Brijesh\", 35, \"Krishna\",36, \"Ram\",34, \"Amit\", 30,\n\"Rohit\"]\nprint (list_var2)\nOutput:\n['Brijesh', 'Krishna', 'Ram', 'Amit', 'Rohit']\n['Brijesh', 35, 'Krishna', 36, 'Ram', 34, 'Amit', 30, 'Rohit']\nStrings\nThe string is an array of characters. The string is created by single quotation\nmarks, double quotation marks, and triple quotation marks. We can print the\nstring with the help of the function.\nprint()\nExample 1.12:\n# Creating a string\n# Single string\nstr1 = \"Python\"\nprint (str1) # Multiple string\nstr2 = \"\"\"Python is good programming,\nIt is used for data analysis,\nIt is very faster in the computational point of view.\"\"\"\nprint (str2)\nOutput:\nPython\nPython is good programming,\nIt is used for data analysis,\nIt is very faster in the computational point of view.\nVariables and identifiers\nA variable is a name that refers to a value. It is an essential part of a\nprogramming language because a variable can hold the value. The programming\nis significantly more comfortable and understandable when you use a variable\nfor holding a value. In Python, a single value can be assigned to multiple\nvariables at the same time. It is also possible to initialize various variables\nsame time with different values.\nLet us take some examples to understand more about the variable.\nExample 1.13:\n# multiple variables assignment with same value\nx=y=10\nprint ('value of x is:',x)\nprint ('value if y is:',y)\nOutput:\nvalue of x is: 10\nvalue if y is: 10\nExample 1.14:\n# Initializing multiple variables\nx,y,z=10,'amit',123.52\nprint ('value of x is:',x) print ('value if y is:',y)\nprint ('value if z is:',z)\nOutput:\nvalue of x is: 10\nvalue if y is: amit\nvalue if z is: 123.52\nExample 1.15:\nstr='Python is very easy and efficient programming language'\nnum=10\nfloat_var=34.44\nprint (str)\nprint (num)\nprint (float_var)\nOutput:\nPython is very easy and efficient programming language\n10\n34.44\nIn this example, we have defined three variables , , and for\nstr num float_var\nholding a string, number, and float value.\nExample 1.16:\n# Showing variable and its type\nstr='Python is very easy and efficient programming language'\nnum=10\nfloat_var=34.44\nprint (str)\nprint (num)\nprint (float_var)\nprint (type(str))\nprint (type(num))\nprint (type(float_var))\nOutput: Python is very easy and efficient programming language\n10\n34.44\n<class 'str'>\n<class 'int'>\n<class 'float'>\nA variable name should be meaningful while creating a variable because it is\nmore understandable when you use it to create a meaningful variable. Variable\nnames can be long and contain letters and numbers, but they should start with a\nletter; special characters are not allowed. Underscore is also allowed. Let's take\nan example to understand the variable name.\nExample 1.17: Variable name\nThis_is_for_storing_Name =\"Dr. Brijesh Bakariya\"\n_My_Qualification = \"Ph.D.\"\nprint (This_is_for_storing_Name)\nprint (_My_Qualification)\nOutput:\nDr. Brijesh Bakariya\nPh.D.\nPython identifiers\nAn identifier is a name given to entities such as variables, functions, etc.\nA combination of upper-case letters (A to Z), Lower case letters (a to z), and\ndigits (0 to 9), underscore ( ) are allowed in an identifier, but it cannot start\n_\nwith digits.\nExample 1.18:\n# Identifier\nName1='Amit'\nNAME='Raj'\nN12='Ramesh'\n_Name='Rohit'\nprint (Name1)\nprint (NAME) print (N12)\nprint (_Name)\nOutput:\nAmit\nRaj\nRamesh\nRohit\nData types\nPython has a data type for every value. Moreover, everything is an object in\nPython, and data types can be classes and objects of these classes. There are\nvarious categories of built-in data types in Python:\nFigure 1.33: Categories of Data Type\nExample 1.19:\n# data types #str\nx1 = \"Dr. Brijesh Bakariya\"\n#int\nx2= 35\n#float\nx3 = 205.2\n#complex\nx4 = 3j\n#list\nx5 = [\"mango\", \"cherry\", \"apple\"]\n#tuple\nx6 = (\"mango\", \"cherry\", \"apple\")\n#range\nx7 = range(3)\n#dict\nx8 = {\"name\" : \"Brijesh\", \"age\" : 35}\n#set\nx9 = {\"mango\", \"cherry\", \"cherry\"}\n#frozenset\nx10 = frozenset({\"apple\", \"banana\", \"apple\"})\n#bool\nx11 = True\nprint (x1)\nprint (x2)\nprint (x3)\nprint (x4)\nprint (x5)\nprint (x6)\nprint (x7)\nprint (x8)\nprint (x9)\nprint (x10)\nprint (x11)\nOutput:\nDr. Brijesh Bakariya\n35\n205.2 3j\n['mango', 'cherry', 'apple']\n('mango', 'cherry', 'apple')\nrange(0, 3)\n{'name': 'Brijesh', 'age': 35}\n{'cherry', 'mango'}\nfrozenset({'banana', 'apple'})\nTrue\nStatements\nThe statement is an instruction that can be executed by the Python interpreter.\nThere are various types of statements that we use, such as assignment statements,\nstatements, statements, etc.\nwhile if\nMost of the statements use indentation for defining the scope of a code. Here,\nindentation means putting whitespace at the beginning of a line, similar to curly\nbrackets for other programming languages.\nExample 1.20: Statement\na = 10\nb = 20\nif b > a:\nprint (\"b is greater than a\")\nelif a == b:\nprint (\"a and b are equal\")\nelse:\nprint (\"a is greater than b\")\nOutput:\nb is greater than a\nKeywords\nKeywords are not allowed in a variable name, function name, or any other\nidentifier. In Python 3.7, there are 35 keywords. Those are given below:\nFalse await else import pass\nNone break except in raise True class finally is return\nand continue for lambda try\nas def from nonlocal while\nassert del global not with\nasync elif if or yield\nDictionary\nDictionary is a collection of data values. It uses a two-element key and value. It\nis an unordered collection of data because it depends on the element defined in\nthe dictionary. Each key is separated from its value by a colon ( ), the items are\n:\nseparated by commas, and it is enclosed in curly braces. An item can be\nchangeable.\nExample 1.21: Dictionary\n# Creating a Dictionary\n# with Integer Keys\nDict = {1: 'Brijesh', 2: 'Krishna', 3: 'Amit'}\nprint (\"\\nDictionary with the use of Integer Keys: \")\nprint (Dict)\nOutput:\nDictionary with the use of Integer Keys:\n{1: 'Brijesh', 2: 'Krishna', 3: 'Amit'}\nConclusion\nIn this chapter, we discussed the basics and various features of Python. We also\ndiscussed installing and executing the Python programs. Various IDEs that are\nused to write Python code. Briefly description about various concepts of Python\nwith examples. Based on these examples, you can write your code for a specific\ntask. In the next chapter, we will discuss operators as the next topic used in\nPython.\nPoints to remember\nPython is a high-level and interpreted language\nPython is a free and open-source language There are 35 keywords in Python 3.7\nMultiple choice questions\n1. Who developed the Python language?\na. Zim Den\nb. Guido van Rossum\nc. Niene Stom\nd. Wick van Rossum\n2. In which language is Python written?\na. English\nb. PHP\nc. C\nd. Java\n3. Python was developed in which year?\na. 1972\nb. 1995\nc. 1991\nd. 1981\n4. Python 3.0 was released in which year?\na. 2000\nb. 2008\nc. 2011\nd. 2016\n5. By the use of which character, a single line is made a comment in\nPython?\na. *\nb. @\nc. #\nd. ! 6. Which of the following statements is true?\na. Python is a high-level programming language.\nb. Python is an interpreted language.\nc. Python is an object-oriented language\nd. All of the above\n7. What is used to define a block of code in Python?\na. Parenthesis\nb. Indentation\nc. Curly braces\nd. None of the above\n8. What is the extension of a Python file?\na. .p\nb. .py\nc. .python\nd. None of the above\nAnswers\n1. b\n2. c\n3. c\n4. b\n5. c\n6. d\n7. b\n8. b\nQuestions\n1. What is Python? Describe various features of Python.\n2. What do you mean by Python Interpreter? 3. Write Python code to display your name.\n4. How to get input in Python? Write a code for getting input.\n5. What do you mean by indentation? Write a code for it.\n6. What do you mean by keywords? How many keywords are there in Python\n3?\n7. Discuss variables and identifiers.\n8. Discuss data type in Python. CHAPTER 2\nOperators and Expressions\nperator is a particular concept in Python that is carried out from the\nO\ncomputational point of view. Here, there are two types of the terminology\nused - operator and operands. The operator is a symbol that is performed\nwith operands' help, and the operand is the value that the operator operates.\nStructure\nIn this chapter, we will cover the following topics:\nTypes of operators\nWriting expression in Python\nUse comments during a program\nWorking with function and modules\nObjective\nThe objective of this chapter is to introduce Python operators, expressions,\nfunctions, and modules. After completing this chapter, you should be familiar\nwith various Python operators and their working. Also, you will be able to\nwrite Python programs using operators and expressions.\nWhat is an operator?\nIt is a particular type of symbol that performs some operations on operands\nand returns the result. Let us take an example for better understanding, 10+20\nis an expression. Here, 10 and 20 are operands, and is an operator. So, in\n+\nthis example, a simple arithmetic expression is evaluated, and the result will\nbe the addition of the two values.\nThere are various types of operators used in Python. The table 2.1 shows the\nhierarchy of the operators available in Python: Operators Symbols\nArithmetic operators +,-, *,\/, %, **,\/\/\nComparison operators >,>=,<,<=,==,! =\nAssignment and shortcut operators =, +=,-=,*=,\/=,%=,**=,\/\/=\nUnary operators +x, -x\nBitwise operators &,|,^,~,<<,>>\nLogical operators and, or, not\nMembership Operators in, not\nIdentity operators is, is not\nTable 2.1: Hierarchy of the operators\nArithmetic operators\nIt performs the basic mathematical operation on the numeric operands. The\narithmetic operators return the result, and the outcome depends on which type\nof operands you are using in programming.\nAddition (+): The symbol is used while using this operator. It uses\n+\nbetween two operands and this operator adds the two value. For\nexample, a=4, b=2 then returns 6.\na + b\nSubtraction (-): The symbol (minus) is used while using this\n\u2013\noperator. It uses between two operands, and this operator subtracts the\nvalue and returns the result. For example, a=4, b=2, then returns\na - b\n2.\nMultiplication (*): The symbol is used while using this operator. It\n*\noperates between two operands, and this operator multiplies these\nvalues and returns the result. For example, a=4, b=2, then returns 8.\na*b\nDivision (\/): The symbol is used while using this operator. It uses two\n\/\noperands, and this operator divides the value and returns the result. For\nexample, a=4, b=2 then returns 2.\na \/ b\nModulus (%): The symbol is used while using this operator. It uses\n%\nbetween two operands, and this operator returns the remainder. For\nexample, a=4, b=2 then returns 0.\na % b Exponent (**): The symbol is used while using this operator. It\n**\noperates between two operands. It performs exponential (power)\ncalculation on operators. For example, a=4, b=2, then means\na ** b\n(4)2. The result will be 8.\nFloor Division (\/\/): Floor division is like regular division, but it returns\nthe highest possible integer. This integer is less than or equal to the\noutcome of normal division. For example, and\n7\/\/2 = 3 7.0\/\/2.0 =\n, ,\n3.0 -11\/\/3 = -4 -11.0\/\/3 = -4.0\nExample 2.1:\na=4\nb=2\nc=a+b #Addition (+)\nprint (c)\nd=a-b #Subtraction (-)\nprint (d)\ne=a*b #Multiplication (*)\nprint (e)\nf=a\/b #Division (\/)\nprint (f)\ng=a%b # Modulus (%)\nprint (g)\nh=a**b #Exponent (**)\nprint (h)\ni=a\/\/b #Floor Division (\/\/)\nprint (i)\nOutput:\n6\n2\n8\n2.0\n0\n16\n2 Comparison operators\nThese operators compare the two values and also decide the relation\nbetween them. It is also called a relational operator because it shows the\nrelation between two operands. This type of operator returns a Boolean\nvalue ( \/ ). There are various types of relational operators.\nTrue False\nGreater than (>): It returns true if the left operand is greater than the\nright. Example, ( ).\na>b\nGreater than or equal to (>=): It returns true if the left operand is\ngreater than or equal to the right. Example, ( ).\na>=b\nLess than (<): It returns true if the left operand is less than the right.\nExample, ( ).\na<b\nLess than or equal to (<=): It returns true if the left operand is less\nthan or equal to the right. Example, ( ).\na<=b\nEqual to (==): It returns true if both operands are equal. Example,\n( ).\na==b\nNot equal to (! =): It returns true if operands are not equal. Example,\n( ).\na != b\nExample 2.2:\nx = 10\ny = 20\nprint (\"x is equal to y:\", x == y)\nprint (\"x is not equal to y:\", x != y)\nprint (\"x is less than y:\", x < y)\nprint (\"x is greater than y:\", x > y)\nx = 100\ny = 200\nprint (\"x is either less than or equal to y:\", x <= y)\nprint (\"y is either greater than or equal to y:\", y >= x)\nOutput:\nx is equal to y: False\nx is not equal to y: True\nx is less than y: True x is greater than y: False\nx is either less than or equal to y: True\ny is either greater than or equal to y: True\nAssignment and shortcut operators\nIt is used in Python to assign values to variables. Suppose is a\nx = 10\nsimple assignment operator that assigns the value 10 on the right to the\nvariable on the left. There are various compound operators in Python, such\nx\nas that adds to the variable and later assigns the same. It is\nx += 10\nequivalent to . It is also called a shortcut operator. There are\nx = x + 10\nvarious types of assignment and shortcut operators.\nAssignment (=) operator: This operator assigns values from right side\noperands to left side operand assigns into .\nz = x + y x + y z\nAdd AND (+=) operator: This operator adds the right operand to the\nleft operand and assigns the result to the left operand is\nz += x\nequivalent to .\nz = z + x\nSubtract AND (-=) operator: This operator subtracts the right operand\nfrom the left operand and assigns the result to the left operand\nz -= x\nequals .\nz = z \u2013 x\nMultiply AND (*=) operator: This operator multiplies the right\noperand with the left operand and assigns the result to the left operand\nz\nis equivalent to .\n*= x z = z * x\nDivide AND (\/=) operator: This operator divides the left operand with\nthe right operand and assigns the result to the left operand is\nz \/= x\nequivalent to .\nz = z \/ x\nModulus AND (%=) operator: This operator takes modulus using two\noperands and assigns the result to left operand is equivalent to\nz %= x\n.\nz = z % x\nExponent AND (**=) operator: This operator performs exponential\n(power) calculation on operators and assign value to the left operand\nz\nis equivalent to .\n**= x z = z ** x\nFloor division (\/\/=) operator: This operator performs floor division on\noperators and assign value to the left operand is equivalent to\nz \/\/= x\n.\nz = z \/\/ x Example 2.3:\nx = 10\ny = 20\nz = 0\nz = x + y\nprint (\" 1 - Value of z is \", z)\nz += x\nprint (\" 2 - Value of z is \", z)\nz *= x\nprint (\" 3 - Value of z is \", z)\nz \/= x\nprint (\" 4 - Value of z is \", z)\nz = 2\nz %= x\nprint (\" 5 - Value of z is \", z)\nz **= x\nprint (\" 6 - Value of z is \", z)\nz \/\/= x\nprint (\" 7 - Value of z is \", z)\nOutput:\n1 - Value of z is 30\n2 - Value of z is 40\n3 - Value of z is 400\n4 - Value of z is 40.0\n5 - Value of z is 2\n6 - Value of z is 1024\n7 - Value of z is 102\nUnary operators\nIt is used in Python, and it is performed on a single operand. There are two\ntypes of unary operators such as unary ( ) and unary ( ). Let us take an\n+ -\nexample to understand unary operators.\nExample 2.4: x = 10\nprint (\"Unary positive operator\", +x)\nprint (\"Unary Negative operator\", -x)\nOutput:\nUnary positive operator 10\nUnary Negative operator -10\nBitwise operators\nBitwise operator works on bits and performs bit-by-bit operation.\nSuppose and , then the binary conversion of and is 11010,\nx = 26 y = 18 x y\n10010. Let us understand the various bitwise operations on and with their\nx y\nresults:\nx= 11010\ny= 10010\nx & y = 10010\nx | y = 11010\nx ^ y = 01000\n~x = 00101\n~y = 01101\nThere are the following Bitwise operators:\nBinary AND (&): This operator copies a bit to the result if it exists in\nboth operands.\nBinary OR (|): This operator copies a bit if it exists in either operand.\nBinary XOR (^): This operator copies the bit if it is set in one operand\nbut not both.\nBinary One's Complement (~): It is unary and has the effect of\nflipping bits.\nBinary Left Shift (<<): In this operator, the left operand's value is\nmoved left by the number of bits specified by the right operand.\nBinary Right Shift (>>): In this operator the left operands value is\nmoved right by the number of bits specified by the right operand. Let us take an example to understand all bitwise operators.\nExample 2.5:\nx = 26 # 26 = 11010\ny = 18 # 18 = 10010\nz = 0\nz = x & y,\nprint (\"1 - Value of z is \", z)\nz = x | y,\nprint (\"2 - Value of z is \", z)\nz = x ^ y,\nprint (\"3 - Value of z is \", z)\nz = ~x,\nprint (\"4 - Value of z is \", z)\nz = x << 2,\nprint (\"5 - Value of z is \", z)\nz = x >> 2,\nprint (\"6 - Value of z is \", z)\nOutput:\n1 - Value of z is 18\n2 - Value of z is 26\n3 - Value of z is 8\n4 - Value of z is -27\n5 - Value of z is 104\n6 - Value of z is 6\nLogical operators\nLogical operators are used to perform arithmetic and logical computations.\nThese are special symbols ( , , and ) for accomplishing the\nAND OR NOT\noperations.\nLogical AND: This operator returns true when both the conditions\nbecome true.\nLogical OR: This operator returns true when two operands are non-\nzero. Logical NOT: This operator returns the reverse result, or it can say\ntrue condition becomes false and false condition becomes true.\nExample 2.6:\nx = 7\nprint (x > 3 and x < 10) # returns True because 7 is greater\nthan 3 AND 7 is less than 10\nprint (x > 3 or x < 4) # returns True because one of the\nconditions are true (7 is greater than 3, but 7 is not less\nthan 4)\nprint (not(x > 3 and x < 10)) # returns False because not is\nused to reverse the result\nOutput:\nTrue\nTrue\nFalse\nMembership operators\nA membership operator is used to test if a sequence is presented in an object.\nHere, an object may be strings, lists, or tuples. There are two types of\nmembership operators in and not. Let us take an example of using these\noperators.\nOperator (in): This operator evaluates to true if it finds a variable in\nthe specified sequence and false otherwise.\nOperator (not): This operator evaluates to true if it does not find a\nvariable in the specified sequence and false otherwise.\nExample 2.7:\nx= 10\ny = 20\nlist = [10, 12, 23, 44, 35],\nif (x in list):\nprint (\" 1 - x is available in the given list\") else:\nprint (\" 1 - x is not available in the given list\")\nif (y not in list):\nprint (\" 2 - y is not available in the given list\")\nelse:\nprint (\" 2 - y is available in the given list\")\nx = 2\nif (x in list):\nprint (\" 3 - x is available in the given list\")\nelse:\nprint (\" 3 - x is not available in the given list\")\nOutput:\n1 - x is available in the given list\n2 - y is not available in the given list\n3 - x is not available in the given list\nIdentity operators\nThis operator is used to compare the objects, not if they are equal, but if they\nare the same object, with the exact memory location. There are two types of\nidentity operators and . Let us take an example of using these\nis is not\noperators.\nOperator (is): This operator returns true if both variables are the same\nobject.\nOperator (is not): This operator returns true if both variables are not\nthe same object.\nExample 2.8:\nx = [\"Amit\", \"Raj\"]\ny = [\"Amit\", \"Raj\"]\nz = x\nprint (x is z) # returns True because z is the same object as\nx\nprint (x is y) # returns False because x is not the same\nobject as y, even if they have the same content print (x == y) # This comparison returns True because x is\nequal to y\nprint (x is not z) # returns False because z is the same\nobject as x\nprint (x is not y) # returns True because x is not the same\nobject as y, even if they have the same content\nprint (x != y) # This comparison returns False because x is\nequal to y\nOutput:\nTrue\nFalse\nTrue\nFalse\nTrue\nFalse\nOperators precedence and associativity\nOperator precedence means which operator should be executed first. It is\nbased on the priority of an operator. If two or more operators have the same\nprecedence, it will check the associativity of an operator. Associativity\nmeans how to operate the value either left to right or right to left.\nSuppose an expression is then first of all will be executed\n2*4+6 2*4\nbecause has higher precedence between and operator.\n* * +\nSuppose an expression is , then the operator's priority is the same, it\n5\/2*3\nwill check the associativity of an operator. Here associativity of and is\n\/ *\nleft to right, then 5\/2 will be executed first.\nThe following table lists all operators from the highest precedence to the\nlowest precedence:\nOperator Description Associativity\n() Parentheses left-to-right\n** Exponent right-to-left\n* \/ % Multiplication\/division\/modulus left-to-right + Addition\/subtraction left-to-right\n<< >> Bitwise shift left, Bitwise shift right left-to-right\n< <= Relational less than\/less than or equal to Relational greater left-to-right\n> >= than\/greater than or equal to\n== != Relational is equal to\/is not equal to left-to-right\nis, is not Identity left-to-right\nin, not in Membership operators\n& Bitwise AND left-to-right\n^ Bitwise exclusive OR left-to-right\n| Bitwise inclusive OR left-to-right\nno Logical NOT right-to-left\nand Logical AND left-to-right\nor Logical OR left-to-right\n= Assignment right-to-left\n+= -= Addition\/subtraction assignment\n*= \/= Multiplication\/division assignment\n%= &= Modulus\/bitwise AND assignment\n^= |= Bitwise exclusive\/inclusive OR assignment\n<<= >>= Bitwise shift left\/right assignment\nTable 2.2: Operators description and its associativity\nExample 2.9:\nx = 12\ny = 14\nx = 15\np = 6\nq = 0\nq = (x + y) * x \/ p #(30 * 15) \/ 5\nprint (\"Value of (x + y) * x \/ p is \", q)\nq = ((x + y) * x) \/ p # (30 * 15) \/ 5\nprint (\"Value of ((x + y) * x) \/ p is \", q)\nq = (x + y) * (x \/ p), # (30) * (15\/5)\nprint (\"Value of (x + y) * (x \/ p) is \", q)\nq = x + (y * x) \/ p, # 20 + (150\/5) print (\"Value of x + (y * x) \/ p is \", q)\nOutput:\nValue of (x + y) * x \/ p is 72.5\nValue of ((x + y) * x) \/ p is 72.5\nValue of (x + y) * (x \/ p) is 72.5\nValue of x + (y * x) \/ p is 50.0\nExpressions in Python\nIt is a representation of value. Moreover, it is a combination of values,\nvariables, operators, and calls to functions. Expressions need to be\nevaluated. If you ask Python to print an expression, the interpreter evaluates\nit and displays the desired result.\nPython expressions only contain three things, identifiers, literals and,\noperators.\nIdentifiers: It can be any name that is used to define a class, function,\nvariable module, or an object.\nLiterals: It can be string literals, byte literals, integer literals, floating-\npoint literals, and imaginary literals.\nOperators: Based on the token or symbol, it can evaluate an operation.\nThere are following operators, and their corresponding token can be used to\nimplement any expression:\nadd +\nsubtract \u2013\nmultiply *\npower **\nInteger Division \/\nremainder %\ndecorator @\nBinary left shift <<\nBinary right shift >> and &\nor \\\nBinary XOR ^\nBinary ones complement ~\nLess than <\nGreater than >\nLess than or equal to <=\nGreater than or equal to >=\nCheck equality ==\nCheck not equal !=\nExample 2.10:\na = 9\nb = 12\nc = 3\nx = a - b \/ 3 + c * 2 - 1\ny = a - b \/ (3 + c) * (2 - 1)\nz = a - (b \/ (3 + c) * 2) - 1\nprint (\"X = \", x)\nprint (\"Y = \", y)\nprint (\"Z = \", z)\nOutput:\nX = 10.0\nY = 7.0\nZ = 4.0\nOperations on strings\nA string is an essential concept in Python because in many places it can be\nused in coding. The string can be created either in single quotation marks or\ndouble quotation marks. Let us take an example of string creation:\nstring1= 'Python Programming.'\nstring2=\"Python Programming.\" Both are the ways to create a string.\nAccessing values in strings\nAn assignment is much easier than another programming language because\nPython does not support character type. It is treated as strings of length one. If\nwe want to take a subpart of a string, then we have to take a substring. We\nhave to use the square brackets for slicing, and index or indices to obtain\nyour substring.\nString can also update and reassign the value into another string. Let us take\nan example.\nExample 2.11:\nstr1='Python Programming'\nstr2=\"Computer Science\"\nprint (\"str1[0]: \", str1[0])\nprint (\"str2[0:5]: \", str2[0:5])\nprint (\"Updated String :- \", str1[:7] + 'Book')\nOutput:\nstr1[0]: P\nstr2[0:5]: Compu\nUpdated String :- Python Book\nThere are various types of special symbol used in the string:\nConcatenation (+): It adds values on either side of the operator.\nRepetition (*): It creates a new string, concatenating multiple copies of\nthe same string.\nSlice ([]): It gives the character from the given index.\nRange slice ([:]): It gives the characters from the given range.\nMembership (in): It returns true if a character exists in the given string.\nMembership (not in): It returns true if a character does not exist in the\ngiven string. There are various types of formatted string operators which decide the\nformatting of string:\n%c character\n%s string conversion\n%i signed decimal integer\n%d signed decimal integer\n%u unsigned decimal integer\n%o octal integer\n%x hexadecimal integer (lowercase letters)\n%X hexadecimal integer (Uppercase letters)\n%e exponential notation (with lowercase 'e')\n%E exponential notation (with Uppercase 'E')\n%f floating point real number\n%g the shorter of %f and %e\n%G the shorter of %f and %E\nLet us take an example.\nExample 2.12:\nprint (\"My name is %s and age is %d years\" % (Amit, 30))\nOutput:\nMy name is Amit and age is 30 years\nTriple quotes\nIt is used for writing a string in multiple lines. It can be written in triple\nquotes to three consecutive single or double quotes.\nExample 2.13:\nBio_Auth = \"\"\" Brijesh Bakariya received Graduation degree\nfrom Barkatullah University Bhopal M.P. in 2005, and Post-\nGraduation Degree in Computer Applications from Devi Ahilya Vishwavidyalaya Indore M.P. in year 2009. He has done Ph.D.\nDegree in the Department of Computer Applications, Maulana\nAzad National Institute of Technology Bhopal M.P\"\"\"\nprint (Bio_Auth)\n))\nOutput:\nBrijesh Bakariya received Graduation degree from Barkatullah\nUniversity Bhopal M.P. in 2005, and Post-Graduation Degree in\nComputer Applications from Devi Ahilya Vishwavidyalaya Indore\nM.P. in year 2009. He has done Ph.D. Degree in the Department\nof Computer Applications, Maulana Azad National Institute of\nTechnology Bhopal M.P bbbbb\nThere are various types of built-in functions which manipulate strings:\n: It capitalizes the first letter of the string.\ncapitalize()\n: It returns a space-padded string with the\ncenter(width, fillchar)\noriginal string cantered to a total of width columns.\n: It counts how many times\ncount(str, beg= 0,end=len(string))\noccurs in string or in a substring of string if starting index beg and\nstr\nending index end are given.\n: It decodes the\ndecode(encoding='UTF-8',errors='strict')\nstring using the codec registered for encoding. It defaults to the default\nstring encoding.\n: It returns encoded\nencode(encoding='UTF-8',errors='strict')\nstring version of string, on error, default is to raise a\nValueError\nunless errors is given with 'ignore' or 'replace'.\n: It determines if a\nendswith(suffix, beg=0, end=len(string))\nstring or a substring of string (if starting index beg and ending index end\nare given) ends with suffix, returns true if so, and false otherwise.\n: Expands tabs in the string to multiple\nexpandtabs (tabsize=8)\nspaces, defaults to 8 spaces per tab if tab size is not provided.\n: It determines if occurs\nfind (str, beg=0 end=len(string)) str\nin string or a substring of string if starting index beg and ending index\nend are given, returns index if found, and -1 otherwise. : It is same as , but\nindex(str, beg=0, end=len(string)) find()\nraises an exception if not found.\nstr\n: It returns true if the string has at least one character and all\nisalnum()\ncharacters are alphanumeric and false otherwise.\n: It returns true if the string has at least one character and all\nisalpha()\ncharacters are alphabetic and false otherwise.\n: It returns true if the string contains only digits and false\nisdigit()\notherwise.\n: It returns true if the string has at least 1 cased character\nislower()\nand all cased characters are in lowercase and false otherwise.\n: It returns true if a Unicode string contains only numeric\nisnumeric()\ncharacters and false otherwise.\n: It returns true if the string contains only whitespace\nisspace()\ncharacters and false otherwise.\n: It returns true if the string is properly \"title case\" and false\nistitle()\notherwise.\n: It returns true if the string has at least one cased character\nisupper()\nand all cased characters are uppercase and false otherwise.\n: It merges (concatenates) the string representations of\njoin(seq)\nelements in sequence into a string, with separator string.\nseq\n: It returns the length of the string.\nlen(string)\n: It returns a space-padded string with the\nljust(width[, fillchar])\noriginal string left-justified to a total of width columns.\n: It converts all uppercase letters in a string to lowercase.\nlower()\n: It removes all leading whitespace in a string.\nlstrip()\n: It returns a translation table to be used in the translate\nmaketrans()\nfunction.\n: It returns the alphabetical character from the string .\nmax(str) max str\n: It returns the alphabetical character from the string .\nmin(str) min str\n: It replaces all old in string with new\nreplace(old, new [, max])\nor at most max occurrences if max given.\n: It is same as , but\nrfind(str, beg=0,end=len(string)) find()\nsearch backwards in string. : It is same as , but\nrindex(str, beg=0, end=len(string)) index()\nsearch backwards in string.\n: It returns a space-padded string with\nrjust(width,[, fillchar])\nthe original string right-justified to a total of width columns.\n: It removes all trailing whitespace of a string.\nrstrip()\n: It splits a string\nsplit(str=\"\", num=string.count(str))\naccording to delimiter (space if not provided) and returns list of\nstr\nsubstrings, split into at most substrings if given.\nnum\n: It splits a string at all (or\nsplitlines(num=string.count('\\n'))\n) NEWLINEs and returns a list of each line with NEWLINEs\nnum\nremoved.\n: It determines if a\nstartswith(str, beg=0,end=len(string))\nstring or a substring of a string (if starting index beg and ending index\nend are given) starts with a substring , returns true if so and false\nstr\notherwise.\n: It performs both and on string.\nstrip([chars]) lstrip() rstrip()\n: It returns a string where all the upper case letters are\nswapcase()\nlower case and vice versa.\n: It returns \" \" version of a string, that is,\nstring.title() titlecased\nall words begin with uppercase and the rest are lowercase.\n: It translates a string\ntranslate(table, deletechars=\"\")\naccording to translation table , removing those in the\nstr(256 chars)\ndel string.\n: It converts lowercase letters in a string to uppercase.\nupper()\n: It returns original string left padded with zeros to a\nzfill (width)\ntotal of width characters, intended for numbers, retains any\nzfill()\nsign given (less one zero).\n: Returns true if a Unicode string contains only decimal\nisdecimal()\ncharacters and false otherwise.\nLet us take an example to understand all the above built-in functions.\nExample 2.14:\ntext = \"dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\" print (\"text.capitalize() : \", text.capitalize())\nprint (\"text.center(40, 'a') : \", text.center(40, 'a'))\nsub = \"i\";\nprint (\"text.count(sub, 4, 40) : \", text.count(sub, 4, 40))\nsub = \"wow\";\nprint (\"text.count(sub) : \", text.count(sub))\ntext1 = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\ntext2 = \"NIT\";\nprint (text1.find(text2))\nprint (text1.find(text2, 10))\nprint (text1.find(text2, 40))\ntext1 = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\ntext2 = \"Ph.D.\";\nprint (text1.index(text2))\nprint (text1.index(text2, 30))\nprint (text1.index(text2, 30))\ntext = \"this2009\"; # No space in this texting\nprint (text.isalnum())\ntext = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\nprint (text.isalnum())\ntext = \"this\"; # No space & digit in this texting\nprint (text.isalpha())\ntext = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\nprint (text.isalpha())\ntext = \"123456\"; # Only digit in this texting\nprint (text.isdigit())\ntext = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\nprint (text.isdigit())\ntext = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\nprint (text.islower())\ntext = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\nprint (text.islower()) text = u\"this2009\";\nprint (text.isnumeric())\ntext = u\"23443434\";\nprint (text.isnumeric())\ntext = \" \";\nprint (text.isspace())\ntext = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\nprint (text.isspace())\ntext = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\nprint (text.istitle())\ntext = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\nprint (text.istitle())\ntext = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\";\nprint (text.isupper())\ntext = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\nprint (text.isupper())\ns = \"-\";\nseq = (\"a\", \"b\", \"c\"); # This is sequence of textings.\nprint (s.join(seq))\ntext = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\nprint (\"Length of the texting: \", len(text))\ntext = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\nprint (text.ljust(50, '0'))\ntext = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\nprint (text.lower())\ntext = \" Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\nprint (\"Max character: \" + max(text))\ntext = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\nprint (\"Max character: \" + max(text))\ntext = \"this-is-real-texting-example\u2026.wow!!!\"\nprint (\"Min character: \" + min(text))\ntext = \"this-is-a-texting-example\u2026.wow!!!\"\nprint (\"Min character: \" + min(text)) text = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\nthis is really texting\"\nprint (text.replace(\"is\", \"was\"))\nprint (text.replace(\"is\", \"was\", 3))\ntext1 = \"this is really a texting example\u2026.wow!!!\"\ntext2 = \"is\"\nprint (text1.rfind(text2))\nprint (text1.rfind(text2, 0, 10))\nprint (text1.rfind(text2, 10, 0))\nprint (text1.find(text2))\nprint (text1.find(text2, 0, 10))\nprint (text1.find(text2, 10, 0))\ntext1 = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\ntext2 = \"from\"\nprint (text1.rindex(text2))\nprint (text1.index(text2))\ntext = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\nprint (text.rjust(50, '0'))\ntext = \"Line1-abcdef \\nLine2-abc \\nLine4-abcd\"\nprint (text.split())\nprint (text.split(' ', 1))\ntext = \"1-a b c d e f\\n 2-a b c\\n\\n 4-a b c d\"\nprint (text.splitlines())\nprint (text.splitlines(0))\nprint (text.splitlines(3))\nprint (text.splitlines(4))\nprint (text.splitlines(5))\ntext = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\nprint (text.startswith('this'))\nprint (text.startswith('is', 2, 4))\nprint (text.startswith('this', 2, 4))\ntext = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\nprint (text.swapcase())\ntext = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\nprint (text.swapcase())\ntext = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\nprint (text.title()) text = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\nprint (\"text.capitalize() : \", text.upper())\nvar = \"Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\"\nprint (var.zfill(40))\nprint (var.zfill(50))\nvar = u\"this2009\";\nprint (var.isdecimal())\ntext = u\"23443434\";\nprint (text.isdecimal())\nOutput:\ntext.capitalize() : Dr. brijesh bakariya received ph.d. from\nnit bhopal\ntext.center(40, 'a') : dr. Brijesh Bakariya received Ph.D.\nfrom NIT Bhopal\ntext.count(sub, 4, 40) : 3\ntext.count(sub) : 0\n41\n41\n41\n30\n30\n30\nTrue\nFalse\nTrue\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nTrue\nTrue\nFalse\nFalse\nFalse False\nFalse\na-b-c\nLength of the texting: 51\nDr. Brijesh Bakariya received Ph.D. from NIT Bhopal\ndr. brijesh bakariya received ph.d. from nit bhopal\nMax character: y\nMax character: y\nMin character: !\nMin character: !\nDr. Brijesh Bakariya received Ph.D. from NIT Bhopal thwas was\nreally texting Dr. Brijesh Bakariya received Ph.D. from NIT\nBhopal thwas was really texting\n5\n5\n-1\n2\n2\n-1\n36\n36\nDr. Brijesh Bakariya received Ph.D. from NIT Bhopal\n['Line1-abcdef', 'Line2-abc', 'Line4-abcd']\n['Line1-abcdef', '\\nLine2-abc \\nLine4-abcd']\n['1-a b c d e f', ' 2- a b c', '', ' 4- a b c d']\n['1-a b c d e f', ' 2- a b c', '', ' 4- a b c d']\n['1-a b c d e f\\n', ' 2- a b c\\n', '\\n', ' 4- a b c d']\n['1-a b c d e f\\n', ' 2- a b c\\n', '\\n', ' 4- a b c d']\n['1-a b c d e f\\n', ' 2- a b c\\n', '\\n', ' 4- a b c d']\nFalse\nFalse\nFalse\ndR. bRIJESH bAKARIYA RECEIVED pH.d. FROM nit bHOPAL\ndR. bRIJESH bAKARIYA RECEIVED pH.d. FROM nit bHOPAL\nDr. Brijesh Bakariya Received Ph.D. From Nit Bhopal\ntext.capitalize() : DR. BRIJESH BAKARIYA RECEIVED PH.D. FROM\nNIT BHOPAL Dr. Brijesh Bakariya received Ph.D. from NIT Bhopal\nDr. Brijesh Bakariya received Ph.D. from NIT Bhopal\nFalse\nTrue\nType conversion\nIt is the process of converting the value from one data type to another data\ntype. The data type may be an integer, string, float, etc. There are two types\nof type conversion as implicit type conversion and explicit type conversion.\nImplicit type conversion\nIn this conversion, Python automatically converts one data type to another\ndata type. A user does not get involved in this type of conversion. Let us take\nan example of implicit type conversion.\nExample 2.15:\nnum_int = 234\nnum_float = 23.4\nnum_new= num_int + num_float\nprint (\"datatype of num_int:\", type(num_int))\nprint (\"datatype of num_flo:\", type(num_float))\nprint (\"Value of num_new:\", num_new)\nprint (\"datatype of num_new:\", type(num_new))\nOutput:\ndatatype of num_int: <class 'int'>\ndatatype of num_flo: <class 'float'>\nValue of num_new: 257.4\ndatatype of num_new: <class 'float'>\nExplicit type conversion\nIn this conversion, users convert the data type of an object to the required\ndata type. It uses some predefined functions like , , ,\nint() float() str() etc. to perform explicit type conversion. Moreover, it is also called\ntypecasting because the user casts (changes) the objects' data type.\nTypecasting can be done by assigning the required data type function to the\nexpression. There are following syntax of explicit type casting:\n<required_datatype>(expression)\nExample 2.16:\nnum_int = 345\nnum_str = \"867\"\nprint (\"Data type of num_int:\", type(num_int))\nprint (\"Data type of num_str before Type Casting:\",\ntype(num_str))\nnum_str = int(num_str)\nprint (\"Data type of num_str after Type Casting:\",\ntype(num_str))\nnum_sum = num_int + num_str\nprint (\"Sum of num_int and num_str:\", num_sum)\nprint (\"Data type of the sum:\", type(num_sum))\nOutput:\nData type of num_int: <class 'int'>\nData type of num_str before Type Casting: <class 'str'>\nData type of num_str after Type Casting: <class 'int'>\nSum of num_int and num_str: 1212\nData type of the sum: <class 'int'>\nPython avoids the loss of data in implicit type conversion.\nExplicit type conversion is also called type casting. The data types of\nobjects are converted using predefined functions by the user.\nIn type casting, loss of data may occur as we enforce the object to a\nspecific data type.\nPython comments If we want to explain or understand the particular code, Python provides the\nfacility in comments. Moreover, comments can be used to describe Python\ncode. Comments do not execute, or it is free from execution. Comments start\nwith a symbol, and it can be placed at the end of a line. There are two\n#\ntypes of comments in Python. These are:\nSingle line comments\nMultiline comments\nSingle line comments\nIt starts with a # symbol that means you have to write symbol in every line.\n#\nMultiline comments\nA multi-line comment in Python is a block of text enclosed by a delimiter\n( ) at the beginning and end of the comment. There should be no white\n\"\"\"\nspace between the delimiters ( ).\n\"\"\"\nLet us take an example to understand comments.\nExample 2.17:\nprint (\"Python Programming\") # Single line comment\n\"\"\"\nThis is a comment\nwritten in\nmore lines\n\"\"\"\nprint (\"Book for Computer Science.\")\nOutput:\nPython Programming\nBook for Computer Science.\nFunctions in Python A function is a block of statements that performs a specific task. It is used for\ncode reusability because if you are using some lines then in the place of this,\nyou can use function and function will do the same thing multiple times.\nThere are two types of function, as built-in function and user-defined\nfunction.\nBuilt-in function: A built-in function is already defined, and you have\nto call the types of function and function that will perform the task.\nUser-defined function: We can create our function to perform a\nparticular task. This type of function will be created according to user\nneeds.\nDefining a function\nIt starts with keywords followed by the function name and parentheses\ndef\n.\n()\ndef function_name()\nAn argument can be passed within parentheses of the function. The code\nblock within every function starts with a colon ( ) and is indented.\n:\nExample 2.18:\ndef fun_name (str): # Function definition\nprint (str)\nreturn;\nfun_name (\"Python Programming\") # Function calling\nOutput:\nPython Programming\nModule\nIt is used for understanding and organizing a code. It is a group related to\ncode that is called a module. Moreover, a module is a file consisting of\nPython code. A module can define functions, classes, and variables.\nYou have to save the code with the file extension . This is a module.\n.py Example 2.19:\nSave this code in a file named :\nmyname.py\ndef fname(str):\nprint (\"Dr.\", \" + str)\nThe following screenshot shows the code window for saving a module file:\nFigure 2.1: Module file\nUse a module\nNow we can use the module by using the statement:\nimport\nExample 2.20:\nImport the module named and call the name function:\nmyname\nimport myname\nmyname.fname(\"Brijesh Bakariya\")\nThe following screenshot shows a code window in which module is\nmyname\nimported: Figure 2.2: Import and use of module\nParameters or arguments\nIt is a piece of information that is passed into a function. A parameter is the\nvariable listed inside the parentheses in the function definition. An argument\nis a value that is sent to the function when it is called. The number of\nparameters should be matched with several arguments with its data type.\nLet us take an example to understand parameters and arguments.\nExample 2.21:\ndef name_fun(fname, lname): # Two Parameters\nprint (fname + \" \" + lname)\nname_fun(\"Python\", \"Book\") # Two arguments\nOutput:\nPython Book\nConclusion\nIn this chapter, we discussed various types of operators. We also discussed\nthe operator's precedence and associativity for the evaluation of an expression. We discussed a brief description of various concepts of string\noperations, function, and module creations. It is discussed how to pass\nparameters in function and module. In the next chapter, we will discuss\ncontrol flow statements as the next topic used in Python.\nPoints to remember\nOperator return actual or Boolean values.\nThe expression will be executed according to the operator's precedence\nand associativity\nPython avoids the loss of data in implicit type conversion.\nComments do not execute, or it is free from execution.\nMultiple choice questions\n1. print 9\/\/2\na. 4.5\nb. 4.0\nc. 4\nd. Error\n2. Which is the correct operator for power(xy)?\na. x^y\nb. x**y\nc. x^^y\nd. None of the mentioned\n3. Which one of these is floor division?\na. \/\nb. \/\/\nc. %\nd. None of the mentioned\n4. What is the output of this expression, 3*1**3? a. 27\nb. 9\nc. 3\nd. 1\n5. Which one of the following has the same precedence level?\na. Addition and Subtraction\nb. Multiplication, Division and Addition\nc. Multiplication, Division, Addition and Subtraction\nd. Addition and Multiplication\n6. Which one of the following has the highest precedence in the\nexpression?\na. Exponential\nb. Addition\nc. Multiplication\nd. Parentheses\n7. Operators with the same precedence are evaluated from?\na. Left to Right\nb. Right to Left\nc. Depends on Compiler\nd. None of the above\n8. Is \"in\" an operator in Python?\na. True\nb. False\nc. Neither true nor false\nd. None of the above\n9. str1=\"6\/4\"\nprint(\"str1\")\na. 1 b. 6\/4\nc. 1.5\nd. str1\n10. str1=\"Information\"\nprint(str1[2:8])\na. format\nb. formatio\nc. orma\nd. ormat\n11. Which keyword is used for function?\na. Fun\nb. Define\nc. Def\nd. Function\nAnswers\n1. b\n2. b\n3. b\n4. c\n5. a\n6. d\n7. a\n8. a\n9. d\n10. a\n11. c Questions\n1. What is an operator? Explain in detail.\n2. How many types of operator are there? Explain each operator in detail.\n3. What do you mean by operators' precedence and associativity? Explain\nin detail.\n4. Discuss identifiers and literals.\n5. Explain various types of operations performed on strings.\n6. Discuss type conversion with example.\n7. What do you mean by calling and called function?\n8. What do you mean by comments in Python? CHAPTER 3\nControl Flow Statements\nhe control flow of a program is the order in which the code for the\nT\nprogram is executed. Conditional statements, loops, and function calls\ngovern the control flow of a Python program.\nStructure\nIn this chapter, we will cover the following topics:\nTypes of control flow statements\nTypes of loops\nUse of and statements\nbreak continue\nUse of statements\npass\nObjective\nThe objective of this chapter is to introduce Python control flow statements.\nAfter completing this chapter, you should be familiar with various Python\ncontrol statements such as , , , and . Also, you\nif for while break continue\nwill be able to write Python programs using these conditional and looping\nstatements.\nUnderstanding control flow statement\nA control flow statement shows a program's control flow. Moreover, it is the\norder in which the program's code executes. The control flow of a Python\nprogram is regulated by conditional statements, loops, and function calls.\nThere are three types of control structures (figure 3.1):\nSequential control structures\nSelection control structures Repetition control structures\nFigure 3.1: Types of control flow statements\nSequential control structures\nIt uses a default mode because control moves line by line in a program.\nMoreover, it is a series of statements that is executed in a sequence.\nExample 3.1:\n# Python Program to find the area of triangle\na = 5\nb = 6\nc = 7\n# calculate the semi-perimeter\ns = (a + b + c) \/ 2\n# calculate the area\narea = (s*(s-a)*(s-b)*(s-c)) ** 0.5\nprint ('The area of the triangle is %0.2f' %area)\nOutput:\nThe area of the triangle is 14.70\nSelection control structures A selection control statement is also known as decision control statements\nor branching statements. The selection statements are based on condition. If a\ncondition is true, then it will be executed. It is also used for checking and\ntesting purposes.\nThere are various types of decision control statements:\nif\nif-else\nnested if\nif-elif-else\nif statements\nIf statements are used for running a particular code based on the condition. If\na condition is true, then it will work; otherwise, it won\u2019t. The following\nfigure 3.2 shows the flow diagram of the statement:\nif Figure 3.2: The if statements flow diagram\nExample 3.2:\n# If the number is positive and Negative\nn = 17\nif n > 0:\nprint (n, \"is a positive number.\")\nn1 = -12\nif n1<0:\nprint (n1, \"is a Negative number.\") Output:\n17 is a positive number.\n-12 is a Negative number.\nExample 3.3:\nn1 = 23\nn2 = 56\nif n2 > n1:\nprint (\"n2 is greater than n1\")\nif n2 < n1:\nprint (\"n2 is lesser than n1\")\nif n1 == n2:\nprint (\"n1 and n2 are equal\")\nOutput:\nn2 is greater than n1\nif-else statements\nThe statement is used for running a particular code based on the\nif-else if\nand statements. If a condition is true, then it will execute the code\nelse\nwithin block. If a condition is not true, then it will execute the code within\nif\nthe block. The following figure 3.3 shows the flow diagram of the\nelse if-\nstatement:\nelse Figure 3.3: The if-else statements flow diagram\nExample 3.4:\n# Program to checks whether the number is positive or\nnegative\nn = 7\nif n >= 0:\nprint (\"Positive or Zero\")\nelse:\nprint (\"Negative number\") Output:\nPositive or Zero\nExample 3.5:\nprice = 500\nif price >= 1000:\nprint (\"price is greater than 1000\")\nelse:\nprint (\"price is less than 1000\")\nOutput:\nprice is less than 1000\nnested if\nA nested statement means an statement inside another statement.\nif if if\nThe following figure 3.4 shows the flow diagram of nested statement:\nif Figure 3.4: The nested if flow diagram\nExample 3.6:\nn = 23\nif n >= 0:\nif n == 0:\nprint(\"Zero\")\nelse:\nprint (\"Positive number\")\nelse:\nprint (\"Negative number\")\nOutput:\nPositive number\nExample 3.7: x = 32\nif x > 10:\nprint (\"Above ten\")\nif x > 20:\nprint (\"and also above 20\")\nelse:\nprint (\"but not above 20.\")\nOutput:\nAbove ten\nand also above 20\nif-elif-else\nThe statement is used to execute a statement or a block of\nif-elif-else\nstatements conditionally. The following figure 3.5 shows the flow diagram of\nstatement:\nif-elif-else Figure 3.5: The if-elif-else flow diagram\nExample 3.8:\nn = 3.4\nif n > 0:\nprint (\"Positive number\")\nelif n == 0:\nprint (\"Zero\")\nelse:\nprint (\"Negative number\")\nOutput:\nPositive number Example 3.9:\nprice = 50\nif price > 100:\nprint (\"price is greater than 100\")\nelif price == 100:\nprint (\"price is 100\")\nelse :\nprint (\"price is less than 100\")\nOutput:\nprice is less than 100\nRepetition control structures\nIt is used to repeat a group of code multiple times, that is, looping. If we\nwant to repeat some instructions according to a particular condition, this\ncontrol structure will be used.\nThere are two types of loops in Python:\nloop\nfor\nloop\nwhile\nfor loop\nA loop is used to repeat over a sequence that is either a list, tuple,\nfor\ndictionary, or a set. It is essential to note that the keyword is part of the\nin\nstatement's syntax and is functionally unrelated to the in operator used\nfor\nfor membership testing. The following figure 3.6 shows the flow diagram of\nloop:\nfor Figure 3.6: The for-loop flow diagram\nExample 3.10:\n# Python program to repeating over range 0 to n-1\nn = 10\nfor i in range(0, n):\nprint (i)\nOutput:\n0\n1\n2\n3\n4\n5\n6\n7\n8 9\nExample 3.11:\nlist = [1,2,3,4,5,6,7,8,9,10]\nn = 5\nfor i in list:\nc = n*i\nprint (c)\nOutput:\n5\n10\n15\n20\n25\n30\n35\n40\n45\n50\nExample 3.12:\nfor x in range(5): #print numbers from 0 to 4\nprint(x)\nfor x in range(3, 6): #print numbers from 3 to 5\nprint(x)\nfor x in range(3, 8, 2): #print numbers from 3 to 7, step by\n2\nprint(x)\nOutput:\n0\n1\n2\n3\n4 3\n4\n5\n3\n5\n7\nwhile loop\nIt repeats the statement until a given condition is satisfied. If the condition is\ntrue, the loop will work; otherwise, it won\u2019t. The flow diagram of the\nwhile\nloop is shown in figure 3.7:\nwhile\nFigure 3.7: The while loop flow diagram\nExample 3.13:\ncnt = 0\nwhile (cnt < 10):\nprint (\"The count is:\", cnt)\ncnt = cnt + 1\nOutput:\nThe count is: 0\nThe count is: 1 The count is: 2\nThe count is: 3\nThe count is: 4\nThe count is: 5\nThe count is: 6\nThe count is: 7\nThe count is: 8\nThe count is: 9\nExample 3.14:\nn = 2\nwhile n < 10:\nprint (n)\nn = n + 3\nOutput:\n2\n5\n8\nNested loop\nA nested loop means one loop inside another loop. We can put a loop\nfor\ninside a , or a while inside a , or inside , or a inside\nwhile for for for while\na . Let us take an example to understand the nested loop.\nwhile\nExample 3.15:\n# This program uses a nested for loop to find the prime\nnumbers from 2 to 20\ni = 2\nwhile(i < 20):\nj = 2\nwhile(j <= (i\/j)):\nif not(i%j): break\nj = j + 1\nif (j > i\/j) : print (i, \" is prime\")\ni = i + 1\nOutput:\n2 is prime\n3 is prime\n5 is prime\n7 is prime\n11 is prime\n13 is prime\n17 is prime\n19 is prime\nExample 3.16:\n#program to print a pattern\nfor i in range (1, 5):\nfor j in range(i):\nprint (j + 1, end = ' ')\nprint ()\nOutput:\n1\n1 2\n1 2 3\n1 2 3 4\nExample 3.17:\n#program to print a pattern\nfor i in range (1, 5):\nfor j in range(i):\nprint (j + 1, end = ' ')\nprint ()\nOutput:\n1 1 2\n1 2 3\n1 2 3 4\nBreak statement\nThis statement is used to terminate a loop. The control will switch out of the\nloop when the statement is executed. The flow diagram of the\nbreak break\nstatement is shown in figure 3.8. If the statement is inside a nested\nbreak\nloop, then the statement will terminate the innermost loop:\nbreak\nFigure 3.8: The break statement flow diagram Example 3.18:\nnumbers = (1, 2, 3, 4, 5, 6, 7, 8, 9) # Declaring the tuple\nnum_sum = 0\ncount = 0\nfor x in numbers:\nnum_sum = num_sum + x\ncount = count + 1\nif count == 6:\nbreak\nprint (\"Sum of first \",count,\"integers is: \", num_sum)\nOutput:\nSum of first 6 integers is: 21\nExample 3.19:\nfor i in range(100):\nprint(i)\nif i == 7:\nbreak\nprint ('Loop exited')\nOutput:\n0\n1\n2\n3\n4\n5\n6\n7\nLoop exited\nContinue statement\nIt is used to skip the rest of the code inside a loop for the current iteration\nonly. In a statement, the loop does not terminate but continues with\ncontinue the next iteration. The flow diagram of the statement is shown in\ncontinue\nfigure 3.9:\nFigure 3.9: The continue statement flow diagram\nExample 3.20:\nfor i in range(10):\nif i==5:\ncontinue\nprint (i) Output:\n0\n1\n2\n3\n4\n6\n7\n8\n9\nExample 3.21:\nfor x in range(7):\nif (x == 4 or x==6):\ncontinue\nprint (x)\nOutput:\n0\n1\n2\n3\n5\nThe pass statement\nThe pass statement means a null statement in Python. The major difference\nbetween a comment and a pass statement is that while the interpreter ignores\na comment entirely, the pass is not ignored. Moreover, nothing happens when\nthe is executed. It results in no operation (NOP). Let us take an example\npass\nto understand the statement.\npass\nExample 3.22:\na = 33\nb = 200\nif b > a: pass\nOutput:\nNo output\nExample 3.23:\nsequence = {'b', 'g', 'd', 'k'}\nfor val in sequence:\npass\nOutput:\nNo output\nConclusion\nThis chapter discussed various types of control statements, that is, sequential\ncontrol structures, selection control structures, and repetition control\nstructures. It discusses each control statement in detail. It is discussed how\nthe loop will work? So, this chapter contains every control statement with a\nsuitable example and diagram. In the next chapter, we will discuss function\nas the next topic used in Python.\nPoints to remember\nSequential control structures use a default mode.\nSelection control statements are also known as decision control\nstatements or branching statements.\nRepetition control structures are also called loops.\nA statement is used for terminating a loop.\nbreak\nThe statement means null statement.\npass\nMultiple choice questions\n1. Which of the following is False regarding loops in Python?\na. Loops are used to perform certain tasks repeatedly. b. While loop is used when multiple statements are executed\nrepeatedly until the given condition becomes False\nc. While loop is used when multiple statements are executed\nrepeatedly until the given condition becomes true.\nd. for loop can be used to iterate through the elements of lists.\n2. Can we write if\/else into one line in Python?\na. Yes\nb. No\nc. if\/else not used in Python\nd. None of the above\n3. In a Python program, a control structure:\na. Defines program-specific data structures\nb. Directs the order of execution of the statements in the program\nc. It dictates what happens before the program starts and after it\nterminates\nd. None of the above\n4. for loop in Python works on\na. range\nb. iteration\nc. Both of the above\nd. None of the above\n5. In which of the following loops in Python can we check the\ncondition?\na. for loop\nb. while loop\nc. do-while loop\nd. None of the above\n6. To break the infinite loop, which keyword do we use?\na. continue b. break\nc. exit\nd. None of the above\n7. What do we put at the end of the loop?\na. semicolon\nb. colon\nc. comma\nd. None of the above\nAnswers\n1. b\n2. a\n3. b\n4. c\n5. b\n6. b\n7. b\nQuestions\n1. What do you mean by control flow statement? Discuss its types.\n2. Discuss all the decision control statements with suitable examples.\n3. What do you mean by and loop? Discuss in detail.\nfor while\n4. Explain nested loop with example.\n5. Write the difference between and statements? How\nbreak continue\nare they used in programming?\n6. Why statement is a null statement in Python?\npass CHAPTER 4\nFunctions\nunctions are a useful way to divide code into manageable pieces,\nF\nallowing us to organize, make it more readable, reuse, and save time.\nFurthermore, a function is a code block that executes when it is called. It\naccepts data as a parameter or an argument and returns the outcome.\nStructure\nIn this chapter, we will cover the following topics:\nUse of predefined and user-defined function\nUse of local and global variables\nTypes of functions (lambda functions, recursive functions, etc.)\nUse of parameter passing method into a function\nObjectives\nAfter studying this chapter, the concepts and working of function in Python\nshould be understood. You should be familiar with parameter passing and\nreturning values from functions. Also, you will be able to write Python\nprograms by using functions.\nIntroduction to Function\nA function contains a block of a statement that performs a specific task.\nThere are some essential rules for defining a function:\nFunction blocks start with the keyword. After that, the function\ndef\nname and parentheses ( ) are used.\n()\nAn argument or parameter should be inside the parentheses.\npass\nAny function's code block begins with a colon ( ) and is indented.\n: Syntax\ndef function_name(parameters):\n\"Statements 1\"\n\"Statements 2\"\n\"Statements 3\"\n-\n-\n-\n\"Statements n\"\nreturn [expression]\nThere are two types of functions as shown in figure 4.1:\nFigure 4.1: Types of functions\nPredefined functions\nIt is also called as built-in function because its functionality is predefined in\nPython. The Python interpreter has several functions that are always present\nfor use. There are various types of built-in functions. Some of the built-in\nfunctions are:\n: It returns the absolute value of a number.\nabs()\n: It returns the binary version of a number.\nbin()\n: It returns a floating-point number.\nfloat()\n: It converts a number into a hexadecimal value.\nhex()\n: It returns an integer number.\nint()\n: It returns the length of an object.\nlen()\n: It returns a list.\nlist() : It returns the largest item in an iterable.\nmax()\n: It returns the smallest item in an iterable.\nmin()\n: It converts a number into an octal.\noct()\n: It returns the value of to the power of .\npow() x y\n: It prints to the standard output device.\nprint()\n: It returns a sequence of numbers, starting from 0 and\nrange()\nincrements by 1 (by default).\n: It rounds a numbers.\nround()\nLet us take an example of the above built-in functions to clearly understand\ntheir usage.\nExample 4.1:\n#Return the absolute value of a number\nx1 = abs(-5.37)\nprint (x1)\n# Return the binary version of 24\nx2 = bin(24)\nprint (x2)\n#Convert the number 7 into a floating-point number\nx3 = float(7)\nprint (x3)\n#Convert 321 into hexadecimal value\nx4 = hex(321)\nprint (x4)\n#Convert the number 7.2 into an integer\nx5 = int(7.2)\nprint (x5)\n#Return the number of items in a list\nlist1 = [\"Brijesh\", \"Krishna\", \"Amit\", \"Raj\"]\nx6 = len(list1)\nprint (x6)\n#Return the largest number x8 = max(245, 433)\nprint (x8)\n#Return the lowest number\nx9 = min(343, 434)\nprint (x9)\n#Convert the number 12 into an octal value\nx10 = oct(32)\nprint (x10)\nx11 = pow(5, 5) #Return the value of 5 to the power of 5\n(same as 5 * 5 * 5 * 5)\nprint (x11)\n#Print a message onto the screen\nPrint (\"It is a message\")\n#Create a sequence of numbers from 0 to 7, and print each\nitem in the sequence\nx12 = range(8)\nfor n in x12:\nprint (n)\n#Round a number to only two decimals\nx13 = round(6.66543, 2)\nprint (x13)\nOutput:\n5.37\n0b11000\n7.0\n0x141\n7\n4\n433\n343\n0o40\n3125\nIt is a message 0\n1\n2\n3\n4\n5\n6\n7\n6.67\nUser-defined functions\nWhen a function is written for a specific task, those functions are called as\nuser-defined function. Moreover, it is a function created or written by the\nuser. Let's take an example of user-defined functions to clearly understand\ntheir working procedure.\nExample 4.2:\n# Declaring a show function\ndef show():\nprint (\"Inside function\")\n# Calling function\nshow()\nOutput:\nInside function\nExample 4.3:\n# A simple Python function for checking even and odd\ndef evenOdd(var):\nif (var%2 == 0):\nprint (\"Number is Even\")\nelse:\nprint (\"Number is Odd\")\n# Calling a function\nevenOdd(12) evenOdd(37)\nOutput:\nNumber is Even\nNumber is Odd\nFunction call\nWe may call a function to perform a task once it has been specified. For\ncalling a function, we type the name of the function and the necessary\nparameters.\nSyntax:\nfunction_name (argument_1, argument_2)\nExample 4.4:\n# Function Definition\ndef my_function():\nprint (\"This function has created\")\nmy_function() # Function Calling\nOutput:\nThis function has created\nExample 4.5:\n# Function Definition\ndef my_name(name):\nprint (name)\nmy_name('Ankit') # Function Calling with argument\nOutput:\nAnkit\nExample 4.6:\n# Function for sum of three numbers def sum_three_numbers(num1, num2, num3):\nreturn num1 + num2 + num3\n# Function calling with three arguments\nx= sum_three_numbers (10,20,30)\nprint (x)\nOutput:\n60\nFunction parameters and arguments\nA piece of information can be passed into a function based on function\narguments and parameters. Arguments are a specific value which passes into\na function. We can give many arguments, but they should be separated with a\ncomma. Both the terms, parameter and argument can be used interchangeably.\nFurthermore, data is passed through a function. There is a slight distinction\nbetween the function parameters and arguments.\nThe variable mentioned within the parentheses in the function description is\nreferred to as a parameter, while an argument is a value passed to the\nfunction when it is called. Let's look at an example to help you understand the\nmeaning of function arguments and parameters.\nExample 4.7:\n# Two parameters F_name and L_name\ndef Name_function(F_name, L_name): # Function Definition\nprint (F_name + \" \" + L_name)\n# Two arguments value (Brijesh, Bakariya)\nName_function(\"Brijesh\", \"Bakariya\") # Function Calling\nOutput:\nBrijesh Bakariya\nDefault arguments In Python, default values for function arguments are allowed. The assignment\noperator ( ) can be used to provide a default value for an argument. Consider\n=\nthe following scenario.\nExample 4.8:\ndef my_name(name, msg=\"how are you?\"): # Function\nDefinition\nprint (\"Hello\", name + ', ' + msg)\nmy_name(\"Dr. Brijesh Bakariya\") # Function Calling\nmy_name(\"Brijesh\", \"Welcome\") # Function Calling\nOutput:\nHello Dr. Brijesh Bakariya, how are you?\nHello Brijesh, Welcome\nLet's look at some other examples related to function.\nExample 4.9:\n#Python Arbitrary Arguments\ndef some_name(*names):\nprint(\"Hello\", names)\nsome_name(\"Brijesh\", \"Krishna\", \"Ram\", \"Amit\")\n#Arguments passing\ndef fun1(food):\nfor n in food:\nprint(n)\nvar = [\"apple\", \"banana\", \"cherry\"]\nfun1 (fruits)\nOutput:\nHello ('Brijesh', 'Krishna', 'Ram', 'Amit')\napple\nbanana\ncherry Variable scope and lifetime\nVariable cannot be accessible from any part of the program. Some of the\nvariables may not even exist for the entire duration of the program. The\nexistence and accessibility depends on the declaration of the variable.\nScope of the variable\nIt is a part of the program in which a variable is accessible. There are two\ntypes of scope of the variable.\nLocal scope\nGlobal scope\nLocal scope\nA variable created in the nested function then the scope exists in that\nfunction. Suppose the variable is declared in the innermost function, then the\nscope of that variable is only in the innermost function.\nGlobal scope\nA global variable is one that is generated in the main body of the software\nand belongs to the global scope. Global variables of this kind are available\nin any scope. Furthermore, the global variable is easily understood by any\nfunction, method, or code.\nThe lifetime of the variable\nIt is the duration for which a variable exists. Let's take an example to\nunderstand the concept of variable scope and lifetime.\nExample 4.10:\n# Here a variable created inside a function i.e. local scope\ndef show():\nx = 234 # Local variable\nprint (x)\nshow() x = 234 # Global Variable\ndef show():\nprint (x)\nshow()\nprint (x) # Global scope\nOutput:\n234\n234\n234\nLocal and global variables\nLocal variables are declared inside the method or block. Local variables are\nassessable only within the declared method or block and not outside that\nmethod or block.\nExample 4.11:\ndef my_fun():\nx=10 #Local variable\nprint (x)\nmy_fun()\nOutput:\n10\nExample 4.12:\ndef my_fun():\nx=10 #Local variable\nmy_fun()\nprint (x) # Here x is not local variable\nOutput: name 'x' is not defined\nGlobal variables\nThis type of variable is defined in the main body of a file. It is available\nthroughout the program. All kinds of functions or blocks can easily\nunderstand and access a global variable.\nExample 4.13:\nx = 100\ndef my_fun():\nprint (x) # Calling variable \u2018x\u2019 inside my_fun()\nmy_fun()\nprint (x) # Calling variable \u2018x\u2019 outside my_fun()\nOutput:\n100\n100\nExample 4.14:\nx=100 # Global Variable and global scope\ndef my_fun():\nx=50 # Local scope within my_fun()\nprint (x) # Print local variable\nmy_fun()\nprint (x) # Print Global variable\nOutput:\n50\n100\nGlobal statement\nThe local variable's scope is limited to the block in which it is specified.\nFurthermore, when we construct a variable within a function, that variable is local. It can only be used within that function, but we can construct a\nglobal\nvariable within a function using the keyword. Let's look at an\nglobal\nexample of a statement using the keyword to better\nglobal global\nunderstand the definition.\nExample 4.15:\ndef my_func():\nglobal x\nx = 100 # x is not local it is global because of global\nkeyword\nmy_func()\nprint (x) # print a global variable\nOutput:\n100\nSuppose we have a variable with the same name as that of a global variable\nin the program. In such a case, a new local variable of that name is created,\ndifferent from the global variable.\nExample 4.16:\nx=100\ndef show():\nx=50\nprint (\"In Function x is=\",x)\nshow()\nprint (\"Outside function is=\",x)\nOutput:\nIn Function x is= 50\nOutside function is= 100\nReturn statement\nIt's used to finish the function call's execution and return the result (value or\nexpression). There are a few key points to remember when it comes to statements:\nreturn\nReturn None is the same as a statement with no arguments.\nreturn\nThe statements following the statements are skipped.\nreturn\nIf there is no expression in the return declaration, the unique value None\nis returned.\nYou can't use a statement outside of a function.\nreturn\nSyntax:\ndef fun_name():\nfunction body\n.\n.\n.\nreturn [expression]\nExample 4.17:\ndef fun():\nreturn 10+20\nprint (fun())\nOutput:\n30\nExample 4.18:\n# Add both the parameters and return them\ndef addition(n1, n2):\ntotal = n1+ n2\nreturn total;\ntotal = addition(10, 20);\nprint (\"Addition is =\", total)\nOutput:\nAddition is = 30 Lambda functions\nAn anonymous function or function defined without a name is called lambda\nfunctions. Generally, functions are defined using the keyword, but\ndef\nanonymous functions are defined using the keyword. Lambda\nlambda\nfunctions have the following syntax:\nlambda arguments: expression\nThe following are some essential points about lambda functions:\nThe number of arguments for a lambda function is infinite, but there is\nonly one expression.\nIf we need an anonymous function for a short time, we use lambda\nfunctions.\nThe meaning of Lambda does not include a \" \" statement; instead,\nreturn\nit always includes an expression that is returned.\nExample 4.19:\n# Add 50 to argument n, and return the result:\nres = lambda a : a + 50\nprint (res(15))\nOutput:\n65\nExample 4.20:\n# sum of three numbers\nres = lambda n1, n2, n3 : n1 + n2 + n3\nprint (res(10, 20, 30))\nOutput:\n60\nRecursive functions When a function called itself is called recursion. When we define a function\nand call the same function in their definition that means that code is\nrecursive. Recursion is a very efficient technique for programming but one\nthing is to be remembered that the recursion should be terminated. If the\nterminating condition is there in recursion that means the code is properly\nworking. If the terminating condition is not there, that means the recursive\ncode is going to infinite times.\nSyntax:\ndef func_name(): <-\n|\n| (recursive call)\n|\nfunc_name() ----\nThe following are the advantages and disadvantages of a recursive function.\nAdvantages\nUsing recursion, this function can be broken down into smaller sub-\nproblems.\nOften creating a sequence is simpler than nested iteration.\nThe use of recursive functions makes the code appear simple and\nefficient.\nDisadvantages\nRecursive calls use a lot of memory and time, which is why they are\ncostly to use.\nDebugging recursive functions is difficult.\nThe logic behind recursion can be difficult to understand at times.\nExample 4.21:\n# Program for fibonacci series up to k terms\ndef fib(k): # Recursive function if k <= 1:\nreturn k\nelse:\nreturn(fib(k-1) + fib(k-2))\nterm=9\nif term <= 0:\nprint (\"Invalid input ! Please input a positive value\")\nelse:\nprint (\"Fibonacci series:\")\nfor i in range(term):\nprint (fib(i))\nOutput:\n0\n1\n1\n2\n3\n5\n8\n13\n21\nExample 4.22:\n# Recursive program for factorial of a number\ndef fact(k): # Recursive function\nif k == 1:\nreturn k\nelse:\nreturn k * fact(k-1)\nn = 7\n# check if the input is valid or not\nif n < 0:\nprint (\"Invalid input ! Please enter a positive number.\")\nelif n == 0: print (\"Factorial of number 0 is 1\")\nelse:\nprint (\"Factorial of number\", n, \"=\", fact(n))\nOutput:\nFactorial of number 7 = 5040\nFunction redefinition\nPython provides a facility for the redefinition of function because Python is\ndynamic. Redefinition of function means redefining an already defined\nfunction. Let's take an example to understand the concept of function\nredefinition.\nExample 4.23:\n# Program for function redefinition\nfrom time import gmtime, strftime\ndef show(msg): # Function definition\nprint (msg)\nshow(\"Ready.\")\ndef show(msg): # Function redefinition\nprint (strftime(\"%H:%M:%S\", gmtime()))\nprint (msg)\nshow (\"Processing.\")\nOutput:\nReady.\n11:20:20\nProcessing.\nConclusion\nIn this chapter, we discussed function and how they are important for\nmodular programming. They are concerned about the parameter passing\nmethod into a function. We have also discussed local and global variable, statements, and their scope. So, this chapter contains every variation of\nfunction and its working procedure. In the next chapter, we will discuss\nstrings and its related features as the next topic used in Python.\nPoints to remember\nFunction blocks start keyword after the function name and\ndef\nparentheses ().\nEach function has an indented code block that begins with a colon ( ).\n:\nReturn None is equivalent to a return statement with no arguments.\nThe number of arguments in a lambda function is unlimited, but there is\nonly one expression.\nMultiple choice questions\n1. Which keyword is used for function definition?\na. fun\nb. define\nc. def\nd. function\n2. Which of the following encloses the input parameters or arguments\nof a function?\na. brackets\nb. parentheses\nc. curly braces\nd. quotation marks\n3. What is called when a function is defined inside a class?\na. class\nb. function\nc. method\nd. Module 4. If the return statement is not used inside the function, the function\nwill return:\na. None\nb. 0\nc. Null\nd. Arbitrary value\n5. What is a recursive function?\na. A function that calls other functions.\nb. A function which calls itself.\nc. Both A and B\nd. None of the above\n6. How is a function declared in Python?\na. def function function_name():\nb. declare function function_name():\nc. def function_name():\nd. declare function_name():\n7. What will be the output of the following Python code?\nx = 50\ndef func():\nglobal x\nprint ('x is', x)\nx = 2\nprint ('Changed global x to', x)\nfunc()\nprint ('Value of x is', x)\na. x is 50\nChanged global x to 2\nValue of x is 50\nb. x is 50\nChanged global x to 2 Value of x is 2\nc. x is 50\nChanged global x to 50\nValue of x is 50\nd. Error\n8. What will be the output of the following Python code?\ndef show(message, times = 1):\nprint(message * times)\nshow('Hello')\nshow('World', 5)\na. Hello\nWorldWorldWorldWorldWorld\nb. Hello\nWorld 5\nc. Hello\nWorld,World,World,World,World\nd. Hello\nHelloHelloHelloHelloHello\nAnswers\n1. c\n2. b\n3. c\n4. a\n5. b\n6. c\n7. b\n8. a Questions\n1. What is a function? Discuss its types.\n2. What do you mean by function call? Discuss with an example.\n3. Explain function parameters and arguments with examples.\n4. What do you mean by the scope of the variable? Explain with an\nexample.\n5. Discuss the statement with an example\nglobal\n6. Discuss statement with an example.\nreturn\n7. What do you mean by lambda functions? Explain with a suitable\nexample.\n8. Write all the advantages and disadvantages of recursive functions. CHAPTER 5\nStrings\ntrings are arrays of bytes in Python that represent Unicode characters.\nS\nHowever, since Python lacks a character data type, a single character is\nsimply a string with one length. Square brackets may be used to access the\nstring's elements. Single quotes ('\u2026') or double quotes (\"\u2026\") may be used to\nenclose strings in Python.\nStructure\nIn this chapter, we will cover the following topics:\nUse of various types of string operations\nUse of built-in string functions\nUse of string formatting operator\nUse of immutable strings\nObjective\nAfter studying this chapter, you should be able to understand the working of\nstrings and various strings operations in Python. Also, you will be able to\nwrite programs with strings, including string comparison, iterations, and\nimmutable.\nConcepts of String\nA string is a sequence of characters. It is an essential concept in Python.\nThere are some important points about strings.\nStrings are amongst the most popular types in Python.\nPython can create strings simply by enclosing characters in quotes\n(single, double, or triple).\nPython treats single-quotes the same as double-quotes. A string is a sequence of Unicode characters and a character is simply a\nsymbol.\nIf we want to create a string of names, then it has to write the name within\nquotes like . The string can also assign a variable for\nWrite name here\nfurther operation and usage of that string. Let us take a basic example to\nunderstand this concept of string.\nExample 5.1:\nstr = \"This is a sting.\"\nprint (str)\nOutput:\nThis is a string\nThe character data type is not available in Python. A single character is\nconsidered as a string and its length would be one. The individual elements\nof any string can be accessed using square brackets ( ).\n[]\nExample 5.2:\nstr = \"Brijesh\"\nprint (str[0])\nprint (str[1])\nprint (str[2])\nprint (str[3])\nprint (str[4])\nprint (str[5])\nprint (str[6])\nOutput:\nB\nr\ni\nj\ne\ns\nh The string can use loop, character by character.\nfor\nExample 5.3:\nfor i in \"Krishna\":\nprint (i)\nOutput:\nK\nr\ni\ns\nh\nn\na\nOther concepts of strings such as function for getting the length of a\nlen()\nstring, keyword , for checking the substring or character is present\nin not in\nor not in a string. It can also use in an statement.\nif\nExample 5.4:\n# print a length of a string\nstr = \"Brijesh\"\nprint (len(str)) #String Length\n# print \"simple\" in a string\nstr1= \"Python is so simple\"\nprint (\"simple\" in str1)\n#Print only if \"simple\" is present in a string:\nstr2 = \"Python is so simple\"\nif \"simple\" in str2:\nprint (\"Yes, 'simple' is present.\")\n# print \"simple\" is not in a string\nstr3 = \"Python is so simple\"\nprint (\"programming\" not in str3)\nOutput: 7\nTrue\nYes, 'simple' is present.\nTrue\nString concatenation\nString concatenation means combining two strings. If we have two strings\nand those strings have been assigned into two variables and , they\nstr1 str2\ncan be concatenated or combined and .\nstr1 str2\nThere are four ways to concatenate the strings.\nUsing operator\n+\nUsing method\njoin()\nUsing operator\n%\nUsing function\nformat()\nUsing + operator\nIt is a straightforward way to concatenate two strings. It can add multiple\nstrings together. Let us take an example to understand this concept.\nExample 5.5:\n# Defining strings\nfname = \"Brijesh\"\nlname = \"Bakariya\"\n# + Operator is used to combine strings\nname = fname + lname\nprint (name)\nOutput:\nBrijeshBakariya\nUsing join() method The method is a string method that returns a string in which the\njoin()\nsequence elements have been joined using an separator.\nstr\nExample 5.6:\nfname = \"Brijesh\"\nlname = \"Bakariya\"\nprint (\"\".join([fname, lname]))\n# join() method string with a separator Space(\" \")\nname = \" \".join([fname, lname])\nprint (name)\nOutput:\nBrijeshBakariya\nBrijesh Bakariya\nUsing % operator\nIt can use a string formatting operator ( ) for concatenating the strings.\n%\nExample 5.7:\nfname = \"Brijesh\"\nlname = \"Bakariya\"\n# % operator\nprint (\"% s % s\" % (fname, lname))\nOutput:\nBrijesh Bakariya\nUsing format() function\nIt's an example of a string formatting method. Multiple substitutions and value\nformatting are possible. To concatenate the strings, it must use\n. This method uses positional formatting to concatenate\nstr.format()\nelements inside a series. The function in the following example\nformat()\ncombines the string stored in the and variables and stores it in\nfname lname another variable name. The curly braces are used to position strings in a\nspecific order. The first variable is stored in the first set of curly braces,\nwhile the second set of curly braces is stored in the second set of curly\nbraces.\nExample 5.8:\nfname = \"Brijesh\"\nlname = \"Bakariya\"\nprint (\"{} {}\".format(fname, lname))\n# result in name\nname = \"{} {}\".format(fname, lname)\nprint (name)\nOutput:\nBrijesh Bakariya\nBrijesh Bakariya\nAppending strings\nAppending to string means adding one string to other. Suppose we have two\nstrings and those strings have been assigned into two variables and\nstr1\n, then it can be appended or add to . There are two ways to\nstr2 str1 str2\nappend one string to another.\nUsing += operator\nUsing join()\nUsing += operator\nIt is a more straightforward way than the traditional way employed in other\nlanguages, like using a dedicated function to perform this particular task. Let\nus take an example to understand this concept.\nExample 5.9:\n# initializing string\nstr1 = \"Brijesh\" # initializing add_string\nstr2 = \"Bakariya\"\n# printing original string\nprint (\"The original string : \" + str(str1))\n# printing original add string\nprint (\"The add string : \" + str(str2))\n# adding one string to another\nstr1 += str2 # Using += operator\n# print result\nprint (\"The appended string is : \" + str1)\nOutput:\nThe original string: Brijesh\nThe add string: Bakariya\nThe appended string is: BrijeshBakariya\nUsing join()\nThis method is used to join the strings. This method's advantage over the\nabove method can be realized when we have many strings to concatenate\nrather than just two. Let us take an example to understand this concept.\nExample 5.10:\n# initializing string\nstr1 = \"Brijesh\"\n# initializing add_string\nstr2 = \"Bakariya\"\n# printing original string\nprint (\"The original string : \" + str(str1))\n# printing original add string\nprint (\"The add string : \" + str(str2))\n# adding one string to another\nresult = \"\".join((str1, str2)) # Using join()\n# print result\nprint (\"The appended string is : \" + result) Output:\nThe original string : Brijesh\nThe added string : Bakariya\nThe appended string is : BrijeshBakariya\nMultiplying strings\nMultiplication of strings in Python is much easier because it is similar to\nanother data type (number value, etc.). There are various methods that we\ncan go to multiply strings. Let us take an example to understand this concept.\nExample 5.11:\nstr1= \"Python Programming\"\nstr2= 2*str1 # Method 1\nprint (str2)\nstr3=4*(str1) # Method 2\nprint (str3)\nstr4= 3*('Python', 'Programming') # Method 3\nprint (str4)\nOutput:\nPython ProgrammingPython Programming\nPython ProgrammingPython Programming\n('Python', 'Programming', 'Python', 'Programming', 'Python',\n'Programming')\nImmutable strings\nAn immutable string means that the string values cannot be updated.\nMoreover, once we assign the string's value, it cannot be reassigned when\nwe perform this, it will produce an error. Let us take an example to\nunderstand this concept.\nExample 5.12:\nstr= \"Brijesh\" print (str)\nstr[0] = \"V\" # Cannot reassign\nOutput:\nstr[0] = \"V\" # Cannot reassign\nTypeError: 'str' object does not support item assignment\nString formatting operator\nIt uses the operator for string formatting operations. Various symbols can\n%\nbe used along with , as shown in table 5.1:\n%\nSymbol Description\n%f It is for a floating-point real number\n%d It is for a signed decimal integer\n%u It is for an unsigned decimal integer\n%o It is for an octal integer\n%X It is for a hexadecimal integer (Uppercase letters)\n%e It is for an exponential notation (with lowercase 'e')\n%E It is for an exponential notation (with UPPERcase 'E')\n%g It is for the shorter of %f and %e\n%G It is for the shorter of %f and %E\n%c It is for a character\n%s It is for a string conversion via str() before formatting\n%i It is for a signed decimal integer\n%x It is for a hexadecimal integer (lowercase letters)\nTable 5.1: String formatting symbols and their description\nLet us take an example to understand the concept of string formatting\noperator.\nExample 5.13: # Initialize variable as a string\nvar = '27'\nstring = \"Variable as string = %s\" %(var)\nprint (string)\n# Printing as raw data\nprint (\"Variable as raw data = %r\" %(var))\n# Convert the variable to integer\n# And perform check other formatting options\nvar = int(var)\nstring = \"Variable as integer = %d\" %(var)\nprint (string)\nprint (\"Variable as float = %f\" %(var))\nprint (\"Variable as printing with special char = %c Ram\" %\n(var))\nprint (\"Variable as hexadecimal = %x\" %(var))\nprint (\"Variable as octal = %o\" %(var))\nOutput:\nVariable as string = 27\nVariable as raw data = '27'\nVariable as integer = 27\nVariable as float = 27.000000\nVariable as printing with special char = Ram\nVariable as hexadecimal = 1b\nVariable as octal = 33\nBuilt-in string functions\nThere are various types of built-in string functions. We just use those\nfunctions and get the desired results. One crucial point is that these functions\nreturn new strings. It cannot change the original string. Here are some\nessential built-in string functions.\n: It returns the number of times a specified value occurs in a\ncount()\nstring. : It returns if all characters in the string are in lower\nislower() True\ncase.\n: It splits the string at the specified separator and returns a list.\nsplit()\n: It returns if the string ends with the specified value.\nendswith() True\n: It returns a centered string.\ncenter()\n: It returns if all characters in the string are\nisalnum() True\nalphanumeric.\n: It returns if all characters in the string are numeric.\nisnumeric() True\n: It converts the first character of each word to upper case\ntitle()\nLet us take an example to understand the above built-in string functions.\nExample 5.14:\n# built-in string functions\ntxt = \"Python is a good prog., Python is easy to learn,\nPython is easy to understand.\"\ncnt = txt.count(\"Python\")\nprint (cnt)\nlow = txt.islower() # check if all the characters in the\ntext are in lower case\nprint (low)\nspl= txt.split() #Split a string into a list where each word\nis a list item\nprint (spl)\new = txt.endswith(\".\") #Check if the string ends with a (.)\nprint (ew)\ncen = txt.center(10) # space of 10 characters\nprint (cen)\nan = txt.isalnum() #Check if all the characters in the text\nare alphanumeric\nprint (an)\nisn = txt.isnumeric() #Check if all the characters in the\ntext are numeric print (isn)\ntit = txt.title() # first letter in each word upper case\nprint (tit)\nOutput:\n3\nFalse\n['Python', 'is', 'a', 'good', 'prog.,', 'Python', 'is',\n'easy', 'to', 'learn,', 'Python', 'is', 'easy', 'to',\n'understand.']\nTrue\nPython is a good prog., Python is easy to learn, Python is\neasy to understand.\nFalse\nFalse\nPython Is A Good Prog., Python Is Easy To Learn, Python Is\nEasy To Understand.\nSlice operation\nThe function returns a slice object that can be used to slice strings,\nslice()\nlists, tuple, etc. Following is the syntax with parameters description of\nfunction.\nslice()\nSyntax:\nslice(stop)\nslice(start, stop, step)\nA parameter specifies the index at which an object's slicing begins. A\nstart\nstop parameter sets the index at which an object's slicing comes to a halt. The\nincrement between each index for slicing is determined by the step\nparameter, an optional statement.\nFollowing are some important points about the function\nslice()\nThe function returns a sliced object that only contains\nslice()\nelements from the defined set. If only one parameter is passed, then the start and step are considered to\nbe .\nNone\nLet us take an example to understand the concept of functions.\nslice()\nExample 5.15:\n# It start the slice object at position 2, and slice to\nposition 4, and return the result:\nvar = (\"b\", \"r\", \"i\", \"j\", \"e\", \"s\", \"h\")\nsl = slice(2, 4)\nprint (var[sl])\n#It use the step parameter to return every second item:\nvar = (\"b\", \"r\", \"i\", \"j\", \"e\", \"s\", \"h\")\nsl = slice(0, 7, 2)\nprint (var[sl])\nOutput:\n('i', 'j')\n('b', 'i', 'e', 'h')\nExample:\n# String slicing\nstr ='BrijeshBakariya'\nsl1 = slice(2)\nsl2 = slice(1, 4, 3)\nprint (\"String slicing\")\nprint (str[sl1])\nprint (str[sl2])\n# List slicing\nlst = [5, 6, 7, 8, 9]\nsl1 = slice(2)\nsl2 = slice(1, 4, 2)\nprint (\"\\nList slicing\")\nprint (lst[sl1])\nprint (lst[sl2]) # Tuple slicing\ntpl = (4, 5, 6, 7, 8)\nsl1 = slice(3)\nsl2 = slice(1, 5, 2)\nprint (\"\\nTuple slicing\")\nprint (tpl[sl1])\nprint (tpl[sl2])\nOutput:\nString slicing\nBr\nr\nList slicing\n[5, 6]\n[6, 8]\nTuple slicing\n(4, 5, 6)\n(5, 7)\nThe ord() and chr() functions\nThe ord() function\nIt's a built-in feature that returns the single Unicode character's integer as an\ninteger. The returned integer represents the Unicode code point. Furthermore,\nthe function returns an integer representing the character's Unicode\nord()\ncode point when passed a string of length 1. A will be raised if\nTypeError\nthe string length is greater than one. Let us take an example to understand the\nconcept of functions.\nord()\nExample 5.16:\nres1 = ord('A')\nres2 = ord('a')\nprint (res1, res2) # prints the unicode value Output:\n65 97\nThe chr() function\nFrom an integer, the method returns a character or string. The integer\nchr()\nrepresents the character's Unicode code point. Let us take an example to\nunderstand the concept of functions.\nchr()\nExample 5.17:\nres1 = chr(65) #return a character of unicode valve 65\nres2 = chr(97) #return a character of unicode valve 97\nprint (res1, res2) # prints the character value\nOutput:\nA\nComparing strings\nComparing strings means identifying whether the two strings are equivalent\nto each other or not. There are three ways to compare the strings.\nUsing relational operators\nUsing is and is not\nUser-defined function\nUsing relational operators\nThe relational operators compare the Unicode values of the characters of the\nstrings. It returns a Boolean value according to the operator used. Following\nare the relational operators available in Python.\nOperator (==): This operator checks whether two strings are equal.\nOperator (!=): This operator checks if two strings are not equal.\nOperator (<): This operator checks if the string on its left is smaller\nthan that on its right. Operator (<=): This operator checks if the string on its left is smaller\nthan or equal to that on its right.\nOperator (>): This operator checks if the string on its left is greater\nthan that on its right.\nOperator (>=): This operator checks if the string on its left is greater\nthan or equal to that on its right.\nLet us take an example to understand the concept of relational operators for\nstring.\nExample 5.18:\nprint (\"Brijesh\" == \"Brijesh\")\nprint (\"Brijesh\" < \"brijesh\")\nprint (\"Brijesh\" > \"brijesh\")\nprint (\"Brijesh\" <= \"brijesh\")\nprint (\"Brijesh\" >= \"brijesh\")\nprint (\"Brijesh\" != \"Brijesh\")\nOutput:\nTrue\nTrue\nFalse\nTrue\nFalse\nFalse\nUsing is and is not\nThis type of operator checks whether both the operands refer to the same\nobject or not. Let us take an example to understand this concept.\nExample 5.19:\nstr1 = \"Brijesh\"\nstr2 = \"Brijesh\"\nstr3 = str1\nprint (str1 is not str1) print (str1 is not str2)\nprint (str1 is not str3)\nprint (str1 is str1)\nprint (str1 is str2)\nprint (str1 is str3)\nOutput:\nFalse\nFalse\nFalse\nTrue\nTrue\nTrue\nUser-defined function\nWe can make user-defined functions for string comparison. A user-defined\nfunction will compare the strings based upon the number of digits. Let's take\nan example\nExample 5.20:\ndef str_cmp(str1, str2): #comparison of string based on the\nnumber of digits\ncount1 = 0\ncount2 = 0\nfor i in range(len(str1)):\nif str1[i] >= \"0\" and str1[i] <= \"9\":\ncount1 += 1\nfor i in range(len(str2)):\nif str2[i] >= \"0\" and str2[i] <= \"9\":\ncount2 += 1\nreturn count1 == count2\nprint (str_cmp(\"234\", \"5672\"))\nprint (str_cmp(\"1246\", \"Brijesh\")) print (str_cmp(\"22Brijesh\", \"Brijesh22\"))\nOutput:\nFalse\nFalse\nTrue\nIterating strings\nIterating over a string means accessing each of its characters one at a time.\nThere are various ways to iterate over the characters of a string in Python.\nLet's take an example.\nExample 5.21:\n# Using simple iteration and range()\nstr1 = \"Brijesh\"\nfor var in str1:\nprint (var, end=' ')\nprint (\"\\n\")\nstr2 = \"Bakariya\"\nfor i in range(0, len(str2)): # Iterate over index\nprint (str2[i])\nOutput:\nB r i j e s h\nB\na\nk\na\nr\ni\ny\na Example 5.22:\n#Using enumerate() function\nstr3 = \"Brijesh\"\n# Iterate over the string\nfor i, v in enumerate(str3):\nprint (v)\nOutput:\nB\nr\ni\nj\ne\ns\nh\nExample 5.23:\n#Using enumerate() function\nstr3 = \"Brijesh\"\n# Iterate over the string\nfor i, v in enumerate(str3):\nprint (v)\nOutput:\nB\nr\ni\nj\ne\ns\nh\nIn Python, we can also iterate over the words of a string. A string of several\nwords separated by spaces is given. In Python, there are many methods for\niterating over words in a string. Using split()\nWe can split the string into a list of words, but this method fails if the string\ncontains punctuation marks. Let us take an example.\nExample 5.24:\nstr1 = \"Python is a good prog., Python is easy to use, Python\nis easy to understand\"\nprint (\"The original string is: \" + str1)\nresult = str1.split() # using split() to extract words from\nstring\nprint (\"\\nThe words of string are\")\nfor i in result:\nprint (i)\nOutput:\nThe original string is: Python is a good prog., Python is\neasy to use, Python is easy to understand\nThe words of string are\nPython\nis\na\ngood\nprog.,\nPython\nis\neasy\nto\nuse,\nPython\nis\neasy\nto\nunderstand Using re.findall()\nThis approach necessitates the use of regular expressions to complete the\njob. After filtering the string and extracting words while ignoring punctuation\nmarks, the function returns the list. Let's look at an example.\nfindall()\nExample 5.25:\n#findall() example\nimport re\nstr1= \"Python is a good prog., Python is easy to use, Python\nis easy to understand\"\nprint (\"The original string is: \" + str1)\nresult = re.findall(r'\\w+', str1)\nprint (\"\\nThe words of string are\")\nfor i in result:\nprint (i)\nOutput:\nThe original string is: Python is a good prog., Python is\neasy to use, Python is easy to understand\nThe words of string are Python\nis\na\ngood\nprog\nPython\nis\neasy\nto\nuse\nPython\nis\neasy\nto\nunderstand The string module\nThe string module is a built-in module for using classes and constants. First\nof all, we have to import it so that it can be used. Let us take an example.\nString module constants\nThere are various types of string constants defined in this module are:\n: The following constants are concatenated:\nstring.ascii_letters\nand .\nascii_lowercase ascii_uppercase\n: The lowercase letters '\nstring.ascii_lowercase abcdefghijklmno\n'. This value is not locale-dependent and will not change.\npqrstuvwxyz\n: The uppercase letters '\nstring.ascii_uppercase ABCDEFGHIJKLM\n'. This value is not locale-dependent and will not\nNOPQRSTUVWXYZ\nchange.\n: The string '0 '.\nstring.digits 123456789\n: The string ' '.\nstring.hexdigits 0123456789abcdefABCDEF\n: String of ASCII characters which are\nstring.punctuation\nconsidered punctuation characters in the C locale:\n.\n!\"#$%&'()*+,-.\/:;<=>?@[\\]^_`{|}~\nExample 5.26:\n# import string library function\nimport string\n# Storing the value in variable result variables\nresult1 = string.ascii_letters\nresult2 =string.ascii_lowercase\nresult3 =string.ascii_uppercase\nresult4 =string.digits\nresult5 =string.hexdigits\nresult6 =string.punctuation\n# Printing the value\nprint (result1)\nprint (result2)\nprint (result3) print (result4)\nprint (result5)\nprint (result6)\nOutput:\nabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\nabcdefghijklmnopqrstuvwxyz\nABCDEFGHIJKLMNOPQRSTUVWXYZ\n0123456789\n0123456789abcdefABCDEF\n!\"#$%&'()*+,-.\/:;<=>?@[\\]^_`{|}~\nString capwords() function\nThis function splits the specified string into words and capitalizes each word\nin it.\nExample 5.27:\n# import string library function\nimport string\nstr= 'My name is Dr. Brijesh Bakariya'\nresult= string.capwords(str)\nprint (result)\nOutput:\nMy Name Is Dr. Brijesh Bakariya\nString module classes\nThere are two types of string module classes:\nFormatter\nTemplate\nFormatter This class becomes useful if we want to subclass it and define your format\nstring syntax. Moreover, it is same as function. Let us take an\nstr.format()\nexample to understand the concept of class.\nFormatter\nExample 5.28:\nfrom string import Formatter\nformatter = Formatter()\nprint (formatter.format('{Faculty}', Faculty='Dr. Brijesh\nBakariya'))\nprint (formatter.format('{} {Faculty}', 'Hello', Faculty='Dr.\nBrijesh Bakariya'))\nprint ('{} {Faculty}'.format('Hello', Faculty='Dr. Brijesh\nBakariya')) # it is same as format()\nOutput:\nDr. Brijesh Bakariya\nHello Dr. Brijesh Bakariya\nHello Dr. Brijesh Bakariya\nTemplate\nThe class enables us to construct output specification syntax that is\nTemplate\neasier to understand. The format combines with valid Python identifiers,\n$\nsuch as alphanumeric characters and underscores, to create placeholder\nnames. Let's look at an example to understand the idea of the class.\nTemplate\nExample 5.29:\n# template example\nfrom string import Template\n# Creating a template\ntemp = Template('P is $P')\n# Substitute value\nprint (temp.substitute({'P' : 1}))\n# List of faculty stores the name and their id Faculty = [('Dr. Brijesh Bakariya',11), ('Dr.Krishna K.\nMohbey ',22), ('Dr. Amit Kumar',33)]\ntemp = Template('Hello $name, $id is your employee id')\nfor var in Faculty:\nprint (temp.substitute(name = var[0], id = var[1]))\nOutput:\nP is 1\nHello Dr. Brijesh Bakariya, 11 is your employee id\nHello Dr.Krishna K. Mohbey, 22 is your employee id\nHello Dr. Amit Kumar, 33 is your employee id\nRegular expression\nA regular expression is a special sequence of characters that uses a\nspecialized syntax to help you fit or locate other strings or sets of strings. It\nalso defines a set of strings (pattern) that corresponds to it. The following\nmetacharacters are available for use in functions:\nMetacharacters (\\): It used to drop the special meaning of a character.\nMetacharacters ([]): It represents a character class.\nMetacharacters (^): It matches the beginning.\nMetacharacters ($): It matches the end.\nMetacharacters (.): It matches any character except newline.\nMetacharacter s(?): It matches zero or one occurrence.\nMetacharacters (|): It matches any of the characters separated by it.\nMetacharacters (*): It shows any number of occurrences (including 0\noccurrences)\nMetacharacters (+): It is for one or more occurrences.\nMetacharacters ({}): It indicates several occurrences of a preceding\nregular expression to match.\nMetacharacters (()): It encloses a group of regular expressions.\nLet us take an example to understand the concept of regular expression. Example 5.30:\nimport re\np = re.compile('[a-m]')\nprint (p.findall(\"My name is Brijesh\"))\nOutput:\n['a', 'm', 'e', 'i', 'i', 'j', 'e', 'h']\nThe ' ' metacharacter plays a crucial function in signaling different\n\\\nsequences. Following are the uses of metacharacter ( ), which is shown in\n\\\ntable 5.2:\nSymbol Description\n\\d It's equivalent to the set class [0-9] and matches every decimal digit.\n\\D It can be used to match any non-digit character.\n\\s It is compatible with every whitespace character.\n\\S It can be used to match any non-whitespace character.\n\\w It is equivalent to the class [a-zA-Z0-9], which matches every\nalphanumeric character.\n\\W It can be used to match any non-alphanumeric character.\nTable 5.2: Metacharacters along with backslash (\\)\nExample 5.31:\nimport re\np1 = re.compile('\\d') # \\d is equivalent to [0-9].\nprint (p1.findall(\"My age is 36 year and my year of Birth is\n1985\"))\np2 = re.compile('\\d+') # \\d+ will match a group on [0-9],\ngroup of one or greater size\nprint (p2.findall(\"My age is 36 year and my year of Birth is\n1985\"))\np3 = re.compile('\\w') # \\w is equivalent to [a-zA-Z0-9_]. print (p3.findall(\"Welcome to the world of python. *\"))\np4 = re.compile('\\w+') # \\w+ matches to group of\nalphanumeric character.\nprint (p4.findall(\"My age is 36 year and my year of Birth is\n1985.\"))\np5 = re.compile('\\W') # \\W matches to non alphanumeric\ncharacters.\nprint (p5.findall(\"Welcome to the world of python. *\"))\np6 = re.compile('br*') # '*' replaces the no. of occurrence\nof a character.\nprint (p6.findall(\"brbrbrbrbrbrbrbbbrrrrrr\"))\nOutput:\n['3', '6', '1', '9', '8', '5']\n['36', '1985']\n['W', 'e', 'l', 'c', 'o', 'm', 'e', 't', 'o', 't', 'h', 'e',\n'w', 'o', 'r', 'l', 'd', 'o', 'f', 'p', 'y', 't', 'h', 'o',\n'n']\n['My', 'age', 'is', '36', 'year', 'and', 'my', 'year', 'of',\n'Birth', 'is', '1985']\n[' ', ' ', ' ', ' ', ' ', '.', ' ', '*']\n['br', 'br', 'br', 'br', 'br', 'br', 'br', 'b', 'b',\n'brrrrrr']\nExample 5.32:\nimport re\n# Upon matching, 'y' is replaced by '!!' and CASE has been\nignored\nprint (re.sub('y', '~*', 'My age is 36 year and my year of\nBirth is 1985', flags = re.IGNORECASE))\n# Consider the Case Sensitivity, 'y' in \"year\", will not be\nreplaced.\nprint (re.sub('y', '!!', 'My age is 36 year and my year of\nBirth is 1985')) # As count has been given value 1, the maximum time\nreplacement occurs is 1\nprint (re.sub('y', '!!', 'My age is 36 year and my year of\nBirth is 1985', count=1, flags = re.IGNORECASE))\n# 'r' before the patter denotes RE, \\s is for start and end\nof a String.\nprint (re.sub(r'\\sAND\\s', ' & ', 'Book and note book',\nflags=re.IGNORECASE))\nOutput:\nM~* age is 36 ~*ear and m~* ~*ear of Birth is 1985\nM!! age is 36 !!ear and m!! !!ear of Birth is 1985\nM!! age is 36 year and my year of Birth is 1985\nBook & note book\nConclusion\nThis chapter discussed strings and their various operations like\nconcatenating, appending, multiplying, etc. It is concerned about the string\nformatting operator and its working procedure. It also discussed some built-\nin string functions and other operations like , , ,\nslice() ord() chr()\ncomparing and iterating a string, further explaining regular expression with a\ngood example. In the next chapter, we will discuss lists as the next topic used\nin Python.\nPoints to remember\nA string can be created by enclosing characters in quotes (single,\ndouble, or triple).\nAn immutable string means string value cannot be updated.\nString uses operator for string formatting operations.\n%\nThe function returns the value of a single Unicode character as\nord()\nan integer.\nA regular expression is a special sequence of characters for matching\npurposes. Multiple choice questions\n1. Which of the following is False?\na. A string is immutable.\nb. capitalize() function in a string is used to return a string by\nconverting the whole string into uppercase.\nc. lower() function in a string is used to return a string by converting\nthe whole string into lowercase.\nd. None of these.\n2. Which of the following functions convert an integer to hexadecimal\nstring in Python?\na. unichr(x)\nb. ord(x)\nc. hex(x)\nd. oct(x)\n3. What is the output of for x in [2, 3, 4]: print x?\na. x\nb. 2 3 4\nc. Error\nd. None of the above.\n4. Suppose a list with name arr contains 5 elements. You can get the\n2nd element from the list using:\na. arr[-2]\nb. arr[2]\nc. arr[-1]\nd. arr[1]\n5. Which of the following operations cannot be performed on a Python\nstring?\na. Deletion of a Python string b. Splitting of a Python string\nc. Adding elements in a Python string\nd. Reassigning of a Python string\n6. Which string method is used to check if all the given characters in a\nPython string defined in our program are in lower case?\na. isnumeric()\nb. islower()\nc. isdigit()\nd. islwer()\n7.\nstr1=\"8\/2\"\nprint(\"str1\")\na. 1\nb. 6\/4\nc. 1.5\nd. str1\n8.\nstr1=\"Information\"\nprint(str1[2:8])\na. format\nb. formatio\nc. orma\nd. ormat\n9. Python has a built-in package called?\na. reg\nb. regex\nc. re\nd. regx\n10. Which function returns a list containing all matches?\na. findall\nb. search c. split\nd. find\n11. Which character stands for Zero or more occurrences in regex?\na. *\nb. #\nc. @\nd. |\nAnswers\n1. b\n2. c\n3. b\n4. d\n5. c\n6. b\n7. d\n8. a\n9. c\n10. a\n11. a\nQuestions\n1. What is a string? Write a program to display a string.\n2. What do you mean by string concatenation? Discuss all methods of\nstring concatenation.\n3. Discuss multiplying strings with suitable examples.\n4. What do you mean by immutable strings? Explain with a suitable\nexample.\n5. Discuss string formatting operator with proper explanation. 6. Write any five built-in string functions with an explanation\n7. Explain , , and method with example.\nslice() ord() chr()\n8. Discuss all the methods for comparing and iterating the strings\n9. What do you mean by regular expression? Explain with a suitable\nexample. CHAPTER 6\nLists\nhe list datatype in Python is the most powerful, and it can be written as a\nT\nlist of comma-separated values between square brackets. A list is often\nused to store the sequence of different types of data. The list is mutable,\nwhich means it can modify its element after it is created. This chapter covers\nmultiple operations that can be applied on lists.\nStructure\nIn this chapter, we will cover the following topics:\nUse the concept of lists.\nUse the various type of list operations\nUse list functions\nUse list processing\nUse of different sorting in list\nObjective\nThis chapter's goal is to introduce the lists in Python. After completing this\nchapter, you should be able to perform various list-related operations. Also,\nyou will be able to write Python codes using the list. This chapter covers\nvarious types of list sorting, such as bubble sort, selection sort, insertion\nsort, quick sort, merge sort, and so on. You will also understand the uses of\nvarious list functions in Python.\nBasics of lists\nList is a very important data type in Python, and it is written as a comma-\nseparated values enclosed with square brackets. The following is the\nexample of lists: list1 = ['Brijesh', 'Krishna', 36, 35];\nlist2 = [1, 2, 3, 4, 5];\nlist3 = [\"a\", \"b\", \"c\", \"d\"]\nThere are the following important points about lists:\nList items are ordered, and that order will not change except for some\nlist methods.\nThe list allows duplicate values.\nThe list is changeable, which means we can add and delete items in a\nlist after it has been created.\nThe first item has index [0], and indexing will increase.\nLet us take a basic example to understand the basic concept of lists.\nExample 6.1:\n# Basics of lists\nl1 = ['Brijesh', 'Krishna', 36, 35];\nl2 = [1, 2, 3, 4, 5];\nl3 = [\"a\", \"b\", \"c\", \"d\"]\nprint (l1)\nprint (l2)\nprint (l3)\n#List allow duplicates values\ndl = [\"Brijesh\", \"Krishna\", \"Krishna\", \"Krishna\", \"Brijesh\",\n\"Misthi\"]\nprint (dl)\nOutput:\n['Brijesh', 'Krishna', 36, 35]\n[1, 2, 3, 4, 5]\n['a', 'b', 'c', 'd']\n['Brijesh', 'Krishna', 'Krishna', 'Krishna', 'Brijesh',\n'Misthi']\nExample 6.2: l1 = ['Brijesh', 'Krishna', 36, 35];\nprint (type(l1))\nlc = list (('Brijesh', 'Krishna', 36, 35))\nprint (lc)\nOutput:\n<class 'list'>\n['Brijesh', 'Krishna', 36, 35]\nCreating lists\nIt can make any list by putting the series in square brackets and separating\n[]\nit with commas. It may contain any number of items of various kinds, such as\nintegers, floats, strings, and so on. Let us take a basic example.\nExample 6.3:\n# empty list\nl1 = []\n# list of integers\nl2 = [4, 5, 6, 7]\n# list with mixed data types\nl3 = [2, \"Dr. Brijesh Bakariya\", \"Dr. Krishna K. Mohbey\",\n88.9]\nprint (l1)\nprint (l2)\nprint (l3)\nOutput:\n[]\n[4, 5, 6, 7]\n[2, 'Dr. Brijesh Bakariya', 'Dr. Krishna K. Mohbey', 88.9]\nAccessing values from a list Every value in a list is indexed, and it can access them by referring to the\nindex number. There are various ways to access a list of elements.\nUsing list index\nIt can access a list object using the index operator . The indexes begin\n[]\nfrom 0. Suppose the list has seven elements, then it starts from 0 to 6. If you\nwant to access out of index values, it will raise an . One of the\nIndexError\nessential things to remember an index must be an integer value means to float,\nand other types are not allowed. If you put another data type in the index\nvalue, then it will raise . Let us take an example to understand this\nTypeError\nconcept.\nExample 6.4:\n# List indexing\nListExample = ['b', 'r', 'i', 'j', 'e', 's', 'h']\nprint (ListExample [0])\nprint (ListExample [1])\nprint (ListExample [2])\nprint (ListExample [3])\nprint (ListExample [4])\nprint (ListExample [5])\nprint (ListExample [6])\nOutput:\nb\nr\ni\nj\ne\ns\nh\nNegative indexing\nNegative indexing is also allowed for its sequences. In negative indexing, -1\nrefers to the last item, -2 to the second last, -3 to the third last, and so on. The following figure 6.1 shows the negative indexing in Python.\nFigure 6.1: Negative indexing in Python.\nLet us take an example to understand this concept.\nExample 6.5:\n# Example of negative list\nListExample = ['b','r','i','j','e','s','h']\nprint (ListExample [-1]) # Last index\nprint (ListExample [-2])\nprint (ListExample [-3])\nprint (ListExample [-4])\nprint (ListExample [-5])\nprint (ListExample [-6])\nprint (ListExample [-7]) # First Index\nOutput:\nh\ns\ne\nj\ni\nr\nb\nExample 6.6:\nlist1 = ['Brijesh', 'Krishna', 36, 35]\nprint (list1[-1]) print (list1[-2])\nprint (list1[-3])\nprint (list1[-4])\nOutput:\n35\n36\nKrishna\nBrijesh\nTo slice, delete, remove, and clear a list of elements\nIt can be accessed through the range of items in a list by using the slicing\noperator. It is represented by colon ( ). Adding and changing an element in\n:\nthe list is possible using the assignment operator ( ). The keyword can\n= del\nbe used to remove one or more items from a list. It can completely delete the\nlist. The method can be used to remove a specific object, while\ndelete()\nthe method can be used to remove an item at a specific index. To\npop()\nempty a list, we can use the method. Let's look at an example to\nclear()\nbetter understand the operators and methods described.\nExample 6.7:\nml = ['b', 'r', 'i', 'j', 'e', 's', 'h']\nprint(ml[2:5]) #elements 3rd to 5th\nprint(ml[:-6]) #elements beginning to 5th\nprint(ml[3:]) #elements 4th to end\nprint(ml[:]) #elements beginning to end\nml = ['b', 'r', 'i', 'j', 'e', 's', 'h']\ndel ml[2] # delete one item\nprint(ml)\ndel ml[1:5] # delete multiple items\nprint (ml)\nmlist = ['b', 'r', 'i', 'j', 'e', 's', 'h']\nmlist.remove('r')\nprint (mlist) print (mlist.pop(1))\nprint (mlist)\nprint (mlist.pop())\nprint (mlist)\nmlist.clear()\nprint (mlist)\ndel ml # delete entire list\nprint (ml) # Error: List not defined\nOutput:\n['i', 'j', 'e']\n['b']\n['j', 'e', 's', 'h']\n['b', 'r', 'i', 'j', 'e', 's', 'h']\n['b', 'r', 'j', 'e', 's', 'h']\n['b', 'h']\n['b', 'i', 'j', 'e', 's', 'h']\ni\n['b', 'j', 'e', 's', 'h']\nh\n['b', 'j', 'e', 's']\n[]\nTraceback (most recent call last):\nFile \"C:\\Users\\brije\\.spyder-py3\\temp.py\", line 31, in\n<module>\nprint(ml) # Error: List not defined\nNameError: name 'ml' is not defined\nUpdating values in Lists\nWe can update single or multiple lists. It can use ( ) assignment operator,\n=\nappend and extend the method for accomplishing the task. Let us take an\nexample to understand the mentioned operators and methods\nExample 6.8: # Add\/Change List Elements\nvar = [1, 2, 3, 4]\nvar[0] = 9 # change the 1st item\nprint (var)\nvar[1:4] = [22, 33, 44] # change 2nd to 4th items\nprint (var)\n# Appending and Extending lists in Python using the append()\nvar = [11, 22, 33]\nvar.append(44)\nprint (var)\nvar.extend([55, 66, 77]) #Add several items using extend()\nmethod\nprint (var)\nprint (var + [224,353,464]) # Add + operator to combine two\nlists.\nOutput:\n[9, 2, 3, 4]\n[9, 22, 33, 44]\n[11, 22, 33, 44]\n[11, 22, 33, 44, 55, 66, 77]\n[11, 22, 33, 44, 55, 66, 77, 224, 353, 464]\nNested list\nA nested list means a list within a list. Moreover, a list contains a sublist of\nelements. Suppose we have a list named then it includes a list and\nlst\nsublist. A nested list is made up of a series of sublists separated by commas.\nlst = ['ab', ['cd', ['efg', 'hij'], 'kl', 'mn'], 'o', 'p']\nThe following figure 6.2 shows the hierarchical structures for understanding\nabove example: Figure 6.2: Nested list in Python.\nExample 6.9:\nlst = ['ab', ['cd', ['efg', 'hij'], 'kl', 'mn'], 'o', 'p']\nprint (L[2]) # Prints' o'\nprint (L[2][2]) # Prints' kl'\nprint (L[2][2][0]) # Prints 'k'\nOutput:\no\nkl\nk\nIt can add and remove items in a nested list by using , ,\nappend() insert()\n, , , method. It can also find length using\nextend() pop() del remove()\nand iterate through a nested list by using loop. Let us take an\nlen() for\nexample to understand this concept.\nExample 6.10: lst = ['b', ['ri', 'je'], 'sh']\nlst[1][1] = 0\nprint (lst)\nlst[1].append('BB')\nprint (lst)\nlst[1].insert(0,'PP')\nprint (lst)\nlst[1].extend([77,88,99])\nprint (lst)\nOutput:\n['b', ['ri', 0], 'sh']\n['b', ['ri', 0, 'BB'], 'sh']\n['b', ['PP', 'ri', 0, 'BB'], 'sh']\n['b', ['PP', 'ri', 0, 'BB', 77, 88, 99], 'sh']\nAliasing\nVariables are objects, and when we assign one to another, all variables refer\nto the same object. Moreover, when two identifiers refer to the same\nvariable, then it is called aliasing. Let us take an example to understand this\nconcept.\nExample 6.11:\nvar1 = [555, 666,777]\nvar2 = var1 #Aliasing\nprint (var1 is var2)\nprint (var1)\nprint (var2)\nOutput:\n[True\n[555, 666, 777]\n[555, 666, 777] The same list has two different names in the above example, and ;\nvar1 var2\nhowever, after executing the assignment statement , you can see\nvar2 = var1\nthat and relate to the same list. This indicates that it is aliasing.\nvar1 var2\nExample 6.12:\nvar1 = [555, 666,777]\nvar2 = [555, 666,777]\nprint (var1)\nprint (var2)\nprint (var1 == var2)\nprint (var1 is var2)\nvar2 = var1\nprint (var1 == var2)\nprint (var1 is var2)\nvar2[0] = 999\nprint (var1)\nprint (var2)\nOutput:\n[555, 666, 777]\n[555, 666, 777]\nTrue\nFalse\nTrue\nTrue\n[999, 666, 777]\n[999, 666, 777]\nCloning lists\nIf we want to change a list while keeping a copy of the original, we must\ncopy the entire list, not just the reference. To prevent the ambiguity of the\nword clone, this method is often referred to as cloning. The quickest and\nsimplest way to clone a list is to use the slicing process.\nExample 6.13: list1 = [777, 888, 999]\nlist2 = list1[:] # make a clone using slice\nprint (list1 == list2)\nprint (list1 is list2)\nlist2[0] = 555\nprint (list1)\nprint (list2)\nOutput:\nTrue\nFalse\n[777, 888, 999]\n[555, 888, 999]\nThere are various types of ways to cloning a list.\nUsing slicing\nIt is the most straightforward method of cloning a list. When we want to\nchange a list while keeping a copy of the original, we use this form. Let us\ntake an example to understand this concept.\nExample 6.14:\ndef cloning_List(li1):\nlst1 = li1[:] #Slice Operator\nreturn lst1\nlvar1 = [55,66,77,88,99]\nlvar2 = cloning_List(lvar1)\nprint (\"Original List:\", lvar1)\nprint (\"After Cloning:\", lvar2)\nOutput:\nOriginal List: [55, 66, 77, 88, 99]\nAfter Cloning: [55, 66, 77, 88, 99]\nUsing the extend() method The function can be used to copy the lists into a new list. Let us\nextend()\ntake an example to understand this concept.\nExample 6.15:\ndef cloning_List(li1):\nlst1 = []\nlst1.extend(li1)\nreturn lst1\nlvar1 = [55,66,77,88,99]\nlvar2 = cloning_List(lvar1)\nprint (\"Original List:\", lvar1)\nprint (\"After Cloning:\", lvar2)\nOutput:\nOriginal List: [55, 66, 77, 88, 99]\nAfter Cloning: [55, 66, 77, 88, 99]\nUsing the list() method\nUsing the built-in function list, it's also the simplest way to clone a .\nlist ()\nLet us take an example to understand this concept.\nExample 6.16:\ndef cloning_List(li1):\nlst1 = list(li1)\nreturn lst1\nlvar1 = [55,66,77,88,99]\nlvar2 = cloning_List(lvar1)\nprint (\"Original List:\", lvar1)\nprint (\"After Cloning:\", lvar2)\nOutput:\nOriginal List: [55, 66, 77, 88, 99]\nAfter Cloning: [55, 66, 77, 88, 99] Using list comprehension\nTo copy all the elements from one list to another, a list comprehension\nmethod is used. Let us take an example to understand this concept.\nExample 6.17:\ndef cloning_List(li1):\nlst1 = [i for i in li1]\nreturn lst1\nlvar1 = [55,66,77,88,99]\nlvar2 = cloning_List(lvar1)\nprint (\"Original List:\", lvar1)\nprint (\"After Cloning:\", lvar2)\nOutput:\nOriginal List: [55, 66, 77, 88, 99]\nAfter Cloning: [55, 66, 77, 88, 99]\nUsing the append() method\nThe method can be used to append or add elements to the list or\nappend()\ncopy them to a new list. It's used to add elements to the list's last location.\nLet us take an example to understand this concept.\nExample 6.18:\ndef cloning_List(li1):\nlst1 = []\nfor i in li1: lst1.append(i)\nreturn lst1\nlvar1 = [55,66,77,88,99]\nlvar2 = cloning_List(lvar1)\nprint (\"Original List:\", lvar1)\nprint (\"After Cloning:\", lvar2)\nOutput: Original List: [55, 66, 77, 88, 99]\nAfter Cloning: [55, 66, 77, 88, 99]\nUsing the copy() method\nTo copy all the elements from one list to another, use this method. Let us take\nan example to understand this concept.\nExample 6.19:\ndef cloning_List(li1):\nlst1 =[]\nlst1 = li1.copy()\nreturn lst1\nlvar1 = [55,66,77,88,99]\nlvar2 = cloning_List(lvar1)\nprint (\"Original List:\", lvar1)\nprint (\"After Cloning:\", lvar2)\nOutput:\nOriginal List: [55, 66, 77, 88, 99]\nAfter Cloning: [55, 66, 77, 88, 99]\nList parameters\nThe constructor takes a single argument; this argument could be a\nlist()\nsequence like string, tuples, set, dictionary, or an iterator object. It can also\npass a list as an argument. Let us take an example to understand this concept.\nExample 6.20:\nname_list = ['Brijesh', 'Krishna', 'Ravi', 'Ram', 'Misthi']\nprint (list(name_list))\ndef list_Fun(l):\nprint (l)\nname_list = ['Brijesh', 'Krishna', 'Ravi', 'Ram', 'Misthi']\nlist_Fun(name_list) Output:\n['Brijesh', 'Krishna', 'Ravi', 'Ram', 'Misthi']\n['Brijesh', 'Krishna', 'Ravi', 'Ram', 'Misthi']\nBasic list operations\nGenerally, list support and operator for list concatenation and list\n+ *\nrepetition. But there are other list methods to do the same task. In the\nprevious example, we have also used the slice, append, and extend method\nperformed on a string. Let us take an example to understand this concept.\nExample 6.21:\nlst1 = ['b', 'r', 'i', 'j', 'e', 's', 'h']\nprint (lst1 + ['p','q','r']) # A + operator to combine two\nlists.\nprint (2*lst1) # A * operator to repetition.\nprint (lst1[1:3]) #elements 1st to 3rd\n# Appending and Extending lists in Python using the append()\nlst1.append('bakariya')\nprint (lst1)\nlst1.extend(['x','y','z']) #Add several items using extend()\nmethod\nprint (lst1)\nOutput:\n['b', 'r', 'i', 'j', 'e', 's', 'h', 'p', 'q', 'r']\n['b', 'r', 'i', 'j', 'e', 's', 'h', 'b', 'r', 'i', 'j', 'e',\n's', 'h']\n['r', 'i']\n['b', 'r', 'i', 'j', 'e', 's', 'h', 'bakariya']\n['b', 'r', 'i', 'j', 'e', 's', 'h', 'bakariya', 'x', 'y',\n'z']\nThere are various types of built-in functions which are performed on the list.\nWe can easily accomplish our tasks by directly using these functions. The built-in list functions:\n: This function compares elements of both lists.\ncmp(list1, list2)\n: This function returns the length of the list.\nlen(list)\n: This function returns an element from the list with max\nmax(list)\nvalue.\n: This function returns an element from the list with min\nmin(list)\nvalue.\n: This function converts a tuple into the list.\nlist(seq)\nLet us take an example to understand the above built-in list functions.\nExample 6.22:\nlist1 = ['Brijesh', 'Krishna']\nlist2 = ['Ramesh', 'Rajesh']\ndef cmp(p, q):\nreturn (p > q) - (p < q)\nprint (cmp(list1, list2)) # List comparison\nprint (len(list1)) # Length of list\nlist3 = [53535, 68868, 67656]\nprint (\"Maximum value element : \", max(list3)) # Getting Max\nvalue from list\nprint (\"Minimum value element : \", min(list3)) # Getting Min\nvalue from list\ntuple_var = ('Brijesh', 'Krishna', 123, 'xyz');\nprint (\"Tuple elements : \", tuple_var)\nlist_var = list(tuple_var) # Converts a tuple into list.\nprint (\"List elements : \", list_var)\nOutput:\n-1\n2\nMaximum value element : 68868\nMinimum value element : 53535 Tuple elements : ('Brijesh', 'Krishna', 123, 'xyz')\nList elements : ['Brijesh', 'Krishna', 123, 'xyz']\nList methods\nSome other built-in methods are also performed on the list. We can easily\naccomplish our task by directly using this method.\nThe built-in list methods:\n: This method appends object to the list.\nlist.append(obj) obj\n: This method returns a count of how many times\nlist.count(obj) obj\noccurs in the list.\n: This method appends the contents of to the\nlist.extend(seq) seq\nlist.\n: This method returns the lowest index in the list that\nlist.index(obj)\nappears.\nobj\n: This method inserts object into the\nlist.insert(index, obj) obj\nlist at offset index.\n: This method removes and returns the last\nlist.pop(obj=list[-1])\nobject or from the list.\nobj\n: This method removes object from the list.\nlist.remove(obj) obj\n: This method reverses objects of the list in place.\nlist.reverse()\n: This method sorts objects of the list.\nlist.sort([func])\nLet us take an example to understand the above built-in list methods.\nExample 6.23:\nlst1 = ['b', 'r', 'i', 'j', 'e', 's', 'h']\nlst1.append('bakariya')\nprint (lst1)\nlst1.extend(['x','y','z'])\nprint (lst1)\nprint (\"Count : \", lst1.count('bakariya')) print (\"Index for bakariya : \", lst1.index('bakariya'))\nlst1.insert(3, 100)\nprint (lst1)\nprint (\"Poped List : \", lst1.pop())\nlst1.remove('bakariya')\nprint (lst1)\nprint (lst1.reverse())\nlst2 = [44,464,686,313,668,242,575,1212,464]\nlst2.sort()\nprint (lst2)\nprint (lst2.reverse())\nprint (lst2)\nOutput:\n['b', 'r', 'i', 'j', 'e', 's', 'h', 'bakariya']\n['b', 'r', 'i', 'j', 'e', 's', 'h', 'bakariya', 'x', 'y',\n'z']\nCount : 1\nIndex for bakariya : 7\n['b', 'r', 'i', 100, 'j', 'e', 's', 'h', 'bakariya', 'x',\n'y', 'z']\nPoped List : z\n['b', 'r', 'i', 100, 'j', 'e', 's', 'h', 'x', 'y']\nNone\n[44, 242, 313, 464, 464, 575, 668, 686, 1212]\nNone\n[1212, 686, 668, 575, 464, 464, 313, 242, 44]\nList as arrays\nWe know about the list; it is a collection of items containing elements of\nmultiple data types, which may be either numeric, logical character values,\netc. It is also known as an array because it is used in various programming languages like C, C++, Java, etc. An array is a collection of homogeneous\n(same type) elements. If the array elements belong to different data types, an\nexception (incompatible data types) is thrown. Let us take an example to\nunderstand this concept.\nExample 6.24:\n# Simple list\nlist1 = ['Dr. Brijesh Bakariya','Dr. Krishna K. Mohbey', 36,\n35]\nprint (list)\n# Using array in Python\nimport array\nsa = array.array('i', [33, 55, 77])\n# accessing elements of array\nfor i in sa:\nprint (i)\nOutput:\n<class 'list'>\n33\n55\n77\nThere are a few differences between list and array in Python:\nA list can consist of elements belonging to different data types, but an\narray only consists of elements belonging to the same data type.\nA list does not need to import a module for declaration explicitly, but\nan array needs to import a module for declaration explicitly.\nA list cannot directly handle arithmetic operations, but an array can\ndirectly manage arithmetic operations\nA list can be nested to contain different elements, but an array must\ncontain either all nested elements of the same size. A list is preferred for a shorter sequence of data items, but an array is\npreferred for a longer sequence of data items.\nA modification is easier in the list compared to an array.\nThe entire list can be printed without any explicit looping but array\nusing a loop to be formed to print or access the components.\nLooping in lists\nLooping in lists means accessing all the elements in a list one by one.\nMoreover, it is an iteration through a list in Python. There are various ways\nto iterate through a list in Python.\nUsing for loop\nA loop is used for showing all the elements in a list. Let us take an\nfor\nexample to understand this concept.\nExample 6.25:\nlist = [11, 22, 33, 44, 55]\nfor var in list:\nprint (var)\nOutput:\n11\n22\n33\n44\n55\nUsing loop and range()\nSuppose we want to use the traditional loop, which iterates the element\nfor\ntill the range specified. Let us take an example to understand this concept.\nExample 6.26:\nlist = [11, 22, 33, 44, 55] length = len(list) # getting the length of a list\nfor var in range(length):\nprint (list[var])\nOutput:\n11\n22\n33\n44\n55\nUsing while loop\nIt is similar to loop, but its syntax is different. Let us take an example to\nfor\nunderstand this concept. The following example prints all the list values\nusing a loop.\nwhile\nExample 6.27:\nlist = [11, 22, 33, 44, 55]\nlength = len(list) # getting length of list\nx1 = 0\nwhile x1 < length:\nprint (list[x1])\nX1 += 1\nOutput:\n11\n22\n33\n44\n55\nUsing list comprehension\nIt is used to iterate through a list in Python. It is another way of generating a\nlist of elements that possess a specific property. Let us take an example to understand this concept.\nExample 6.28:\nlist = [11, 22, 33, 44, 55]\n[print (i) for i in list] # Using list comprehension\nOutput:\n11\n22\n33\n44\n55\nUsing enumerate()\nThis method can be used when we want to convert the list into an iterable list\nof tuples. Let us take an example to understand this concept.\nExample 6.29:\nlist = [11, 22, 33, 44, 55]\nfor i, val in enumerate(list): # Using enumerate()\nprint (i, \"=\",val)\nOutput:\n0 = 11\n1 = 22\n2 = 33\n3 = 44\n4 = 55\nUsing Numpy\nFor huge n-dimensional lists, it is sometimes better to use an external library\nsuch as NumPy. Let us take an example to understand this concept.\nExample 6.30: import numpy as np\nvar = np.arange(4)\nvar = var.reshape(2, 2)\nfor var1 in np.nditer(var): # iteration\nprint (var1)\nOutput:\n0\n1\n2\n3\nPassing list to function\nPassing a list to function means to pass a list variable to a function, and the\nfunction copy the value of the list variable to function parameters. So it is\neasy to show all the values of the list through the function parameters. Let us\ntake an example to understand this concept.\nExample 6.31:\ndef faculty_name(f):\nfor i in f:\nprint (i)\nfaculty = [\"Dr. Brijesh\", \"Dr. Krishna\", \"Dr. Amit\", \"Dr.\nRaj\"]\nfaculty_name(faculty)\nOutput:\nDr. Brijesh\nDr. Krishna\nDr. Amit\nDr. Raj\nReturning list from the function Returning list to function means to return the value of the list and catch to the\ncalling function. It is assigned a calling function to another variable for\nprinting purposes. Let us take an example to understand this concept.\nExample 6.32:\ndef faculty_name(f):\nfor i in f:\nreturn(i)\nfaculty = [\"Dr. Brijesh\", \"Dr. Krishna\", \"Dr. Amit\", \"Dr.\nRaj\"]\nfor i in faculty:\nfaculty_name(i)\nprint (i)\nOutput:\nDr. Brijesh\nDr. Krishna\nDr. Amit\nDr. Raj\nfilter() function\nA function filters an iterable using a function that checks if each\nfilter()\nelement in the iterable is valid or not. A function returns an\nfilter()\niterator that has passed and part of the iterable through the function check.\nSyntax:\nfilter(function, iterable)\nThere are two parameters of the function as a function and\nfilter()\niterable.\n: It returns true if elements are iterable, false otherwise.\nfunction\n: It means that the iterable to be filtered could be anything\niterable\nfrom sets to lists to tuples to containers of any iterators. Let us take an example to understand this concept.\nExample 6.33:\n# Program to filter the list, and return a new list with only\nthe values equal to or above 18:\nagesPerson = [16, 17, 23, 35, 19, 38]\ndef my_fun(n):\nif n < 18:\nreturn False\nelse:\nreturn True\nadults = filter(my_fun, agesPerson)\nfor i in adults:\nprint (i)\nOutput:\n23\n35\n19\n38\nExample 6.34:\n# function that filters vowels\ndef fun_vowel(n):\nvow = ['a', 'e', 'i', 'o', 'u']\nif (n in vow):\nreturn True\nelse:\nreturn False\n# sequence\nseq = ['b', 'r', 'i', 'j', 'e', 's', 'h', 'b', 'a', 'k', 'a',\n'r', 'i', 'y', 'a']\nfil= filter(fun_vowel, seq) # using filter function print ('The filtered letters are:')\nfor i in fil:\nprint (i)\nOutput:\nThe filtered letters are:\ni\ne\na\na\ni\na\nmap() function\nFor each item in an iterable, this function executes a given function. As a\nparameter, the item is passed into the function. Furthermore, after applying\nthe defined function to each item of a given iterable like a list, tuple, or other\niterable, the function returns a map object of the results.\nmap()\nSyntax:\nmap(function, iterables)\nThe function's first parameter executes for each component, and the\nmap()\nsecond parameter iterable requires a sequence, collection, or iterator object.\nYou can submit as many iterables as you want, as long as each one has its\nparameter in the function. Let us take an example to understand this concept.\nExample 6.35:\ndef my_function(x, y):\nreturn x + y\nm = map(my_function, ('Brijesh', 'Krishna', 'Ramesh'),\n('Amit', 'Sumit', 'Mohit'))\nprint (m)\n# Add two lists using map and lambda\nn1 = [11, 22, 33] n2 = [44, 54, 66]\nres = map(lambda a, b: a + b, n1, n2)\nprint (list(res))\n# List of strings\nlst = ['Brijesh', 'Krishna', 'Ramesh']\nm = list(map(list, lst))\nprint (m)\nOutput:\n<map object at 0x000001EA94A9B108>\n[55, 76, 99]\n[['B', 'r', 'i', 'j', 'e', 's', 'h'], ['K', 'r', 'i', 's',\n'h', 'n', 'a'], ['R', 'a', 'm', 'e', 's', 'h']]\nreduce() function\nThe function is defined in the module, and it takes two\nreduce() functools\narguments: one is a function, and the other is an iterable. One important thing\nwhich you have to remember the function does not return another\nreduce()\niterable. Instead, it returns a single value. The is useful when you\nreduce()\nneed to apply a function to iterable and reduce it to a single cumulative\nvalue. Let us take an example to understand this concept.\nSyntax:\nfunctools.reduce(myfunction, iterable, initializer)\nExample 6.36:\nimport functools\ndef multiply_fun(a,b):\nprint (\"a=\",a,\" b=\",b)\nreturn a*b\nfactorial_var = functools.reduce(multiply_fun, range(1, 6))\nprint ('Factorial of 5: ', factorial_var) Output:\na= 1 b= 2\na= 2 b= 3\na= 6 b= 4\na= 24 b= 5\nFactorial of 5: 120\nThe multiply function is defined to return the product of two numbers in the\nexample above. This function is used in the function along with a\nreduce()\nnumber range of 1, 2, 3, 4, and 5 between 1 and 6. The result is a 5 factorial\nvalue.\nExample 6.37:\nimport functools\nlst1 = [23, 76, 34, 87, 59, 66, 324]\nprint (\"list elements sum : \",end=\"\")\nprint (functools.reduce(lambda x,y : x+y,lst1))\nprint (\"max from list: \",end=\"\")\nprint (functools.reduce(lambda x,y : x if x > y else y,lst1))\nOutput:\nlist elements sum : 669\nmax from list : 324\nSearching in list\nIt means searching whether your element is present in the list or not.\nMoreover, it simply checks if a list contains a particular item. We use ( )\nin\noperator for accomplishing this task. Let us take an example to understand\nthis concept.\nExample 6.38:\nnames = ['Brijesh', 'Krishna', 'Ramesh','Amit', 'Sumit',\n'Mohit']\nif 'Amit' in names: print('Amit Found')\nnames = ['Brijesh', 'Krishna', 'Ramesh','Amit', 'Sumit',\n'Mohit']\namit_pos = names.index('Amit') #index of an item\nprint (amit_pos)\nOutput:\nAmit Found\n3\nExample 6.39:\nflowerList = ['lotus', 'rose', 'sunflower', 'lily',\n'bluebell']\nflowerName = input(\"Enter a flower name:\") # input from user\nif flowerName.lower() in flowerList:\nprint (\"%s is found in the list\" %(flowerName))\nelse:\nprint (\"%s is not found in the list\" %(flowerName))\nOutput:\nEnter a flower name:lily\nlily is found in the list\nSequential search\nIt is the process of searching an element sequentially. It is also called a linear\nsearch. There are the following processes of linear search\n1. Begin with the list's leftmost element and compare to each of the list's\nx\nelements one by one.\n2. Return if matches an element.\nTrue x\n3. Return if does not match any of the elements.\nFalse x\nLet us take an example to understand this concept. Example 6.40:\ndef lin_search(list,n):\nfor var1 in range(len(list)):\nif list[var1] == n:\nreturn True\nreturn False\nlist1 = [54, 99, 'Brijesh', 335,'Krishna', 643]\nn = 'Krishna'\nif lin_search(list1, n):\nprint (\"It is Found\")\nelse:\nprint (\"It is Not Found\")\nOutput:\nIt is Found\nBinary search\nThe binary search technique is to find search elements from a list of\nelements. There are the following properties of binary search.\nIt works only for a sorted sequence of an element.\nThe first searching process starts by comparing the search element with\nthe middle element in the list.\nIf the search element is smaller than the middle element, it will search\nthe left side of the list and repeat it.\nIf the search element is greater than the middle element, it will search\nthe right side of the list and repeat it.\nThe binary search process is implemented using recursion.\nIf an element is search middle, left, and right part of the list, then it\ndisplays the element found.\nThe worst-case time complexity is log n. It is efficient than a linear\nsearch algorithm. There are the following steps for implementing a binary search\n1. Start\n2. Give a search element from the user\n3. Sort the list of elements\n4. In the sorted list, find the middle element.\n5. Compare the search element to the sorted list's middle element.\n6. If both elements match, show \"Element Found\" and exit.\n7. Check if the search element is smaller or larger than the middle element\nif they don't match.\n8. If the search element is smaller than the middle element, repeat steps 3\u2013\n5 for the middle element's left sublist.\n9. If the search element is larger than the middle element, repeat steps 3\u20135\nfor the middle element's right sublist.\n10. Repeat the same steps until the search element is found in the list or the\nsublist contains only one element.\n11. Show \"Element not found\" and stop if that element does not match the\nsearch element.\nLet us take an example to understand the binary search process:\nFigure 6.3: Input linear List\nFigure 6.4: Sorted linear List\nThe size of the list is 10 then the middle element is 5. The 5th element is 22.\nSuppose our search element is 19. Compare 19 to the middle element 22. If it\nis lesser, then it goes to the left part of the list. Again find the middle element\nfrom the left part of the list and follow this process until the element is\nsearched. Let us take an example to understand this concept. Example 6.41:\n# Program for iterative Binary Search Function\ndef binary_search(list2, x):\nbeg = 0\nend = len(list2) - 1\nmid = 0\nwhile beg <= end:\nmid = (beg+ end) \/\/ 2\nif list2[mid] < x:\nbeg = mid + 1\nelif list2[mid] > x:\nend = mid - 1\nelse:\nreturn mid\nreturn -1\n# Test list\nlist1 = [2, 3, 4, 10, 40]\nx = 40\n# calling function\nresult = binary_search(list1, x)\nif result != -1:\nprint (\"Element is present at index\", str(result))\nelse:\nprint (\"Element is not present in list\")\nOutput:\nElement is present at index 4\nExample 6.42:\n# Program for recursive binary search\ndef binary_search(list2, low, high, x): # Check base case\nif high >= low:\nmid = (high + low) \/\/ 2\nif list2[mid] == x:\nreturn mid\nelif list2[mid] > x:\nreturn binary_search(list2, low, mid - 1, x)\nelse:\nreturn binary_search(list2, mid + 1, high, x)\nelse:\nreturn -1 # Element is not present in the list\n# Test list\nlist1 = [2, 3, 4, 10, 40]\nx = 10\n# Function call\nresult = binary_search(list1, 0, len(list1)-1, x)\nif result != -1:\nprint (\"Element is present at index\", str(result))\nelse:\nprint (\"Element is not present in list\")\nOutput:\nElement is present at index 3\nSorting\nSorting means arranging the data in either ascending or descending order.\nThe primary task of sorting algorithms is to organize data elements in a\nparticular order. If our data is properly sorted in order, then it would search\nthe element fast. Moreover, sorting maintains the data structure. Sorting may\nalso be used to display data in a more readable format. Sorting can be used\nin a variety of contexts, including the dictionary, telephone directory, and so\non. Python uses the method for sorting elements of a given list in a\nsort()\nspecific ascending or descending order. The syntax of the method is:\nsort()\nSyntax:\nlist.sort(key=\u2026, reverse=\u2026)\nsorted(list, key=\u2026, reverse=\u2026)\nAn important point which we have to remember is the basic difference\nbetween and is that the method changes the list\nsort() sorted() sort()\ndirectly and doesn't return any value, while doesn't change the list\nsorted()\nand returns the sorted list.\nIn the and methods, there are two parameters:\nsort() sorted() reverse\nand . The sorted list is reversed if the parameter is true. A\nkey reverse key\nparameter is used as a sort comparison key.\nLet us take an example to understand this concept.\nExample 6.43:\nvowels_var = ['i', 'a', 'u', 'o', 'e'] # vowels list\nvowels_var.sort() # sort the vowels\nprint ('Sorted list:', vowels_var) # print vowels\nvowels_var = ['i', 'a', 'u', 'o', 'e'] # vowels list\nvowels_var.sort(reverse=True) #Sort the list in Descending\norder\nprint ('Sorted list:', vowels_var) # print vowels\n#Custom Sorting With key\nlist1 = ['ppp', 'aaaa', 'd', 'bb']\nprint (sorted(list1, key=len))\n#Sort the list by the length of the values:\ndef my_sort_fun(n):\nreturn len(n)\nfaculty = ['Brijesh', 'Krishna', 'Amit', 'Zubin']\nfaculty.sort(key=my_sort_fun)\nOutput: Sorted list: ['a', 'e', 'i', 'o', 'u']\nSorted list: ['u', 'o', 'i', 'e', 'a']\n['d', 'bb', 'ppp', 'aaaa']\nTypes of sorting\nThe following are the various types of sorting:\nIn-place sorting: In this sorting technique, the elements are sorted\nwithin a list. There is no extra space required for sorting an element.\nNot-in-place sorting: In this sorting technique, the elements are sorted,\nbut a different list is required. There is extra space needed for sorting\nelements.\nStable sorting: In a sorting algorithm, stable sorting occurs when the\ncontents do not change the sequence of related content in which they\nappear after sorting.\nUnstable sorting: After sorting, if the contents change the sequence of\nsimilar content in which they appear, it is called unstable sorting in a\nsorting algorithm.\nBubble sort\nBubble sort is a comparison-based algorithm that compares each pair of\nadjacent elements and swaps them if they are out of order. Since the average\nand worst-case complexity of this algorithm are O(n2), where n is the\nnumber of items, it is not suitable for large data sets. The bubble sorting\nprocedure is as follows. To begin with, we'll make a list of an element that\nwill hold the integer numbers.\nlist1 = [5, 3, 8, 6, 7, 2]\nThere are following iterations for sorting.\nFirst iteration\n[5, 3, 8, 6, 7, 2]\nIt compares the first two elements and here 5>3 then swap with each other.\nNow we get a new list that is [3, 5, 8, 6, 7, 2] In the second comparison, 5 < 8, then swapping will happen [3, 5, 8, 6, 7, 2]\nIn the third comparison, 8>6, then swap [3, 5, 6, 8, 7, 2]\nIn the fourth comparison, 8>7, then swap [3, 5, 6, 7, 8, 2]\nIn the fifth comparison, 8>2, then swap [3, 5, 6, 7, 2, 8]\nHere, the first iteration is complete and we get the largest element at the end.\nNow we need to the .\nlen(list1) \u2013 1\nSecond iteration\n[3, 5, 6, 7, 2, 8] - > [3, 5, 6, 7, 2, 8] here, 3<5 then no swap taken place.\n[3, 5, 6, 7, 2, 8] - > [3, 5, 6, 7, 2, 8] here, 5<6 then no swap taken place.\n[3, 5, 6, 7, 2, 8] - > [3, 5, 6, 7, 2, 8] here, 6<7 then no swap taken place.\n[3, 5, 6, 7, 2, 8] - > [3, 5, 6, 2, 7, 8] here 7>2 then swap their position.\nNow [3, 5, 6, 2, 7, 8] - > [3, 5, 6, 2, 7, 8] here 7<8 then no swap taken place.\nThird iteration\n[3, 5, 6, 2, 7, 8] - > [3, 5, 6, 7, 2, 8] here, 3<5 then no swap taken place\n[3, 5, 6, 2, 7, 8] - > [3, 5, 6, 7, 2, 8] here, 5<6 then no swap taken place\n[3, 5, 6, 2, 7, 8] - > [3, 5, 2, 6, 7, 8] here, 6<2 then swap their positions\n[3, 5, 2, 6, 7, 8] - > [3, 5, 2, 6, 7, 8] here 6<7 then no swap taken place.\nNow [3, 5, 2, 6, 7, 8] - > [3, 5, 2, 6, 7, 8] here 7<8 then swap their position.\nIt will iterate until the list is sorted.\nFourth iteration\n[3, 5, 2, 6, 7, 8] - > [3, 5, 2, 6, 7, 8]\n[3, 5, 2, 6, 7, 8] - > [3, 2, 5, 6, 7, 8]\n[3, 2, 5, 6, 7, 8] - > [3, 2, 5, 6, 7, 8]\n[3, 2, 5, 6, 7, 8] - > [3, 2, 5, 6, 7, 8]\n[3, 2, 5, 6, 7, 8] - > [3, 2, 5, 6, 7, 8]\nFifth iteration\n[3, 2, 5, 6, 7, 8] - > [2, 3, 5, 6, 7, 8]\nLet us take an example to understand this concept. Example 6.44:\ndef bubble_sort_fun(list2):\nfor i in range(0,len(list2)-1):\nfor j in range(len(list2)-1):\nif(list2[j]>list2[j+1]):\ntemp = list2[j]\nlist2[j] = list2[j+1]\nlist2[j+1] = temp\nreturn list1\nlist1 = [5, 3, 8, 6, 7, 2]\nprint (\"The unsorted list is: \", list1)\nprint (\"The sorted list is: \", bubble_sort_fun(list1)) #\nCalling function\nOutput:\nThe unsorted list is: [5, 3, 8, 6, 7, 2]\nThe sorted list is: [2, 3, 5, 6, 7, 8]\nSelection sort\nIt is used to sort a list of items into ascending or descending order. In\nselection sort, the first element in the list is chosen and compared to the rest\nof the list's elements repeatedly. Both elements are swapped if one is smaller\nthan the other (in ascending order). The element in the second place in the list\nis then selected and compared to the remaining elements in the list. Both\nelements are swapped if one of them is smaller than the other. This process is\nrepeated until all of the items in the list have been sorted. The selection\nsorting procedure is as follows.\nSuppose we have a list of the action of the following elements with a list that\ncontains the following elements: [3, 5, 1, 2, 4].\nWe'll start with the list that hasn't been sorted:\n3 5 1 2 4\nAll of the elements can be found in the unsorted portion. We examine each\nitem and decide that the smallest element is 1. As a result, we'll swap 1 with 3:\n1 5 3 2 4 of the remaining unsorted elements, [5, 3, 2, 4], 2 is the lowest\nnumber. We now swap 2 with 5:\n1 2 3 5 4\nThis procedure is repeated until the list has been sorted:\n1 2 3 5 4\n1 2 3 4 5\n1 2 3 4 5\nLet us take an example to understand this concept.\nExample 6.45:\ndef selection_sort_fun(list1):\nfor i in range(len(list1)-1):\nidx = i\nfor j in range(i+1, len(list1)-1):\nif list1[j] < list1[idx]:\nidx = j\nlist1[i], list1[idx] = list1[idx], list1[i]\nlist = [23, 12, 17, 34, 98, 77, 58]\nprint (list)\nselection_sort_fun(list)\nprint (list)\nOutput:\n[23, 12, 17, 34, 98, 77, 58]\n[12, 17, 23, 34, 77, 98, 58]\nInsertion sort\nThe insertion sort algorithm places elements in a specific order in a list. In\nthe insertion sort algorithm, each iteration transfers an element from an unsorted portion to a sorted piece until all of the elements in the list are\nsorted. To sort the list using insertion sort, go through the steps below:\n1. We split a list into two parts, i.e., sorted and unsorted.\n2. Iterate from a to over the given list.\nlist[1] list[n]\n3. Compare the current element to the next element.\n4. If the current element is smaller than the next element, compared to the\nelement before. Move to the greater elements one position up to make\nspace for the swapped element.\nSuppose we have a list of following elements action with a list that contains\nthe following elements: [10, 4, 25, 1, 5]\nThe first step to add 10 to the sorted sub-list\n[10, 4, 25, 1, 5]\nNow we take the first element from the unsorted list, i.e., 4. We store this\nvalue in a new variable temp. We can see that the 10>4, then we move the 10\nto the right and overwrite the 4 that was previously stored.\n[10, 10, 25, 1, 5] (temp = 4)\nHere 4 is lesser than all elements in the sorted sub-list, so we insert it at the\nfirst index position.\n[4, 10, 25, 1, 5]\nWe have two elements in the sorted sub-list\nNow check the number 25. We have saved it into the temp variable. 25> 10\nand also 25> 4, then we put it in the third position and add it to the sorted\nsub-list.\n[4, 10, 25, 1, 5]\nAgain we check the number 1. We save it in temp. 1 is less than 25. It\noverwrites 25.\n[4, 10, 25, 25, 5] 10>1 then it overwrites again\n[4, 25, 10, 25, 5]\n[25, 4, 10, 25, 5] 4>1 now put the value of temp = 1\n[1, 4, 10, 25, 5] Now, we have 4 elements in the sorted sub-list. 5<25, then shift 25 to the\nright side and pass temp = 5 to the left side.\n[1, 4, 10, 25, 25] put temp = 5\nNow, we get the sorted list by simply putting the temp value.\n[1, 4, 5, 10, 25] is sorted list.\nLet us take an example to understand this concept\nExample 6.46:\n# creating a function for insertion\ndef insertion_sort_fun(list2):\nfor i in range(1, len(list2)):\nvalue = list2[i]\nj = i - 1\nwhile j >= 0 and value < list2[j]:\nlist2[j + 1] = list2[j]\nj -= 1\nlist2[j + 1] = value\nreturn list2\nlist1 = [23, 16, 7, 88, 73]\nprint (\"The unsorted list is:\", list1)\nprint (\"The sorted list1 is:\", insertion_sort_fun(list1))\nOutput:\nThe unsorted list is: [23, 16, 7, 88, 73]\nThe sorted list1 is: [7, 16, 23, 73, 88]\nQuicksort\nQuicksort is an efficient sorting algorithm because it is based on a partition\nof a list. It uses a divide and conquer approach and divides a list into smaller\nparts. First of all, it picks the pivot element from a list and applies a partition\ntechnique. The result of the partition approach is to locate the pivot element\ninto its actual position. In this technique, there are two types of partitions: Figure 6.5: Divide an element by quicksort\nLet us take an example of a quick sort. The key elements are:\n45, 26, 177, 14, 68, 61, 97, 39, 99, 90\nFirst of all, we chose an element as a pivot or a key value. Suppose 45 is a\nkey value. After that, it uses two indexes, low and high. The elements in the\nlow index are those elements whose values are less than the key value. The\nelements in the high index are those elements whose values are less than the\nkey value. Figure 6.6: Process of sorting by quicksort\nLet us take an example of a quick sort.\nExample 6.47:\ndef partitionMethod(list1,low,high): # divide function\ni = (low-1)\npivot = list1[high] # pivot element\nfor j in range(low, high):\n# If current element is smaller\nif list1[j] <= pivot:\n# increment i = i+1\nlist1[i],list1[j] = list1[j],list1[i]\nlist1[i+1],list1[high] = list1[high],list1[i+1]\nreturn (i+1)\n# sort\ndef quickSortMethod(list2,low,high):\nif low < high:\n# index\npi = partitionMethod(list2,low,high)\n# sort the partitions\nquickSortMethod(list2, low, pi-1)\nquickSortMethod(list2, pi+1, high)\nlist3 = [22,44,21,12,56,87,35,23,66]\nn = len(list3)\nquickSortMethod(list3,0,n-1)\nprint (\"Sorted list is:\")\nfor i in range(n):\nprint (list3[i],end=\" \")\nOutput:\nSorted list is:\n12 21 22 23 35 44 56 66 87\nMerge sort\nMerge sorting employs the divide and conquer strategy. Since a list with only\none element is always sorted, the unsorted list is divided into n sublists, each\nwith one element. Then it merges these sublists, again and again, to create\nnew sorted sublists until only one sorted list remains. Merge sort has an O(n\nlog n) time complexity. It is also a stable sort but not in place of the sorting\napproach. Let us take an example of merge sort 85, 76, 46, 92, 30, 41, 12, 19,\n93, 3, 50, 11. The following figure 6.7 and figure 6.8 shows the divide and\nconquer and merging process of merge sort. Figure 6.7: Process of divide and conquer in merge sort\nFigure 6.8: Process of merging in merge sort\nLet us take an example for understanding this concept.\nExample 6.48:\ndef merge_sort_fun(list1, left_index, right_index):\nif left_index >= right_index:\nreturn\nmiddle = (left_index + right_index)\/\/2\nmerge_sort_fun(list1, left_index, middle)\nmerge_sort_fun(list1, middle + 1, right_index)\nmerge_fun(list1, left_index, right_index, middle) def merge_fun(list1, left_index, right_index, middle):\nleft_sublist = list1[left_index:middle + 1]\nright_sublist = list1[middle+1:right_index+1]\nleft_sublist_index = 0\nright_sublist_index = 0\nsorted_index = left_index\nwhile left_sublist_index < len(left_sublist) and\nright_sublist_index < len(right_sublist):\nif left_sublist[left_sublist_index] <=\nright_sublist[right_sublist_index]:\nlist1[sorted_index] = left_sublist[left_sublist_index]\nleft_sublist_index = left_sublist_index + 1\nelse:\nlist1[sorted_index] = right_sublist[right_sublist_index]\nright_sublist_index = right_sublist_index + 1\nsorted_index = sorted_index + 1\nwhile left_sublist_index < len(left_sublist):\nlist1[sorted_index] = left_sublist[left_sublist_index]\nleft_sublist_index = left_sublist_index + 1\nsorted_index = sorted_index + 1\nwhile right_sublist_index < len(right_sublist):\nlist1[sorted_index] = right_sublist[right_sublist_index]\nright_sublist_index = right_sublist_index + 1\nsorted_index = sorted_index + 1\nlist1 = [44, 65, 2, 3, 58, 14, 57, 23, 10, 1, 7, 74, 48]\nmerge_sort_fun(list1, 0, len(list1) -1)\nprint (list1)\nOutput:\n[1, 2, 3, 7, 10, 14, 23, 44, 48, 57, 58, 65, 74] Conclusion\nThis chapter discussed the lists and their creation, accessing, and updating\nvalues in lists. It is concerned about nesting, aliasing, and cloning of lists.\nSome list parameters, operations, and methods are discussed. Also, passing\nand returning list from function and some other list function like ,\nfilter()\n, and function also included. It also discusses searching and\nmap() reduce()\nsorting methods in the list such as linear search, binary search, bubble,\nselection, insertion, quick, and merge sort. In the further chapter, we will\ndiscuss tuple as the next topic used in Python.\nPoints to Remember\nIn a list, values are enclosed with square brackets.\nThe first item on the list is indexed as [ ].\n0\nA slice is represented by a colon ( ).\n:\nA nested list means a list within a list.\nThe constructor takes a single argument.\nlist()\nA list is used in an operator for searching in a list.\nThe method is used for sorting elements of a given list.\nsort()\nMultiple Choice Questions\n1. Which of the following is True regarding lists in Python?\na. Lists are immutable.\nb. The size of the lists must be specified before their initialization\nc. Elements of lists are stored in a contagious memory location.\nd. size(list1) command is used to find the size of lists.\n2. What is the output of the following code:\nlist1=[1,3,5,2,4,6,2]\nlist1.remove(2)\nprint(sum(list1))\na. 18 b. 19\nc. 21\nd. 22\n3. Which of the following commands will create a list?\na. list1 = list()\nb. list1 = []\nc. list1 = list([1, 2, 3])\nd. all of the mentioned\n4. What is the output when we execute the list(\"hello\")?\na. ['h', 'e', 'l', 'l', \u2018o\u2019].\nb. [\u2018hello\u2019].\nc. [\u2018llo\u2019].\nd. [\u2018olleh\u2019].\n5. Suppose list Example is ['h',' e',' l',' l',\u2019o\u2019], what is\nlen(listExample)?\na. 5\nb. 4\nc. None\nd. Error\n6. Suppose list1 is [4, 2, 2, 4, 5, 2, 1, 0], which of the following is the\ncorrect syntax for slicing operation?\na. print(list1[0])\nb. print(list1[:2])\nc. print(list1[:-2])\nd. all of the mentioned\n7. What is the output of the following code:\nlist1 = range(100, 110)\nprint (list1.index(105)) a. 105\nb. 5\nc. 106\nd. 104\n8. What is the output of the code?\nlist1 = [1, 2, 3, 4, 5]\nlist2 = list1\nlist2[0] = 0;\nprint(list1)\na. [1, 2, 3, 4, 5, 0]\nb. [0,1, 2, 3, 4, 5]\nc. [0, 2, 3, 4, 5]\nd. [1, 2, 3, 4, 0]\n9. Suppose list1 is [2, 33, 222, 14, 25], What is list1[-1]?\na. Error\nb. None\nc. 25\nd. 2\n10. What is the best time complexity of bubble sort?\na. N^2\nb. NlogN\nc. N\nd. N(logN)^2\n11. What is the best case for linear search?\na. O(nlogn)\nb. O(logn)\nc. O(n)\nd. O(1) 12. What is the worst case for linear search?\na. O(nlogn)\nb. O(logn)\nc. O(n)\nd. O(1)\n13. Which of the following is a disadvantage of linear search?\na. Requires more space\nb. Greater time complexities compared to other searching algorithms\nc. Not easy to understand\nd. Not easy to implement\n14. What is the worst-case complexity of selection sort?\na. O(nlogn)\nb. O(logn)\nc. O(n)\nd. O(n2)\nAnswers\n1. c\n2. c\n3. d\n4. a\n5. a\n6. d\n7. b\n8. c\n9. c\n10. c\n11. d 12. c\n13. b\n14. d\nQuestions\n1. How to create a list? Explain with example.\n2. How to access values from lists? Explain with example.\n3. Explain slice, delete, remove and clear methods of a list. Give a\nsuitable example.\n4. How to update the values in a list? Explain with example.\n5. What do you mean by aliasing and cloning a list? Explain with example.\n6. Write any five built-in list functions with suitable examples.\n7. What do you mean by the built-in list methods? Explain with example.\n8. How to use loops in lists? Explain with example.\n9. Explain the working , , and methods with\nfilter() map() reduce()\nexamples.\n10. Explain linear and binary search with proper explanation.\n11. Explain quick sort and merge sort with example. CHAPTER 7\nTuple\nhe tuple is an important data type in Python, which stores various\nT\nelements as an object. It is also known as an immutable data type that\nmeans its elements are fixed and cannot be changed. In this chapter, you will\nsee various properties and operations that can be applied to tuples. Also,\nvarious functions and operations of tuples are demonstrated with the help of\nexamples and codes.\nStructure\nIn this chapter, we will cover the following topics:\nThe concepts and properties of tuples\nTuple creation and accessing elements\nVarious tuple operations\nPacking and unpacking of tuple elements\nUsing tuples with functions\nObjective\nThe objective of this chapter is to introduce the concept of Python tuples.\nAfter completing this chapter, you should understand the various operations\nand properties of tuples. Also, you will be able to write various codes\nrelated to tuples.\nWhat is a tuple?\nA tuple is a group of objects that have been ordered and are immutable.\nTuples are like lists and strings. Here, the meaning of immutable is that the\ntuple elements are fixed. Once a tuple is created, elements addition and\ndeletions are not possible. Even we cannot shuffle the order of tuple elements. The length of the tuple is also fixed. If we want to increase or\ndecrease a tuple, we need to create a new tuple.\nThe distinctions between tuples and lists are that, unlike lists, tuples cannot\nbe altered, and tuples use parentheses, while lists use square brackets.\nTuples are the type of sequence the same as string. Strings can only store\ncharacters, but tuples are able to store any kind of elements. It means that the\ntuple either stores a group of student's names or stores the IDs of employees.\nTuples can also store elements of mixture types that mean a tuple may have\nelements of numbers, characters, and decimal formats together. Tuples can\nalso store a sequence of sound files, images, etc.\nDifference between tuple and list\nThe following table describes the differences between tuples and lists:\nSr. no. Tuple List\n1. The elements of a tuple are immutable. The elements of a list are mutable.\n2. Tuple elements are enclosed in List elements are enclosed in square\nparenthesis (). brackets [].\n3. If we do not want to change the data A list will be the right decision when\nover time, the tuple is preferable. we decide to change the data in the\nfuture.\n4. Iterating the elements of a tuple is As compared to the tuple, iterating\nfaster. elements of the list is slow.\n5. Tuple can store heterogeneous List stores homogeneous elements.\nelements.\n6. The size of tuples is fixed. Lists are dynamic.\n7. Example: Example:\nT1 = (10,20,30,40,50) L1 = [10,20,30,40,50]\nTable 7.1: Differences between tuples and lists\nCreating tuple\nTo create a tuple in Python, all the elements are enclosed in parenthesis,\n()\nseparated by a comma. A tuple can store heterogeneous data elements.\nBelow are the examples of creating tuples: Example 7.1:\n# Create an empty tuple\nTuple1 = ()\n# tuple with 5 elements\nTuple2 = (10,20,30,40,50)\nprint (Tuple2)\n# tuple of character elements\nTuple3 = ('x', 'y', 'z')\nprint (Tuple3)\n# tuple of strings\nTuple4 = (\"Python\", \"Programming\", \"Book\")\nprint (Tuple4)\n# tuple of heterogeneous data elements\nTuple5 = (100, 20.123, \"Python Programming\")\nprint (Tuple5)\n# tuple of string and list\nTuple6 = (\"Python Book\", [10, 20, 25])\nprint (Tuple6)\nOutput:\n(10, 20, 30, 40, 50)\n('x', 'y', 'z')\n('Python', 'Programming', 'Book')\n(100, 20.123, 'Python Programming')\n('Python Book', [10, 20, 25])\nSingle element tuple\nTo create a tuple of single element, it should be followed by a comma. The\nfollowing example creates a tuple of a single element:\nTup1 = (100,)\nIn the preceding case, if we do not put a comma after , then Python would\n100\ntreat as an rather than a tuple variable.\nTup1 int\nExample 7.2: Tup1 = (100,)\ntype (Tup1)\nTup2=(100)\ntype (Tup2)\nOutput:\n<class 'tuple'>\n<class 'int'>\nWe have to add a comma after the element when a tuple has just one\nelement; otherwise, Python would not consider it as a tuple.\nThe tuple () function\nThe function is a Python built-in function that can be used to create\ntuple ()\na tuple. We can even create a tuple without using this function, but it provides\nan alternative way of creating tuples. The following example shows the use\nof function to create a tuple:\ntuple ()\nExample 7.3:\n# example of tuple() function\n# creating an empty tuple\nT1 = tuple()\nprint(T1)\n# creating a tuple from list\nT2 = tuple([1,2,3,4,5])\nprint (T2)\n# creating a tuple from strings\nT3 = tuple(\"Python Programming\")\nprint (T3)\nOutput:\n()\n(1, 2, 3, 4, 5)\n('P', 'y', 't', 'h', 'o', 'n', ' ', 'P', 'r', 'o', 'g', 'r',\n'a', 'm', 'm', 'i', 'n', 'g') Accessing values in tuple\nIn order to access the elements of a tuple, indexes are used. Tuple indexes\nstart at 0, like string indices, and can be sliced, concatenated, and so on.\nFollowing examples shows how we can access values in tuples:\nExample 7.4:\n# tuple of characters\ntup1 = ('A', 'B', 'C', 'D')\n# tuple of integers\ntup2 = (10, 20, 30, 40, 50, 60, 70)\n# displaying first element of tuple1\nprint tup1[0]\n# displaying second to fifth elements of tuple 2\nprint tup2[1:5]\nOutput:\nA\n(20, 30, 40, 50)\nThe value of the index is always an integer. For example,\nprint\nwill generate type error.\ntup1[2.0]\nTypeError: tuple indices must be integers, not float\nPositive and negative indexes\nIn Python, the same as list and string indexes can be positive and negative.\nPositive indexes start from 0, while negative indexes start from -1. Positive\nindex access elements from the beginning of the tuple, while negative indexes\nare used to access elements from the tuple's end. The positive and negative\nindexes are shown in the following figure:\nFigure 7.1: Positive and negative indexing The following example demonstrates the use of a negative index:\nExample 7.5:\nTuple1 = (10, 20, \"Books\", 108.92)\n# Accessing last element using negative index\nprint(Tuple1[-1])\n# Accessing third element from last\nprint(Tuple1[-3])\nOutput:\n108.92\n20\nSlicing tuple\nSlicing acts in the same manner as strings. We ought to have a position for the\nbeginning and end. The outcome is a tuple between those two positions,\ncontaining every element. We must use the operator on the tuple to slice a\n[]\ntuple. If we have a positive integer when indexing a tuple, the index is\nobtained from the tuple count on the left. In case of a negative index, the\nindex is obtained from the right tuple count. The following code is an\nexample of slicing operations on the tuple:\nExample 7.6:\nT1 = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n# print elements from 3rd to 6th\nprint(T1[2:6])\n# print elements from start to 4th position\nprint(T1[:4])\n# print elements from 4th to last\nprint(T1[3:])\n# print elements from 6th to second last\nprint(T1[5:-1])\n# print entire tuple\nprint(T1[:])\nOutput: (3, 4, 5, 6)\n(1, 2, 3, 4)\n(4, 5, 6, 7, 8, 9, 10)\n(6, 7, 8, 9)\n(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nUpdating tuple\nTuples are immutable, which indicates that the values of tuple elements will\nnot be changed or modified. However, we may change the elements of nested\nitems that are mutable. In the following code, for example, we change the list\nelement present within the tuple. Elements in the list are mutable, so it is\npermissible:\nExample 7.7:\nT1= (1, [2, 3, 4,5], \"Python\")\nprint(T1)\n# Updation is not valid for tuples\n#T1[0] = 100 # It generates error\n# Changing the list element, this is valid because list is\nmutable\nT1[1][2] = 10\nprint(T1)\nOutput:\n(1, [2, 3, 4, 5], 'Python')\n(1, [2, 3, 10, 5], 'Python')\nWe can create a new tuple using a portion of an existing tuple. The example\nbelow demonstrates the creation of a new tuple:\nExample 7.8:\nT1 = (1, 2, 3, 4.5)\nT2 = ('ABCD', 'XYZW')\n# New tuple creation from existing\nT3 = T1 + T2[0:1]\nprint T3 Output:\n(1, 2, 3, 4.5, 'ABCD')\nDeleting elements in tuple\nWe have already demonstrated that tuple elements are immutable, which\nimplies that the elements in a tuple cannot be deleted. However, deleting the\nwhole tuple can be possible. The statement can be used to delete an\ndel\nentire tuple:\nExample 7.9:\nT2 = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n# printing whole tuple\nprint(T2)\n#del T2[2] #it will generate an error\n# deleting an entire tuple\ndel T2\n#print after deleting a tuple\nprint(T2) #it will generate error\nOutput:\n(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nTraceback (most recent call last):\nFile \"main.py\", line 11, in <module>\nprint(T2) #it generates error\nNameError: name 'T2' is not defined\nBasic tuple operations and functions\nThe different operations on tuples that we can perform are very similar to\nlists. In general, with tuples, we just saw the operator. It works with tuples\n+\njust like it works with a list. Tuples behave much like strings to the and\n+ *\noperators; they also imply concatenation and repetition here, except that a\nnew tuple is a result, not a string. Tuples respond the same as strings to all\nthe general sequence operations.\nAddition: Addition operators combine all the elements of two or more\ntuples into a new tuple. Example 7.10:\nT1 = (1, 2, 3)\nT2=(4, 5)\nT3=(10,)\nT4=T1+T2+T3\nprint (T4)\nOutput:\n(1, 2, 3, 4, 5, 10)\nMultiplication: If a tuple is multiplied by any integer, would\nx\nbasically create another tuple with all the elements repeated times\nx\nfrom the first tuple. indicates, for instance, the elements of tuple\nT*5 T\nwill be replicated 5 times:\nExample 7.11:\n#tuple with three elements\nT = (1, 2, 3)\n#replicate 5 times\nprint(T*5)\n#replicate string 3 times\nprint(\"Python\"*3)\nOutput:\n(1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3)\nPythonPythonPython\nlen() function: This function is used to get the number of elements in\nthe tuple.\nmax() and min() function: These functions are used to get the maximum\nand minimum value from the tuple.\nsum() function: This function is used to get the sum of all the elements\nof tuple.\nin keyword: This keyword is used with tuple same as strings and lists.\nIt is used to check whether any element is present or not in the tuple. If\nthe element is present, it returns , otherwise it returns .\nTrue False Example 7.12:\n#tuple with six elements\nT = (10, -2, 300, 40, 302, 900)\n# length of the tuple\nprint (\"Length:\", len(T))\n# Max value from tuple\nprint (\"Max:\", max(T))\n# Min value from tuple\nprint (\"Min:\", min(T))\n# Sum of all elements of tuple\nprint (\"Sum:\", sum(T))\n# Check whether 40 is present or not in tuple\nprint (40 in T)\n# Check whether 500 is present or not in tuple\nprint (500 in T)\nOutput:\n('Length:', 6)\n('Max:', 900)\n('Min:', -2)\n('Sum:', 1550)\nTrue\nFalse\ncmp() function: The function is used to compare two tuples.\ncmp ()\nBased on whether the two tuples being compared are similar or not, it\nwill return either 1, 0 or -1. This function takes two tuples as arguments\nfor comparison. If and are two tuples then the following result\nT1 T2\nwill be produced based on the comparison.\nif , then returns 1\nT1 > T2 cmp(T1, T2)\nif , then returns 0\nT1 = T2 cmp(T1, T2)\nif , then returns -1\nT1 <T2 cmp(T1, T2)\nExample 7.13:\n#first tuple\nT1 = (100, 20,30,40) #second tuple\nT2=(100,2,3,4,5)\nprint(\"T1>T2:\",cmp(T1,T2))\nprint(\"T1<T2:\",cmp(T2,T1))\n#third tuple\nT3 = (100, 20,30,40)\nprint(\"T1=T3:\",cmp(T1,T3))\nOutput:\n('T1>T2:', 1)\n('T1<T2:', -1)\n('T1=T3:', 0)\nindex() function: is a built-in Python function which searches\nindex()\nfor a given element in a tuple and returns the lowest index where the\nelement appears. The function takes maximum three arguments\nindex()\nand follows the given syntax:\ntuple.index(element, start, end)\nHere is the first argument that must be searched in a tuple.\nelement\nand are an optional arguments that indicates starting and\nStart end\nending point index of a searching element:\nExample 7.14:\n# Tuple of four elements\nT1 = (100, 20,30,40)\n# tuple of characters\nT2=(\"PYTHON\")\n# print the index of 100 in tuple T1\nprint(\"Index No.:\",T1.index(100))\n# print the index of T in tuple T2\nprint(\"Index No.:\",T2.index('T'))\n# search the index of 20, start from 1 to 4\nprint(\"Index No.:\",T1.index(20,1,4))\nOutput:\n('Index No.:', 0) ('Index No.:', 2)\n('Index No.:', 1)\ncount() function: The function returns the number of\ncount()\noccurrences in the given tuple for an element.\nExample 7.15:\n#tuple 1\nT1 = (1, 1, 1, 2, 2, 2, 1, 2, 3, 1, 1)\n#tuple 2\nT2 = ('a', 'a', 'a', 'b', 'b', 'a', 'c', 'b', 'a','b')\n#tuple 3\nT3 = ['Bat', 'Cat', 'Sat', 'Bat', 'cat', 'Bat']\n# Counts the number of times 1 appears in tuple 1\nprint(\"Count of 1:\", T1.count(1))\n# Counts the number of times 'a' appears in tuple 2\nprint(\"Count of a:\", T2.count('a'))\n# Counts the number of times 'Bat' appears in tuple 3\nprint(\"Count of Bat:\", T3.count('Bat'))\nOutput:\n('Count of 1:', 6)\n('Count of a:', 5)\n('Count of Bat:', 3)\nPacking and unpacking a tuple\/tuple assignment\nPython has a very useful function known as tuple assignment, which allows\nvalues to be assigned to a tuple of variables on the left-hand side of an\nassignment from a tuple on the right-hand side of the assignment. It is also\ncalled unpacking a tuple of values into a variable. We put values into a new\ntuple while packing, while we extract those values into a single variable\nwhile unpacking. This feature helps more than one variable to be assigned at\na time while a sequence is on the left. In the example below, one tuple T1\nassigns values to five different variables. In this assignment, the number of\nvariables on the left-hand side must be equal to the number of tuple elements\non the right-hand side. Otherwise, this assignment generates an error. Example 7.16:\n# tuple with five elements\/Packing\nT1= ('David', 'India', 1990, 1001)\nprint (\"Tuple Elements are:\", T1)\n# tuple assignment to different variables\/Unpacking\n(EmpName, Country, BirthYear, EmpId)=T1\n# printing individual variables\nprint(\"--------------------------\")\nprint (\"EmpName:\",EmpName)\nprint (\"Country:\", Country)\nprint (\"BirthYear:\", BirthYear)\nprint (\"EmpId:\",EmpId)\nOutput:\nTuple Elements are: ('David', 'India', 1990, 1001)\n--------------------------\nEmpName: David\nCountry: India\nBirthYear: 1990\nEmpId: 1001\nIn the example above, we have a tuple which contains five elements and\nT1\nassign different values to the variables , , , and\nEmpName Country BirthYear\nin a single statement. We can also assign individual element values to\nEmpId\nvariables such as:\nExample 7.17:\n# tuple with five elements\nT1= ('David', 'India', 1990, 1001)\nprint (\"Tuple Elements are:\", T1)\n# assigning one value at a time\nEmpName=T1[0]\nCountry=T1[1]\nBirthYear=T1[2]\nEmpId=T1[3]\n#printing individual values print ('-------------------')\nprint (EmpName)\nprint (Country)\nprint (BirthYear)\nprint (EmpId)\nOutput:\nTuple Elements are: ('David', 'India', 1990, 1001)\n-------------------\nDavid\nIndia\n1990\n1001\nReceiving tuples in functions\nThere is a special way of receiving parameters using the prefix for a\n*\nfunction as a tuple. This is helpful when taking the number of arguments in the\nfunction as a function. All extra arguments passed to the function are stored in\nas a tuple due to the prefix on the variable:\nargs * args\nExample 7.18:\n# This function receives a tuple as an argument\ndef fun1(*args):\nprint(type(args)) #printing the type of args\nPrint(args)\n# creating a tuple\nT1=(\"Python\", \"Book\", 2020)\n# passing tuple to a function\nfun1(T1)\nOutput:\n<class 'tuple'>\n(('Python', 2020),)\nReturning multiple values as a tuple In C and other programming languages, returning multiple values from a\nfunction is impossible, but it is quite simple to do with Python. In Python, by\nsimply returning statements separated by commas, we can return multiple\nvalues. In the example below, a function is defined to return a string\nfun1()\nand a number:\nExample 7.19:\n#Returning multiple values as tuple\n# This function returns a tuple\ndef fun1():\ns1 = \"Python\"\nx = 2020\nreturn (s1, x)\n# calling function\nT1= fun1() #T1 is a tuple\nprint(type(T1))\nprint(T1)\nOutput:\n<class 'tuple'>\n('Python', 2020)\nNested tuples\nWe may declare a tuple inside a tuple in Python, and this is called a nesting\ntuple. To arrange data into hierarchical structures, nesting tuples are used. If\nonly one element is present in a tuple, then it is not called as a tuple. To\nshow to the interpreter that it is a tuple, it should be a trailing comma. We\nhave declared a tuple inside another tuple in the following example:\nExample 7.20:\n# Nested tuples create\nTuple1 = (\"Python\", [1,2,3,4], (5, 5.6, \"Programming\"))\n# Print all elements of tuple\nprint (\"Tuple values are:\", Tuple1)\n# Print first element print (\"first Element:\", Tuple1[0])\n#print second element or sub-tuple\nprint (\"sub tuple:\", Tuple1[1])\n#print third element or sub-tuple\nprint (\"sub tuple:\", Tuple1[2])\nOutput:\nTuple values are: ('Python', [1, 2, 3, 4], (5, 5.6,\n'Programming'))\nfirst Element: Python\nsub tuple: [1, 2, 3, 4]\nsub tuple: (5, 5.6, 'Programming')\nCreating tuple from string and list\nIn Python, a tuple can be created from list as well as string. We need this kind\nof conversion when there are different types of data available and new tuple\nmust be created. The function is used to convert string or list to a\ntuple ()\ntuple. This concept is illustrated in the following example:\nExample 7.21:\n# creating list and string\nL1 = ['Python',1,2,3,4]\nS1 = \"Programming\"\n# printing original list and string\nprint (\"The original list : \", L1)\nprint (\"The original string : \", S1)\nprint (type(L1))\nprint(type(S1))\n#concert list to tuple\nresult1 = tuple(L1)\n#concert string to tuple\nresult2=tuple(S1)\nprint(\"Converted List : \", result1)\nprint (type(result1))\nprint(\"Converted String : \", result2)\nprint (type(result2)) Output:\nThe original list : ['Python', 1, 2, 3, 4]\nThe original string : Programming\n<class 'list'>\n<class 'str'>\nConverted List : ('Python', 1, 2, 3, 4)\n<class 'tuple'>\nConverted String : ('P', 'r', 'o', 'g', 'r', 'a', 'm', 'm',\n'i', 'n', 'g')\n<class 'tuple'>\nThe zip() function\nPython function is mainly used to combine data of two different\nzip ()\ncontainer elements together. This function takes iterables and aggregates their\nelements based on their order in the iterables. As an input it takes any number\nof iterables and returns an iterator of tuples. Iterables may be list, string, etc.\nThe following example groups items of two different list based on the same\nindex:\nExample 7.22:\n#creating two lists\nList1 = ['A', 'B', 'C', 'D']\nList2 = [10, 20, 30, 40]\n#combine using zip\nResult = tuple(zip(List1, List2))\nprint (Result)\nprint (type(Result))\nOutput:\n(('A', 10), ('B', 20), ('C', 30), ('D', 40))\n<class 'tuple'>\nThe returned iterator takes the length of the shortest iterator passed to the\nfunction if the passed iterables are of different lengths. In the example below, we have two lists of size four and two, respectively. The result tuple has\nlength two, based on the shortest list :\nList2\nExample 7.23:\n#creating two lists\nList1 = ['A', 'B', 'C', 'D']\nList2 = [10, 20]\n#combine using zip\nResult = tuple(zip(List1, List2))\nprint (Result)\nprint (type(Result))\nOutput:\n(('A', 10), ('B', 20))\n<class 'tuple'>\nThe function also works for more than two iterables, such as:\nzip()\nExample 7.24:\n#creating three tuples\nT1 = ('Amit', 'Sumit', 'Joy', 'Dev')\nT2 = (50000, 20000, 25000, 80000)\nT3=('HR', 'Clerk','IT', 'Manager')\n#combine using zip\nResult = tuple(zip(T1, T2, T3))\nprint (Result)\nprint (type(Result))\nOutput:\n(('Amit', 50000, 'HR'), ('Sumit', 20000, 'Clerk'), ('Joy',\n25000, 'IT'), ('Dev', 80000, 'Manager'))\n<class 'tuple'>\nThe inverse zip(*) function The operator can be used with the function. It unzips the tuples into\n* zip ()\nindependent lists. In other words, the operator with function\n* zip ()\nunpacks a sequence into positional arguments. The following example shows\nthe concept of unzipping tuples:\nExample 7.25:\n# using zip() and * operator to unpack sequences\n# creating tuple\nT1 = [('A', 100), ('B', 200), ('C', 300), ('D', 4000)]\n# Original tuple\nprint (\"Original tuple is : \", T1)\n# using zip() and * operator to perform unzipping\nT2,T3 = zip(*T1)\nT4=zip(*T1)\n# Printing modified tuple 1\nprint (\"Modified Tuple1 : \", T2)\nprint (type(T2))\n# Printing modified tuple 2\nprint (\"Modified Tuple2 : \", T3)\nprint (type(T3))\n# Printing modified tuple 3\nprint (\"Modified Tuple2 : \", tuple(T4))\nOutput:\nOriginal tuple is : [('A', 100), ('B', 200), ('C', 300),\n('D', 4000)]\nModified Tuple1 : ('A', 'B', 'C', 'D')\n<class 'tuple'>\nModified Tuple2 : (100, 200, 300, 4000)\n<class 'tuple'>\nModified Tuple2 : (('A', 'B', 'C', 'D'), (100, 200, 300,\n4000))\nTuple sorting\nWe have an in-built function named in python to sort the tuple\nsorted()\nelements. This function takes one argument as a parameter to sort tuples. sorted(arg1)\nBy default, the tuple is sorted in ascending order using function. If\nsorted()\nwe want to sort in descending order, we need to set the parameter reverse to\nTrue.\nsorted(arg1, reverse=True)\nExample 7.26:\n# Create a tuple\nTuple1 = (20, 4, 6, -1, 4, 7.8, 2.79, 5.90)\n# Sorting in ascending order\nTDefault=sorted(Tuple1)\n# Sorting in descending order\nTReverse=sorted(Tuple1, reverse=True)\n# Printing original tuple\nprint (\"Original tuple:\", Tuple1)\n# Printing sorted tuple-Ascending\nprint (\"Sorted tuple:\", TDefault)\n# Printing sorted tuple-Descending\nprint (\"Sorted tuple in reverse order:\", TReverse)\nOutput:\nOriginal tuple: (20, 4, 6, -1, 4, 7.8, 2.79, 5.9)\nSorted tuple: [-1, 2.79, 4, 4, 5.9, 6, 7.8, 20]\nSorted tuple in reverse order: [20, 7.8, 6, 5.9, 4, 4, 2.79,\n-1]\nExample 7.27:\ndef TupleSort(t):\nsort1 = sorted(t)\nsort2= sorted(t, reverse=True)\nreturn sort1, sort2\n# Create a tuple\nTuple1 = (20, 4, 6, -1, 4, 7.8, 2.79, 5.90,900)\n# passing parameter to function for sorting\nTDefault, TReverse=TupleSort(Tuple1) # Printing original tuple\nprint (\"Original tuple:\", Tuple1)\n# Printing sorted tuple-Ascending\nprint (\"Sorted tuple:\", TDefault)\n# Printing sorted tuple-Descending\nprint (\"Sorted tuple in reverse order:\", TReverse)\nOutput:\nOriginal tuple: (20, 4, 6, -1, 4, 7.8, 2.79, 5.9, 900)\nSorted tuple: [-1, 2.79, 4, 4, 5.9, 6, 7.8, 20, 900]\nSorted tuple in reverse order: [900, 20, 7.8, 6, 5.9, 4, 4,\n2.79, -1]\nConclusion\nIn this chapter, we discussed the concepts and various properties of tuples.\nWe also discussed how different operations can be applied on the tuples.\nVarious examples and Python codes are given to understand tuple\nsystematically. Based on these examples you can write your own code for a\nspecific task. In the next chapter, we will discuss dictionary as the next data\ntype used in Python.\nPoints to remember\nTuples are immutable data type.\nIn Python, tuples are written with round brackets.\nThe elements of the tuples are not changeable.\nTuples' operations are very similar to list and strings.\nMultiple choice questions\n1. Choose the correct option.\na. Both tuples and lists are immutable.\nb. Tuples are immutable, while lists are mutable.\nc. Both tuples and lists are mutable. d. Tuples are mutable while lists are immutable.\n2. Suppose T = (1, 2, 3, 4,5), which of the following is incorrect?\na. T[2] = 50\nb. print(T[2])\nc. print(max(T))\nd. print(len(T))\n3. What will be the output of the below code?\ntuple1=(1,2,3)\ntuple3=tuple1*2\nprint(tuple3)\na. (2,4,6)\nb. (1,2,3,1,2,3)\nc. (1,1,2,2,3,3)\nd. Error\n4. Which is a correctly declared tuple?\na. T = (\"orange\", \"yellow\", \"red\")\nb. T = \"orange\", \"yellow\", \"red\"\nc. T = [\"orange\", \"yellow\", \"red\"]\nd. T = \"orangeyellowred\"\n5. What will be the output of the following program?\nTuple1 = (10, 20, 40, 30)\nTuple2 = (10, 20, 30, 40)\nprint(Tuple1 <Tuple2)\na. Error\nb. True\nc. False\nd. Unexpected\nAnswers 1. b\n2. a\n3. b\n4. a\n5. c\nQuestions\n1. What is the difference between a list and a tuple?\n2. How would you convert a list into a tuple?\n3. Discuss built-in function supported by tuples?\n4. How does packing and unpacking work on the tuple? Give a suitable\nexample.\n5. What is positive and negative index in a tuple? Write an example.\n6. How can a tuple be passed to a function?\n7. Write Python code to sort tuple elements.\n8. Write Python code to copy the first and second elements of a tuple into\na new tuple.\n9. Write code to count the number of occurrences of an item from a tuple.\n10. Write code to unpack the following tuple into five variables.\nTuple1 = (100, 200, 300, 400, 500) CHAPTER 8\nDictionaries\nictionary is another data type in Python, which is similar to lists and\nD\ntuples. It is also known as an associative array. A dictionary consists of a\ncollection of key-value pairs. Each key-value pair maps the key to its\nassociated value. In this chapter, you will see various properties and\noperations that can be applied to dictionaries. Besides, we have\ndemonstrated various functions and operations of dictionaries with the help\nof examples and codes.\nStructure\nIn this chapter, we will cover the following topics:\nThe basic concepts of the dictionary\nDictionary creation and accessing elements\nVarious operations related to dictionaries\nThe concepts of nested dictionaries\nFormatting dictionary elements\nObjective\nThe objective of this chapter is to introduce the concept of Python\ndictionaries. After completing this chapter, you should be able to understand\nthe various operations and properties of the dictionaries. Also, you will be\nable to write various codes related to dictionaries.\nBasics of dictionary\nDictionary is another important built-in data type in Python. It is used to store\ndata as collections. Dictionaries are not commonly used, such as arrays and\nlists. In Python, a dictionary is a collection that keeps information or value associated with some specific keys. The combination of values along with\nkeys is known as mapping relation. Hence Python dictionaries follow\nmapping relations among elements.\nDictionaries work differently as compared to lists and arrays. List stores and\nretrieves elements from the collection using index positions. It means that we\ncan look up by the index number whenever we want to access an element in a\nlist or array.\nMany applications require a more flexible way of getting information from\nthe collection, and programmers are not interested in working with indexing\nstructures. Hence, dictionaries can provide a better solution. The concept of\ndictionaries can be understood by some real examples. If we want to get the\nphone number of an employee based on their name or want to know the city\nname according to the given pin code, then we have an efficient structure\nknown as a dictionary that follows mapping between values and keys. In\nprogramming, this combination is referred to as a key-value pair. In this\ncombination, we access any information\/value (city name) associated with a\nparticular key (pin code). The following figure shows the simple structure of\nthe dictionary with a key-value example:\nFigure 8.1: Simple structure of a dictionary\nHash and associative array are also another name of a dictionary used in\nsome other programming languages. The following example shows the\nconcept of a dictionary that stores city names associated with pin codes:\n{\"110001\":\"Delhi\", \"400008\": \"Mumbai\", \"700052\":\" Kolkata\"} In Python dictionary, all the elements are enclosed in curly brackets such as\n{\nand . A colon ( ) is used to join the key-value pair. The following is the\n} :\nsyntax of the dictionary:\ndictionary = {\n<key1>: <value1>,\n<key2>: <value2>,\n.\n.\n.\n<keyn>: <valuen>\n}\nCreating a dictionary\nA dictionary can be created in Python by placing element sequences inside\nthe curly brackets of and , separated by comma ( ). There are several\n{ } ,\nvalues in the dictionary: the key and the other corresponding part of the pair\nbeing the value. Values in a dictionary can be of any data type and can be\nduplicated, while keys cannot be repeated and must be immutable. Dictionary\nkeys are case-sensitive, which means different cases represent distinct keys.\nThere are several methods to create a dictionary.\nMethod 1: Create empty dictionary and then add\nitems\nThe first method of dictionary creation is to create an empty dictionary and\nthen add items to it:\nExample 8.1:\n# Creating an empty dictionary\nDict1 = {}\n# Adding items to dictionary\nDict1[\"key1\"] = [1, 2, 3]\nDict1[\"key2\"] = [\"Code\", \"From\", \"Home\"]\nprint (Dict1)\n# Checking type of Dict1 print (type(Dict1))\nOutput:\n{'key1': [1, 2, 3], 'key2': ['Code', 'From', 'Home']}\n<class 'dict'>\nMethod 2: By passing key-value pair literals\nAnother way of creating a dictionary by passing key-value pairs literals:\nExample 8.2:\n# Creating a dictionary\nDict1 = {\n110001 : \"Delhi\",\n400008 : \"Mumbai\",\n700052 : \"Kolkata\",\n600001 : \"Chennai\",\n}\n# Printing dictionary\nprint (Dict1)\n# Checking type of Dict1\nprint (type(Dict1))\nOutput:\n{110001: 'Delhi', 400008: 'Mumbai', 700052: 'Kolkata',\n600001: 'Chennai'}\n<class 'dict'>\nMethod 3: Passing key-value pairs to\ndict()\nfunction\nWe can create a dictionary by passing key-value pairs function:\ntodict()\nExample 8.3:\n# Creating a dictionary\nDict2 = dict( Name='Joy',\nAge=25,\nAddress='Delhi',\nSalary=50000)\n# Printing dictionary\nprint(Dict2)\n# Checking type of Dict1\nprint (type(Dict2))\nOutput:\n{'Name': 'Joy', 'Age': 25, 'Address': 'Delhi', 'Salary':\n50000}\n<class 'dict'>\nMethod 4: Passing list of tuples to dict() function\nThe next method of creating dictionaries is to pass a list of tuples to\ndict ()\nfunction:\nExample 8.4:\n# Passing list of tuples\nDict3= dict(\n[('Name', 'John'),\n('Age', 25),\n('Address', 'Delhi'),\n('Salary', 50000)])\n# Printing dictionary\nprint(Dict3)\n# Checking type of Dict1\nprint (type(Dict3))\nOutput:\n{'Name': 'John', 'Age': 25, 'Address': 'Delhi', 'Salary':\n50000}\n<class 'dict'> Dictionary does not contain any duplicate keys.\nAccessing dictionary values\nA dictionary uses key names to access any value, while indexing is used for\nother data types to reach values. Key names can be used within square\nbrackets to access associated values. The following syntax is used to\n[]\nretrieve any value associated with the key in the dictionary:\nDictionaryname[keyname]\nExample 8.5:\n# Creating a dictionary\nDict1= {\n110001 : \"Delhi\",\n400008 : \"Mumbai\",\n700052 : \"Kolkata\",\n600001 : \"Chennai\",\n}\n# Retrieving values associated with keys\nprint (Dict1[110001])\nprint (Dict1[400008])\nprint (Dict1[600001])\nOutput:\nDelhi\nMumbai\nChennai\nAn alternate way is to use function with key to retrieve associated\nget()\nvalue from the dictionary. This function can be used as follows:\nExample 8.6:\n# Creating a dictionary\nDict1= {\n110001 : 'Delhi',\n400008 : \"Mumbai\", 700052 : \"Kolkata\",\n600001 : \"Chennai\",\n}\n# Retrieving values associated with keys\nprint (Dict1.get(110001))\nprint (Dict1.get(400008))\nprint (Dict1.get(600001))\nOutput:\nDelhi\nMumbai\nChennai\nIf square brackets are used, will be raised if a key is not\n[] KeyError\npresent in the dictionary. The function, on the other hand,\nget()\nreturns if the key is not present.\nNone\nAdding and modifying an item in a Dictionary\nDictionaries are a mutable data type that means element values can be\nchanged. Using an assignment operator with keys, we can add new elements\nor modify existing elements' value. If the key is already present, then it will\nchange the current value. A new key-value pair is added to the dictionary if\nthe key is not present. The following syntax is used to add a new element to a\ndictionary.\nDictionaryname[keyname]=value\nExample 8.7:\n# Adding and modifying dictionary elements\ndict1 = {'name': 'Amit', 'age': 30, 'city': 'Mumbai'}\n# Print the elements\nprint (dict1)\n# Add a new element\ndict1['Post'] = 'Manager'\n# After adding new element, print all values\nprint (dict1) # modifiying an existing value\ndict1['age'] = 32\n# After modifying value, print all values\nprint (dict1)\nOutput:\n{'name': 'Amit', 'age': 30, 'city': 'Mumbai'}\n{'name': 'Amit', 'age': 30, 'city': 'Mumbai', 'Post':\n'Manager'}\n{'name': 'Amit', 'age': 32, 'city': 'Mumbai', 'Post':\n'Manager'}\nAs we have seen in the above example, if a key ( ) is existing in a\nage\ndictionary, then it modifies or replaces old value ( ) with the new value\n30\n( ).\n32\nDeleting elements from a dictionary\nAny elements can be deleted from the dictionary using its associated keys.\nYou may use the operator to delete a component that is present in the\ndel\ndictionary. The downside that can be thought of using this is that an exception\nis raised if the key is not present. The following syntax is used to delete an\nelement from a dictionary:\ndel Dictionaryname[keyname]\nThe following example deletes an element such as with the associated\nage\nvalue from the dictionary :\ndict1\nExample 8.8:\n# Adding and modifying dictionary elements\ndict1 = {'name': 'Amit', 'age': 30, 'city': 'Mumbai'}\n# Add a new element\ndict1['Post'] = 'Manager'\n# Print the elements\nprint (\"Available Elements are:\", dict1)\n# After adding new element, print all values\nprint (\"Before Deletion:\",dict1) # deleting an element age\ndel dict1['age']\n# Values after deleted an element\nprint (\"After Deletion:\", dict1)\nOutput:\nAvailable Elements are: {'name': 'Amit', 'age': 30, 'city':\n'Mumbai', 'Post': 'Manager'}\nBefore Deletion: {'name': 'Amit', 'age': 30, 'city':\n'Mumbai', 'Post': 'Manager'}\nAfter Deletion: {'name': 'Amit', 'city': 'Mumbai', 'Post':\n'Manager'}\nThe operator can even completely delete the dictionary such as:\ndel\ndel dict1\nAfter deleting dictionary , if we try to access , it will cause an\ndict1 dict1\nerror because no longer exists.\ndict1\nAn alternative method is to delete a key and its corresponding value from a\ndictionary using the function. The advantage of using the operator\npop() del\nis that if tried to delete a non-existent element, it can print the desired value\nor message. Second, in addition to completing a basic delete operation, it\nalso returns the value of a key that is being deleted:\nExample 8.9:\n# Example of deleting dictionary element using pop() function\n# Initializing a dictionary\nD1= {\"Amit\" : 20, \"Sumit\" : 25, \"John\" : 28, \"David\" : 29,\n\"Bob\" :30}\n# Printing dictionary before element deletion\nprint (\"The dictionary before performing deletion is : \", D1)\n# Using pop() function to delete an element such as John\ndel_value = D1.pop('John')\n# Printing dictionary after element deletion\nprint (\"The dictionary after deletion is : \", D1)\nprint (\"The removed key's value is : \", del_value) # Again deleting an element which is not present\n# assigns 'Not available' to del_value\ndel_value1 = D1.pop('Jai', 'Not available')\n# Printing dictionary after element deletion\nprint (\"The dictionary after remove is : \", D1)\nprint (\"The removed key's value is : \", del_value1)\nOutput:\nThe dictionary before performing deletion is : {'Amit': 20,\n'Sumit': 25, 'John': 28, 'David': 29, 'Bob': 30}\nThe dictionary after deletion is : {'Amit': 20, 'Sumit': 25,\n'David': 29, 'Bob': 30}\nThe removed key's value is : 28\nThe dictionary after remove is : {'Amit': 20, 'Sumit': 25,\n'David': 29, 'Bob': 30}\nThe removed key's value is : Not available\nThe clear () function\nUsing the function, we can delete all elements from the dictionary\nclear ()\nat once. Following example deletes all the entries from the dictionary :\nD1\nExample 8.10:\n# Example of deleting all element using clear () function\n# Initializing a dictionary\nD1= {\"Amit\" : 20, \"Sumit\" : 25, \"John\" : 28, \"David\" : 29,\n\"Bob\" :30}\n# Printing dictionary before element deletion\nprint (\"The dictionary before performing deletion is : \", D1)\n# Deleting all elements\nD1.clear()\n# Printing dictionary after element deletion\nprint (\"The dictionary after remove is : \", D1)\nOutput: The dictionary before performing deletion is : {'Amit': 20,\n'Sumit': 25, 'John': 28, 'David': 29, 'Bob': 30}\nThe dictionary after remove is : {}\nSorting elements in a dictionary\nA key and its corresponding value consist of a dictionary element. Sorting for\na dictionary may then be carried out as a parameter by using any of the key or\nvalue components. The function is used to sort dictionary elements\nsorted()\neither by keys or by values.\nSorting the dictionary by key\nWe can sort a dictionary directly using the built-in function. This\nsorted()\ncan be achieved by passing the dictionary itself and a function specifying the\nkey parameter that the sorting is to be performed based on:\nExample 8.11:\n# Initializing a dictionary\nD1= {\"Amit\" : 20, \"Sumit\" : 25, \"John\" : 28, \"David\" : 29,\n\"Bob\" :30}\nprint (type(D1))\n# Printing dictionary before sorting\nprint (\"The original dictionary is: \", D1)\n# Sorting by key\nD2= dict(sorted(D1.items(), key=lambda x: x[0]))\nprint (\"After sorting by key: \", D2)\nprint (type(D2))\nOutput:\n<class 'dict'>\nThe original dictionary is: {'Amit': 20, 'Sumit': 25, 'John':\n28, 'David': 29, 'Bob': 30}\nAfter sorting by key: {'Amit': 20, 'Bob': 30, 'David': 29,\n'John': 28, 'Sumit': 25}\n<class 'dict'> Here, the function returns a list of tuples containing the keys and\nD1.items()\ntheir respective values. For a particular item tuple, the function\nlambda\nreturns the key (0th element of the dictionary). Once these are passed to the\nfunction, a sorted sequence is returned, which is then typed into a\nsorted()\ndictionary.\nIn versions of Python 3.6+, this function can be used as it treats dictionaries\nas ordered sequences. For older versions, we may substitute the lambda\nfunction from the operator module with the as follows:\nitemgetter()\nExample 8.12:\nfrom operator import itemgetter\n# Initializing a dictionary\nD1= {\"Amit\" : 20, \"Sumit\" : 25, \"John\" : 28, \"David\" : 29,\n\"Bob\" :30}\nprint (type(D1))\n# Printing dictionary before sorting\nprint (\"The original dictionary is: \", D1)\n# Sorting by key\nD2= dict(sorted(D1.items(), key=itemgetter(0)))\nprint (\"After sorting by key: \", D2)\nprint (type(D2))\nOutput:\n<class 'dict'>\nThe original dictionary is: {'Amit': 20, 'Sumit': 25, 'John':\n28, 'David': 29, 'Bob': 30}\nAfter sorting by key: {'Amit': 20, 'Bob': 30, 'David': 29,\n'John': 28, 'Sumit': 25}\n<class 'dict'>\nSorting dictionary by value\nIt is like sorting a dictionary by value to sorting by key. The only distinction\nis that the parameter based on which the sorting will be carried out is the\nvalue component of this kind's corresponding element. The following\nexample sorts the dictionary according to the value parameter: Example 8.13:\n# Initializing a dictionary\nD1= {\"Amit\" : 20, \"Sumit\" : 25, \"John\" : 28, \"David\" : 29,\n\"Bob\" :30}\nprint (type(D1))\n# Printing dictionary before sorting\nprint (\"The original dictionary is: \", D1)\n# Sorting by value\nD2= dict(sorted(D1.items(), key=lambda x: x[1]))\nprint (\"After sorting by key: \", D2)\nprint (type(D2))\nOutput:\n<class 'dict'>\nThe original dictionary is: {'Amit': 20, 'Sumit': 25, 'John':\n28, 'David': 29, 'Bob': 30}\nAfter sorting by key: {'Amit': 20, 'Sumit': 25, 'John': 28,\n'David': 29, 'Bob': 30}\n<class 'dict'>\nIn the preceding example, the dictionary is sorted according to the values\nD1\nreturned by the lambda function ( value for element). We use the\nx[1] x\nfollowing code for the older versions of Python:\nExample 8.14:\nfrom operator import itemgetter\n# Initializing a dictionary\nD1= {\"Amit\" : 20, \"Sumit\" : 25, \"John\" : 28, \"David\" : 29,\n\"Bob\" :30}\nprint (type(D1))\n# Printing dictionary before sorting\nprint (\"The original dictionary is: \", D1)\n# Sorting by value\nD2= dict(sorted(D1.items(), key=itemgetter(1)))\nprint (\"After sorting by key: \", D2)\nprint (type(D2)) Output:\n<class 'dict'>\nThe original dictionary is: {'Amit': 20, 'Sumit': 25, 'John':\n28, 'David': 29, 'Bob': 30}\nAfter sorting by key: {'Amit': 20, 'Sumit': 25, 'John': 28,\n'David': 29, 'Bob': 30}\n<class 'dict'>\nSorting dictionary in reverse order\nThe function uses another argument known as reverse. This may be\nsorted()\nused to determine the order in which the sorting should be conducted. The\nsorting takes place in reverse order (descending) if is passed. And if\nTrue\n(default) is passed, the sorting will be performed in ascending order.\nFalse\nExample 8.15:\n# Initializing a dictionary\nD1= {\"Amit\" : 20, \"Sumit\" : 25, \"John\" : 28, \"David\" : 29,\n\"Bob\" :30}\n# Printing dictionary before sorting\nprint (\"The original dictionary is: \", D1)\n# Sorting by key in reverse order\nD2= dict(sorted(D1.items(),reverse=True, key=lambda x: x[0]))\nprint (\"After Reverse order Sorting by key: \", D2)\n# Sorting by value in reverse order\nD3= dict(sorted(D1.items(),reverse=True, key=lambda x: x[1]))\nprint (\"After Reverse order Sorting by value: \", D3)\nOutput:\nThe original dictionary is: {'Amit': 20, 'Sumit': 25, 'John':\n28, 'David': 29, 'Bob': 30}\nAfter Reverse order Sorting by key: {'Sumit': 25, 'John': 28,\n'David': 29, 'Bob': 30, 'Amit': 20}\nAfter Reverse order Sorting by value: {'Bob': 30, 'David':\n29, 'John': 28, 'Sumit': 25, 'Amit': 20} Iterating over a Dictionary\nThe dictionary itself is not an iterable object, the functions ,\nitems() keys()\nand values return iterable view objects that can be used for dictionary\niteration. To traverse all the key-value pairs, we can use loop. A list of\nfor\ntuples is returned by the function, each tuple being a key and value\nitems()\npair:\nExample 8.16:\n# Creating a dictionary\nDict1= {0 : 'Zero', 1 : 'One', 2 : 'Two', 3 : 'Three', 4\n:'Four', 5: 'Five'}\n# Printing dictionary\nprint (\"The original dictionary is: \", Dict1)\n# Iterating with for loop\nprint ('Iterating with for loop:')\nfor t in Dict1.items():\nprint (t)\nOutput:\nThe original dictionary is: {0: 'Zero', 1: 'One', 2: 'Two',\n3: 'Three', 4: 'Four', 5: 'Five'}\nIterating with for loop:\n(0, 'Zero')\n(1, 'One')\n(2, 'Two')\n(3, 'Three')\n(4, 'Four')\n(5, 'Five')\nWe can also iterate dictionary by storing key and value out of each pair in\ntwo separate variables such as:\nExample 8.17:\n# Creating a dictionary\nDict1= {0 : 'Zero', 1 : 'One', 2 : 'Two', 3 : 'Three', 4\n:'Four', 5: 'Five'} # Printing original dictionary\nprint (\"The original dictionary is: \", Dict1)\n# Iterating with for loop and storing key and value\nseparately\nprint ('Iterating with storing separate values:')\nfor key,value in Dict1.items():\nprint (key,value)\nOutput:\nThe original dictionary is: {0: 'Zero', 1: 'One', 2: 'Two',\n3: 'Three', 4: 'Four', 5: 'Five'}\nIterating with storing separate values:\n0 Zero\n1 One\n2 Two\n3 Three\n4 Four\n5 Five\nAnother way of dictionary iteration is to use the function. Using\nkey() key()\nfunction, the associated value can be obtained as follows:\nExample 8.18:\n# Creating a dictionary\nDict1= {0 : 'Zero', 1 : 'One', 2 : 'Two', 3 : 'Three', 4\n:'Four', 5: 'Five'}\n# Printing original dictionary\nprint (\"The original dictionary is: \", Dict1)\n# Iterating with key() function\nprint ('Iterating using key() function:')\nfor k1 in Dict1.keys():\nprint (k1, Dict1.get(k1)) #or print(k1, Dict1[k1])\nOutput:\nThe original dictionary is: {0: 'Zero', 1: 'One', 2: 'Two',\n3: 'Three', 4: 'Four', 5: 'Five'} Iterating using key() function:\n0 Zero\n1 One\n2 Two\n3 Three\n4 Four\n5 Five\nNested dictionaries\nAs we have seen earlier, that unordered set of elements is known as a\ndictionary. It contains various elements in the key-value pairs embedded in\ncurly brackets:\n{}\nDictionary = {'key1' : 'value1','key2': 'value2'}\nIf a dictionary is stored inside another dictionary is known as a nested\ndictionary. It is like nested records and nested structures used in other\nlanguages. In other words, we can say that it is a collection of dictionaries\ninto one single dictionary. It can be represented as:\nNested_Dict1 = {\n'Dict1': {'key1': 'value1'},\n'Dict2': {'key1': 'value1'},\n'Dict3': {'key1': 'value1'}\n}\nHere, the is a nested dictionary with the dictionary ,\nNested_Dict1 Dict1\n, and . Dictionary , , and are separate\nDict2 Dict3 Dict1 Dict2 Dict3\ndictionaries that contain their key-value pairs. The following code shows the\ncreation and accessing elements from nested dictionaries:\nExample 8.19:\n# Creating a nested dictionary\nEmp = {'D1' : {'name': 'Amit', 'age': '30', 'Post':\n'Manager'},\n'D2' : {'name': 'Joy', 'age': '25', 'Post': 'Clerk'},\n'D3' :{'name': 'David', 'age': '35', 'Post': 'HR'}\n} # Printing complete nested dictionary\nprint (Emp)\n# Printing values of D1 dictionary\nprint ('-----Details of D1 dictionary-------')\nprint (Emp['D1']['name'])\nprint (Emp['D1']['age'])\nprint (Emp['D1']['Post'])\n# Printing values of D2 dictionary\nprint ('-----Details of D2 dictionary-------')\nprint (Emp['D2']['name'])\nprint (Emp['D2']['age'])\nprint (Emp['D2']['Post'])\n# Printing values of D3 dictionary\nprint ('-----Details of D3 dictionary-------')\nprint (Emp['D3']['name'])\nprint (Emp['D3']['age'])\nprint (Emp['D3']['Post'])\nOutput:\n{'D1': {'name': 'Amit', 'age': '30', 'Post': 'Manager'},\n'D2': {'name': 'Joy', 'age': '25', 'Post': 'Clerk'}, 'D3':\n{'name': 'David', 'age': '35', 'Post': 'HR'}}\n-----Details of D1 dictionary-------\nAmit\n30\nManager\n-----Details of D2 dictionary-------\nJoy\n25\nClerk\n-----Details of D3 dictionary-------\nDavid\n35\nHR Adding another dictionary to the existing nested\ndictionary\nThe following code shows an example of adding a subdictionary to the\nexisting nested dictionary. For adding a new dictionary, we have to use\nelement by its key and assign an associated value:\nExample 8.20:\n# Creating a nested dictionary\nEmp = {'D1' : {'name': 'Amit', 'age': '30', 'Post':\n'Manager'},\n'D2' : {'name': 'Joy', 'age': '25', 'Post': 'Clerk'},\n'D3' :{'name': 'David', 'age': '35', 'Post': 'HR'}\n}\n# Printing dictionary elements before adding a sub dictionary\nprint ('Nested Dictionary before adding a sub dictionary:',\nEmp)\n# Adding a sub dictionary\nEmp['D4'] = {'name': 'Bob', 'age': '32', 'Post': 'Manager'}\n# Printing dictionary elements after adding a sub dictionary\nprint ('Nested Dictionary after adding a sub dictionary:',\nEmp)\nOutput:\nNested Dictionary before adding a sub dictionary: {'D1':\n{'name': 'Amit', 'age': '30', 'Post': 'Manager'}, 'D2':\n{'name': 'Joy', 'age': '25', 'Post': 'Clerk'}, 'D3': {'name':\n'David', 'age': '35', 'Post': 'HR'}}\nNested Dictionary after adding a sub dictionary: {'D1':\n{'name': 'Amit', 'age': '30', 'Post': 'Manager'}, 'D2':\n{'name': 'Joy', 'age': '25', 'Post': 'Clerk'}, 'D3': {'name':\n'David', 'age': '35', 'Post': 'HR'}, 'D4': {'name': 'Bob',\n'age': '32', 'Post': 'Manager'}}\nUpdating nested dictionary items Nested dictionary elements can easily be updated. Simply refer to the item by\nthe key and assign a new value. If the key is already in the dictionary, the\nvalue of that key is replaced by a new one. Following example updates the\nvalues of dictionary inside the dictionary:\nD1 Emp\nExample 8.21:\n# Creating a nested dictionary\nEmp = {'D1' : {'name': 'Amit', 'age': '30', 'Post':\n'Manager'},\n'D2' : {'name': 'Joy', 'age': '25', 'Post': 'Clerk'},\n'D3' :{'name': 'David', 'age': '35', 'Post': 'HR'}\n}\n# Printing dictionary elements before update\nprint ('Nested Dictionary before update:', Emp)\n# Updating values of D1\nEmp['D1'] = {'name': 'Bob', 'age': '32', 'Post':'Director'}\n# Printing dictionary elements after update\nprint ('Nested Dictionary after updating values:', Emp)\nOutput:\nNested Dictionary before update: {'D1': {'name': 'Amit',\n'age': '30', 'Post': 'Manager'}, 'D2': {'name': 'Joy', 'age':\n'25', 'Post': 'Clerk'}, 'D3': {'name': 'David', 'age': '35',\n'Post': 'HR'}}\nNested Dictionary after updating values: {'D1': {'name':\n'Bob', 'age': '32', 'Post': 'Director'}, 'D2': {'name':\n'Joy', 'age': '25', 'Post': 'Clerk'}, 'D3': {'name': 'David',\n'age': '35', 'Post': 'HR'}}\nDeleting elements from a nested dictionary\nWe can use operator to delete elements from the nested dictionary. The\ndel\nfollowing example deletes the value of age according to given key ( )\nage\nfrom dictionary:\nD2\nExample 8.22: # Creating a nested dictionary\nEmp = {'D1' : {'name': 'Amit', 'age': '30', 'Post':\n'Manager'},\n'D2' : {'name': 'Joy', 'age': '25', 'Post': 'Clerk'},\n'D3' :{'name': 'David', 'age': '35', 'Post': 'HR'}\n}\n# Printing dictionary elements before delete\nprint ('Nested Dictionary before delete:')\nprint (Emp)\n# Deleting element from D2\ndel Emp['D2']['age']\n# Printing dictionary elements after Delete\nprint ('Nested Dictionary after Deleting values:')\nprint (Emp['D2'])\nOutput:\nNested Dictionary before delete:\n{'D1': {'name': 'Amit', 'age': '30', 'Post': 'Manager'},\n'D2': {'name': 'Joy', 'age': '25', 'Post': 'Clerk'}, 'D3':\n{'name': 'David', 'age': '35', 'Post': 'HR'}}\nNested Dictionary after Deleting values:\n{'name': 'Joy', 'Post': 'Clerk'}\nDeleting a dictionary from nested dictionary\nWe can delete a complete subdictionary from nested dictionary using\ndel\noperator same as elements. Following example deletes sub dictionary\nD2\nfrom the nested dictionary :\nEmp\nExample 8.23:\n# Creating a nested dictionary\nEmp = {'D1' : {'name': 'Amit', 'age': '30', 'Post':\n'Manager'},\n'D2' : {'name': 'Joy', 'age': '25', 'Post': 'Clerk'},\n'D3' :{'name': 'David', 'age': '35', 'Post': 'HR'}\n} # Printing dictionary elements before Deleting a sub\ndictionary\nprint ('Nested Dictionary before delete:')\nprint (Emp)\n# Deleting D2\ndel Emp['D2']\n# Printing dictionary after Deleting a sub dictionary\nprint ('Nested Dictionary after Deleting D2:')\nprint (Emp)\nOutput:\nNested Dictionary before delete:\n{'D1': {'name': 'Amit', 'age': '30', 'Post': 'Manager'},\n'D2': {'name': 'Joy', 'age': '25', 'Post': 'Clerk'}, 'D3':\n{'name': 'David', 'age': '35', 'Post': 'HR'}}\nNested Dictionary after Deleting D2:\n{'D1': {'name': 'Amit', 'age': '30', 'Post': 'Manager'},\n'D3': {'name': 'David', 'age': '35', 'Post': 'HR'}}\nIterating through a nested dictionary\nWe can traverse through each element in a nested dictionary using loops\nfor\nsuch as:\nExample 8.24:\n# Creating a nested dictionary\nEmp = {'D1' : {'name': 'Amit', 'age': '30', 'Post':\n'Manager'},\n'D2' : {'name': 'Joy', 'age': '25', 'Post': 'Clerk'},\n'D3' :{'name': 'David', 'age': '35', 'Post': 'HR'}\n}\n# Iterating dictionary elements using for loop\nfor Dict_id, value in Emp.items():\nprint (\"\\n Dict ID:\", Dict_id)\nfor key in value:\nprint (key + ':', value[key])\nprint (\"------------------\") Output:\nDict ID: D1\nname: Amit\nage: 30\nPost: Manager\n------------------\nDict ID: D2\nname: Joy\nage: 25\nPost: Clerk\n------------------\nDict ID: D3\nname: David\nage: 35\nPost: HR\n------------------\nIn the previous example, the first loop returns all the keys in the nested\ndictionary . It consists of the of each employee. We have used\nEmp Dict ID\nthese IDs to unpack the values of each employee. The second loop goes\nthrough the values of each employee. Then, it returns all the keys , ,\nname age\nof each employee's dictionary. Then the keys of the employees and the\nPost\nassociated values are printed.\nBuilt-in dictionary functions\nThere are various built-in functions and methods available in Python that are\nused to perform various operations on dictionaries. The following are some\nimportant functions:\nlen () function: This function returns the total length of the dictionary\nelements. This would be equal to the number of elements in the\ndictionary. It can be used as follows:\nlen(dict)\nstr() function: This function produces a printable string representation\nof a given dictionary. It has the following syntax:\nstr(dict) type () function: The function returns the type of the passed\ntype()\nparameter. If the passed parameter is a dictionary, then it would return\ntype as a dictionary:\ntype(dict)\nExample 8.25:\n# Built-in dictionary functions\n# Creating a dictionary\nD1= {\"Amit\" : 20, \"Sumit\" : 25, \"John\" : 28, \"David\" : 29,\n\"Bob\" :30}\n# Finding the length of the dictionary\nprint (\"The length of dictionary is : \", len(D1))\n# String representation of dictionary\nD2=str(D1)\nprint (\"The String representation of dictionary is : \", D2)\nprint (type(D2))\nprint ('The type of D1 is:', type(D1))\nOutput:\nThe length of dictionary is : 5\nThe String representation of dictionary is : {'Amit': 20,\n'Sumit': 25, 'John': 28, 'David': 29, 'Bob': 30}\n<class 'str'>\nThe type of D1 is: <class 'dict'>\ncmp () function: The function compares two dictionary elements\ncmp\nbased on key and values. Based on whether the two dictionaries being\ncompared are similar or not, it will return either 1, 0, or -1. This\nfunction takes two dictionaries as arguments for comparison. If and\nD1\nare two dictionaries, then following result will be produced based\nD2\non the comparison. In Python 3.x, this feature is not available.\n, then returns\nif D1 = D2 cmp (D1, D2) 0\n, then returns\nif D1 < D2 cmp (D1, D2) -1\n, then returns\nif D1 > D2 cmp (D1, D2) 1\nExample 8.26: D1 = {'name': 'Amit', 'age': 25};\nD2 = {'name': 'Amit', 'age': 25};\nD3 = {'name': 'Sumit', 'age': 20};\nD4 = {'name': 'Rahul', 'age': 30};\nprint (\"Return Value : %d\" % cmp(D1, D2))\nprint (\"Return Value : %d\" % cmp(D2, D3))\nprint (\"Return Value : %d\" % cmp(D1, D4))\nOutput:\nReturn Value : 0\nReturn Value : 1\nReturn Value : -1\nany () function: This function checks whether any key is or not. It\nTrue\ntakes an iterable parameter such as dictionary. If all keys are or\nFalse\nthe dictionary is empty, it returns . If at least one key is true, it\nFalse\nreturns .\nTrue\nExample 8.27:\n# 0 or False\nD1 = {0: 'It is False'}\nprint (any(D1))\n# 1 or True\nD2 = {0: 'It is False', 1: 'It is True'}\nprint (any(D2))\n# Both keys are false\nD3 = {0: 'It is False', False: 'It is False'}\nprint (any(D3))\n# Empty Dictionary\nD4 = {}\nprint (any(D4))\n# All are True\nD5 = {True: 'It is True', 1: 'It is True'}\nprint (any(D5))\nOutput:\nFalse True\nFalse\nFalse\nTrue\nall () function: When all elements are in the given dictionary, this\nTrue\nfunction returns . If not, will return it. In other words, If all\nTrue False\nkeys are or the dictionary is empty, is returned by\nTrue True all()\nfunction. Else, like all other cases, this returns .\nFalse\nExample 8.28:\n# 0 or False\nD1 = {0: 'It is False'}\nprint (all(D1))\n# 1 or True\nD2 = {0: 'It is False', 1: 'It is True'}\nprint (all(D2))\n# Both keys are false\nD3 = {0: 'It is False', False: 'It is False'}\nprint (all(D3))\n# Empty Dictionary\nD4 = {}\nprint (all(D4))\n# 1 or True\nD5 = {True: 'It is True', 1: 'It is True'}\nprint (all(D5))\nOutput:\nFalse\nFalse\nFalse\nTrue\nTrue\nThe copy()method The method returns a shallow copy of the dictionary. The original\ncopy()\ndictionary does not change it. The following example illustrates the use of\nmethod:\ncopy()\nExample 8.29:\nD1 = {'name': 'Python', 'year': 2021}\nprint ('Original Value of D1:', D1)\n# creating a copy of D1\nD2 = D1.copy()\nprint ('Copied Version :', D2)\nOutput:\nOriginal Value of D1: {'name': 'Python', 'year': 2021}\nCopied Version: {'name': 'Python', 'year': 2021}\nFormatting dictionaries\nWe can interpolate strings using dictionaries. They have a syntax in which,\nbetween the operator and the conversion character, we need to include the\n%\nkey in the parentheses. For instance, if we have an stored in a\nint salary\nkey and we want to format it as then we can put\nxxxx.xx %(salary).2fat\nin the position we want it to be shown.\nExample 8.30:\n# Creating a dictionary\nD1= {'name': 'Amit', 'salary': 30000, 'Post': 'Manager'}\n# Printing dictionary\nprint (D1)\nprint ('--------------')\nprint ('----------Formatted dictionary-----------')\n# Formatted printing\nprint (\"My Name is: %(name)s\" %D1)\nprint (\"My Salary is: %(salary).2f and POST is: %(Post)s \"\n%D1)\nOutput: {'name': 'Amit', 'salary': 30000, 'Post': 'Manager'}\n--------------\n----------Formatted dictionary-----------\nMy Name is: Amit\nMy Salary is: 30000.00 and POST is: Manager\nConclusion\nIn this chapter, we discussed the concepts and various functionalities of\ndictionaries. We also discussed how dictionaries could be created in\ndifferent ways. Various examples and Python code are given for dictionary\nimplementations. Based on these examples, you can write your own code to\nuse dictionaries. In the next chapter, we will discuss the file handling\nconcepts in Python.\nPoints to remember\nDictionaries are an unordered and changeable collection of data values\nthat hold key-value pairs.\nIn Python, dictionaries are written inside curly braces .\n{}\nDictionaries operations are very similar to lists and tuples.\nWe can shrink or grow a nested dictionary as need.\nMultiple choice questions\n1. Which of the following statements create a dictionary in Python?\na. D = {}\nb. D = {'David':50, 'Alex':35}\nc. D = {35: 'David', 50: 'Alex'}\nd. All of the mentioned\n2. Which one of the following is correct with respect to dictionaries?\na. In Python, a dictionary can have two same keys with different\nvalues. b. In Python, a dictionary can have two same values with different\nkeys\nc. In Python, a dictionary can have two same keys or same values but\ncannot have two same key-value pair\nd. In Python, a dictionary can neither have two same keys nor two\nsame values.\n3. If we write the below code, which of the following will give an\nerror?\nSuppose D1={\"A\":1,\"B\":2,\"C\":3, \"D\":4, \u201cE\":5}\na. print(len(D1))\nb. print(D1.get(\"B\"))\nc. D1[\"A\"]=5\nd. None of these\n4. Which one of the following is correct to empty a dictionary?\nStudent = {\n\"name\": \"Amit\",\n\"age\": 30,\n\"percent\": 85\n}\na. del Student\nb. del Student[0:2]\nc. Student.clear()\nd. empty Student\n5. What will be the output of the following Python code?\na={1:\"A\",2:\"B\",3:\"C\"}\nb=a.copy()\nb[2]=\"D\"\nprint(a)\na. Error, copy () method does not exist for dictionaries\nb. {1: 'A', 2: 'B', 3: 'C'} c. {1: 'A', 2: 'D', 3: 'C'}\nd. \"None\" is printed\nAnswers\n1. d\n2. b\n3. d\n4. c\n5. b\nQuestions\n1. What is the difference between a list, tuple, and a dictionary?\n2. What are the features of python dictionaries? Discuss.\n3. What is meant by key-value pairs in a dictionary?\n4. How to create a dictionary in Python? Give an example.\n5. Discuss built-in functions supported by dictionaries?\n6. How does operation work on dictionaries? Give an example.\ndel\n7. Explain nested dictionary with suitable example.\n8. Write a Python program to sort dictionary elements in reverse order.\n9. Write a program to input students' names and phone numbers and store\nthem in the dictionary as the key-value pair. Perform the following\noperations on the dictionary:\na. Display name and phone number of all the students.\nb. Add a new key-value pair in this dictionary and display the\nmodified dictionary.\nc. Delete a particular student from the dictionary.\nd. Modify the phone number of an existing student.\ne. Check if a student is present in the dictionary or not\nf. Display the dictionary in descending order of names CHAPTER 9\nFile Handling\nhen data must be saved permanently in a file, file handling is essential.\nW\nA file is a named location on the disc where relevant data is stored.\nAfter the program has been terminated, we can access the data that has been\nsaved. The idea of file handling has been extended to various other\nlanguages, but the implementation is either complicated or lengthy. However,\nlike other Python concepts, this concept is simple and straightforward. In this\nchapter, you will see various concepts and functions related to file handling.\nBesides, we have demonstrated various file operations with the help of\nexamples and codes.\nStructure\nIn this chapter, we will cover the following topics:\nThe need for file handling\nTypes of files\nOpening and closing files\nReading and writing in files\nVarious methods of file handling\nObjective\nThe objective of this chapter is to introduce the concept of file handling in\nPython. After completing this chapter, you should be able to perform various\nfile-related operations. Also, you will be able to write Python codes to\nmanage files on a disk. You will also understand the uses of different file-\nrelated methods in Python.\nFile handing A file is a collection of bytes used to store information. This information is\norganized in a particular format, ranging from a simple text file to a complex\nprogram executable. Finally, these byte files are converted into binary 1 and\n0 for faster computer processing.\nPython, like many other programming languages, supports file handling and\nallows its users to read and write files and perform a variety of other file-\nrelated tasks. Python handles files differently depending on whether they are\ntext or binary, which is crucial. Each line of code consists of a series of\ncharacters that together form a text file. A unique character called as the EOL\nor End of Line character, such as the comma, or a newline character, is used\nto end each line of a file. It signals to the interpreter that the current line has\nended and that a new one has started. On most modern file systems, files are\ndivided into three parts:\nHeader: Details about the file's contents (file name, size, type, and so\non).\nData: The file's contents as written by the author or writer.\nEnd of file: A special character that denotes the file's termination.\nNeed of file handling\nIn programming, we need a particular piece of input data to be generated\nmultiple times. It is not always sufficient to simply show data on the console.\nThe data to be displayed can be huge. Only a limited amount of data can be\ndisplayed on the console; additionally, since memory is volatile, it is\nchallenging to recover programmatically generated data repeatedly. If we\nneed to store something, we can do so on the local file system, which is\nvolatile and accessible at any time. This necessitates the use of Python's file\nhandling functionality. File handling in Python allows us to use our Python\nprogram to create, edit, read, and delete files on the local file system. On a\nfile, you can perform the following operations:\nCreating a new file\nOpening previously saved file\nClosing an opened file\nReading from a file Writing into a file\nFile deletion\nFile path\nA file path is required when accessing a file on an operating system. A file\npath is a string that defines a file's location. It is divided into three major\nsegments:\nDirectory path: The location of a file or folder on a file system,\nseparated by a forward slash ( ) in Linux or Unix or a backslash ( ) in\n\/ \\\nWindows.\nFile name: The file's real name.\nExtension: It defines the file type.\nThe following figure shows a file path example. Assume you needed to\naccess the file, and your current location was the same as the path.\nabc.jpeg\nTo get to the file, you must first navigate to the path folder, then to the\ndir1\ndirectory, and finally to the file. is the folder path.\nabc.jpeg Path\/dir1\/\nis the name of the file. is the file extension. So\nAbc .jpeg\nis the complete path:\npath\/dir1\/abc.jpeg\nFigure 9.1: Example of file path Opening a file\nTo perform reading and writing operations on a file, it needs to be opened\nfirst. To open a file in Python, the user needs to create a file object\nassociated with a physical file. In addition, the function is used to\nopen()\nopen a file in Python. The function in Python takes two arguments:\nopen()\nthe file name and the access mode. The function returns a file object, which\ncan be used for reading, writing, and other operations. The following syntax\nis used to open a file in Python.\nSyntax:\nFile_object_Name = open(<file_name>, <access_mode>,\n<buffering>)\nVarious modes, such as read, write, and append are available for accessing\nthe files. The access mode to open a file is defined as follows:\nr The file is opened in read-only mode. The file pointer is present at the start. If no\naccess mode is defined, the file is opened in this mode by default.\nrb It converts the binary file to read-only mode. The file pointer is present at the\nstart of the file.\nr+ It opens the file for both reading and writing. The file pointer is present at the\nstart of the file.\nrb+ It opens the file in binary format for reading and writing. The file pointer is\npresent at the start of the file.\nw It only allows you to write into the file. If a file with the same name already\nexists, it is overwritten; otherwise, it is created. The file pointer is present at the\nstart of the file.\nwb It opens the file so that it can only be written in binary format. If the file already\nexists, it is overwritten; otherwise, it generates a new one. The file pointer is\npresent at the start of the file.\nw+ It opens the file for both writing and reading. It differs from r+ in that it\noverwrites the previous file if one exists, while r+ leaves the previously written\nfile alone. If no such file exists, it creates one. The file pointer is present at the\nstart of the file.\nwb+ It opens the file in binary format for both writing and reading. The file pointer is\npresent at the start of the file.\nA The file is opened in append mode. If there is one, the file pointer is at the end of the previously written file. If no file with the same name already exists, it creates\na new one.\nab It opens the file in binary format in append mode. The pointer is at the end of the\nfile that was previously written. If no file of the same name remains, it produces\na new binary file.\na+ It opens a file for both appending and reading. If a file exists, the file pointer\nstays at the end of it. If no file with the same name already exists, it produces a\nnew one.\nab+ It opens a binary file for appending and reading. The file pointer is already at the\nfile's end.\nTable 9.1: File access modes\nExample 9.1:\nfileobj = open(\"file1.txt\",\"r\") #Opening file1.txt in read\nmode\nif filobj:\nprint (\"File opened.\")\nOutput:\nFile opened.\nWe passed file name ( ) as the first argument and opened the file in\nfile1.txt\nread mode with as the second argument in the above example. The\nr\nholds the file object, and if the file is successfully opened, the print\nfileobj\nstatement is executed.\nWe have stored in the same directory.\nfile1.txt\nClosing a file\nWe can perform any operation on the file using the file system that is\ncurrently open in Python; thus, it is best to practice closing the file once all\nprocesses have been completed. After we've completed all of the files'\noperations, we'll use the method to close it. When the\nclose() close()\nmethod on a file object is called, any unwritten data is deleted. Syntax:\nFile_Object_Name.close()\nExample 9.2:\nfileobj = open(\"file1.txt\",\"r\") #Opening file1.txt in read\nmode\nif fileobj:\nprint (\"File opened.\")\nfileobj.close() # Closing file1.txt\nOutput:\nFile opened.\nWriting into a file\nA string is written to a file using the method. To write text to a file,\nwrite()\nwe must first open it with the open method and one of the access modes\nmentioned below:\n: If the file already exists, it will be overwritten. The file pointer is\nw\nlocated at the start of the file.\n: The file will be appended to the current one. The file pointer is at the\na\nfile's end. If no such file exists, it creates one.\nExample 9.3:\n# opening f1.txt in write mode. If this file is not present,\na new file will be created.\nObj1= open (\"f1.txt\", \"w\")\n# writing contents in this file\nObj1.write(\"Python programming \\n\")\nObj1.write(\"It is a programming language \\n\")\nObj1.write(\"It supports file handling \\n\")\n# closing this file\nObj1.close() Output:\nFile Name: f1.txt\nPython programming\nIt is a programming language\nIt supports file handling\nScreenshot of f1.txt\nFigure 9.2: Screenshot of f1.txt\nExample 9.4:\n# opening f1.txt in Append mode. If this file is not present,\na new file will be created.\nObj1= open (\"f1.txt\", \"a\")\n# Appending contents in this file\nObj1.write(\"Python is easy to learn \\n\")\nObj1.write(\u201cIt is an object-oriented programming language\u201d)\n# closing this file\nObj1.close()\nOutput:\nFile Name: f1.txt\nPython programming\nIt is a programming language\nIt supports file handling\nPython is easy to learn\nIt is an object-oriented programming language\nScreenshot of f1.txt Figure 9.3: Screenshot of f1.txt\nwritelines() method\nThe method is a Python built-in method for writing a list of\nwritelines()\nstrings or list items to a file.\nSyntax:\nfileobject.writelines(list_of_items)\nExample 9.5:\n# file creation\nfobj = open(\"f2.txt\", \"w\")\n# writing multiple strings\nfobj.writelines([\"Python programming \",\"Programming book\n\\n\"])\n# list\nlist1 = [\"Krishna \",\"Brijesh \",\"Arvind \",\"Joy \"]\n# writing list\nfobj.writelines(list1)\n# closing the file\nfobj.close()\n# again opening file in read mode\nfobj = open(\"f2.txt\", \"r\")\nprint (fobj.read())\n# closing the file\nfobj.close()\nOutput: Python programming book\nKrishna Brijesh Arvind Joy\nWriting numbers to a file\nPython reads files as strings by default, and the function expects\nwrite()\nonly to write strings. If we want to write numbers to a file, we'll need to use\nthe function to cast them as strings.\nstr()\nExample 9.6:\nn= range(0, 25)\nfn = \"fundemo.txt\"\n# open file to write\nobj= open(fn, 'w')\nfor i in n:\nobj.write(str(i) + \" \")\nobj.close() #Close the file\nOutput:\nFigure 9.4: fundemo output\nReading a file\nIn Python, there are several ways to read a text file. The method can\nread()\nbe used to retrieve a string that includes all the characters in a file.\nSyntax:\nFile_Object.read()\nBefore reading a file, it is required to open that file in ' ' (read) mode.\nr\nExample 9.7: The contents of the file are shown as follows:\ntest.txt Figure 9.5: test.txt file\n# opening test.txt file in read mode.\nObj1= open (\"test.txt\", \"r\")\n# reading whole content\nData=Obj1.read()\nprint (Data)\n# closing this file\nObj1.close()\nOutput:\nPython programming book.\nIt is a programming language.\nIt supports file handling.\nIt is easy to learn.\nUsing a certain number of characters is another way to read a text. The\ninterpreter will, for example, read the first twenty characters of stored data\nand return it as a string using the following code:\nExample 9.8:\n# opening test.txt file in read mode.\nObj1= open (\"test.txt\", \"r\")\n# reading whole content\nData=Obj1.read(20)\nprint (Data)\n# closing this file\nObj1.close()\nOutput:\nPython programming b readline() method\nThe function in Python makes it easy to read a file line by line.\nreadline()\nThe method reads the file's lines starting at the beginning, so if\nreadline()\nwe call it three times, we'll get the first three lines of the file. This method\nwill return a string of characters containing a single line of data from the file\neach time it is called:\nObj1= open (\"test.txt\", \"r\")\nprint Obj1.readline()\nThis will return the file's first line, as follows:\nPython programming book.\nIf we just wanted to return the file's fourth line, we'd do it like this:\nObj1= open (\"test.txt\", \"r\")\nprint Obj1.readline(4)\nIt is easy to learn.\nExample 9.9:\n# opening test.txt file in read mode.\nObj1= open (\"test.txt\", \"r\")\n# reading first line\nLine1=Obj1.readline()\n# reading second line\nLine2=Obj1.readline()\n# printing lines\nprint (Line1)\nprint (Line2)\n# closing this file\nObj1.close()\nOutput:\nPython programming book.\nIt is a programming language. readlines() method\nIf we wanted to get back every line in the file, separated properly. The same\nfunction will be used but in a different format. The\nmethod is used to accomplish this. It returns a\nFileObject.readlines()\nlist of lines up to the end of the file (EOF).\nExample 9.10:\n# opening test.txt file in read mode.\nObj1= open (\"test.txt\", \"r\")\n# reading whole content\nData=Obj1.readlines()\nprint (Data)\n# closing this file\nObj1.close()\nOutput:\n['Python programming book.', 'It is a programming language.',\n'It supports file handling.', 'It is easy to learn.']\nReading file through a loop\nThe loop-over method can be used to read all the lines from a file in a more\nmemory accessible and fast manner. The corresponding code is simple and\neasy to read, which is a benefit of using this method.\nExample 9.11:\n# opening test.txt file in read mode.\nObj1= open (\"test.txt\", \"r\")\n# reading content through loop\nfor x in Obj1:\nprint (x)\n# closing this file\nObj1.close()\nOutput: Python programming book.\nIt is a programming language.\nIt supports file handling.\nIt is easy to learn.\nReading numbers from a file\nTo read numbers from a file, method is used. Firstly, we have to\nread()\nopen a file in reading mode then; the numbers can be easily read. The\nfollowing example reads stored numbers from the file.\nfundemo.txt\nExample 9.12:\nfn = \"fundemo.txt\"\n# open file to write\nobj= open(fn, 'r')\ndata=obj.read()\nprint (data)\nobj.close() #Close the file\nOutput:\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23\n24\nCreating a new file\nWith the help of the function, you can create a new file by using one\nopen()\nof the following access modes.\n: it creates a new file with the name you specify. It throws an error if a\nx\nfile with the same name already exists.\n: If no such file exists, it creates a new one with the specified name. If\na\nthe file with the given name already exists, it appends the content to it.\n: If no such file exists, it creates a new one with the specified name. If\nw\na file exists, it overwrites.\nExample 9.13: #creating a new empty file\nfileobj= open(\"myfile1.txt\", \"x\")\n#close this file\nfileobj.close()\nThe preceding code will create a new file in the current working directory. If\nyou want your file to be created at an absolute path on the disc, you can also\ngive it a complete path.\nExample 9.14: Creating a new file with an existing name\n#creating a new file, but myfile1.txt is already exist\nfileobj= open(\"myfile1.txt\", \"x\")\nOutput:\nTraceback (most recent call last):\nFile \"main.py\", line 2, in <module>\nfileobj= open(\"myfile1.txt\", \"x\")\nFileExistsError: [Errno 17] File exists: 'myfile1.txt'\nIn the previous example, we tried to create a new file .\nmyfile1.txt\nHowever, this file already exists in the same directory. We get\n.\nFileExistsError\nThe file object attributes\nYou can get different file-related details once a file is opened and you have\none file object. The following is a list of all file object attributes:\n: It is a value that indicates the current state of the file\nclosed bool\nobject.\n: The encoding details of the file.\nencoding\n: It returns the file mode of the file in which the file is opened.\nmode\n: It returns the file name.\nname\nExample 9.15:\n# Opening a file in read mode\nFileobj = open(\"fundemo.txt\", \"r\") print (\"File Name:\", Fileobj.name)\nprint (\"File closed or not : \", Fileobj.closed)\nprint (\"File Mode : \", Fileobj.mode)\nprint (\"File Encoding\", Fileobj.encoding)\nOutput:\nFile Name: fundemo.txt\nFile closed or not : False\nFile Mode : r\nFile Encoding UTF-8\nFile positions\nWhen we use Python to open a file for reading, we get a file handle those\npoints to the file's beginning. The pointer always points to the end of the\nreading as we read from the file, and the next read will begin there. The\nfollowing methods are used to get file position and change position,\nrespectively:\nThe method returns the current file position; in other words, the\ntell()\nnext read or write will occur at that many bytes from the file's\nbeginning.\nThe method is used to adjust the file's current\nseek(offset[, from])\nlocation. The number of bytes to be moved is defined by the offset\nstatement. The statement determines the starting point for the bytes\nfrom\nto be transferred from.\nIf from is set to 0 in the function, the file's beginning will be used as\nseek()\nthe reference position, 1 the current position will be used as the reference\nposition, and 2 the file's end will be used as reference position.\nExample 9.16:\n# Creating a file`\nObj1= open (\"testfile.txt\", \"w\")\n# writing contents in this file\nObj1.write(\"Python programming \\n\")\nObj1.write(\"It is a programming language \\n\") Obj1.write(\"It supports file handling \\n\")\nObj1.write(\"I like Python.\")\n# closing this file\nObj1.close()\n# Opening a file in read mode\nFileobj = open(\"testfile.txt\", \"r\")\n#initially the filepointer is at 0\nprint (\"Pointer Position: \",Fileobj.tell()) #0\n#reading the content of the file\nLine1= Fileobj.readline()\nprint (Line1)\nprint (\"Pointer Position:\", Fileobj.tell()) # 20\nLine2= Fileobj.readline()\nprint (Line2)\nprint (\"Pointer Position:\", Fileobj.tell()) # 50\nLine3= Fileobj.readline()\nprint (Line3)\nprint (\"Pointer Position:\", Fileobj.tell()) # 77\nLine4= Fileobj.readline()\nprint (Line4)\nprint (\"Pointer Position:\", Fileobj.tell()) # 91\nOutput:\nPointer Position: 0\nPython programming\nPointer Position: 20\nIt is a programming language\nPointer Position: 50\nIt supports file handling\nPointer Position: 77\nI like Python.\nPointer Position: 91 Example 9.17:\n# Creating a file`\nObj1= open (\"testfile1.txt\", \"w\")\n# writing contents in this file\nObj1.write(\"Python programming \\n\")\nObj1.write(\"It is a programming language \\n\")\nObj1.write(\"It supports file handling \\n\")\nObj1.write(\"I like Python.\")\n# closing this file\nObj1.close()\n# Opening a file in read mode\nFileobj = open(\"testfile1.txt\", \"r\")\n#initially the filepointer is at 0\nprint (\"Pointer Position: \",Fileobj.tell())\n#reading the content of the file\nLine1= Fileobj.readline()\nprint (Line1)\nprint (\"Pointer Position:\", Fileobj.tell())\nLine2= Fileobj.readline()\nprint (Line2)\n#changing the file pointer location to 10.\nFileobj.seek(10);\nprint (\"Pointer Position:\", Fileobj.tell())\nLine3= Fileobj.readline()\nprint (Line3)\nprint (\"Pointer Position:\", Fileobj.tell())\nLine4= Fileobj.readline()\nprint (Line4)\nprint (\"Pointer Position:\", Fileobj.tell())\n#changing the file pointer location to 10.\nFileobj.seek(20);\nprint (\"Pointer Position:\", Fileobj.tell()) Output:\nPointer Position: 0\nPython programming\nPointer Position: 20\nIt is a programming language\nPointer Position: 10\ngramming\nPointer Position: 20\nIt is a programming language\nPointer Position: 50\nPointer Position: 20\nPython directory operations\nA directory is a structure that holds all of the documents, files, and\ndirectories associated with it. In Python, the OS module offers functions for\ncommunicating with the operating system. This module provides access to\nvarious operating-system-specific functions for manipulating processes,\nfiles, file descriptors, folders, and other low-level OS features.\nCurrent working directory\nreturns the current working directory's path. This is the location\ngetcwd()\nwhere the operating system converts a relative file name to an absolute file\nname.\nExample 9.18 :\n#importing os module\nimport os\n#print the current working directory\nprint (os.getcwd())\nOutput:\n\/home\/Krishna\nList of directories You can get a directory list from a specific location. You must use the\nfunction to accomplish this. The function will return a\nlistdir(location)\nlist of strings containing the names of the directories in the specified location\nif you pass it in the location. The simple function will return the\nlistdir()\ncontents of the current directory.\nExample 9.19:\nimport os\ndata = os.listdir() #list of contents from current directory\nprint (data)\nprint (os.listdir('\/usr')) # list of contents from usr\ndirectory\nOutput:\n['main.py']\n['games', 'local', 'include', 'share', 'lib', 'bin', 'src',\n'sbin']\nCreating a directory\nThe method is used to create a directory. Let's make a new\nos.mkdir()\ndirectory called \" \". The method will then print a list of\nmydir os.listdir()\ndirectories along the path.\nExample 9.20:\nimport os\n#create directory\nos.mkdir(\"mydir\")\nprint (os.listdir()) # list of contents\nOutput:\n['mydir', 'main.py']\nChange directory To change the directory, we must first import the module and then use the\nos\nmethod to change our program's base path.\nos.chdir()\nExample 9.21:\nimport os\n#change directory\nos.chdir('\/Users\/Krishna\/')\n#print current working directory\nprint (os.getcwd())\nOutput:\n\/Users\/Krishna\nRenaming a directory\nThe method allows you to rename a folder from one name to\nos.rename()\nanother.\nExample 9.22:\nimport os\n#rename directory\nos.mkdir('mydir1')\nprint (os.listdir(os.getcwd()))\n#rename\nos.rename(\"mydir1\",\"mydir2\")\nprint (os.listdir(os.getcwd()))\nOutput:\n['mydir1', 'main.py']\n['mydir2', 'main.py']\nDelete a directory\nThe function is used to remove an already empty directory. The\nrmdir()\ndirectory will not be removed if it is not empty. Example 9.23:\nimport os\nos.mkdir('mydir1')\nprint ('Before deletion:',os.listdir(os.getcwd()))\n#delete directory\nos.rmdir(\"mydir1\")\nprint ('After deletion:',os.listdir(os.getcwd()))\nOutput:\nBefore deletion: ['mydir1', 'main.py']\nAfter deletion: ['main.py']\nRenaming and deleting file\nThe module in Python provides methods for performing file-processing\nos\noperations, including renaming and removing files. To use this module, you\nmust first import it before calling any related functions. The renaming and\ndeletion of files are the same as the directories. The function\nos.rename()\nis used to rename a file with a new name and function can\nos.remove()\ndelete a specific file.\nSyntax for rename:\nos.rename(Previous_file_name, new_file_name)\nSyntax for delete:\nos.remove(file_name)\nExample 9.24:\n# File rename example\nimport os\nprint ('Before rename:',os.listdir(os.getcwd()))\n# Rename a file from myfile1.txt to newfile1.txt\nos.rename(\"myfile1.txt\", \"newfile1.txt\")\nprint ('After rename:',os.listdir(os.getcwd())) Output:\nBefore rename: ['f1.txt', 'myfile1.txt', 'main.py',\n'myfile2.txt']\nAfter rename: ['f1.txt', 'newfile1.txt', 'main.py',\n'myfile2.txt']\nExample 9.25:\n#file delete example\nimport os\nprint ('Before Delete:', os.listdir(os.getcwd()))\n# Delete a file newfile1.txt\nos.remove(\"newfile1.txt\")\nprint ('After Delete:', os.listdir(os.getcwd()))\nOutput:\nBefore Delete: ['f1.txt', 'myfile1.txt', 'newfile1.txt',\n'main.py', 'myfile2.txt']\nAfter Delete: ['f1.txt', 'myfile1.txt', 'main.py',\n'myfile2.txt']\nBinary files\nIn Python, there are two kinds of files: text and binary. Binary files make up\nthe majority of the files we see on our computers. Working with binary files\nis easy with Python's tools. Strings of form bytes are used in binary files. It\nmeans that you'll get a byte's object back when reading binary data from a\nfile. We must use the same modes (as before) with the letter at the end\nb\nwhen working with binary files. Such that Python recognizes that we're\ndealing with binary files. The mode is used to write the binary file.\nwb\nSimilarly, and modes are used to read and append data in binary files,\nrb ab\nrespectively.\nExample 9.26: Writing into binary files\ndata = [12,34,100,240,255]\n#printing data print (data)\n#converts to bytes\nbdata = bytes(data)\nprint (bdata)\nfileobj = open(\"myfile1.bin\", \"wb\")\nfileobj.write(bdata)\nfileobj.close()\nOutput:\n[12, 34, 100, 240, 255]\nb'\\x0c\"d\\xf0\\xff'\nExample 9.27: Reading from binary file\n# Open binary file\nfobj = open('myfile1.bin', 'rb')\n# read string from binary file\nresult = fobj.read()\nprint (result)\nOutput:\nb'\\x0c\"d\\xf0\\xff'\nConclusion\nIn this chapter, we discussed the file handling concepts in Python. We also\ndiscussed various file modes in which it can be opened for processing.\nMultiple examples and Python code are given for file processing, such as\nread, write, delete, rename, etc. Based on these examples, you can write your\ncode for file processing. In the next chapter, we will discuss the exception\nhandling concept in Python with various examples.\nPoints to remember\nPrimary modes of files are read, write, and append.\nThe module can be used to process various files and directories.\nos Binary files can be processed, including at the end of file modes.\nb\nThe method returns all the data as one string.\nread()\nMultiple choice questions\n1. To read three characters from a file object Obj, we use\n____________\na. Obj.read(3)\nb. Obj.read()\nc. Obj.readline()\nd. Obj.readlines()\n2. To read the next line of the file from a file object Obj, we use\n____________\na. Obj.read(3)\nb. Obj.read()\nc. Obj.readline()\nd. Obj.readlines()\n3. Assuming file1.txt contains:\nThis is line 1\nThis is line 2\nThis is line 3\nThis is line 4\nCode snippet:\nf1= open(\"file1.txt\",'a')\nprint (f1.read())\nf1.close()\nWhat is the output of the program snippet?\na. This is line 1\nb. This is line 4\nc. Entire file contents d. None, IOError\n4. Which one of the following is not an attribute of the file?\na. closed\nb. encoding\nc. rename\nd. mode\n5. What is the use of the tell() method in Python?\na. tells you the current position within the file\nb. tells you the end position within the file\nc. tells you the file is opened or not\nd. none of the mentioned\nAnswers\n1. a\n2. c\n3. d\n4. c\n5. a\nQuestions\n1. What do you mean by file handling?\n2. Explain the function with its syntax in detail.\nopen()\n3. List out the basic file modes available in Python.\n4. Discuss various file object attributes.\n5. What are the various directory operations available in Python? Explain.\n6. What is a binary file? Write code to read data from a binary file.\n7. What are the uses of and functions?\ntell() seek()\n8. How can a file be deleted using a Python code? Discuss. 9. Write a function in Python to read the content from a text file \" \"\nf1.txt\nline by line and display it on the screen.\n10. Write a Python program to count the number of lines in a text file. CHAPTER 10\nException Handling, Modules, and\nPackages\nxception handling enhances your code and helps you avoid potential\nE\nerrors that would cause your application to fail unexpectedly. In this\nchapter, we will look at how Python handles exceptions. This chapter\nfocuses on Python classes that are highly well-built, as well as the\ntry-\nclause. Besides, we have demonstrated various error handling\nfinally\ncodes with the help of examples. Modules and packages are discussed in this\nchapter, as well.\nStructure\nIn this chapter, we will cover the following topics:\nThe basic concept of errors and exceptions\nPython exception and its hierarchy\nException handling\nBuilt-in and user-defined exceptions\nModules\nPackages\nObjective\nThe objective of this chapter is to introduce exception handling in Python.\nAfter completing this chapter, you should be able to handle exceptions using\nbuilt-in Python functions. Also, you will be able to write Python codes for\nhandling exceptions. You will also be able to understand the uses of modules\nand packages in Python. Errors and exceptions\nError handling improves the robustness of your code, protecting it from\npossible errors that might cause your application to exit unexpectedly. Errors\ncannot be dealt with, but Python exceptions can. An error can be a syntax\nerror, but several different types of exceptions can occur during execution,\nwhich aren't always inoperable. An Error may indicate crucial issues that a\nreasonable application should avoid, while an Exception may indicate\ncircumstances that an appropriate application should try to capture. Errors\nare a type of uncontrolled exception that is unrecoverable, such as an\n, which a programmer should avoid handling. Consider\nOutOfMemoryError\nwhat would happen if you wrote code deployed in production but still\nterminated due to an exception. The client would be unhappy, so it's best to\ntreat the exception ahead of time and prevent the uncertainty. Syntax errors\nand exceptions are two distinct types of errors.\nSyntax error\nSyntax errors, often known as parsing errors, occur when the parser detects a\nsyntactic error in your code. To better understand it, let's look at an example.\nExample 10.1:\n#Syntax error example\nx = 8\ny = 10\nz = x y\nOutput:\nFile \"<string>\", line 3\nz = x y\n^\nSyntaxError: invalid syntax\nWhen the parser encounters an error while executing the code, the arrow\nabove (in output) indicates it. The failure is caused by the token preceding\nthe arrow. Python will do much of the work for you in resolving such basic errors since it will print the file name and line number where the error\noccurred.\nException\nAn exception is an error that occurs when a program is being executed. Non-\nprogrammers understand exceptions as instances that do not follow a general\nrule. Even if a sentence or expression's syntax is correct, it can still produce\nan error when executed. Exceptions in Python are errors that are observed\nduring execution but are not always serious. When a Python code throws an\nerror, an exception object is formed. The program will be forced to end\nsuddenly if the code does not explicitly handle the exception. Exceptions are\nusually ignored by programs, resulting in error messages like this:\nExample 10.2:\n# Example of type error\nname= 'amit'\nage=30\nage+name\nOutput:\nTraceback (most recent call last):\nFile \"<string>\", line 3, in <module>\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\nExample 10.3:\n#Example of division by zero exception\n100 * (10\/0)\nOutput:\nTraceback (most recent call last):\nFile \"<string>\", line 1, in <module>\nZeroDivisionError: division by zero\n> Python exceptions come in various forms, and the form is written alongside\nthe message: in the above two cases, the types are and\nTypeError\n. The name of the Python built-in exception is printed in\nZeroDivisionError\nboth error strings as the exception type. Based on the type of exception, the\nremaining portion of the error line contains information about what caused\nthe error.\nHandling Exceptions\nPython's exception handling is close to Java's. A try block contains the code,\nwhich can throw an exception. The clauses catch exceptions in Java,\ncatch\nbut statements added by the keyword exceptions in Python. It\nexcept catch\nis possible to make customized exceptions. It's possible to force an exception\nto occur using the statement. If you have some suspicious code that\nraise\nmight throw an exception, you can protect your program by putting it in a\nt block. Have an except declaration after the block, followed by a\nry: try:\nblock of code that as elegantly as possible solves the problem. The syntax for\nblocks is as follows.\ntry\u2026.except\u2026else\nSyntax:\ntry:\n# Our code\nexcept Exception_1:\n#If Exception_1 occurs, this block will be executed.\nexcept Exception_2:\n# If Exception_2 occurs, this block will be executed.\nelse:\n# If No exception occurs, this block will be executed.\nThe main components of exception handling are as follows:\n: It will execute the code block in which you expect an error.\ntry\n: It catches the exception, which occurs in a block.\nexcept try\n: This block of code will be executed if there are no exceptions.\nelse\n: This block of code will always be executed, regardless of\nfinally\nwhether there is an exception.\nThere can be several except statements in a single, block.\ntry A generic except clause may also be used to handle any exception.\nYou may add an clause after the clause(s). This else block\nelse except\nruns when no exception occurs in the block.\ntry\nExample 10.4:\n#Example of ValueError exception\ntry:\nmy_var = input (\"Enter a Number: \")\nmy_var = int(my_var)\nprint(my_var)\nexcept ValueError:\nprint(\"Exception occurs\")\nelse:\nprint('No exception occurred')\nOutput:\n----------------------Run program with following input-------\n--------------------\nEnter a Number: 5\n5\nNo exception occurred\n----------------------Run program with following input-------\n--------------------\nEnter a Number: amit\nException occurs\nExample 10.5:\n#Example of ZeroDivisionError exception\ntry:\nMy_var1=int (input (\"Enter Value for 1st variable:\"))\nMy_var2=int (input (\"Enter Value for 2nd variable:\"))\nprint (My_var1\/My_var2) # It will run if My_var2 is not\nzero\nexcept ZeroDivisionError:\n# It will execute if My_var2=0\nPrint (\"Zero Division Exception Occurred\") else:\nprint ('No exception occurred')\nOutput:\n----------------------Run program with following input-------\n--------------------\nEnter value for 1st variable: 12\nEnter value for 2nd variable: 2\n6.0\nNo exception occurred\n----------------------Run program with following input-------\n--------------------\nEnter value for 1st variable:123\nEnter value for 2nd variable: 0\nZero Division Exception Occurred\nExample 10.6:\n#Example of LookupError exception\ntry:\nx = ['a', 'b', 'c', 'd']\nprint (x[5])\nexcept LookupError:\nprint (\"Index Error Exception Occurred\")\nelse:\nprint ('No exception occurred')\nOutput:\nIndex Error Exception Occurred\nSingle except block\nA single statement can be used with a block. This block can\nexcept try\ncatch all types of exceptions. In this type of exception handling, the\nprogrammer cannot find the actual reason for the problems.\nExample 10.7: try:\nvar1 = int (input(\"Input 1st number:\"))\nvar2 = int (input(\"Input 2nd number:\"))\nvar3 = var1\/var2\nprint (\"var1 divided var2 =\", var3)\nexcept:\nprint (\"Any Exception.\")\nelse:\nprint (\"Else block.\")\nOutput:\n----------------------Run program with following input-------\n--------------------\nInput 1st number:5\nInput 2nd number:2\nx divided y = 2.5\nElse block.\n----------------------Run program with following input-------\n--------------------\nInput 1st number:5\nInput 2nd number:0\nAny Exception.\nMultiple except blocks\nFor a single block, several blocks are possible. However, only\ntry except\none of the exception clauses will be carried out. Let's look at the Python\nexample of having multiple blocks for a single block. When the\nexcept try\ninterpreter detects an exception, it seems to the blocks that are\nexcept\nrelated to the block. The types of exceptions that these except blocks\ntry\nmanage can be defined. The interpreter executes the block when it\nexcept\ndetects a corresponding exception.\nExample 10.8:\nX1=int (input (\"Input 1st value:\")\nY1=int (input (\"Input 2nd value: \"))\ntry: print (X1\/Y1) # It will run if Y1 is not zero\nprint ('10'+10) # It will not print\nexcept TypeError:\nprint (\"Type Exception\")\nexcept ZeroDivisionError:\nprint (\"You divided by 0\")\nOutput:\n----------------------Run program with following input-------\n--------------------\nInput 1st value: 5\nInput 2nd value: 0\nYou divided by 0\n----------------------Run program with following input-------\n--------------------\nInput 1st value: 100\nInput 2nd value: 25\n4.0\nType Exception\nMultiple exceptions in one except\nWe can also handle multiple exceptions with a single block using\nexcept\nparentheses to do this. The interpreter will return a syntax error if this is not\ndone.\nExample 10.9:\n#Multiple exceptions in one except\nX1=int (input (\"Input 1st value:\"))\nY1=int (input (\"Input 2nd value: \"))\ntry:\nprint (X1\/Y1) # It will run if Y1 is not zero\nprint ('10'+10) # It will not print\nexcept (TypeError,ZeroDivisionError):\nprint (\"Either Type or Division by zero exception\") Output:\n----------------------Run program with following input-------\n--------------------\nInput 1st value: 1\nInput 2nd value:0\nEither Type or Division by zero exception\n----------------------Run program with following input-------\n--------------------\nInput 1st value: 55\nInput 2nd value: 11\n5.0\nEither Type or Division by zero exception\nelse and finally\nThe keywords and can be used with the and\nelse finally try except\nclauses in Python. During program execution, if an exception occurs in the\nblock, then except block is executed. But if there is no exception found in\ntry\nthe block, then block is executed. Another statement is\ntry else finally\nused in exception handling. All the codes written inside the block\nfinally\nare always executed either when the exception occurs or not. As a result, the\nerror-free block skips the clause and reaches the block\ntry except finally\nbefore executing the rest of the code.\nSyntax:\ntry:\n#Code which we want to run\nexcept:\n#This code will run if an exception occurs\nelse:\n#This code will run if no exception occurs\nfinally:\n#This code will always run\nExample 10.10:\n#Exception handling with else and finally a=int (input ('Enter 1st value: '))\nb=int (input ('Enter 2nd value: '))\ntry:\nprint ('Code in try block')\nc=a\/b\nexcept ZeroDivisionError:\nprint (\"Except block.\")\nprint (\"Division by zero error.\")\nelse:\nprint (\"else block.\")\nprint (\"a\/b= \", c)\nfinally:\nprint (\"finally block. Always run.\")\nOutput:\n----------------------Run program with following input-------\n--------------------\nEnter 1st value: 200\nEnter 2nd value: 13\nCode in try block\nelse block.\na\/b= 15.384615384615385\nfinally block. Always run.\n----------------------Run program with following input-------\n--------------------\nEnter 1st value: 200\nEnter 2nd value: 0\nCode in try block\nExcept block.\nDivision by zero error.\nfinally block. Always run.\nRaising exceptions\nIn the sense of exception handling, Python also includes the keyword.\nraise\nIt results in an explicit exception being thrown. Built-in errors are raised implicitly. During execution, however, you can force a built-in or custom\nexception. For instance, if a program needs 1GB of memory to run, we may\nraise an exception to prevent the program from running. The following is the\nsyntax for using the statement.\nraise\nSyntax:\nraise Exception_class (<value>)\nExample 10.11:\n#raise exception example\ntry:\nval=int(input('Enter a number between 1 to 50 :'))\nif val > 50:\nraise ValueError(val)\nexcept ValueError:\nprint (val, \"Number is not between 1 to 50\")\nelse:\nprint (val, \"Number is between 1 to 50\")\nOutput:\n----------------------Run program with following input-------\n--------------------\nEnter a number between 1 to 50 :56\n56 Number is not between 1 to 50\n----------------------Run program with following input-------\n--------------------\nEnter a number between 1 to 50 :20\n20 Number is between 1 to 50\nExample 10.12:\n#raise exception with message\ntry:\nval = int(input(\"Please enter a positive number: \"))\nif(val<= 0):\n# raise statement with message\nraise ValueError(\"Negative number.\") except ValueError as e:\nprint (e)\nOutput:\nPlease enter a positive number: -52\nNegative number.\nExample 10.13:\n#raise exception\ntry:\nx = int (input (\"Enter first number:\"))\ny= int (input (\"Enter second number:\"))\nif y == 0:\nraise ArithmeticError(y)\nelse:\nprint (\"x\/y= = \",x\/y)\nexcept ArithmeticError as e:\nprint (\"value of y is=\",e)\nOutput:\n----------------------Run program with following input-------\n--------------------\nEnter first number:5\nEnter second number:2\nx\/y= = 2.5\n----------------------Run program with following input-------\n--------------------\nEnter first number:12\nEnter second number:0\nvalue of y is= 0\nBuilt-in exceptions\nWhen errors occur in Python, a number of built-in exceptions are raised. The\nbuilt-in functions can be used to display these built-in exceptions as\nlocal()\nfollows: print (dir(locals()['__builtins__']))\nOutput:\nFigure 10.1: Built-in exceptions\nSome important built-in exceptions are described below:\nr: If an assert argument fails, this exception is raised.\nAssertionErro\n: When an attribute assignment or relation fails, this\nAttributeError\nexception is raised.\n: When the function encounters an end-of-file state,\nEOFError input()\nthis exception is raised.\n: When a floating-point operation fails, this\nFloatingPointError\nexception is raised.\n: It is raised when the method of a generator\nGeneratorExit close()\nis called.\n: When the imported module cannot be found, this\nImportError\nexception is raised.\n: When the index of a series is out of control, it is raised.\nIndexError\n: When a key isn't found in a dictionary, this exception is\nKeyError\nraised.\n: When the user presses the interrupt key (Ctrl + C\nKeyboardInterrupt\nor Delete), this exception is raised. : When an action runs out of memory, this exception is\nMemoryError\nraised.\n: When a variable isn't found in either local or global scope,\nNameError\nthis exception is raised.\n: Abstract techniques were used to raise it.\nNotImplementedError\n: When a system operation results in a system-related mistake,\nOSError\nthis exception is raised.\n: When the product of an arithmetic operation is too\nOverflowError\nhigh to be expressed, this exception is raised.\n: When a weak reference proxy is used to access a\nReferenceError\ngarbage collection, this exception is raised.\n: If an error does not fit into any of the other categories,\nRuntimeError\nit is raised.\n: The function raises this exception to mean\nStopIteration next()\nthat the iterator has no more items to return.\n: When a parser encounters a syntax error, it raises this\nSyntaxError\nexception.\n: If the indentation is wrong, it is raised.\nIndentationError\n: When the indentation consists of a mix of tabs and spaces,\nTabError\nthe indentation is raised.\n: When the interpreter senses an internal error, this\nSystemError\nexception is raised.\n: The function raised this exception.\nSystemExit sys.exit()\n: When a function or procedure is applied to an object of the\nTypeError\nwrong kind, this exception is raised.\n: When a reference to a local variable is made in\nUnboundLocalError\na function or procedure, but no value has been bound to that variable,\nthis exception is raised.\n: When a Unicode-related encoding or decoding error\nUnicodeError\noccurs, this exception is raised.\n: When a Unicode-related error occurs during\nUnicodeEncodeError\nencoding, this exception is raised. : When a Unicode-related error occurs, this\nUnicodeDecodeError\nexception is raised.\n: When a Unicode-related mistake occurs\nUnicodeTranslateError\nduring translation, this exception is raised.\n: It occurs when a function receives an argument with the\nValueError\ncorrect type but the wrong value.\n: When the second operand of a division or\nZeroDivisionError\nmodulo operation is zero, this exception is raised.\nUser-defined exceptions\nYou can also build your own exceptions by deriving classes from the built-in\nexceptions in Python. By creating a new exception class, programmers can\ncall their exceptions. Exceptions must be either directly or indirectly\ninherited from the class. The below code shows an example of a\nException\nuser-defined exception.\nExample 10.14:\n#User-defined exception example\nclass MyException(Exception):\n#constructor\ndef __init__(self, a):\nself.a = a\n# display function\ndef __str__(self):\nreturn (repr(self.a))\ntry:\nraise(MyException(\"My Exception\"))\n# exception value stored in e\nexcept MyException as e:\nprint ('New Exception occurred:',e.a)\nOutput:\nNew Exception occurred: My Exception\nIn the preceding example, we have created a new exception class,\n. Exceptions must be either directly or indirectly derived from\nMyException the built-in class.\nException\nExample 10.15:\n#User-defined exception example\nclass MyClass(RuntimeError):\ndef __init__(self, a):\nself.a = a\ntry:\nraise MyClass(\"It is a user defined exception\")\nexcept MyClass as e:\nprint (e)\nOutput:\nIt is a user defined exception\nA runtime error is a built-in class that is raised when a generated error does\nnot fall into one of the categories listed above. The preceding code\ndemonstrates how to use runtime error as the base class and user-defined\nerror ( ) as the derived class.\nMyClass\nPre-defined clean\u2013up action\nThere are various situations in which we want our program to perform a\nparticular job, regardless of whether it runs perfectly or throws an error. We\nuse the and block to catch any errors or exceptions. The\ntry except try\nstatement provides a beneficial optional clause that is intended for specifying\nclean-up actions ( ) that must be executed in any circumstances. The\nfinally\nclause would be executed no matter what; however, the clause\nfinally else\nruns only if an exception was not raised.\nExample 10.16:\n# clean up actions example\ndef div(x, y):\ntry:\nz = x \/\/ y\nexcept ZeroDivisionError:\nprint (\"Divide by zero. \") else:\nprint (\"Division value is :\", z)\nfinally:\nprint (\" It is Finally clause, always run. \")\n# passing parameters to function\ndiv(50, 4)\ndiv(30, 0)\nOutput:\nDivision value is : 12\nIt is Finally clause, always run.\nDivide by zero.\nIt is Finally clause, always run.\nModules\nIn modular programming, a complex and unmanageable program is divided\ninto multiple subprograms known as a module. Each of the modules can be\nused to perform some specific task. In Python, modules can be created by\nusing Python files that may contain definitions and various statements.\nFunctions, classes, and variables can all be defined in a module. Runnable\ncode can also be used in a module. The code is easier to understand and use\nwhen it is structured into modules. It also organizes the code logically.\nOur Python code file with the extension ( ) is treated as the module. The\n.py\nPython module can contain executable code. We must import the particular\nmodule to use the functionality of one module in another. Assume you've\ncreated a file called that includes the following code:\nmymodule.py\nmymodule.py\n# Example of a module (mymodule.py)\ndef fun_add (x, y):\nreturn (x+y)\ndef fun_sub (x, y):\nreturn (x-y)\nTo call the functions _ and specified in the module\nfun add() fun_sub()\nnamed file ( ), we must include this module in our main module.\nmymodule.py Loading module\nTo use the module's functionality, we must first load it into our Python code.\nPython has two types of statements, which are listed below.\nThe statement\nimport\nThe statement\nfrom-import\nThe import statement\nA module can be linked with our Python program using an import statement.\nWith a single statement, we can import several modules, but a\nimport\nmodule is only loaded once, regardless of how many times it has been\nimported into our register. The statement's syntax is mentioned as\nimport\nfollows:\nSyntax:\nimport module1, module2, module3, \u2026\u2026.. module n\nIf an statement is identified, the interpreter imports the module if it is\nimport\nincluded in the search path. When importing a module, the interpreter\nsearches all the directories in the search path. For example, to import the\nmodule , add the following command to the program's top.\nmymodule.py\nExample 10.17:\n# importing module mymodule.py\nimport mymodule\nprint (fun_add (10, 20))\nprint (fun_sub (100, 50))\nOutput:\n30\n50\nThe from\u2026import statement\nPython allows you to import only the specific attributes of a module, rather\nthan the whole module, into the namespace. The from import statement can be used for this. The expression is used in the following syntax.\nfrom\u2026import\nSyntax:\nfrom <module_name> import <name_1>, <name_2>\u2026.<name_n>\nConsider the following module, , which includes the functions\nmymodule\nand\nfun_add() fun_sub().\nExample 10.18:\nFile name:\nmymodule.py\n# mymodule.py\ndef fun_add(x, y):\nreturn (x+y)\ndef fun_sub(x, y):\nreturn (x-y)\nIf we want to import only function from this module, then\nfun_add()\nfollowing code will be used.\nFile name:\nmain.py\n# importing fun_add() from mymodule.py\nfrom mymodule import fun_add\nprint (fun_add(10, 20))\nOutput:\n30\nExample 10.19:\n# importing pi from math module\nfrom math import pi\nprint (\"pi value=\", pi)\nOutput:\npi value= 3.141592653589793 When we know the attributes to be imported from the module in advance, we\ncan use the statement. Our code will not get heavier as a result\nfrom\u2026import\nof this. The may also be used to import all of a module's attributes.\n*\nConsider the following example, in which all the functions of are\nmymodule\nimported.\nExample 10.20:\nFile name: main.py\n# importing all attributes from mymodule.py\nfrom mymodule import *\nprint (sub(100, 20))\nprint (add(100, 20))\nOutput:\n80\n120\nRenaming a module\nPython allows us to import a module with a particular name and then use that\nname to reference that module in our Python source code. The following is\nthe syntax for renaming a module.\nSyntax:\nimport <module-name> as <new-name>\nExample 10.21:\n# importing from mymodule.py\nimport mymodule as mm # rename mymodule to mm\nprint (mm.sub(20, 10))\nprint (mm.add(100, 20))\nOutput:\n10\n120 The dir() built-in function\nThe function can be used to find names specified within a module. In\ndir()\nthe module , for example, we've specified two functions:\nmymodule add()\nand . In the module, we can use as follows:\nsub() mymodule dir()\n>>> dir(mymodule)\n['__builtins__',\n'__cached__',\n'__doc__',\n'__file__',\n'__initializing__',\n'__loader__',\n'__name__',\n'__package__',\n'add',\n'sub']\nWe can see a sorted list of names here (along with and ). All other\nadd sub\nnames that begin with an underscore are the module's default Python\nattributes. The function can be used without any arguments to find all\ndir()\nthe names specified in our current namespace.\nExample 10.22:\n> a=10\n> b=30\n> import math\n> dir()\n['__annotations__', '__builtins__', '__doc__', '__loader__',\n'__name__', '__package__', '__spec__', 'a', 'b', 'math']\nThe reload() function\nAs previously mentioned, regardless of how many times a module is\nimported into the Python source file, it is only loaded once. However, Python\nprovides us with the function to reload an already imported\nreload()\nmodule and re-run the top-level code. The function is used in the\nreload()\nfollowing syntax. Syntax:\nreload(<module-name>)\nExample 10.23:\nreload(mymodule)\nPython built-in modules\nMany pre-defined functions are also available as a part of libraries bundled\nwith Python distributions, in addition to built-in functions. Built-in modules\ndescribe the functions that are specified in modules. The Python shell is\nintegrated with built-in modules, which are written in C. Each built-in\nmodule includes resources for system-specific functions like OS\nmanagement, disc IO, and so on. Many Python scripts (with the extension)\n.py\ncontaining useful utilities can also be found in the standard library. Use the\nfollowing command in the Python console to see a list of all the available\nmodules:\nhelp('modules')\nFollowing are some examples of built-in modules:\nExample 10.24:\n# Example of built-in module math\nimport math as m\n# using square (sqrt) function\nprint (m.sqrt(100))\n# using pi function\nprint (m.pi)\n# degree\nprint (m.degrees(3))\n# radians\nprint (m.radians(60))\n# Sin\nprint (m.sin(60))\n# Cosine print (m.cos(30))\n# Tangent\nprint (m.tan(90))\n# factorial\nprint (m.factorial(6))\nOutput:\n10.0\n3.141592653589793\n171.88733853924697\n1.0471975511965976\n-0.3048106211022167\n0.15425144988758405\n-1.995200412208242\n720\nExample 10.25:\n# datetime built-in module\nfrom datetime import time\nfrom datetime import date\nd = date(2000, 1, 1)\nprint (\"Given date is:\", d)\nprint (date.today()) #It will show current date\nTime = time(5, 30, 10)\nprint (\"hour =\", Time.hour)\nprint (\"minute =\", Time.minute)\nprint (\"second =\", Time.second)\nprint (\"microsecond =\", Time.microsecond)\nOutput:\nGiven date is: 2000-01-01\n2021-04-21\nhour = 5\nminute = 30 second = 10\nmicrosecond = 0\nExample 10.26:\n# built-in module random\nimport random\n# random integer between 0 and 10\nprint ('Random number between 0 and 10:',random.randint(0,\n5))\n# random float between 0 and 1\nprint ('Random float between 0 and 1:',random.random())\n# random number between 0 and 100\nprint ('Random number between 0 and 100:',random.random() *\n100)\nList = [2, 4, True, 80, \"Python\", 20, \"Book\", 45]\n# random element from a list\nprint ('Random element from list',random.choice(List))\nOutput:\nRandom number between 0 and 10: 3\nRandom float between 0 and 1: 0.7476231433619301\nRandom number between 0 and 100: 46.881247400915406\nRandom element from list 80\nPackages in Python\nWe organize a large number of files into various folders and subfolders\nbased on specific parameters so that they are easier to locate and handle. On\nthe other hand, a module in Python brings the principle of modularity to the\nnext logical level. As you might know, a module can contain a variety of\nobjects such as classes, functions, and so on. One or more related modules\ncan be included in a package. A package is a folder that contains one or more\nmodule files on a physical level. Packages help us store other sub-packages and modules to be used by the user when needed, much as drives and\ndirectories allow us to store files in an operating system.\nCreating packages\nWe build a file called within a directory to inform Python that\n__init__.py\nit is a package, and then it is considered a package, and we can create other\nmodules and subpackages inside it. This file may be left blank\n__init__.py\nor filled in with the package's initialization code.\nWe can follow these three basic steps to build a package in Python:\n1. First, we create a directory and name it a package, preferably the one\nrelated to its function.\n2. After that, we add the required classes and functions.\n3. Finally, inside the directory, we construct an file to\n__init__.py\ninform Python that it is a package.\nExample 10.27:\nFirst, we'll make a directory called . After that, we must build\nMobiles\nmodules. To do so, create a file called and write the below code.\nOppo.py\nFile name: Oppo.py\n# Creating Modules\nclass Oppo:\n# constructor\ndef __init__(self):\nself.phone = ['Android', '8GB', '32MP']\n# function\ndef show(self):\nprint ('Features of Oppo')\nfor s in self.phone:\nprint (s)\nThen we make a new file called and put the same code into it, but\nVivo.py\nwith different members.\nFile name: Vivo.py\n# Creating Modules class Vivo:\n# constructor\ndef __init__(self):\nself.phone = ['Android ', '16GB', '64MP']\n# function\ndef show(self):\nprint ('Features of Vivo')\nfor s in self.phone:\nprint (s)\nThen we make a new file called and copy the same code into it,\niphone.py\nbut with different members.\nFile name: iPhone.py\n# Creating Modules\nclass iPhone:\n# constructor\ndef __init__(self):\nself.phone = ['IOS', '128GB', '12MP']\n# function\ndef show(self):\nprint ('Features of iPhone')\nfor s in self.phone:\nprint (s)\nThe file is finally created. This file will be located in the\n__init__.py\ndirectory and can either be left blank or filled with the initialization\nMobiles\ncode.\nFile name: __init__.py\nfrom Oppo import Oppo\nfrom Vivo import Vivo\nfrom iPhone import iPhone\nNow it's time to put our new package to work. To do so, create a\nTest.py\nfile in the same directory as the package and write the following\nMobiles\ncode:\nFile name: Test.py # Import classes from Mobiles package\nfrom Mobiles import Oppo\nfrom Mobiles import Vivo\nfrom Mobiles import iPhone\n# Create an object of Oppo class and call its functions\nobj1 = Oppo()\nobj1.show()\n# Create an object of Vivo class and call its functions\nobj2 = Vivo()\nobj2.show()\n# Create an object of iPhone class and call its function\nobj3 = iPhone()\nobj3.show()\nOutput:\nFeatures of Oppo\nAndroid\n8GB\n32MP\nFeatures of Vivo\nAndroid\n16GB\n64MP\nFeatures of iPhone\nIOS\n128GB\n12MP\nThe following figure 10.2 shows the folder structure of the\nMobiles\npackage: Figure 10.2: Mobiles package folder structure\n__init__.py\nThe content of the package is stored in a special file named ,\n__init__.py\nwhich is found in the package folder. It has two functions:\nIf a folder contains the file, the Python interpreter\n__init__.py\nrecognizes it as a package.\nmakes resources from its modules available for import.\n__init__.py\nWhen this package is imported, an empty file makes all\n__init__.py\nmodules' functions accessible. It's worth noting that the folder's\nfile is needed for Python to recognize it as a package.\n__init__.py\nSubpackages\nPackages may have any number of nested sub-packages. The figure 10.3\nshows an example of a subpackage inside a Mobiles package: Figure 10.3: Mobiles package folder structure with subpackages\nLike earlier, the three modules ( , , and ) are\nOppo.py Vivo.py iPhone.py\nidentified. They are now separated into two subpackage folders,\nand , rather than being grouped in the\nSub_package1 Sub_package2\ndirectory. Importing continues to operate in the same manner as\nMobiles\nbefore. The syntax is similar, but a dot separates the package name and\nsubpackage name.\nimport Mobiles.Sub_package1.Oppo\nimport Mobiles.Sub_package2.Vivo\nimport Mobiles.Sub_package2.iPhone\nConclusion\nIn this chapter, we discussed exception handling, modules, and packages in\nPython. We also discussed the uses of , , , and\ntry except else finally\nblocks for managing exceptions. Module implementations and their importing\nare also presented. Besides, package creations and services are also\ndiscussed with Python codes. Based on these examples, you can write your\ncode. In the next chapter, we will discuss the concepts of object-oriented\nprogramming in Python.\nPoints to remember An exception is a type of error that occurs during the execution of a\nprogram.\nTo handle exceptions, four keywords are used: , , , and\ntry except else\n.\nfinally\nTo raise an exception, use the keyword.\nraise\nA module is a smaller part of a larger program.\nfile indicates that a particular folder is a package.\n__init__.py\nMultiple choice questions\n1. The import statement is used for?\na. Creating package\nb. Handling Exception\nc. Linking module\nd. None of the above\n2. How many except statements can a try-except block have?\na. 0\nb. 1\nc. More than one\nd. More than zero\n3. What will be the output for the following code?\nx = \"\"hello\"\"\nif not type(x) is int:\nraise TypeError(\"\"Only integers are allowed\"\")\na. hello\nb. garbage value\nc. Only integers are allowed\nd. Error\n4. When is the finally block executed?\na. When there is no exception b. When there is an exception\nc. Only when some condition that has been specified is satisfied\nd. Always\n5. What will be the output of the following Python code?\nfrom math import factorial\nprint(math.factorial(5))\na. 120\nb. Nothing is printed\nc. Error, method factorial doesn't exist in the math module\nd. Error, the statement should be: print(factorial(5))\n6. To obtain a list of all the functions defined under sys module, which\nof the following functions can be used?\na. print(dir(sys))\nb. print(sys)\nc. print(dir.sys)\nd. print(dir[sys])\n7. What is the output of the code shown below?\nimport random\nrandom.choice(2,3,4)\na. An integer other than 2, 3 and 4\nb. Either 2, 3 or 4\nc. Error\nd. 2 only\nAnswers\n1. c\n2. d\n3. c 4. d\n5. d\n6. a\n7. c\nQuestions\n1. What do you mean by exception handling?\n2. How exceptions can be handled. Discuss?\n3. What is a package?\n4. Create a package and import it into a Python file. Also, write steps to\ncreate it.\n5. What is the importance of block in exception handling?\nfinally\n6. What is a module? How can we create a module?\n7. Write a Python program to demonstrate the example of\nraise\nkeywords.\n8. Discuss the importance of some built-in modules.\n9. Write a Python program to handle arithmetic exceptions.\n10. Discuss the uses of multiple blocks with a single .\nexcept try CHAPTER 11\nObject-oriented Programming\nbject-oriented programming as a discipline has gained widespread\nO\nacceptance among programmers. Python, a popular programming\nlanguage, adheres to the object-oriented programming style as well. It is\nconcerned with declaring Python classes and properties, which is the core of\nOOPs concepts. In this chapter, you will see various concepts of object-\noriented programming about Python. Besides, we have demonstrated\ndifferent OOPs concepts with the help of examples and codes.\nStructure\nIn this chapter, we will cover the following topics:\nThe basic concepts of object-oriented programming\nObjects and classes creation\nConcepts and Types of constructors\nConcepts of inheritance and polymorphism\nVarious Python methods to achieve OOPs\nObjective\nThe objective of this chapter is to introduce the concept of object-oriented\nprogramming in Python. After completing this chapter, you should be able to\nunderstand classes, objects, constructors, inheritance, and polymorphism.\nAlso, you will be able to write Python codes related to OOPs.\nObject-Oriented Programming\nObject-oriented programming (OOP) is a way of structuring a program by\ngrouping associated properties and functionalities into separate objects.\nObject-oriented programming is based on classes and objects. Class is the blueprint, while objects are real entities and are able to perform various\ntasks. Data elements, also known as properties, and behavior, such as actions\nor functions, make up an object. Another popular programming paradigm is\nprocedural programming, which structures a program like a recipe by\nproviding a series of steps, such as functions and code blocks that flow\nsequentially to complete a task.\nPython, like other general-purpose programming languages, has been an\nobject-oriented language. It enables us to build applications in an object-\noriented manner. We can easily develop and use classes and objects in\nPython. Using classes and objects to construct the software is an object-\noriented paradigm. The object is linked to real-world objects such as a\ncomputer, a home, a mobile, etc. The OOPS definition emphasizes the\ndevelopment of reusable code. It is a common method of resolving a problem\nby creating objects. The following are the key concepts of an object-oriented\nprogramming paradigm:\nClass\nObject\nMethod\nData Abstraction and Encapsulation\nInheritance\nPolymorphism\nIntroduction to classes\nA set of objects can be described as a class. It's a logical entity with some\nunique properties and methods. For instance, if you have a student class, it\nshould have an attribute and a method, such as name, age, address, and\ncourse.\nObject\nThe object is a self-contained entity with state and actions. It could be a\nlaptop, a purse, a phone, a table, a pencil, or something else. In Python,\neverything is an object, with attributes and methods on almost everything. A\nclass must construct an object to assign memory when it is defined. Method\nIn Python, a method is like a function, except that it is linked to objects and\nclasses. Except for two big variations, Python methods and functions are\nsimilar.\nFor the object for which it is named, the method is used implicitly.\nData in the class is accessible to the method.\nData abstraction and encapsulation\nIn object-oriented programming, encapsulation is also essential. It's used to\nlimit access to variables and methods. Encapsulation protects code and data\nfrom accidental modification by wrapping them together in a single device.\nAbstraction is a technique for hiding internal information and displaying only\nthe functionalities. The term abstract refers to the process of giving items\nnames that capture the essence of what a function or a program does. Both\ndata abstraction and encapsulation are often used interchangeably. Since data\nabstraction is accomplished by encapsulation, the terms are nearly\ninterchangeable.\nInheritance\nThe most fundamental component of object-oriented programming is\ninheritance, which simulates the process of inheritance in real life. It states\nthat the child object inherits all of the parent object's properties and\nbehaviors. We may construct a class that inherits all the properties and\nbehaviors of another class by using inheritance. The new class is a derived\nclass or a child class, whereas the base class or parent class is known as the\none whose properties are acquired. It ensures that the code can be reused.\nPolymorphism\nPolymorphism is made up of the words poly and morphs. Poly stands for\nmany, and morph stands for form. We consider polymorphism as the ability\nto execute a task in many forms. It uses a single type of entity (method,\noperator, or object) to represent multiple types in various scenarios. For instance, we have one addition operator that can add different kinds of\nvalues.\nObject-oriented versus procedure-oriented\nprogramming languages\nThe following is a description of the differences between object-oriented\nand procedural programming:\nObject-oriented programming Procedural programming\nObject-oriented programming is a problem- A sequence of instructions is used in procedural\nsolving method that employs the use of objects to programming to perform step-by-step\nperform computation. computations.\nIt simplifies production and maintenance. When working with procedural programming, it\ncan be challenging to keep track of the codes as\nthe project grows larger.\nIt is a simulation of a real-world entity. As a It doesn't simulate the real world. It is based on a\nresult, OOPs can quickly solve real-world set of step-by-step instructions that are broken\nproblems. down into smaller components known as\nfunctions.\nIt allows data to be hidden. As a result, it is safer Since procedural languages lack a proper method\nthan procedural languages. You won't be able to for data binding, they are insecure.\naccess private information from anywhere.\nC++, Java, .Net, Python, C# are examples of C, Fortran, Pascal, VB are examples of\nobject-oriented programming languages. procedural languages.\nTable 11.1: Differences between object-oriented and procedural programming\nPython class and objects\nA class is a virtual entity that serves as an object's blueprint. After creating\nan object, it occupies memory and came into existence. For example, assume\na class is a model for a building structure. A building includes all the\ninformation about the rooms, gardens, area, and balcony. Based on these data\nitems, we can construct as many houses as we want. As a result, the structure\ncan be thought of as a class or a blueprint of the building, and we can make\nas many objects (houses) as we want. The object is known as the instance of a class. The process of constructing an\nobject is referred to as instantiation. In the above example, all the individual\nhouses will be the objects of the class, i.e., the building.\nDefining a class in Python\nThe keyword , followed by the class name, is used to build a class in\nclass\nPython. The following is the syntax for creating a class.\nSyntax:\nclass <Class_Name>\n# data members\n# member functions\nA class declares all its attributes in a new local namespace. Data members\nor functions may be included as attributes.\nIt also contains unique attributes that start with double underscores. For\nexample, returns the class's docstring. The following statement can\n__doc__\naccess it:\n<class-name>. __doc__.\nWhen we define a class, a new class object with the same name is generated.\nWe may use this class object to access the various attributes and create new\nobjects of that class.\nExample 11.1:\n# Creating a class\nclass Student:\n\"This is an example of student class\"\nage = 25\ndef fun(self):\nprint('Python')\n# display age\nprint (Student.age)\n#call function\nprint (Student.fun)\n# display docstring print (Student.__doc__)\nOutput:\n25\n<function Student.fun at 0x7f4fbdb88e50>\nThis is an example of student class\nExample 11.2:\n# Creating a student class\nclass Student:\nstuid = 1001\nstuname = \"Amit\"\ndef show (self):\nprint (self.stuid,self.stuname)\n# Creating an object\nobj=Student()\n# Calling a member function\nobj.show()\nOutput:\n1001 Amit\nIn the above example, a class is created with two fields: and\nStudent stuid\n. This class also contains a function , which can show the\nstuname show ()\nstudent information.\nThe -variable is used here as a reference variable to the current class\nself\nobject. In the function description, it is always the first argument. In the\nfunction call, however, using self is optional.\nThe -parameter accesses the class variables and corresponds to\nself\nthe current instance of the class. Instead of self, we can use anything,\nbut it must be the first parameter of any class function.\nCreating an object If we want to use a class's attributes in another class or method, we must first\ninstantiate it. A class can be instantiated by calling its name. The syntax for\ncreating a class instance (object) is mentioned below:\n<object-name> = <class-name>(<arguments>)\nThe following code shows an example of creating objects of the class.\nbook\nExample 11.3:\n# Creating a class book\nclass Book:\n# defining attribute\nname= \"Python Programming\"\nauthor = \"Krishna\"\nyear=2021\n# creating function\ndef show(self):\nprint (\"Book Name:\", self.name)\nprint (\"Author:\", self.author)\nprint (\"Year:\", self.year)\n# Object creation\nB1 = Book()\nB2 = Book()\n# Accessing class attribute and method through objects\nprint (B1.name)\nprint ('----------')\nB2.show()\nOutput:\nPython Programming\n----------\nBook Name: Python Programming\nAuthor: Krishna\nYear: 2021\nDeleting properties or object Using the keyword, we can delete the object's properties or the object\ndel\nitself. The following examples demonstrate the deletion of some properties\nand objects, respectively.\nExample 11.4:\n# Deleting properties of a class\nclass Book:\n# defining attribute\nname= \"Python Programming\"\nauthor = \"Krishna\"\nyear=2021\n# creating function\ndef show(self):\nprint (\"Book Name:\", self.name)\nprint (\"Author:\", self.author)\nprint (\"Year:\", self.year)\n# Object creation\nB1 = Book()\n# Accessing class attribute and method through objects\nprint ('-----Before Deletion-----')\nB1.show()\n# deleting a property (name)\ndel B1.name\nprint ('-----After Deletion-----')\nB1.show()\nOutput:\n-----Before Deletion-----\nBook Name: Python Programming\nAuthor: Krishna\nYear: 2021\nTraceback (most recent call last):\nFile \"<string>\", line 19, in <module>\nAttributeError: name Since we deleted the name property, it will throw an Attribute error:\nname.\nExample 11.5:\n# Example of object deletion\n# Creating a class book\nclass Book:\n# defining attribute\nname= \"Python Programming\"\nauthor = \"Krishna\"\nyear=2021\n# creating function\ndef show(self):\nprint (\"Book Name:\", self.name)\nprint (\"Author:\", self.author)\nprint (\"Year:\", self.year)\n# Object creation\nB1 = Book()\n# Accessing class attribute and method through objects\nprint ('-----Before Deletion of Object-----')\nB1.show()\n# deleting object B1\ndel B1\nprint ('-----After Deletion of Object-----')\nB1.show()\nOutput:\n-----Before Deletion of Object-----\nBook Name: Python Programming\nAuthor: Krishna\nYear: 2021\n-----After Deletion of Object-----\nTraceback (most recent call last):\nFile \"<string>\", line 21, in <module>\nNameError: name 'B1' is not defined Since we deleted the B1 object, it will throw a NameError.\nData abstraction\nIn object-oriented programming, data abstraction is an important feature. We\ncan also hide Python data by prefixing the attribute to be hidden with a\ndouble underscore ( ). The attribute will no longer be available outside the\n__\nclass via the object after performing this. The following Python code shows\nthe concept of data abstraction.\nExample 11.6:\nclass Student:\n__n = 0;\ndef __init__(self):\nStudent.__n+=1\ndef show(self):\nprint (\"Total Students:\",Student.__n)\ns1 = Student()\ns2 = Student()\ns3 = Student()\ns1.show()\ns2.show()\nprint (s1.__n) # It will generate error because n is not\navailable to access outside class\nOutput:\nTotal Students: 3\nTotal Students: 3\nTraceback (most recent call last):\nFile \"<string>\", line 12, in <module>\nAttributeError: 'Student' object has no attribute '__n'\nConstructors in Python\nA constructor is a particular type of function that is used to initialize the\nclass's instance members. The constructor in C++ or Java has the same name as the class, but Python handles constructors differently. When we create an\nobject of a class, the constructor function executes it. There are two kinds of\nconstructors such as parameterized constructors and non-parameterized\nconstructors. In Python, the constructor is defined using the\n__init__()\nmethod. It takes the keyword as a first argument, allowing access to the\nself\nclass's attributes and methods. Depending on the definition, we\n__init__()\ncan pass any number of arguments when constructing the class object. It's\nmainly used to set up the class attributes. Every class must have a default\nconstructor if we have not defined any other constructor.\nExample 11.7:\n# Creating a class book\nclass Book:\n#defining constructor\ndef __init__(self, n, a, y):\nprint ('Constructor example')\nself.name = n\nself.author = a\nself.year=y\n# creating function\ndef show(self):\nprint (\"Book Name:\", self.name)\nprint (\"Author:\", self.author)\nprint (\"Year:\", self.year)\n# Object creation and passing arguments to constructor\nB1 = Book(\"Python Programming\", \"John\",2021)\nB2 = Book(\"Java Programming\", \"David\",2020)\n# Accessing class attribute and method through objects\nprint ('-----Values are-----')\nB1.show()\nB2.show()\nOutput:\nConstructor example\nConstructor example\n-----Values are----- Book Name: Python Programming\nAuthor: John\nYear: 2021\nBook Name: Java Programming\nAuthor: David\nYear: 2020\nExample 11.8:\n#Program for counting number of objects in a class\nclass Test:\n#Defining data member\ncount = 0\n#Defining constructor\ndef __init__(self):\nTest.count += 1\n# Creating objects\nT1=Test()\nT2=Test()\nT3=Test()\nT4=Test()\nT5=Test()\nprint (\"The number of objects:\",Test.count)\nOutput:\nThe number of objects: 5\nNon-parameterized constructor\nWhen we don't want to update the value or just have self as an argument, we\nuse the non-parameterized constructor. The following code shows an\nexample of the non-parameterized constructor.\nExample 11.9:\n# Class creation\nclass Test:\n# Defining non-parameterized constructor def __init__(self):\nprint (\"Non parameterized constructor\")\ndef display(self,s):\nprint (\"Python\",s)\n# Creating objects\nT1=Test()\n# calling function\nT1.display(\"Programming\")\nOutput:\nNon parameterized constructor\nPython Programming\nParameterized constructor\nAlong with the self, the parameterized constructor has several parameters.\nThe following Python code demonstrates parameterized constructor.\nExample 11.10:\n# Class creation\nclass Test:\n# Defining Parameterized constructor\ndef __init__(self,arg1):\nprint (\"Parameterized constructor\")\nself.arg1=arg1\ndef display(self,s1):\nprint (\"Python\",self.arg1,s1)\n# Creating objects and passing a parameter\nT1=Test(\"Programming\")\n# calling function with one argument\nT1.display(\"Book\")\nOutput:\nParameterized constructor\nPython Programming Book Default constructor\nThe default constructor is used when no constructor is included in the class,\nor when it is not declared. It defines the objects' initial values. The following\nexample demonstrates the concept of a default constructor.\nExample 11.11:\n# Default constructor example\n#Class Declaration\nclass Employee:\nEmp_id = 5001\nEmp_name = \"David\"\n# Function definition\ndef show(self):\nprint(self.Emp_id,self.Emp_name)\n# Object creation\nobj= Employee()\n# Function calling\nobj.show()\nOutput:\n5001 David\nMultiple constructors in a class\nWe can include two or more similar constructors in a class. In the following\nexample, we have included two constructors of the same type. The object\nT1\nis called the second constructor in the following code, even though both have\nthe same configuration. The object does not have access to the first\nT1\nconstructor. If the class has many constructors, the object of the class will\nalways call the last constructor.\nExample 11.12:\n# Multiple constructor example\n#Class Declaration\nclass Test: # defining first constructor\ndef __init__(self):\nprint (\"First Constructor\")\n# defining second constructor\ndef __init__(self):\nprint (\"Second Constructor\")\n# defining third constructor\ndef __init__(self):\nprint (\"Third Constructor\")\n# Creating an object\nT1 = Test()\nOutput:\nThird Constructor\nConstructor overloading is not permitted in Python.\nPython inheritance\nThe object-oriented framework includes inheritance as a key component.\nSince we can use an existing class to build a new class instead of starting\nfrom scratch, inheritance allows us to reuse the program's code. The child\nclass inherits the parent class's properties and has access to all of the data\nmembers and functions specified in the parent class. A child class may also\nhave its implementation for the parent class's functions. A derived class can\ninherit a base class in Python by simply mentioning the base class after the\nderived class name in brackets. To inherit a base class into a derived class,\nuse the syntax as shown below:\nclass <derived-class_Name> (base-class_Name):\n# derived class body\nA derived class can inherit properties of multiple base classes. This kind of\ninheritance can be achieved by mentioning all base classes inside the\nbrackets. The following syntax is used to inherit properties of multiple\nclasses.\nSyntax: class <derive-class_name> (<base-class 1>, <base-class 2>,\n\u2026.. <base-class n>):\n# derived class body\nExample 11.13:\n# Inheritance example\n#Creating a base class\nclass Base():\n# defining function inside base class\ndef fun1(self):\nprint ('Base class function')\n# Creating a derived class\nclass Derived(Base):\n# defining function inside derived class\ndef fun2(self):\nprint ('Derived class function')\n# Creating object of derived class\nobj = Derived()\n# accessing functions of both base and derived classes\nobj.fun1()\nobj.fun2()\nOutput:\nBase class function\nDerived class function\nTypes of inheritance\nThere are four types of inheritances in Python, depending upon the number of\nchild and parent groups involved. These are as follows:\nSingle inheritance\nMulti-level inheritance\nMultiple inheritance\nHierarchical inheritance Single inheritance\nA derived class can inherit properties from a single base class, allowing for\ncode reuse and new features to existing code. The following figure 11.1\nshows the concept of single inheritance.\nFigure 11.1: Single inheritance\nExample 11.14:\n# Single inheritance example\n#Creating a base class\nclass Base():\n# defining function inside base class\ndef fun1(self,a):\nprint ('Base class function')\nself.a=a\nprint ('Base class:', self.a)\n# Creating a derived class\nclass Derived(Base):\n# defining function inside derived class\ndef fun2(self,b):\nprint ('Derived class function')\nself.b=b\nprint ('Derived class:',self.b)\n# Creating object of derived class\nobj = Derived()\n# accessing functions of both base and derived classes\nobj.fun1(10) obj.fun2(20)\nOutput:\nBase class function\nBase class: 10\nDerived class function\nDerived class: 20\nMultilevel inheritance\nFeatures from the base and derived classes are passed down to the new\nderived class in multi-level inheritance. In Python, there is no limit to the\nnumber of levels to which multi-level inheritance can be archived. The\nfollowing figure 11.2 represents the concept of multi-level inheritance:\nFigure 11.2: Multilevel inheritance\nExample 11.15:\n# Multilevel inheritance example\n#Creating a base class\nclass Base():\ndef __init__(self):\nprint ('Base constructor')\n# defining function inside base class\ndef funB(self,a): print ('Base class function')\nself.a=a\nprint ('Base class:', self.a)\nclass Intermediate (Base):\n# defining function inside intermediate class\ndef funI(self,b):\nprint ('Intermediate class function')\nself.b=b\nprint ('Intermediate class:', self.b)\n# Creating a derived class\nclass Derived(Intermediate):\n# defining function inside derived class\ndef funD(self,c):\nprint ('Derived class function')\nself.c=c\nprint ('Derived class:',self.c)\n# Creating object of derived class\nobj = Derived()\n# accessing functions of all three classes\nobj.funB(10)\nobj.funI(20)\nobj.funD(30)\nOutput:\nBase constructor\nBase class function\nBase class: 10\nIntermediate class function\nIntermediate class: 20\nDerived class function\nDerived class: 30\nMultiple inheritance\nMultiple inheritance is a type of inheritance in which a class may be derived\nfrom multiple base classes. In multiple inheritance, the derived class inherits all of the properties of the base classes. An example of multiple inheritances\nis shown in figure 11.3, in which a derived class inherits properties of two\nbase classes.\nFigure 11.3: Multiple inheritance\nExample 11.16:\n# Multiple inheritance example\n#Creating first base class\nclass Base1():\n# defining function inside base class\ndef funB1(self,a):\nprint('Base class 1 function')\nself.a=a\nprint('Base class 1 value:', self.a)\n#Creating second base class\nclass Base2():\n# defining function inside base class\ndef funB2(self,a):\nprint('Base class 2 function')\nself.a=a\nprint('Base class 2 value:', self.a)\n# Creating a derived class\nclass Derived(Base1, Base2):\n# defining function inside derived class\ndef funD(self,c): print('Derived class function')\nself.c=c\nprint('Derived class value:',self.c)\n# Creating object of derived class\nobj = Derived()\n# accessing functions of both base and derived classes\nobj.funB1(10)\nobj.funB2(20)\nobj.funD(30)\nOutput:\nBase class 1 function\nBase class 1 value: 10\nBase class 2 function\nBase class 2 value: 20\nDerived class function\nDerived class value: 30\nHierarchical inheritance\nHierarchical inheritance is a form of inheritance in which multiple derived\nclasses are inherited from a single base class. The following figure 11.4\nshows an example of hierarchical inheritance in which three derived classes\nare inherited from one base class:\nFigure 11.4: Hierarchical inheritance\nExample 11.17:\n# Hierarchical inheritance example #Creating base class\nclass Base():\n# defining funtion inside base class\ndef funB(self,a):\nprint ('Base class 1 function')\nself.a=a\nprint ('Base class 1 value:', self.a)\n# Creating first derived class\nclass Derived1(Base):\n# defining function inside derived class\ndef funD1(self,c):\nprint ('Derived class 1 function')\nself.c=c\nprint ('Derived class 1 value:',self.c)\n# Creating second derived class\nclass Derived2(Base):\n# defining function inside derived class\ndef funD2(self,c):\nprint ('Derived class 2 function')\nself.c=c\nprint ('Derived class 2 value:',self.c)\n# Creating third derived class\nclass Derived3(Base):\n# defining function inside derived class\ndef funD3(self,c):\nprint ('Derived class 3 function')\nself.c=c\nprint ('Derived class 3 value:',self.c)\n# Creating object of first derived class\nobj1 = Derived1()\n# accessing functions from derived classes\nprint (' --------First derived class-----')\nobj1.funB(10)\nobj1.funD1(20)\n# Creating object of second derived class obj2 = Derived2()\n# accessing functions from derived classes\nprint (' --------Second derived class-----')\nobj2.funB(100)\nobj2.funD2(200)\n# Creating object of third derived class\nobj3 = Derived3()\n# accessing functions from derived classes\nprint (' --------Third derived class-----')\nobj3.funB(1000)\nobj3.funD3(2000)\nOutput:\n--------First derived class-----\nBase class 1 function\nBase class 1 value: 10\nDerived class 1 function\nDerived class 1 value: 20\n--------Second derived class-----\nBase class 1 function\nBase class 1 value: 100\nDerived class 2 function\nDerived class 2 value: 200\n--------Third derived class-----\nBase class 1 function\nBase class 1 value: 1000\nDerived class 3 function\nDerived class 3 value: 2000\nThe issubclass(sub,sup) method\nTo check the relationships between the defined classes, use the\nmethod. If the first class is a subclass of the\nissubclass(sub, sup)\nsecond, it returns true; otherwise, it returns false.\nExample 11.18:\nclass A: def fun1(self):\nprint ('Base class 1')\nclass B:\ndef fun2(self):\nprint ('Base class 2')\nclass D(A,B):\ndef fun3(self):\nprint ('Derived class')\nobj = D()\nprint ('D is sub class of B:',issubclass(D,B))\nprint ('A is sub class of B', issubclass(A,B))\nOutput:\nD is sub class of B: True\nA is sub class of B False\nThe isinstance (obj, class) method\nTo check the relationship between objects and classes, use the\nmethod. If the first parameter, , is an instance of the\nisinstance() obj\nsecond parameter, class, it returns true.\nExample 11.19:\nclass A:\ndef fun1(self):\nprint ('Base class 1')\nclass B:\ndef fun2(self):\nprint ('Base class 2')\nclass D:\ndef fun3(self):\nprint ('Derived class')\nobj = D()\nprint ('obj is instance of A:',isinstance(obj,A))\nprint ('obj is instance of B', isinstance(obj,B))\nprint ('obj is instance of D', isinstance(obj,D)) Output:\nobj is instance of A: False\nobj is instance of B False\nobj is instance of D True\nPolymorphism in Python\nPolymorphism is an object-oriented programming term that refers to the\nconcept of having many forms. Polymorphism allows you to use a single\ninterface for inputs of various data types, classes, or even for a different\nnumber of inputs. Polymorphism can be defined in a variety of ways in\nPython.\nPolymorphism in operators\nIn Python programs, we know that the operator is frequently used. It does\n+\nnot, however, have a single application. The operator is used to perform\n+\narithmetic addition on integer data types. Similarly, the operator is used to\n+\nconcatenate string data.\nExample 11.20:\nx = 11\ny = 22\nprint (x+y)\nA = \"Python\"\nB = \"Programming\"\nC= \"Book\"\nprint (A+\" \"+B+ ' '+C)\nOutput:\n33\nPython Programming Book\nFunction Polymorphism Several Python functions can work for a variety of data types. The\nlen()\nfunction is an example of such a function. Python allows it to work with a\nvariety of data types. The function will operate with various data\nlen()\ntypes, including string, list, tuple, set, and dictionary. It does, however, return\nspecific information about specific data types.\nExample 11.21:\nprint (len(\"Python Programming\"))\nprint (len([\"Amit\", \"Sumit\", \"Rohit\"]))\nprint (len({\"Id\": 10001, \"Address\": \"Mumbai\"}))\nprint (len('1234'))\nOutput:\n18\n3\n2\n4\nPolymorphism in Class methods\nSince Python allows various classes to have the same name methods, we may\nuse the principle of polymorphism when constructing class methods. We may\nconstruct a loop that iterates over a tuple of objects in this case. After\nfor\nthat, we call the methods without regard to the class type of each object. We\npresume that each class has these methods.\nExample 11.22:\n# Polymorphism in classes\nclass A():\ndef fun1(self):\nprint (\"function 1 of A\")\ndef fun2(self):\nprint (\"function 2 of A\")\nclass B():\ndef fun1(self): print (\"function 1 of B\")\ndef fun2(self):\nprint (\"function 2 of B\")\nobj1 = A()\nobj2 = B()\nfor i in (obj1, obj2):\ni.fun1()\ni.fun2()\nOutput:\nfunction 1 of A\nfunction 2 of A\nfunction 1 of B\nfunction 2 of B\nMethod overriding (polymorphism in inheritance)\nPolymorphism in Python allows one to identify methods in the child class\nwith the same name as the parent class's methods. In inheritance, the methods\nof the parent class are passed on to the child class. However, a child class\nmethod that has inherited from the parent class may be modified. This is\nespecially useful when the parent class's inherited method doesn't quite suit\nthe child class. In such instances, the method is re-implemented in the child\nclass. Method overriding is the process of re-implementing a method in a\nchild's class.\nExample 11.23:\n# Example of method overriding\nclass Emp:\ndef b1(self):\nprint ('It is Base Class')\ndef fun1(self):\nprint ('Employee Class')\nclass Dept(Emp):\ndef fun1(self): print ('Department class')\nclass Sale(Emp):\ndef fun1(self):\nprint ('Sales class')\ne1 = Emp()\ne1.b1()\ne1.fun1()\nprint('------------')\nd1 = Dept()\nd1.b1()\nd1.fun1()\nprint ('------------')\nsl = Sale()\nd1.b1()\nsl.fun1()\nOutput:\nIt is Base Class\nEmployee Class\n------------\nIt is Base Class\nDepartment class\n------------\nIt is Base Class\nSales class\nPython built-in class functions\nThe following are a class's built-in functions:\n: It's used to get the object's attribute.\ngetattr(obj, name, default)\n: It's used to give a specific value to an\nsetattr(obj, name, value)\nobject's attribute.\n: It deletes a specific attribute.\ndelattr(obj, name) : If the object has a particular attribute, it returns\nhasattr(obj, name)\ntrue.\nExample 11.24:\nclass Emp:\ndef __init__(self, Emp_name, Emp_id, Emp_age):\nself.Emp_name = Emp_name\nself.Emp_id = Emp_id\nself.Emp_age = Emp_age\n# object of the class Emp\nE= Emp(\"Amit\", 1001, 30)\n# printing attribute name of the object E\nprint (getattr(E, 'Emp_name'))\n# Changing the value of attribute Emp_age to 40\nsetattr(E, \"Emp_age\", 40)\n# Display modified value of Emp_age\nprint (getattr(E, 'Emp_age'))\n# prints true if the Emp contains the attribute with Emp_id\nprint (hasattr(E, 'Emp_id'))\n# deleting one attribute\ndelattr(E, 'Emp_id')\n# It will show an error since the attribute Emp_id has been\ndeleted\nprint (E.Emp_id)\nOutput:\nAmit\n40\nTrue\nTraceback (most recent call last):\nFile \"<string>\", line 26, in <module>\nAttributeError: 'Emp' object has no attribute 'Emp_id' Python built-in class attributes\nIn addition to the other attributes, a Python class has several built-in class\nattributes that provide information about the class. The built-in class\nattributes are below:\n: It provides a dictionary with class namespace details.\n__dict__\n: It has a string with the documentation for the class.\n__doc__\n: It's used to get the name of the class.\n__name__\n: It allows you to get to the module where this class is\n__module__\ndefined.\n: It has a tuple that includes all base classes.\n__bases__\nExample 11.25:\nclass Emp:\ndef __init__(self, Emp_name, Emp_id, Emp_age):\nself.Emp_name = Emp_name\nself.Emp_id = Emp_id\nself.Emp_age = Emp_age\ndef show(self):\nprint (self.Emp_name)\nprint (self.Emp_age)\nobj = Emp(\"Joy\",1001,30)\nprint (obj.__doc__)\nprint (obj.__dict__)\nprint (obj.__module__)\nprint (show.__name__)\nprint (Emp.__bases__)\nOutput:\nNone\n{'Emp_name': 'Joy', 'Emp_id': 1001, 'Emp_age': 30}\n__main__\nshow\n(<class 'object'>,) Class or static variables\nAll objects share the class or static variables. For different objects, non-\nstatic variables or instance variables vary. Class variables have a value\nassigned to them in the class declaration, while instance variables or non-\nstatic are variables that have values assigned to them within methods.\nExample 11.26:\n# Class declaration\nclass Student:\nfees = 50000 # Class or static variable\ndef __init__(self,id,name):\nself.id = id # Instance or non-static\nVariable\nself.name = name\n# Objects creation\ns1 = Student(101,'Amit')\ns2= Student(102,'Sumit')\nprint (s1.fees) # prints 50000\nprint (s2.fees) # prints 50000\nprint (s1.id) # prints 101\nprint (s2.id) # prints 102\nprint (s1.name) # prints Amit\nprint (s2.name) # prints Sumit\n# Class variables can be accessed using class name also\nprint (Student.fees) # prints 50000\n# we change the fees for just s1 it won't be changed for s2\ns1.fees = 25000\nprint (s1.fees) # prints 25000\nprint (s2.fees) # prints 50000\n# To change the fees for all we can change them directly from\nthe class\nStudent.fees = 40000\nprint (s2.fees) # prints 40000 Output:\n50000\n50000\n101\n102\nAmit\nSumit\n50000\n25000\n50000\n40000\nClass method vs. static method\nThe decorator is a built-in function decorator that evaluates\n@classmethod\nafter your function is specified. The outcome of that analysis casts a shadow\nover your function definition. The class is implicitly passed as the first\nargument to a class method, just as the instance is implicitly passed to an\ninstance method.\nSyntax:\nclass <class_name>:\n@classmethod\ndef <function_name>(cls, arg1, afr2,\u2026):\n#Function Body\nreturn value\nClass method properties are described below:\nA class method is bound to the class rather than the class's object.\nSince it takes a class parameter those points to the class rather than the\nobject instance, they have access to the class's state.\nIt can change the state of a class that affects all of its instances. It can,\nfor instance, change a variable that affects all instances.\nclass\nAn implicit first argument is not passed to a static method. The\ndecorator is used for static methods.\n@staticmethod Syntax:\nclass <class_name>:\n@staticmethod\ndef <function_name>(cls, arg1, afr2,\u2026):\n#Function Body\nreturn value\nThe following are static method properties:\nA static method is one that is bound to the class rather than the class's\nobject.\nA static method can't access or change the state of the class.\nIt is present in a class since the method makes sense to be present in a\nclass.\nExample 11.27:\n# Example of class method and static method.\nfrom datetime import date\nclass Student:\ndef __init__(self, name, age):\nself.name = name\nself.age = age\n# a class method to create a Student object by birth year.\n@classmethod\ndef fromBOD(cls, name, year):\nreturn cls(name, date.today().year - year)\n# a static method to check if a Student is adult or not.\n@staticmethod\ndef isAdult(age):\nreturn age > 18\ns1 = Student('Ankit', 25)\ns2 = Student.fromBOD('Ankit', 1996)\nprint (s1.age)\nprint (s2.age) # print the result\nprint (s2.isAdult(25))\nOutput:\n25\n25\nTrue\nClass decorator\nDecorators are a potent and valuable Python tool because they enable\nprogrammers to change a function or class's behavior. Decorators allow us to\nwrap another feature to expand its behavior without changing it permanently.\nWe may describe a decorator as a class by using the method.\n__call__\nWhen a user wants to construct an object that acts like a function, the function\ndecorator must return an object that acts like a function, which is where\ncomes into use.\n__call__\nExample 11.28:\nclass DecoratorExample:\ndef __init__(self, fun):\nprint ('This is constructor')\nself.fun = fun\ndef __call__(self):\n# Before function call code.\nprint ('Before function call')\nself.fun()\n# After function calls code.\nprint ('After function call')\n# adding class decorator to the fun\n@DecoratorExample\ndef fun():\nprint (\"Class decorator\")\n# function call\nfun() Output:\nThis is constructor\nBefore function call\nClass decorator\nAfter function call\nRecursive calls to functions\nA method of programming or coding a problem in which a function calls\nitself one or more times in its body is known as recursion. Typically, it\nreturns the function call's return value. We call a function recursive if its\ndescription meets the recursion condition. In Python, we can call a function\ninside another function. In the same way, we can call a function recursively\ninside its body.\nExample 11.29:\n# Recursive function example\n# Function to compute factorial of a given number\ndef fact(n):\nif n == 1:\nreturn 1\nelse:\nreturn (n * fact(n-1))\nx = 6\nprint (\"The factorial value of\", x, \"is\", fact(x))\nOutput:\nThe factorial value of 6 is 720\nConclusion\nIn this chapter, we discussed the concepts of object-oriented programming\nand their implementation in Python. We discussed constructor, inheritance,\npolymorphism, etc. Various built-in class functions and attributes are\ndescribed with the help of examples. Based on these examples, you can write your code for object-oriented programming. In the next chapter, we will\ndiscuss machine learning concepts and their implementations in Python.\nPoints to remember\nPython is object-oriented programming.\nIn Python, almost everything is an object with its own set of properties\nand methods.\nDecorators are a powerful and valuable Python tool. They allow\nprogrammers to modify the behavior of a function or a class,\nWe can implement hybrid inheritance with the help of other\ninheritances.\nMultiple choice questions\n1. Which of the following is not an OOPs concept?\na. Encapsulation\nb. Polymorphism\nc. Exception\nd. Abstraction\n2. What type of inheritance is illustrated in the following Python\ncode?\nclass A():\npass\nclass B():\npass\nclass C(A,B):\npass\na. Multi-level inheritance\nb. Multiple inheritance\nc. Hierarchical inheritance\nd. Single-level inheritance 3. Which of the following is not a type of inheritance?\na. Double level\nb. Multi-level\nc. Single level\nd. Multiple\n4. The _________ keyword defines a template indicating what data\nand code will be contained in each object of type.\na. class\nb. object\nc. Class\nd. Instance\n5. _____ is used to create an object.\na. class\nb. constructor\nc. User-defined functions\nd. In-built functions\nAnswers\n1. c\n2. b\n3. a\n4. a\n5. b\nQuestions\n1. What is object-oriented programming? List some of its advantages.\n2. What are the main features of OOPs?\n3. Differentiate between an object and a class. 4. Define constructor in Python? Also, give an example.\n5. What is the difference between multiple and multi-level inheritance?\n6. What is the concept of the overriding method? Give an example for the\nsame.\n7. What are Python decorators?\n8. Write the difference between a class method and a static method.\n9. Describe polymorphism with a suitable example.\n10. Write code to use the method to assign values to data\n__init__()\nattributes in Python? CHAPTER 12\nMachine Learning with Python\nachine learning is a branch of computer science that allows computers to\nM\nuse data in the same way that humans do. It is a form of artificial\nintelligence that uses an algorithm or a method to extract patterns from raw\ndata. The goal of machine learning is to encourage computers to learn from\ntheir experiences without being specifically programmed or requiring human\ninteraction. In this chapter, you will be familiar with various machine\nlearning approaches and applications. Besides, we have demonstrated\nvarious machine learning algorithms with the help of examples and codes.\nStructure\nIn this chapter, we will cover the following topics:\nThe basic concepts of machine learning\nApplications of machine learning\nTypes of machine learning\nVarious Python libraries for machine learning\nPython codes to implement machine learning approaches\nObjective\nThe objective of this chapter is to introduce the concept of machine learning.\nAfter completing this chapter, you will be able to implement and analyze the\nexisting learning algorithms, including well-studied methods for\nclassification, regression, prediction, and clustering learning. Also, you will\nbe able to write Python codes for machine learning approaches.\nIntroduction to machine learning Machine learning is the science (and art) of programming computers so they\ncan learn from data. It is the field of study that gives computers the ability to\nlearn without being explicitly programmed. A computer program is said to\nlearn from experience E concerning some task T and some performance\nmeasure P, if its performance on T, as measured by P, improves with\nexperience E. For example, through experience gained by playing games\nagainst itself, a computer program that learns to play checkers may improve\nits performance, measured by its ability to win in the class of tasks involving\nplaying checkers games.\nThe concept of self-learning is the key attribute of machine learning. This\nrefers to implementing statistical modeling, all without direct programming,\ninstructions, identifying correlations, and enhancing performance based on\ndata and analytical knowledge. This is what is described as the ability to\nlearn without being explicitly programmed. The machine can perform a task\nusing input data rather than relying on a direct input command. To construct a\ndecision model, machine learning uses data as feedback. Decisions are\ngenerated by deciphering relationships and patterns in the data using\nprobabilistic reasoning, trial and error, and other computation-intensive\ntechniques. It means that the decision model's output is decided not by any\npre-set rules specified by a human programmer but rather by the input data's\nquality. To minimize prediction errors, the human programmer always\nresponds to feeding the data into the model, choosing an appropriate\nalgorithm, and tweaking its settings (called hyper-parameters) and standard\nprogramming, the computer and the developer work a layer apart.\nInput data is usually split into training data and test data in machine learning.\nThe first split of data is the training data, which is the initial reserve of data\nused to develop the model. After developing the model, we can test the\nremaining data model known as the test data by using patterns extracted from\nthe training data, satisfied with its prediction accuracy. If the model's\nperformance is satisfactory by using the test data then the model is ready to\nuse with the applications.\nUses of machine learning\nProblems for which existing solutions require many fine-tuning or long\nlists of rules: one machine learning algorithm can often simplify code\nand perform better than the traditional approach. Complex problems using a traditional approach yields no right solution:\nthe best machine learning techniques can perhaps find a solution.\nFluctuating environments: a machine learning system can adapt to new\ndata.\nWe get insights into complex problems and large amounts of data.\nTraditional programming v\/s machine learning\nAs a unique way to program machines, one genuine way to think about\nmachine learning is that most programming that is not machine learning is\nprocedural and is a set of rules defined by humans. This ruleset is called as\nan algorithm. The following figure shows the concepts of the traditional\nprogramming approach:\nFigure 12.1: Traditional programming approach\nIn machine learning, a person chooses the underlying algorithm or designs it.\nHowever, the algorithms learn about the parameters that shape a\nmathematical model for making predictions from knowledge rather than\ndirect human interference. Humans do not know certain conditions or set\nthem-the computer does. Put another way, train a mathematical model, and use a data set when it sees something similar. The concepts of machine\nlearning approaches are shown in figure 12.2:\nFigure 12.2: A machine learning approach\nThe following figure illustrates how machine learning integrates into data\nscience and computer science's broader landscape: Figure 12.3: Integration of machine learning into a data science and computer science\nApplications of machine learning\nThere are different areas where machine learning is commonly used. Some of\nthe machine learning applications and their techniques are described as\nfollows:\nImage recognition: Before performing any tasks related to images, it is\nalmost necessary to process the images to make them more suitable as\ninput data. It is the conversion of JPEG or PNG file format images to\nusable data for neural networks. To process the image into data, we\nmay use the TensorFlow library in the Python programming language as\nit provides a variety of tools to retrieve the data from an image file. We\ncan resize the image file or even act on a large set of images all at once.\nSpeech recognition: Speech recognition saves us time by speaking\ninstead of typing. It enables us to communicate with machines without\neven writing the programming code. Speech recognition is a great\ninstance of using machine learning in real life. A suitable example is the\nGoogle Meet web application. CMU Sphinx, Kaldi,\nSpeechRecognition, and Wav2letter++ are the speech recognition\nlibraries that we can use to process the audio file.\nTraffic prediction: RNN (Recurrent Neural Network) deep learning\nmay be used to find patterns from traffic datasets to predict if severe\ntraffic jams will happen shortly. Using the Geopandas package of\nPython, we can differentiate the traffic event of a given huge traffic\ndataset. Three forms of traffic incidents are seen, including road delays,\ncollisions, and \"stopped cars on the shoulder.\" We require GPU or TPU\n(Tensor Processing Unit), and Google Colaboratory service offers this\nfree for deep learning. On Google Chrome, we may install a plugin\ncalled Collaboratory.\nSelf-driving cars: Train an end-to-end deep learning model in a driving\nsimulator that would make a car drive around the track by itself. The\nregression problem between the vehicle steering angles and the road\nimages from a car's cameras is tracked in real-time. The driving\nsimulator saves frames from three different front-facing cameras,\nrecords data from the vehicle's point of view, and different driving data like speed, throttle, reverse, and steering angle. We may use matplotlib,\nKeras, NumPy, pandas, or scikit-learn environment and tools.\nEmail spam and malware filtering: An email is one of the most useful\nnetworking methods, and one of the essential features is efficient\ncommunication, Spam, and malware filtering. The outline for a spam\nfiltering system with scratch is 1.) EDA (Exploratory Data Analysis),\n2.) Data Processing, 3.) Feature Extraction, 4.) Scoring & Metrics, 5.)\nImprovement by using Embedding and Neural Network, 6.) Comparison\nof ML & Deep Learning algorithms. We can avail the data set from UC\nIrvine Machine Learning Repository, Kaggle Datasets, AWS Datasets,\nor from Spam Assassin. Two types of data present in the repository are\nHam (not Spam) and Spam data. The Ham data is complicated or\nstraightforward, meaning that specific non-spam data have a strong\nresemblance to spam data, which could cause some trouble deciding for\nthe system.\nDetecting tumors in brain scans: Basically, a tumor is an excessive\nproliferation of cells in some portion of the body, and a brain tumor is a\ncollection or mass accumulated in the brain of these irregular cells. It is\nclassified as primary in two categories, arising in the brain and\nsecondary brain tumor that develops in the brain but arises from the\nspread of a malignant tumor anywhere in the body.\nMagnetic resonance imaging (MRI) is a widely used medical\ntechnology for diagnosing various tissue anomalies, including brain\ntumor detection and diagnosis. The active growth in computerized\nimage segmentation allows doctors to recognize and imagine\nabnormalities to take the necessary steps to optimize fast decision-\nmaking therapy. The main challenges associated with medical imaging\ntraining machine learning models are the high cost of acquiring each\ndataset, receiving patient consent, and an expert's cost analysis of the\nimage.\nCreating a chatbot or a personal assistant: Chat-bot is software for\ncomputers that helps to communicate via messages. To imitate human\nbehavior, they are formulated. ALICE is one of the most popular\nchatbots that work on pattern matching strategy. Pattern matching\nstrategy is the Artificial Linguistic Internet Computer Entity\n(ALICE). ALICE's AIML files are accessible online and include categories such as music, art, philosophy, meetings, etc. for the pattern\nmatching system of chat-bot, AIML files are used.\nFraud detection: Bank purchases via credit or debit cards have risen\ndramatically in recent years, and an increase has also followed this in\nidentity fraud. Financial institutions need to develop efficient and\nproactive fraud detection systems to manage this problem. To deal with\nthis problem, machine learning is a promising solution. In the issue of\nfraud detection, transaction data is categorized and evaluated as\nlegitimate or fraudulent. The fraud detection method is split into two\ngeneral categories: fraud analysis (detection of misuse) and user\nbehavior analysis (Anomaly detection).\nStock market trading: Python can be used to illustrate the idea that\nstock prices obey a random -walk. The random walk does not eliminate\nthe likelihood of beating the market, nor does it support tossing\ninvestment models, but it suggests that these models should be\nconstructed and continuously re-evaluated with extreme care and\ndiligence. The random-walk principle notes that it is not possible to\nforecast stock prices because stock price movements are random.\nMedical diagnosis: Machine learning diagnosis works when the\ndisorder can be reduced to a physiological data classification task in\nplaces where we currently rely on the clinician to be able to visually\ndistinguish patterns that suggest the condition's presence or form.\nAutomatic language translation: The use of software to translate text\nor speech from one language to another is investigated by automatic\nlanguage translation or automatic translation abbreviated by the MT.\nFor MT, we can use a deep neural network. We can figure out how to\nbuild a translation model for neural machines to translate one language\ninto another (For example, English to French). The model accepts\nEnglish text as input and returns the other translation of the language. To\nrun the code that has access to GPU instances, we can use the AWS\nEC2 case.\nAutomatically classifying news articles: We need to know what the\nnews stories are about - we need to identify them to link people with\nthe right content. The articles can be classified into over 80 categories,\nsuch as music, culture, architecture, opinion, food, etc. When an article\nis written, the first step in the pipeline is to remove all the article elements, such as text, title, images, writers, and URLs, and what the\narticle is all about is the classification part.\nForecasting your company's revenue next year, based on many\nperformance matrices: The SpringML app simplifies forecasting by\nrunning ML models that automatically run and include a monthly or\nquarterly revenue metric forecast for a consumer (Example, Revenue,\nACV, and Quantity). Sales leaders will use these historical data-\nconsuming models to gauge pattern and seasonality and current\nopportunities pipeline for the next 6 to 12 months to forecast. A precise\nforecast helps companies to make informed business choices. Some of\nthe forecast methods are given below: 1.) Forecasting time series using\nBayesian models. 2.) Provide the time series predictors. 3.) Evaluate\ncurrent pipeline data on open opportunities by running classification\nalgorithms. 4.) Before finalizing the best set of models to use, evaluate\nthe ensemble over the previous few months.\nSegmenting clients based on their purchases so that you can design\na different marketing strategy for each segment: Based on specific\nessential attributes that may help a business sell more goods at lower\nmarketing prices, market segmentation distinguishes the target market or\nconsumers. We can use ML algorithms based on multiple trees for\nsegmentation. Multiple Additive Regression Tree, Random Forest, and\nBoosting Stochastic Gradient are techniques that render predictions\nusing a multitude of trees and an ensemble of the same.\nA client may be interested in recommending a product based on\npast purchases: Using various algorithms, a recommendation engine\nfilters the data and recommends to users the most important things. It\nfirst captures a customer's past actions and based on that, suggests items\nthat users would be willing to purchase. We may suggest products to a\ncustomer who is the most common among all users. Based on their\ninterests, we can break the users into different segments and suggest\nproducts based on the segment to which they belong.\nBuilding an intelligent bot for a game: We can use Reinforcement\nLearning basics, or we can assume that the game Snake applies Deep\nReinforcement Learning (Neural Network + Q-Learning). We can create\nan AI Agent capable of learning how to play the iconic Snake from\nScratch game, and we use Keras on top of Tensorflow to implement a Deep Reinforcement Learning Algorithm. Reinforcement learning is an\napproach to making decisions based on the Markov Decision Process.\nInstead of a conventional supervised ML approach, we could use Deep-\nQ-Learning. We have two main components in Reinforcement Learning:\nthe environment (game) and the agent (Snake). The environment\nrewards the agent each time the agent acts, which can be positive or\nnegative based on how successful the state's action was.\nTypes of machine learning\nMachine learning systems are mainly categorized into two types based on the\nprocedure of their learning. If the machine is trained under human\nsupervision with label data, it is classified as a supervised learning system.\nIf the machine is trained without human or any label data, the system\nclassifies the data based on similarity or a pattern, it is called an\nunsupervised learning system. Supervised learning is the most exploited form\nof machine learning system and requires extensive data but is the easiest form\nof machine learning.\nSupervised learning\nIn supervised learning, machines learn under the supervision of label data in\nwhich the data set comprises input variables that correspond to the output\nvariables on which the machine learns. There is training data on the which\nmachine is trained by entering some data as an input and giving output\naccording to its training, for example, credit risk, the machine gives\noutcomes based on the credit history as an input and gives a result\ncorresponding to the credit risk. The machine learns to construct a model by\nproviding consistent input-output samples and is trained on it. It is the type of\nmachine learning in which we have an input variable(X) corresponds to\noutput variables F(X), and the model is supervised to learn the correlation of\nthe variables. Supervised learning is also classified as:\nClassification: A machine learning model helps us differentiate the data\ninto separate categories and classify the data as input into specific\ncategories. For example, in medical cases, if a patient is diagnosed\nwith cancer, the machine gives outcomes based on symptoms as its input and gives output positive or negative. Another example is to\ncategorize the pictures of animals into a cat group and a dog group.\nRegression: Regression is like classification, but the only difference\nbetween them is that classification is done only on the discrete values,\nbut in regression, we use continuous values to categorize the data. For\nexample, a model predicts how many years the person will be sick or\nhealthy by giving a radiological image as an input.\nUnsupervised learning\nIn unsupervised learning, the output variables corresponding to input\nvariables are not given. The variables are unlabeled. In unsupervised\nlearning, the model tries to identify the pattern in the given variables and find\nthe hidden pattern that can help create new labels regarding possible outputs.\nIn supervised learning, we train the machine by using input data and no\nassociation with output variables. The motive of using unsupervised learning\nis to find the hidden pattern of the data. This is called an unsupervised\nlearning because there is no labeled data, and the machine learns without the\nhuman's supervision. The machine automatically finds the pattern between the\ndata, and it is classified into two groups clustering and association problems.\nClustering: A clustering issue is where you want to discover the\ninherent groupings in the data, such as by buying activity and grouping\ncustomers.\nAssociation: The learning issue of an association rule is that you want\nto find rules that explain large portions of your data, such as individuals\nwho buy X also tend to buy Y.\nPython libraries for machine learning\nPython is now one of the most popular programming languages for machine\nlearning tasks, and it has largely replaced many other languages in the field,\ndue to its extensive library of functions. Machine Learning Python libraries\ninclude:\nNumpy It is one of the most popular libraries in Python for machine learning. It is\nused to process matrix and multi-dimensional arrays. In this mathematics,\nfunctions are present in large quantities that are very useful for the scientific\ncomputation of scientific data in machine learning.\nExample 12.1:\nimport numpy as np\n# Creating two arrays of rank 2\np = np.array([[1, 2], [3, 4]])\nq = np.array([[5, 6], [7, 8]])\nprint (p)\nprint (q)\nOutput:\n[[1 2]\n[3 4]]\n[[5 6]\n[7 8]]\nPandas\nIt is a data analysis library in Python that is mainly used to manipulate and\nanalyze data. It comes into play before the dataset is prepared for training. It\nis a Python library that gives us a set of tools to analyze data. In Pandas, we\ncan load, prepare, manipulate, model, analyze data, join data, merge data,\nreshape data, and take data from different databases, put it together, and\nanalyze it.\nExample 12.2:\n# importing pandas as pd\nimport pandas as pd\ndata = {\"state\": [\"Delhi\", \"Rajasthan\", \"Maharashtra\",\n\"Gujarat\", \"Punjab\"],\n\"capital\": [\"New Delhi\", \"Jaipur\", \"Mumbai\",\n\"Gandhinagar\", \"Chandigarh\"]\n} data_table = pd.DataFrame(data)\nprint (data_table)\nOutput:\nstate capital\n0 Delhi New Delhi\n1 Rajasthan Jaipur\n2 Maharashtra Mumbai\n3 Gujarat Gandhinagar\n4 Punjab Chandigarh\nScikit-learn\nWith the help of the library in Python, we can use various machine\nscikit\nlearning algorithms like classification, regression, clustering, reduction of\ndimensionality, selection of the model and preprocessing, etc. It is one of the\nmost concerning machine learning libraries in Python. It can easily\ncollaborate with different libraries of machine learning programming, for\nexample, Numpy, and Pandas.\nExample 12.3:\n# Sample Decision Tree Classifier\nfrom sklearn import datasets\nfrom sklearn import metrics\nfrom sklearn.tree import DecisionTreeClassifier\n# load the iris datasets\ndataset = datasets.load_iris()\n# fit a CART model to the data\nmodel = DecisionTreeClassifier()\nmodel.fit(dataset.data, dataset.target)\nprint (model)\n# make predictions\nexpected = dataset.target\npredicted = model.predict(dataset.data)\n# summarize the fit of the model print (metrics.classification_report(expected, predicted))\nprint (metrics.confusion_matrix(expected, predicted))\nOutput:\nDecisionTreeClassifier(class_weight=None, criterion='gini',\nmax_depth=None,\nmax_features=None, max_leaf_nodes=None,\nmin_impurity_decrease=0.0, min_impurity_split=None,\nmin_samples_leaf=1, min_samples_split=2,\nmin_weight_fraction_leaf=0.0, presort=False,\nrandom_state=None,\nsplitter='best')\nprecision recall f1-score support\n0 1.00 1.00 1.00 50\n1 1.00 1.00 1.00 50\n2 1.00 1.00 1.00 50\navg \/ total 1.00 1.00 1.00 150\n[[50 0 0]\n[0 50 0]\n[0 0 50]]\nMatplotlib\nIt is a 2D plotting library for Python programming that is used for data\nvisualization to generalize various figures and high-quality image plots; with\nthe help of the Matplot library, we can easily generalize the various diagrams\nlike histogram, scatter plots, plot error charts, bar charts with just only a few\nlines of code.\nExample 12.4:\nimport matplotlib.pyplot as plt\nimport numpy as np\n# Prepare the data\nx = np.linspace(0, 20, 200)\n# Plot the data\nplt.plot(x, x, label ='linear') # Add a legend\nplt.legend()\n# Show the plot\nplt.show()\nOutput:\nFigure 12.4: Example of a plot\nTensorflow\nIt was initially developed for internal use by the Google brain team. And\ncame into existence in November 2015 under Apache licenses 2D. It helps to\nproduce a machine learning models framework. It supports different types of\ntoolkits for constructing machine learning models that provide different\nlevels of abstraction.\nExample 12.5:\n# import `tensorflow`\nimport tensorflow as tf\nwith tf.compat.v1.Session() as sess:\nx = tf.constant(10.0)\ny = tf.constant(8.0) z = tf.multiply(x, y)\nresult = sess.run(z)\nprint (result)\nOutput:\n80.0\nKeras\nKeras is widely used in Python programming. It provides us with a high-\nlevel neural network API capable of running on top of CNTK, TensorFlow,\nor Theano.\nExample 12.6:\nimport numpy as np\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras import layers\nPytorch\nPython has a large number of tools and libraries that helps us with working\ncomputer vision, machine learning, and processing of natural language. It is\none of the open-source libraries which can easily be used and learned\nquickly. Python can easily combine with the Python data science stack, even\nwith the Numpy. There is a little bit of difference between the functioning of\nNumpy and Pytorch. It can also perform computation on tensors.\nIf Pytorch is not installed earlier, then it can be installed by the\nfollowing command: >\npip install torch\nExample 12.7:\nimport torch\nimport math\ndtype = torch.float\ndevice = torch.device(\"cpu\") # Create random input and output data\nx = torch.linspace(-math.pi, math.pi, 3000, device=device,\ndtype=dtype)\ny = torch.sin(x)\nprint (x)\nprint (y)\np=torch.linspace(3, 10, steps=5)\nprint (p)\nq=torch.linspace(-10, 10, steps=5)\nprint (q)\nOutput:\ntensor([-3.1416, -3.1395,\n-3.1374, \u2026, 3.1374, 3.1395, 3.1416])\ntensor([8.7423e-08, -2.0949e-03, -4.1901e-03, \u2026, 4.1901e-\n03, 2.0949e-03, -8.7423e-08])\ntensor([3.0000, 4.7500, 6.5000, 8.2500, 10.0000])\ntensor([-10., -5., 0., 5., 10.])\nNLTK\nNLTK stands for natural language toolkit and a library used in Python that\nhelps us process natural language. NLTK is the most popular library for\nPython programming that helps in working with human languages. It offers to\nuse the frame net, Wordvec, WordNet, and some others to the programmer,\nand it provides us with the interface and some lexical resources. Some of the\nprimary functions of the NLTK is to find the keywords in documents, voice\nrecognition, stemming of words, and lemmatizing and handwriting.\nYou can install NLTK 3.0, downloadable free of charge from http:\/\/nltk.org\/.,\nbefore going on. To download the version needed for your platform, follow\nthe instructions there.\nStart the Python interpreter as before, after you have installed NLTK, and\ninstall the necessary data for the book by typing the following two commands\nat the Python prompt, then selecting the book set as shown in figure 12.5:\n>>> import nltk\n>>> nltk.download() Figure 12.5: Downloading the NLTK Book Collection using nltk.download().\nExample 12.8:\nimport nltk\nsentence = \"\"\"At Five o'clock on Monday morning\n\u2026 John didn't feel very good and want to do rest.\"\"\"\ntokens = nltk.word_tokenize(sentence)\nprint (tokens)\nOutput:\n['At', 'Five', \"o'clock\", 'on', 'Monday', 'morning', '\u2026',\n'John', 'did', \"n't\", 'feel', 'very', 'good', 'and', 'want',\n'to', 'do', 'rest', '.']\nExample: Loading Text from nltk.book import *\nOutput:\n*** Introductory Examples for the NLTK Book ***\nLoading text1, \u2026, text9 and sent1, \u2026, sent9\nType the name of the text or sentence to view it.\nType: 'texts()' or 'sents()' to list the materials.\ntext1: Moby Dick by Herman Melville 1851\ntext2: Sense and Sensibility by Jane Austen 1811\ntext3: The Book of Genesis\ntext4: Inaugural Address Corpus\ntext5: Chat Corpus\ntext6: Monty Python and the Holy Grail\ntext7: Wall Street Journal\ntext8: Personals Corpus\ntext9: The Man Who Was Thursday by G . K . Chesterton 1908\nExample 12.9: Searching Text\nfrom nltk.book import *\ntext1.concordance(\"women\")\nOutput:\nDisplaying 11 of 11 matches:\nAt creation's final day. And the women of New Bedford, they\nbloom like the\nhere these silent islands of men and women sat steadfastly\neyeing several marble\nFishery, and so plainly did several women present wear the\ncountenance if not, and a still slighter shuffling of women'\ns shoes, and all was quiet again\nthe bitterest threat of your night - women, that beat head -\nwinds round crone\nsoon. Now would all the waves were women, then I'd go\ndrown, and chassee\nby small tame cows and calves; the women and children of\nthis routed host. N the bowels, I suppose, as the old women talk Surgeon's\nAstronomy in the ba\nup the live bodies of all the men, women, and children who\nwere alive sevents. Lord! What an affection all old women\nhave for tinkers. I know an old wom\never would work for lonely widow old women ashore, when I\nkept my job - shop i\nUnderstanding regression\nRegression finds the relationships between the variables. For example, if we\nwant to determine the dependency of the salaries on the other features like\nexperience, education level, their role, and the city in which they work, etc.,\nwe can use regression. In regression, we relate the data of each employee.\nThe data of each employee denotes the one observation in regression. In this,\nwe assume the experience, city, education level, and role as independent\nfeatures.\nLinear regression\nOur goal is to find the relationship between one or more. Our main motive is\nto find the relationship between one or more independent features and\ndependent features that are the continuous target in the linear regression\nmodel. If there is one feature, it is known as univariate linear regression, and\nif there is more than one feature, it is known as multiple linear regressions.\nExample 12.10:\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_squared_error, r2_score\n# generate random data-set\nnp.random.seed(0)\nx = np.random.rand(50, 1)\ny = 2 + 3 * x + np.random.rand(50, 1)\n# sckit-learn implementation\n# Model initialization regression_model = LinearRegression()\n# Fit the data(train the model)\nregression_model.fit(x, y)\n# Predict\ny_predicted = regression_model.predict(x)\n# model evaluation\nrmse = mean_squared_error(y, y_predicted)\nr2 = r2_score(y, y_predicted)\n# printing values\nprint ('Slope:', regression_model.coef_)\nprint ('Intercept:', regression_model.intercept_)\nprint ('Root mean squared error: ', rmse)\nprint ('R2 score: ', r2)\n# plotting values\n# data points\nplt.scatter(x, y, s=20)\nplt.xlabel('x')\nplt.ylabel('y')\n# predicted values\nplt.plot(x, y_predicted, color='b')\nplt.show()\nOutput:\nSlope: [[2.90625874]]\nIntercept: [2.45805209]\nRoot mean squared error: 0.08296096126059752\nR2 score : 0.8830014727436024 Figure 12.6: Regression plot\nNon-linear regression\nNon-linear regression is a type of polynomial regression. It is a method to\ncreate a mode that finds a non-linear relationship between the dependent and\nindependent variables. We used non-linear regression when the data had a\ncurving trend, and it produced more accurate findings than linear regression.\nThis is because we already assume that the data is linear.\nExample 12.11:\nimport numpy, scipy, matplotlib\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import curve_fit\nfrom scipy.optimize import differential_evolution\nimport warnings\nxData = numpy.array([20.1647, 19.019, 16.9580, 15.7683,\n14.7044, 13.6269, 12.6040, 11.4309, 10.2987, 9.23465,\n8.18440, 7.89789, 7.62498, 7.36571, 7.01106, 6.71094,\n6.46548, 6.27436, 6.16543, 6.05569, 5.91904, 5.78247,\n5.53661, 4.85425, 4.29468, 3.74888, 3.16206, 2.58882,\n1.93371, 1.52426, 1.14211, 0.719035, 0.377708, 0.0226971, -0.223181, -0.537231, -0.878491, -1.27484, -1.45266,\n-1.57683, -1.61717])\nyData = numpy.array([0.644557, 0.641059, 0.637555, 0.634059,\n0.634135, 0.631825, 0.631899, 0.627209, 0.622516, 0.617818,\n0.616103, 0.613736, 0.610175, 0.606613, 0.605445, 0.603676,\n0.604887, 0.600127, 0.604909, 0.588207, 0.581056, 0.576292,\n0.566761, 0.555472, 0.545367, 0.538842, 0.529336, 0.518635,\n0.506747, 0.499018, 0.491885, 0.484754, 0.475230, 0.464514,\n0.454387, 0.444861, 0.437128, 0.415076, 0.401363, 0.390034,\n0.378698])\ndef func(x, a, b, Offset):\nreturn 1.0 \/ (1.0 + numpy.exp(-a * (x-b))) + Offset\n# function for genetic algorithm to minimize (sum of squared\nerror)\ndef sumOfSquaredError(parameterTuple):\n# do not print warnings by genetic algorithm\nwarnings.filterwarnings(\"ignore\")\nval = func(xData, *parameterTuple)\nreturn numpy.sum((yData - val) ** 2.0)\ndef generate_Initial_Parameters():\n# min and max used for bounds\nmaxX = max(xData)\nminX = min(xData)\nmaxY = max(yData)\nminY = min(yData)\nparameterBounds = []\nparameterBounds.append([minX, maxX]) # search bounds for a\nparameterBounds.append([minX, maxX]) # search bounds for b\nparameterBounds.append([0.0, maxY]) # search bounds for\nOffset\n# \"seed\" the numpy random number generator for repeatable\nresults\nresult = differential_evolution(sumOfSquaredError,\nparameterBounds, seed=5)\nreturn result.x\n# generate initial parameter values geneticParameters = generate_Initial_Parameters()\n# curve fit the test data\nfittedParameters, pcov = curve_fit(func, xData, yData,\ngeneticParameters)\nprint ('Parameter are:', fittedParameters)\nmodelPredictions = func(xData, *fittedParameters)\nabsError = modelPredictions - yData\nSE = numpy.square(absError) # squared errors\nMSE = numpy.mean(SE) # mean squared errors\nRMSE = numpy.sqrt(MSE) # Root Mean Squared Error, RMSE\nRsquared = 1.0 - (numpy.var(absError) \/ numpy.var(yData))\nprint ('RMSE value is:', RMSE)\nprint ('R-squared is:', Rsquared)\n# graph\ndef ModelAndScatterPlot(graphWidth, graphHeight):\nf = plt.figure(figsize=(graphWidth\/100.0,\ngraphHeight\/100.0), dpi=100)\naxes = f.add_subplot(111)\n# first the raw data as a scatter plot\naxes.plot(xData, yData, 'D')\n# create data for the fitted equation plot\nxModel = numpy.linspace(min(xData), max(xData))\nyModel = func(xModel, *fittedParameters)\n# now the model as a line plot\naxes.plot(xModel, yModel)\naxes.set_xlabel('X Data') # X axis data label\naxes.set_ylabel('Y Data') # Y axis data label\nplt.show()\nplt.close('all')\nw = 500\nh = 500\nModelAndScatterPlot(w, h)\nOutput:\nParameter are: [0.21593498 -6.66784414 -0.35271173]\nRMSE value is: 0.008432181989377313 R-squared is: 0.9886129643523501\nFigure 12.7: Non-linear regression plot\nIntroduction to classification\nClassification refers to predictive models' problems that classify the input\ndata into a class label. The task of a predictive model is mapping function (f)\nfrom the input (x) to the output (y). Classification is a type of supervised\nlearning where we have the output variables corresponding to the input\nvariables. Classification is used in various domains such as in medical\ndiagnosis, credit approval, target marketing, etc. For example, In Email, the\nmessage's detection as spam or non-spam is a classification problem. In this\nproblem, we use binary classification that classifies messages as spam or\nnon-spam in only two classes. In this classifier, we use the input variable as\ntraining data. So, in this case, the spam and non-spam known emails are used as the training data, and after the training, it can be used to detect the\nunknown emails by giving it as an input. The different types of classification\npredictive modeling problems are:\nBinary classification\nMulti-class classification\nMulti-label classification\nBinary classification\nIn binary classification, we classify the data into two class labels, for\nexample:\nClassification of emails as Spam or not.\nPrediction of conversion buys or not.\nPrediction of churn or not.\nSome popular algorithms which are used for binary classification are:\nLogistic regression\nK-Nearest neighbors\nDecision trees\nSupport vector machine\nNa\u00efve Bayes\nMulti-class classification\nMulti-class classification, unless binary classification, classifies the data\ninto more than two classes, for example:\nClassification of face\nClassification of plant species\nRecognition of optical character\nThe most widely used algorithm for machine learning algorithms are:\nK-Nearest Neighbors\nDecision Trees Na\u00efve Bayes\nRandom forest\nGradient Boosting\nA binary classification algorithm can be used for multi-class problems. This\ncan be done by using the various strategies of fitting multiple binary\nclassification modes.\nOne-vs-rest: That fits for binary classification model for each class vs.\nall other classes.\nOne-vs-one: That fits for binary classification model for every pair of\nclasses.\nWe can also use these strategies of binary classification for multi-class\nclassification includes:\nLogistic regression\nSupport vector machine\nMulti-label classification\nIn this type of classification, there are two or more class labels, where one\nor more class label is used to predict the examples. If we consider the photo\nclassification, in which we have multiple objects in the photo, the model will\npredict the presence of various objects like bicycle, person, apple, etc.\nMulti-class classification is unlike binary classification, in which a single\nlabel of the class is predicted for any example. Multi-label classification is\ncommonly used in predicting the multiple outputs in which every output is\npredicted by using Bernoulli probability distribution. For multi-label\nclassification, we cannot directly use the binary classification algorithm or\nmulti-class classification. We used a specialized version of the multi-label\nclassification are:\nMulti-label Decision tree\nMulti-label Random forests\nMulti-label Gradient boosting\nImbalanced classification An imbalanced classification task is somewhat similar to a binary\nclassification task in which the majority of examples in the training dataset\nbelongs to the normal class and the minority belongs to the abnormal class.\nFor example:\nFraud detection\nDetection of outlier\nDiagnosis tests in medical\nThe binary classification solves this problem; even some may require\nspecialized techniques. From changing the composition of samples in the\nbinary data set using the specialized technique to under-sampling the majority\nclass or oversampling the minority class. For example:\nRandom sampling\nSmote oversampling\nA minority class was used to fit the model on the training dataset.\nSpecialized modeling algorithm is used to train the dataset with minority\nclasses such as cost-sensitive machine algorithm. For examples:\nCost-sensitive logistic Regression\nCost-sensitive Decision trees\nCost-sensitive support vector machine\nClassification methods\nK-Nearest Neighbors\nOne of the simplest classification algorithms is KNN that stands for the K-\nNearest Neighbor, which classifies the data based on its similarities. This\nalgorithm assigns the objects to the nearest class. In this, K represents the\nnumber of neighboring objects in the space of feature compared to\nclassification of the object. For the classification of inputs, we need to\nperform some actions that are:\nMeasurement of the distance between the objects in the training\nsamples. Select the numbers of objects K that are classified in the class, which\nfrequently occurs among the K-nearest neighbor.\nFigure 12.8: KNN classification\nThe figure 12.8 shows an example of KNN classification. In this figure, the\ntest sample (blue circle) should be classified as either class 1 or class 2. If\nK=3 (single line), the test sample was assigned to class 1 because there are\ntwo class elements of class 1 and only one element of class 2.\nIf K=5 (dotted line), the test sample is assigned to class 2 because it has\nthree elements and class 1 has two elements.\nAdvantages: Implementation of this algorithm is very simple, robust for\nnoisy training data, and if the training data is large, it is very effective.\nDisadvantage: The accuracy of the model depends on K's value, and its\nimplementation cost is high as it needs to compute the distance between the\nobjects to all the training samples.\nExample 12.12:\nimport numpy as np import pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.metrics import confusion_matrix, accuracy_score\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn import datasets\ndataset = pd.read_csv('Iris.csv')\n#Summarize the Dataset\nprint ('dataset shape is :', dataset.shape)\nprint ('dataset head :', dataset.head(5))\nprint ('dataset description :', dataset.describe())\ndataset.groupby('Species').size()\n#Dividing data into features and labels\nfeature_columns = ['SepalLengthCm', 'SepalWidthCm',\n'PetalLengthCm','PetalWidthCm']\nX = dataset[feature_columns].values\ny = dataset['Species'].values\n#Spliting dataset into training set and test set\nX_train, X_test, y_train, y_test = train_test_split(X, y,\ntest_size = 0.2, random_state = 0) yu\n# Instantiate learning model (k = 3)\nclassifier = KNeighborsClassifier(n_neighbors=5)\n# Fitting the model\nclassifier.fit(X_train, y_train)\n# Predicting the Test set results\ny_pred = classifier.predict(X_test)\ncm = confusion_matrix(y_test, y_pred)\nprint ('confusion matrix:\\n',cm)\naccuracy = accuracy_score(y_test, y_pred)*100\nprint ('Accuracy of our model is equal ' +\nstr(round(accuracy, 2)) + ' %.')\nOutput: dataset shape is : (150, 6)\ndataset head : Id SepalLengthCm \u2026\nPetalWidthCm Species\n0 1 5.1 \u2026 0.2 Iris-setosa\n1 2 4.9 \u2026 0.2 Iris-setosa\n2 3 4.7 \u2026 0.2 Iris-setosa\n3 4 4.6 \u2026 0.2 Iris-setosa\n4 5 5.0 \u2026 0.2 Iris-setosa\n[5 rows x 6 columns]\ndataset description\n: Id SepalLengthCm \u2026\nPetalLengthCm PetalWidthCm\ncount 150.000000\n150.000000 \u2026 150.000000 150.000000\nmean 75.500000\n5.843333 \u2026 3.758667 1.198667\nstd 43.445368\n0.828066 \u2026 1.764420 0.763161\nmin 1.000000\n4.300000 \u2026 1.000000 0.100000\n25% 38.250000\n5.100000 \u2026 1.600000 0.300000\n50% 75.500000\n5.800000 \u2026 4.350000 1.300000\n75% 112.750000\n6.400000 \u2026 5.100000 1.800000\nmax 150.000000\n7.900000 \u2026 6.900000 2.500000\n[8 rows x 5 columns]\nconfusion matrix:\n[[11 0 0]\n[0 12 1]\n[0 0 6]]\nThe accuracy of our model is equal to 96.67 %.\nCopy file into the current working directory before\nIris.csv\nexecuting this program. You can get this file from a web search if not available.\nUnderstanding decision trees\nDecision trees help to build a classification model of machine learning in the\nform of tress structure. The decision tree splits the data into subsets in a\nhierarchal structure, and at the same time associated decision tree is\nincrementally developed. In the decision tree, the final output is decision\nnodes and leaf nodes. The decision tree has two or more branches and in leaf\nnode gives the final result or classification of data into classes. The topmost\ndecision mode in a decision tree is a root node. We can use both numerical\nand categorical data in the decision tree.\nAssumptions while creating a decision tree:\nWe consider the whole training data set as the root in the beginning.\nMostly preferred feature values are categorical.\nBefore building the model, continuous values are discretized.\nBased on attribute values, records are distributed recursively.\nOrdering of attributes as root or internal nodes is done by using a\nstatistical approach.\nHow do the decision trees work?\nThe accuracy of a decision tree depends on the strategy which splits the\ndataset. For both classification and regression, the criteria decision is\ndifferent. In decision trees, we can use multiple algorithms to split the data\nfrom a node into two or more sub-nodes. The homogeneity increases between\nthe sub-node by following splitting criteria, or we can say that the efficiency\nof the node increases concerning the target variable. In the decision, the tree\nsplits the node based on given variables and selects the split, which gives us\nthe most homogenous sub-nodes.\nThe selection of the algorithm is typically based on the type of target\nvariables. Let us see some algorithms used in the decision tree:\nID3-which is an extended form of D3\nC4.5-it is a successor of D3 CART-used for the classification and Regression Trees\nMARS-multivariable adaptive regression splines\nThe top-down greedy search approach is used for the building of the ID3\nalgorithm for the possible branches and without backtracking. We choose in\ncase of a greedy algorithm which is the best at that moment.\nSteps in id3 algorithm\n1. It starts with the set S as the root node.\n2. With every iteration of the algorithm. We calculate the Entropy and\ninformation gain of every attribute.\n3. Select those attributes which have the largest information gain or\nsmallest entropy.\n4. Then the selected attribute is used to split the set S to produce a subset\nof the data.\n5. The algorithm is continuous to recur on the unselected subset.\nAttribute selection measures:\nIf the dataset consists of many attributes, then to decide which attribute is\nused to split the data and place it at the root or the internal node at a different\nlevel is a complex task, and it cannot be solved by choosing any node\nrandomly as the root node. It will give us a bad result with low accuracy. For\nthis problem, the researcher finds the following solutions:\nEntropy\nInformation gain\nGini index\nGain Ratio\nReduction in variance\nChi-square\nIssues in decision tree\nThe following are some important issues in the decision tree:\n1. Working with continuous attributes. 2. Avoiding overfitting\n3. Super Attributes\n4. Working with missing values.\nExample 12.13:\nimport numpy as np\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.datasets import load_iris\nfrom matplotlib import pyplot as plt\nfrom sklearn import datasets\nfrom sklearn import tree\nimport sklearn.metrics as metrics\n#Loading datasets\niris_data = load_iris()\niris=pd.DataFrame(iris_data.data)\n#priting features name of iris data\nprint (\"Name of features : \", iris_data.feature_names)\n#shape of datasets\nprint (\"Dataset Shape: \", iris.shape)\n#first six sample\nprint (\"Dataset: \\n\",iris.head())\n#priting samples and target\nX = iris.values[:, 0:5]\nY = iris_data.target\n#print (X)\n#print (Y)\n# Splitting the dataset into train and test\nX_train, X_test, y_train, y_test = train_test_split(X, Y,\ntest_size = 0.3, random_state = 100)\n# Decision tree classifier\nclf= DecisionTreeClassifier(class_weight=None,\ncriterion='gini', random_state = 100) #fitting the training data\nclf.fit(X_train, y_train)\n# prediction on random data\nX=[[6.4,1.8,6.6,2.1]]\nY_pred=clf.predict(X)\nprint (Y_pred)\n# prediction on X_test (testing data)\nY_pred=clf.predict(X_test)\nprint (Y_pred)\n#Accuray of the model\nprint ('Accuracy:',metrics.accuracy_score(y_test, Y_pred))\n#Decision making in decision tree\ntext_representation = tree.export_text(clf)\nprint (text_representation)\ntree.plot_tree(clf)\nOutput:\nName of features : ['sepal length (cm)', 'sepal width (cm)',\n'petal length (cm)', 'petal width (cm)']\nDataset Shape: (150, 4)\nDataset:\n0 1 2 3\n0 5.1 3.5 1.4 0.2\n1 4.9 3.0 1.4 0.2\n2 4.7 3.2 1.3 0.2\n3 4.6 3.1 1.5 0.2\n4 5.0 3.6 1.4 0.2\n[2]\n[2 0 2 0 2 2 0 0 2 0 0 2 0 0 2 1 1 2 2 2 2 0 2 0 1 2 1 0 1 2\n1 1 1 0 0 1 0\n1 2 2 0 1 2 2 0]\nAccuracy: 0.9555555555555556\n|--- feature_2 <= 2.45\n| |--- class: 0\n|--- feature_2 > 2.45\n| |--- feature_3 <= 1.65\n| | |--- feature_2 <= 5.00 | | | |--- class: 1\n| | |--- feature_2 > 5.00\n| | | |--- feature_0 <= 6.05\n| | | | |--- class: 1\n| | | |--- feature_0 > 6.05\n| | | | |--- class: 2\n| |--- feature_3 > 1.65\n| | |--- feature_2 <= 4.85\n| | | |--- feature_1 <= 3.10\n| | | | |--- class: 2\n| | | |--- feature_1 > 3.10\n| | | | |--- class: 1\n| | |--- feature_2 > 4.85\n| | | |--- class: 2 Figure 12.9: Example of a decision tree\nIf the following error occurs in plotting tree\u00e8\nAttributeError:\n, then\nmodule 'sklearn.tree' has no attribute 'plot_tree'\nupdate by the following command.\nscikit-learn\n>pip install -U scikit-learn\nThe following parameters can be used in the decision tree classifier: Logistic regression\nIt is a classification algorithm used to classify discrete data, for example, for\nthe classification of email as spam or non-spam, fraud detection in online\ntransactions, and classifying malignant tumor or Benign tumor. Logistic\nregression converts its output by using a logistic sigmoid function that returns\na probability value.\nA logistic regression algorithm is used for the classification of problems in\nmachine learning. It is a predictive analysis algorithm by bussing the concept\nof probability. We can also call it a linear regression model, but we can use a\nmore complex cost function in logistic regression. This function is called a\nsigmoid function or logistic function instead of a linear function. The limit of\nthe cost function of the hypothesis of logistic regression is between 0 and 1.\nTherefore, if the linear function fails to represent it as the value greater than\n1 or less than 0 that is not possible according to the hypothesis of linear\nregression, logistic regression hypothesis expectation can be represented as:\n0 < h\u03b8 (x) < 1\nSigmoid function\nThe sigmoid function is used to map the predicted values to probabilities\u2014\nthis function helps to map the real value to other values between 0 and 1. In\nmachine learning, for the mapping of predicted values to the probabilities,\nwe use the sigmoid function.\nHypothesis representation\nWe used the hypothesis's formula by using linear regression; that is, we\nmodify it for logistic regression, which means we expect the hypothesis value between 0 and 1. When using linear regression, we used a formula of\nthe hypothesis, that is:\nh\u0398(x) = \u03b2\u2080 + \u03b2\u2081X\nFor logistic regression, we are going to modify it a little bit i.e.\n\u03c3 (Z) = \u03c3 (\u03b2\u2080 + \u03b2\u2081X)\nWe have expected that our hypothesis will give values between 0 and 1.\nZ = \u03b2\u2080 + \u03b2\u2081X\nh\u0398 (x) = sigmoid(Z)\ni.e. h\u0398 (x) = 1\/(1 + e^ - (\u03b2\u2080 + \u03b2\u2081X)\nThe Hypothesis of logistic regression can be represented as:\nExample 12.14:\nimport seaborn as sns\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.model_selection import train_test_split\n#Load the data set\ndata = sns.load_dataset(\"iris\")\ndata.head()\n#Prepare the training set\n# X = feature values, all the columns except the last column\nX = data.iloc[:, :-1]\n# y = target values, last column of the data frame\ny = data.iloc[:, -1]\n# Plot the relation of each feature with each species\n#Split the data into 80% training and 20% testing\nx_train, x_test, y_train, y_test = train_test_split(X, y,\ntest_size=0.3, random_state=42)\n#Train the model\nmodel = LogisticRegression() model.fit(x_train, y_train) #Training the model\n#Test the model\npredictions = model.predict(x_test)\nprint (predictions)# printing predictions\n#Check precision, recall, f1-score\nprint (classification_report(y_test, predictions))\nprint (accuracy_score(y_test, predictions))\nOutput:\n['versicolor' 'setosa' 'virginica' 'versicolor' 'versicolor'\n'setosa'\n'versicolor' 'virginica' 'versicolor' 'versicolor'\n'virginica' 'setosa'\n'setosa' 'setosa' 'setosa' 'versicolor' 'virginica'\n'versicolor'\n'versicolor' 'virginica' 'setosa' 'virginica' 'setosa'\n'virginica'\n'virginica' 'virginica' 'virginica' 'virginica' 'setosa'\n'setosa'\n'setosa' 'setosa' 'versicolor' 'setosa' 'setosa'\n'virginica' 'versicolor'\n'setosa' 'setosa' 'setosa' 'virginica' 'versicolor'\n'versicolor' 'setosa'\n'setosa']\nprecision recall f1-score support\nsetosa 1.00 1.00 1.00 19\nversicolor 1.00 1.00 1.00 13\nvirginica 1.00 1.00 1.00 13\naccuracy 1.00 45\nmacro avg 1.00 1.00 1.00 45\nweighted avg 1.00 1.00 1.00 45\n1.0\nSupport vector machine\nThe support vector machine is a machine learning model that is very\npowerful and versatile, capable of performing linear and non-linear data classification. SVM is the popular and most widely used model in machine\nlearning, and if anyone is interested in machine learning, they should have\nthis model in their toolbox. Support vector machine is well suited for the\nclassification of complex medium-sized and small datasets. The figure 12.10\ndemonstrates SVM classification:\nFigure 12.10: Support vector machine classification\nTo find a hyperplane in an N-dimensional space is the SVM algorithm's\nprimary objective, which classifies the data. There may be more than one\nhyperplane chosen to separate the two classes of the data points and our\nobjectives are to find a hyperplane that has the maximum margin, which\nmeans there should be maximum distance that helps for the future data point's\nclassification by providing some reinforcement.\nHyperplanes and Support Vectors\nHyperplanes are decision boundaries that classify the data. Data points that\nfall under either side of the plane can be attributed to different classes and\nthe plane's dimension depending on the number of features. The hyperplane is\na simple line in case the number of input features is 2 and a hyperplane is a\ntwo-dimensional plane if the number of input features is 3. If the number of\nfeatures exceeds 3, it becomes difficult to imagine the hyperplane. Support\nvectors are data points close to the plane and impacts the hyperplane's\npositions and orientation. We can maximize the margin of the hyperplane by\nusing support vectors. By deleting the support vectors the position of the hyperplanes will be changed. These points help us in the building of SVM. In\nSVM, we take the output of a linear function, and if the output is less than -1,\nwe classify it as another class. That means the range of threshold values is 1\nand -1 in SVM. We can obtain the reinforcement range of value ([1, -1]) as a\nmargin. In the SVM algorithm, we try to maximize the margin between the\ndata points and the plane.\nExample 12.15:\n#Import scikit-learn dataset library\nfrom sklearn import datasets\nfrom sklearn.model_selection import train_test_split\nfrom sklearn import svm\nfrom sklearn import metrics\nfrom sklearn.metrics import confusion_matrix\n#Load dataset\ncancer = datasets.load_breast_cancer()\n# print the names of features\nprint (\"Features: \", cancer.feature_names)\n# print the label type of cancer('malignant' 'benign')\nprint (\"Labels: \", cancer.target_names)\n# print data(feature)shape\ncancer.data.shape\n# Split dataset into training set and test set\nX_train, X_test, y_train, y_test =\ntrain_test_split(cancer.data, cancer.target,\ntest_size=0.3,random_state=109) # 70% training and 30% test\nclf = svm.SVC(kernel='linear') # Linear Kernel\n#Train the model using the training sets\nclf.fit(X_train, y_train)\n#Predict the response for test dataset\ny_pred = clf.predict(X_test)\n# Print Model Accuracy\nprint (\"Confusion matrix:\\n \",confusion_matrix(y_test,\ny_pred))\nprint (\"Accuracy:\",metrics.accuracy_score(y_test, y_pred))\nOutput: Features: ['mean radius' 'mean texture' 'mean perimeter'\n'mean area'\n'mean smoothness' 'mean compactness' 'mean concavity'\n'mean concave points' 'mean symmetry' 'mean fractal\ndimension'\n'radius error' 'texture error' 'perimeter error' 'area\nerror'\n'smoothness error' 'compactness error' 'concavity error'\n'concave points error' 'symmetry error' 'fractal dimension\nerror'\n'worst radius' 'worst texture' 'worst perimeter' 'worst\narea'\n'worst smoothness' 'worst compactness' 'worst concavity'\n'worst concave points' 'worst symmetry' 'worst fractal\ndimension']\nLabels: ['malignant' 'benign']\nConfusion matrix:\n[[61 2]\n[ 4 104]]\nAccuracy: 0.9649122807017544\nModel evaluation methods\nTo measure model efficiency, model evaluation metrics are required. The\nchoice of measurement criteria depends on the role of machine learning (such\nas classification, regression, ranking, clustering, topic modeling, and others).\nFor several tasks, specific metrics are beneficial, such as precision-recall.\nThe bulk of machine learning programs are supervised learning functions,\nsuch as classification and regression. We concentrate on metrics for these\ntwo supervised models of learning. The following are some of the metrics\nused in classification problems.\nConfusion matrix\nAccuracy\nPrecision\nSensitivity\/ Recall\nSpecificity F1 score\nROC (Receiver operating characteristics) curve\nAUC (Area under ROC curve)\nConfusion matrix\nCompared to the actual results (target value) in the data, a confusion matrix\nshows the number of right and wrong predictions made by the classification\nmodel. The matrix is NxN, where the number of destination values is N.\n(classes). Using the data in the matrix, the output of such models is generally\nevaluated. A 2x2 confusion matrix for two groups (positive and negative) is\nshown in the following table:\nTable 12.1: Confusion matrix\nAccuracy\nThe percentage of the total number of predictions was correct. For\nclassification issues, accuracy is a standard assessment metric. It's the\nnumber of accurate forecasts made as a percentage of all forecasts made.\nAccuracy = (TP+TN)\/total\nMisclassification: (FP+FN)\/total or (1-Accuracy)\nPrecision\nWhat is the percentage of real true, out of the total expected true, as in how\nmuch the model correctly predicts? Accuracy can become an inaccurate\ncriterion for assessing our success when we have a class imbalance. Precision=TP\/(TP+FP)\nSensitivity\/recall\nRecall calculates how many of the actual positives our model capture through\nlabeling it as True Positive. Regarding all the examples that belong in the\nclass, recall is defined as the fraction of examples predicted to belong to a\nclass.\nRecall: TP\/(TP+FN)\nSpecificity\nIt is the percentage out of the overall real negative instances of negative\ninstances. Therefore, here is the actual number of negative instances present\nin the dataset denominator (TN + FP). It is equivalent to recall, but the\nchange is on the negative side.\nSpecificity: FP\/(FP+TN)\nF1 score\nIt is the harmonic means of accuracy and recall. It takes both of them into\naccount, so the higher the F1 score, the better. See that if one goes low, the\nfinal F1 score drops considerably because of the numerator item. So in the\nF1 score, a model does well if the positive predicted is positive (precision)\nand does not skip positive and predict negative ones (recall).\nF1: (2*Recall*Precision)\/(Recall+Precision)\nROC (Receiver operating characteristics) curve\nThe ROC chart is similar to the charts of gain or rise. They provide a means\nof comparison between models of classification. The ROC chart displays the\nfalse positive rate (1-specificity) on the X-axis, the probability of target=1\nwhen the true value is 0, against the true positive rate (sensitivity) on the Y-\naxis, the probability of target=1 when the true value is 1. Ideally, the curve\nwould ascend rapidly to the top-left, meaning the model correctly predicts\nthe cases. For a random construct, the diagonal red line is an example of the\nROC graph is shown as follows: Figure 12.11: ROC Curve\nAUC (Area under ROC curve)\nThe region under the ROC curve is also used as a measure of the\nclassification models' consistency. There is a region under the curve of 0.5\nfor a random classifier, while AUC equals 1 for a perfect classifier. Most of\nthe classification models have an AUC between 0.5 and 1 in action. An\nexample of the AUC graph is shown as follows: Figure 12.12: Area under ROC Curve\nConclusion\nIn this chapter, we discussed the concepts, applications, and methods of\nmachine learning. Various examples and Python code are given for\nimplementing machine learning approaches. Based on these examples, you\ncan write your code for machine learning methods by setting different\nparameters and different datasets. In the next chapter, we will discuss\nclustering concepts in Python.\nPoints to remember\nMachine learning just informs how computers do tasks on their own.\nMachine learning systems are mainly categorized as supervised\nlearning and unsupervised learning.\nRegression is like classification, which uses the continuous value to\ncategorize the data.\nThe number of accurate and inaccurate assumptions made by the\nclassification model is seen in the confusion matrix. Multiple choice questions\n1. What is machine learning?\na. Machine Learning is a field of computer science.\nb. Machine Learning is a type of artificial intelligence that extracts\npatterns out of raw data by using an algorithm.\nc. Machine Learning focuses on allowing computer systems to learn\nfrom experience without being explicitly programmed or human\nintervention.\nd. All the above\n2. Which of the following is NOT supervised learning?\na. PCA\nb. Decision Tree\nc. Linear Regression\nd. Naive Bayes\n3. Which one of the following is used to build a model?\na. Validation data\nb. Training data\nc. Test data\nd. Hidden data\n4. The most widely used metrics and tools to assess a classification\nmodel are:\na. Confusion matrix\nb. AUC\nc. ROC\nd. All the above\n5. Which of the following Python libraries are used for data analysis\nand scientific computations?\na. Numpy b. Scipy\nc. Pandas\nd. All the above\nAnswers\n1. d\n2. a\n3. b\n4. d\n5. d\nQuestions\n1. What are the popular algorithms uses in machine learning?\n2. What is the difference between supervised and unsupervised machine\nlearning?\n3. Define precision and recall.\n4. What is the ROC curve, and what does it represent?\n5. Write some advantages and disadvantages of decision trees?\n6. What is a confusion matrix, and why do you need it?\n7. What is the difference between classification and regression?\n8. What is meant by 'Training set' and 'Test Set'?\n9. Discuss various Python libraries for machine learning.\n10. Write a basic machine learning program to check a model's accuracy by\nimporting any dataset using any classifier? CHAPTER 13\nClustering with Python\nluster analysis, also known as clustering, is an unsupervised machine\nC\nlearning approach for grouping unlabeled datasets. It aims to build\nclusters or groups from data points in a dataset with high intra-cluster\nsimilarity and low inter-cluster similarity. In this chapter, you will be\nfamiliar with various clustering methods and applications. Besides, we have\ndemonstrated various clustering algorithms with the help of examples and\ncodes.\nStructure\nIn this chapter, we will cover the following topics:\nThe basic concepts of unsupervised learning\nVarious issues and applications of unsupervised learning\nTypes of clustering methods\nPython codes to implement clustering methods\nObjective\nYou can perform clustering using different approaches. This chapter\ndemonstrates various clustering approaches with suitable examples. Also,\nyou will be able to write Python codes for unsupervised machine learning\napproaches using different datasets and parameters.\nIntroduction to unsupervised learning\nUnsupervised machine learning algorithms, without reference to known or\nlabeled results, infer patterns from a dataset. With the exception of\nsupervised machine learning, unsupervised machine learning techniques\nshould not be best applied to a problem of regression or classification since\nwe have no idea what the output data values may be. This makes it difficult for us to train the algorithm the way we would usually do. Instead,\nunsupervised learning can be used to find the data's inner principle. Such\napplications of techniques for unsupervised machine learning include:\nClustering helps us to divide the dataset into different groups\nautomatically per the resemblance. Cluster analysis sometimes\noverestimates the correlation between groups and does not treat data\nsets as persons. For this purpose, cluster analysis is a bad option for\nclient segmentation and targeting applications.\nIn the dataset, anomaly detection will automatically determine\nirregular data points. It helps detect fraudulent purchases, finds\ndefective hardware pieces, or identifies an outlier during data entry\ntriggered by a user mistake.\nSets of things that often occur together in your dataset are found through\nAssociation mining. It is also used by retailers for basket research, as\nit enables analysts to discover items often bought at the same time and\ncreate more successful sales and marketing strategies.\nFor data pre-processing, latent variable models are frequently used,\nsuch as minimizing the cost function in a dataset (decreasing\ndimensional space) or decaying the dataset into different pieces.\nIssues with unsupervised learning\nIn contrast to supervised learning assignments, unsupervised learning is\ncomplex.\nHow would we realize if the findings are relevant when there are no\nresponse labels available?\nLet the specialist look at the outcomes (external evaluation).\nDescribing an objective clustering feature (internal evaluation)\nNeed for unsupervised learning\nAll sorts of unexplained trends in knowledge are identified through\nunsupervised machine learning.\nUnsupervised approaches help you identify characteristics that can be\nbeneficial for classification. It occurs in real-time to evaluate and mark all the input data among\nstudents.\nUnlabeled data from a computer is better to get than labeled data, which\nrequires manual involvement.\nClustering\nCluster analysis, used for inferential statistical analysis to identify hidden\ntrends or data grouping, is the most popular unmonitored form of learning.\nThe clusters are simulated using a measure of similarity identified by metrics\nsuch as Euclidean or probabilistic distance. Clustering is the most critical\nunsupervised learning problem, and it deals with finding a structure in a set\nof unlabeled data, just like any other problem of this kind. The method of\narranging objects into groups whose members are similar in some way,\naccording to a broad concept of clustering. A cluster is thus a group of\nobjects that are similar to one another but dissimilar to objects from other\nclusters. The figure 13.1 shows the concept of the clustering process:\nFigure 13.1: Clustering process\nClustering is used to figure out how a collection of unlabeled data is\norganized internally. But how do you know if clustering is good? It can be\nshown that there is no single best criterion that is independent of the\nclustering's goal. As a result, the user's responsibility is to include this\ncondition for the clustering result to meet their requirements. To find a\nspecific clustering solution, we must first identify the clusters' similarity\nmeasures. Proximity measures\nWe need to specify a proximity measure for two data points to cluster them.\nThe term \"proximity\" refers to how similar or dissimilar the samples are to\none another. It can be defined as Similarity measure and distance. It is also\nshown in figure 13.2:\nSimilarity measure S (X, X): Large if X and X are similar.\ni j i j\nDistance or dissimilarity measure D (X, X): Small if X and X are\ni j i j\nsimilar.\nFigure 13.2: Proximity measures\nDistance measuring methods\nThe selection of distance measures is an essential part of clustering. It\ncontrols the clusters' shape by defining how the similarity of two elements (x,\ny) is determined. The Euclidean and Manhattan distances are the two most\ncommon distance measurement methods, and they are defined as follows:\nEuclidean distance\nManhattan distance Where, x and y are two vectors of length n.\nClustering methods\nDensity-based methods: These techniques perceive the clusters as a\ndense area with some resemblance and separate them from the lower\ndensity space area. Such techniques have substantial precision and the\npotential to combine two clusters. Examples include DBSCAN\n(Density-Based Spatial Clustering of Noise Applications), OPTICS\n(Ordering Points for Clustering Structure Identification), etc.\nHierarchical-based methods: The clusters generated in this process\nform a hierarchy-based tree-type structure. The previously created one\nis used to shape new clusters. It is categorized into two parts:\nAgglomerative (Bottom-up approach)\nDivisive (Top-down approach)\nExamples of hierarchical-based clustering methods are CURE\n(Clustering Using Representatives), BIRCH (Balanced Iterative\nReducing Clustering and using Hierarchies), etc.\nPartitioning methods: Such techniques group the artifacts into k\nclusters, and each partition one cluster forms. This approach is used to\noptimize the similarity function of an objective criterion, such as when\nthe distance is a significant parameter, such as K-means, CLARANS\n(Clustering Large Applications based on Randomized Search), etc.\nGrid-based methods: In this step, the data space is formulated into a\nfinite number of cells that form a grid-like structure. All clustering\noperations performed on these grids are quick regardless of the number\nof data items, such as STING (Statistical Information Grid), wave\ncluster, CLIQUE (CLustering In Quest), etc.\nK-means clustering\nK-means is an algorithm for classifying or grouping the objects into K\ncategory numbers based on attributes\/features. K is a positive integer\nnumber. The grouping is achieved by reducing the total of squares of distances between data and the corresponding vector cluster. Therefore, the\nobject of K-mean clustering is to classify information.\nThe primary step of clustering with k-means is clear. We evaluate the amount\nof cluster K initially, and we presume the centroid or middle of these\nclusters. We can take any random objects as the original centroids, or the first\nK objects' sequence can also service such as the original vector. Then the\nalgorithm K implies that the three steps below will be completed before\nconvergence.\nExample 13.1:\n# k-means clustering example\nfrom numpy import unique\nfrom numpy import where\nfrom sklearn.datasets import make_classification\nfrom sklearn.cluster import KMeans\nfrom matplotlib import pyplot\n# dataset defining\nData, _ = make_classification(n_samples=10000, n_features=2,\nn_informative=2, n_redundant=0, n_clusters_per_class=1,\nrandom_state=4)\n# defining model\nmodel = KMeans(n_clusters=3)\n# Model fitting\nmodel.fit(Data)\n# assign a cluster\nAssign = model.predict(Data)\n# retrieving unique clusters\nclusters = unique(Assign)\n# create scatter plot for samples from each cluster\nfor c in clusters:\n# get row indexes for samples with this cluster\nri = where(Assign == c)\n# create scatter of these samples\npyplot.scatter (Data[ri, 0], Data[ri, 1])\n# show the plot\npyplot.show() Output:\nFigure 13.3: K-mean clustering\nThe number of clusters must be defined when using K-means clustering.\nWhen clusters are of varying sizes, densities, and non-globular forms,\nK-means has issues.\nHierarchical Clustering (BIRCH)\nUsually, hierarchical-based clustering is being used on hierarchical data, as\nyou might get from a database of businesses or taxonomies. It constructs a\ntree of clusters to arrange everything from the top to bottom. It is more\nstringent than the other types of clustering, but it is ideal for particular types\nof data sets.\nExample 13.2:\n# Example of birch clustering\nfrom numpy import unique\nfrom numpy import where\nfrom sklearn.datasets import make_classification\nfrom sklearn.cluster import Birch\nfrom matplotlib import pyplot\n# define dataset\nData, _ = make_classification(n_samples=10000, n_features=2,\nn_informative=2, n_redundant=0, n_clusters_per_class=1,\nrandom_state=4) # defining model\nmodel = Birch(threshold=0.5, n_clusters=4)\n# Model fitting\nmodel.fit(Data)\n# assign a cluster\nAssign = model.predict(Data)\n# retrieve unique clusters\nclusters = unique(Assign)\n# create scatter plot for samples from each cluster\nfor c in clusters:\n# get row indexes for samples with this cluster\nri = where(Assign == c)\n# create scatter of these samples\npyplot.scatter(Data[ri, 0], Data[ri, 1])\n# show the plot\npyplot.show()\nOutput:\nFigure 13.4: BIRCH Clustering\nDensity-based Clustering (DBSCAN)\nIn density-based clustering, data is clustered by high data point concentration\nareas, surrounded by low data point concentration areas. The algorithm\nessentially finds the sites with data points that are dense, and those clusters\nare named. The best thing about this is that there can be any form in the clusters. You are not limited to anticipated circumstances. Under this method,\nthe clustering algorithms do not attempt to allocate cluster outliers, so they\nare neglected.\nExample 13.3:\n# Example of DBSCAN clustering\nfrom numpy import unique\nfrom numpy import where\nfrom sklearn.datasets import make_classification\nfrom sklearn.cluster import DBSCAN\nfrom matplotlib import pyplot\n# define dataset\nData, _ = make_classification(n_samples=1000, n_features=2,\nn_informative=2, n_redundant=0, n_clusters_per_class=1,\nrandom_state=4)\n# define the model\nmodel = DBSCAN(eps=0.30, min_samples=10)\n# fitting model and predicting clusters\na = model.fit_predict(Data)\n# retrieve unique clusters\nclusters = unique(a)\n# create scatter plot for samples from each cluster\nfor c in clusters:\n# get row indexes for samples with this cluster\nri = where(a == c)\n# create scatter of these samples\npyplot.scatter(Data[ri, 0], Data[ri, 1])\n# show the plot\npyplot.show()\nOutput: Figure 13.5: DBSCAN Clustering\nOPTICS\nOPTICS clustering is a simplified variant of DBSCAN. OPTICS stands for\nOrdering Points To Identify the Clustering Structure. It does not generate an\nactual clustering of a data set; instead, it provides an augmented ordering of\nthe database representing the density-based clustering structure. This cluster-\nordering includes knowledge that corresponds to density-based clustering's\nacross a wide variety of parameter settings. Python code for OPTICS\nclustering is given below.\nExample 13.4:\n# Example of OPTICS clustering\nfrom numpy import unique\nfrom numpy import where\nfrom sklearn.datasets import make_classification\nfrom sklearn.cluster import OPTICS\nfrom matplotlib import pyplot\n# define dataset\nData, _ = make_classification(n_samples=1000, n_features=2,\nn_informative=2, n_redundant=0, n_clusters_per_class=1,\nrandom_state=4)\n# define the model\nmodel = OPTICS(eps=0.5, min_samples=9)\n# fit model and predict clusters Assign = model.fit_predict(Data)\n# retrieve unique clusters\nclusters = unique(Assign)\n# create scatter plot for samples from each cluster\nfor c in clusters:\n# get row indexes for samples with this cluster\nrow_in = where(Assign == c)\n# create scatter of these samples\npyplot.scatter(Data[row_in, 0], Data[row_in, 1])\n# showing the plot\npyplot.show()\nOutput:\nFigure 13.6: OPTICS Clustering\nConclusion\nIn this chapter, we discussed the concepts and various methods of clustering.\nVarious examples and Python code are given for implementing clustering\nmethods. Based on these examples, you can write your code for various\nclustering methods by setting different parameters and different datasets.\nPoints to remember\nClustering is an unsupervised problem of defining natural groups in the\ninput data's feature space.\nThere are many clustering algorithms available, and no single approach\nis best for all datasets. "}