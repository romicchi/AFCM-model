{"text":"Contents\nIntroduction 1\nOn programming . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\nWhy language matters . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\nWhat is JavaScript? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6\nCode, and what to do with it . . . . . . . . . . . . . . . . . . . . . . . 7\nOverview of this book . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8\nTypographic conventions . . . . . . . . . . . . . . . . . . . . . . . . . . 8\n1 Values, Types, and Operators 10\nValues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\nNumbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\nStrings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\nUnary operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\nBoolean values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\nEmpty values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\nAutomatic type conversion . . . . . . . . . . . . . . . . . . . . . . . . . 18\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n2 Program Structure 22\nExpressions and statements . . . . . . . . . . . . . . . . . . . . . . . . 22\nBindings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23\nBinding names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\nThe environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\nFunctions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\nThe console.log function . . . . . . . . . . . . . . . . . . . . . . . . . . 26\nReturn values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\nControl flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\nConditional execution . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\nwhile and do loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30\nIndenting Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\nfor loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\nBreaking Out of a Loop . . . . . . . . . . . . . . . . . . . . . . . . . . 33\nii Updating bindings succinctly . . . . . . . . . . . . . . . . . . . . . . . 34\nDispatching on a value with switch . . . . . . . . . . . . . . . . . . . . 34\nCapitalization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\nComments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\n3 Functions 39\nDefining a function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39\nBindings and scopes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40\nFunctions as values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42\nDeclaration notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\nArrow functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44\nThe call stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45\nOptional Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46\nClosure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\nRecursion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49\nGrowing functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\nFunctions and side effects . . . . . . . . . . . . . . . . . . . . . . . . . 54\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55\n4 Data Structures: Objects and Arrays 57\nThe weresquirrel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57\nData sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58\nProperties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\nMethods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60\nObjects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61\nMutability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\nThe lycanthrope\u2019s log . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64\nComputing correlation . . . . . . . . . . . . . . . . . . . . . . . . . . . 66\nArray loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68\nThe final analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68\nFurther arrayology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70\nStrings and their properties . . . . . . . . . . . . . . . . . . . . . . . . 72\nRest parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74\nThe Math object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75\nDestructuring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76\nJSON . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78\niii Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79\n5 Higher-Order Functions 82\nAbstraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83\nAbstracting repetition . . . . . . . . . . . . . . . . . . . . . . . . . . . 83\nHigher-order functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 85\nScript data set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86\nFiltering arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87\nTransforming with map . . . . . . . . . . . . . . . . . . . . . . . . . . . 88\nSummarizing with reduce . . . . . . . . . . . . . . . . . . . . . . . . . . 88\nComposability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90\nStrings and character codes . . . . . . . . . . . . . . . . . . . . . . . . 91\nRecognizing text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95\n6 The Secret Life of Objects 97\nEncapsulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97\nMethods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98\nPrototypes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99\nClasses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101\nClass notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102\nOverriding derived properties . . . . . . . . . . . . . . . . . . . . . . . 103\nMaps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104\nPolymorphism . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106\nSymbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107\nThe iterator interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108\nGetters, setters, and statics . . . . . . . . . . . . . . . . . . . . . . . . 110\nInheritance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112\nThe instanceof operator . . . . . . . . . . . . . . . . . . . . . . . . . . . 113\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115\n7 Project: A Robot 117\nMeadowfield . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117\nThe task . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119\nPersistent data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121\nSimulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122\nThe mail truck\u2019s route . . . . . . . . . . . . . . . . . . . . . . . . . . . 124\nPathfinding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124\niv Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126\n8 Bugs and Errors 128\nLanguage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128\nStrict mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129\nTypes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130\nTesting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131\nDebugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132\nError propagation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134\nExceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135\nCleaning up after exceptions . . . . . . . . . . . . . . . . . . . . . . . . 136\nSelective catching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138\nAssertions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142\n9 Regular Expressions 143\nCreating a regular expression . . . . . . . . . . . . . . . . . . . . . . . 143\nTesting for matches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144\nSets of characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144\nRepeating parts of a pattern . . . . . . . . . . . . . . . . . . . . . . . . 146\nGrouping subexpressions . . . . . . . . . . . . . . . . . . . . . . . . . . 147\nMatches and groups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147\nThe Date class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148\nWord and string boundaries . . . . . . . . . . . . . . . . . . . . . . . . 150\nChoice patterns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150\nThe mechanics of matching . . . . . . . . . . . . . . . . . . . . . . . . 151\nBacktracking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152\nThe replace method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154\nGreed . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155\nDynamically creating RegExp objects . . . . . . . . . . . . . . . . . . 157\nThe search method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\nThe lastIndex property . . . . . . . . . . . . . . . . . . . . . . . . . . . 158\nParsing an INI file . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160\nInternational characters . . . . . . . . . . . . . . . . . . . . . . . . . . . 162\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165\n10 Modules 167\nModules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167\nv Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168\nImprovised modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169\nEvaluating data as code . . . . . . . . . . . . . . . . . . . . . . . . . . 170\nCommonJS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171\nECMAScript modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173\nBuilding and bundling . . . . . . . . . . . . . . . . . . . . . . . . . . . 175\nModule design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178\n11 Asynchronous Programming 180\nAsynchronicity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180\nCrow tech . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182\nCallbacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183\nPromises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185\nFailure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186\nNetworks are hard . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188\nCollections of promises . . . . . . . . . . . . . . . . . . . . . . . . . . . 190\nNetwork flooding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191\nMessage routing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192\nAsync functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194\nGenerators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196\nThe event loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197\nAsynchronous bugs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201\n12 Project: A Programming Language 202\nParsing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202\nThe evaluator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207\nSpecial forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208\nThe environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210\nFunctions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211\nCompilation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212\nCheating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214\n13 JavaScript and the Browser 216\nNetworks and the Internet . . . . . . . . . . . . . . . . . . . . . . . . . 216\nThe Web . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218\nvi HTML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218\nHTML and JavaScript . . . . . . . . . . . . . . . . . . . . . . . . . . . 221\nIn the sandbox . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222\nCompatibility and the browser wars . . . . . . . . . . . . . . . . . . . 222\n14 The Document Object Model 224\nDocument structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224\nTrees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225\nThe standard . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226\nMoving through the tree . . . . . . . . . . . . . . . . . . . . . . . . . . 227\nFinding elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228\nChanging the document . . . . . . . . . . . . . . . . . . . . . . . . . . 229\nCreating nodes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230\nAttributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232\nLayout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233\nStyling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235\nCascading styles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236\nQuery selectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237\nPositioning and animating . . . . . . . . . . . . . . . . . . . . . . . . . 238\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241\n15 Handling Events 243\nEvent handlers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 243\nEvents and DOM nodes . . . . . . . . . . . . . . . . . . . . . . . . . . 244\nEvent objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245\nPropagation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245\nDefault actions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247\nKey events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247\nPointer events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 249\nScroll events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253\nFocus events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254\nLoad event . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255\nEvents and the event loop . . . . . . . . . . . . . . . . . . . . . . . . . 255\nTimers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256\nDebouncing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 259\nvii 16 Project: A Platform Game 261\nThe game . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261\nThe technology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262\nLevels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262\nReading a level . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263\nActors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 265\nEncapsulation as a burden . . . . . . . . . . . . . . . . . . . . . . . . . 268\nDrawing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269\nMotion and collision . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274\nActor updates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277\nTracking keys . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279\nRunning the game . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282\n17 Drawing on Canvas 284\nSVG . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 284\nThe canvas element . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 285\nLines and surfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286\nPaths . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287\nCurves . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289\nDrawing a pie chart . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291\nText . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 292\nImages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293\nTransformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 295\nStoring and clearing transformations . . . . . . . . . . . . . . . . . . . 297\nBack to the game . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299\nChoosing a graphics interface . . . . . . . . . . . . . . . . . . . . . . . 304\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 305\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 306\n18 HTTP and Forms 308\nThe protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 308\nBrowsers and HTTP . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310\nFetch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 312\nHTTP sandboxing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313\nAppreciating HTTP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 314\nSecurity and HTTPS . . . . . . . . . . . . . . . . . . . . . . . . . . . . 314\nForm fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 315\nFocus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 317\nDisabled fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 318\nviii The form as a whole . . . . . . . . . . . . . . . . . . . . . . . . . . . . 318\nText fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320\nCheckboxes and radio buttons . . . . . . . . . . . . . . . . . . . . . . . 321\nSelect fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 322\nFile fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 323\nStoring data client-side . . . . . . . . . . . . . . . . . . . . . . . . . . . 325\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 328\n19 Project: A Pixel Art Editor 330\nComponents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330\nThe state . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332\nDOM building . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 334\nThe canvas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 334\nThe application . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337\nDrawing tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339\nSaving and loading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 342\nUndo history . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 345\nLet\u2019s draw . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 346\nWhy is this so hard? . . . . . . . . . . . . . . . . . . . . . . . . . . . . 347\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 348\n20 Node.js 350\nBackground. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350\nThe node command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351\nModules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 352\nInstalling with NPM . . . . . . . . . . . . . . . . . . . . . . . . . . . . 353\nThe file system module . . . . . . . . . . . . . . . . . . . . . . . . . . . 355\nThe HTTP module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 357\nStreams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359\nA file server . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 366\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367\n21 Project: Skill-Sharing Website 369\nDesign . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 369\nLong polling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 370\nHTTP interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 371\nThe server . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 373\nThe client . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 380\nix Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 387\nExercise Hints 388\nProgram Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 388\nFunctions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 389\nData Structures: Objects and Arrays . . . . . . . . . . . . . . . . . . . 390\nHigher-Order Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 392\nThe Secret Life of Objects . . . . . . . . . . . . . . . . . . . . . . . . . 393\nProject: A Robot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 394\nBugs and Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 395\nRegular Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 395\nModules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 396\nAsynchronous Programming . . . . . . . . . . . . . . . . . . . . . . . . 398\nProject: A Programming Language . . . . . . . . . . . . . . . . . . . . 399\nThe Document Object Model . . . . . . . . . . . . . . . . . . . . . . . 400\nHandling Events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 400\nProject: A Platform Game . . . . . . . . . . . . . . . . . . . . . . . . . 402\nDrawing on Canvas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 402\nHTTP and Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 404\nProject: A Pixel Art Editor . . . . . . . . . . . . . . . . . . . . . . . . 406\nNode.js . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 408\nProject: Skill-Sharing Website . . . . . . . . . . . . . . . . . . . . . . . 409\nx \u201cWe think we are creating the system for our own purposes. We\nbelieve we are making it in our own image... But the computer is\nnot really like us. It is a projection of a very slim part of ourselves:\nthat portion devoted to logic, order, rule, and clarity.\u201d\n\u2014Ellen Ullman, Close to the Machine: Technophilia and its\nDiscontents\nIntroduction\nThis is a book about instructing computers. Computers are about as common\nas screwdrivers today, but they are quite a bit more complex, and making them\ndo what you want them to do isn\u2019t always easy.\nIf the task you have for your computer is a common, well-understood one,\nsuch as showing you your email or acting like a calculator, you can open the\nappropriate application and get to work. But for unique or open-ended tasks,\nthere probably is no application.\nThat is where programming may come in. Programming is the act of con-\nstructing a program\u2014a set of precise instructions telling a computer what to do.\nBecause computers are dumb, pedantic beasts, programming is fundamentally\ntedious and frustrating.\nFortunately, if you can get over that fact, and maybe even enjoy the rigor\nof thinking in terms that dumb machines can deal with, programming can be\nrewarding. It allows you to do things in seconds that would take forever by\nhand. It is a way to make your computer tool do things that it couldn\u2019t do\nbefore. And it provides a wonderful exercise in abstract thinking.\nMost programming is done with programming languages. A programming\nlanguage is an artificially constructed language used to instruct computers. It\nis interesting that the most effective way we\u2019ve found to communicate with a\ncomputer borrows so heavily from the way we communicate with each other.\nLike human languages, computer languages allow words and phrases to be\ncombined in new ways, making it possible to express ever new concepts.\nAtonepointlanguage-basedinterfaces, suchastheBASICandDOSprompts\nof the 1980s and 1990s, were the main method of interacting with computers.\nThey have largely been replaced with visual interfaces, which are easier to learn\nbut offer less freedom. Computer languages are still there, if you know where\nto look. One such language, JavaScript, is built into every modern web browser\nand is thus available on almost every device.\nThis book will try to make you familiar enough with this language to do\nuseful and amusing things with it.\n1 On programming\nBesides explaining JavaScript, I will introduce the basic principles of program-\nming. Programming, it turns out, is hard. The fundamental rules are simple\nand clear, but programs built on top of these rules tend to become complex\nenough to introduce their own rules and complexity. You\u2019re building your own\nmaze, in a way, and you might just get lost in it.\nThere will be times when reading this book feels terribly frustrating. If you\nare new to programming, there will be a lot of new material to digest. Much of\nthis material will then be combined in ways that require you to make additional\nconnections.\nItisuptoyoutomakethenecessaryeffort. Whenyouarestrugglingtofollow\nthe book, do not jump to any conclusions about your own capabilities. You are\nfine\u2014you just need to keep at it. Take a break, reread some material, and make\nsure you read and understand the example programs and exercises. Learning is\nhard work, but everything you learn is yours and will make subsequent learning\neasier.\nWhen action grows unprofitable, gather information; when infor-\nmation grows unprofitable, sleep.\n\u2014Ursula K. Le Guin, The Left Hand of Darkness\nA program is many things. It is a piece of text typed by a programmer,\nit is the directing force that makes the computer do what it does, it is data\nin the computer\u2019s memory, yet it controls the actions performed on this same\nmemory. Analogies that try to compare programs to objects we are familiar\nwith tend to fall short. A superficially fitting one is that of a machine\u2014lots of\nseparate parts tend to be involved, and to make the whole thing tick, we have\nto consider the ways in which these parts interconnect and contribute to the\noperation of the whole.\nA computer is a physical machine that acts as a host for these immaterial\nmachines. Computers themselves can do only stupidly straightforward things.\nThe reason they are so useful is that they do these things at an incredibly\nhigh speed. A program can ingeniously combine an enormous number of these\nsimple actions to do very complicated things.\nA program is a building of thought. It is costless to build, it is weightless,\nand it grows easily under our typing hands.\nBut without care, a program\u2019s size and complexity will grow out of control,\nconfusing even the person who created it. Keeping programs under control is\nthe main problem of programming. When a program works, it is beautiful. The\n2 art of programming is the skill of controlling complexity. The great program\nis subdued\u2014made simple in its complexity.\nSome programmers believe that this complexity is best managed by using\nonly a small set of well-understood techniques in their programs. They have\ncomposed strict rules (\u201cbest practices\u201d) prescribing the form programs should\nhave and carefully stay within their safe little zone.\nThis is not only boring, it is ineffective. New problems often require new\nsolutions. The field of programming is young and still developing rapidly, and\nit is varied enough to have room for wildly different approaches. There are\nmany terrible mistakes to make in program design, and you should go ahead\nand make them so that you understand them. A sense of what a good program\nlooks like is developed in practice, not learned from a list of rules.\nWhy language matters\nIn the beginning, at the birth of computing, there were no programming lan-\nguages. Programs looked something like this:\n00110001 00000000 00000000\n00110001 00000001 00000001\n00110011 00000001 00000010\n01010001 00001011 00000010\n00100010 00000010 00001000\n01000011 00000001 00000000\n01000001 00000001 00000001\n00010000 00000010 00000000\n01100010 00000000 00000000\nThat is a program to add the numbers from 1 to 10 together and print out\nthe result: 1 + 2 + ... + 10 = 55. It could run on a simple, hypothetical\nmachine. To program early computers, it was necessary to set large arrays of\nswitches in the right position or punch holes in strips of cardboard and feed\nthem to the computer. You can probably imagine how tedious and error-prone\nthis procedure was. Even writing simple programs required much cleverness\nand discipline. Complex ones were nearly inconceivable.\nOf course, manually entering these arcane patterns of bits (the ones and\nzeros) did give the programmer a profound sense of being a mighty wizard.\nAnd that has to be worth something in terms of job satisfaction.\nEach line of the previous program contains a single instruction. It could be\nwritten in English like this:\n3 1. Store the number 0 in memory location 0.\n2. Store the number 1 in memory location 1.\n3. Store the value of memory location 1 in memory location 2.\n4. Subtract the number 11 from the value in memory location 2.\n5. If the value in memory location 2 is the number 0, continue with instruc-\ntion 9.\n6. Add the value of memory location 1 to memory location 0.\n7. Add the number 1 to the value of memory location 1.\n8. Continue with instruction 3.\n9. Output the value of memory location 0.\nAlthough that is already more readable than the soup of bits, it is still rather\nobscure. Using names instead of numbers for the instructions and memory\nlocations helps.\nSet \u201ctotal\u201d to 0.\nSet \u201ccount\u201d to 1.\n[loop]\nSet \u201ccompare\u201d to \u201ccount\u201d.\nSubtract 11 from \u201ccompare\u201d.\nIf \u201ccompare\u201d is zero, continue at [end].\nAdd \u201ccount\u201d to \u201ctotal\u201d.\nAdd 1 to \u201ccount\u201d.\nContinue at [loop].\n[end]\nOutput \u201ctotal\u201d.\nCan you see how the program works at this point? The first two lines give\ntwo memory locations their starting values: total will be used to build up the\nresult of the computation, and count will keep track of the number that we are\ncurrently looking at. The lines using compare are probably the weirdest ones.\nThe program wants to see whether count is equal to 11 to decide whether it\ncan stop running. Because our hypothetical machine is rather primitive, it can\nonly test whether a number is zero and make a decision based on that. So it\nuses the memory location labeled compare to compute the value of count - 11\nand makes a decision based on that value. The next two lines add the value\n4 of count to the result and increment count by 1 every time the program has\ndecided that count is not 11 yet.\nHere is the same program in JavaScript:\nlet total = 0, count = 1;\nwhile (count <= 10) {\ntotal += count;\ncount += 1;\n}\nconsole.log(total);\n\/\/ \u2192 55\nThis version gives us a few more improvements. Most important, there is\nno need to specify the way we want the program to jump back and forth\nanymore. The while construct takes care of that. It continues executing the\nblock (wrapped in braces) below it as long as the condition it was given holds.\nThat condition is count <= 10, which means \u201ccount is less than or equal to 10\u201d.\nWe no longer have to create a temporary value and compare that to zero, which\nwas just an uninteresting detail. Part of the power of programming languages\nis that they can take care of uninteresting details for us.\nAtthe end of the program, after the whileconstructhas finished, the console\n.log operation is used to write out the result.\nFinally, here is what the program could look like if we happened to have\nthe convenient operations range and sum available, which respectively create a\ncollection of numbers within a range and compute the sum of a collection of\nnumbers:\nconsole.log(sum(range(1, 10)));\n\/\/ \u2192 55\nThe moral of this story is that the same program can be expressed in both\nlong and short, unreadable and readable ways. The first version of the program\nwas extremely obscure, whereas this last one is almost English: log the sum of\nthe range of numbers from 1 to 10. (We will see in later chapters how to define\noperations like sum and range.)\nA good programming language helps the programmer by allowing them to\ntalk about the actions that the computer has to perform on a higher level.\nIt helps omit details, provides convenient building blocks (such as while and\nconsole.log), allows you to define your own building blocks (such as sum and\nrange), and makes those blocks easy to compose.\n5 What is JavaScript?\nJavaScript was introduced in 1995 as a way to add programs to web pages in the\nNetscape Navigator browser. The language has since been adopted by all other\nmajor graphical web browsers. It has made modern web applications possible\u2014\napplications with which you can interact directly without doing a page reload\nfor every action. JavaScript is also used in more traditional websites to provide\nvarious forms of interactivity and cleverness.\nIt is important to note that JavaScript has almost nothing to do with the\nprogramming language named Java. The similar name was inspired by mar-\nketing considerations rather than good judgment. When JavaScript was being\nintroduced, the Java language was being heavily marketed and was gaining\npopularity. Someone thought it was a good idea to try to ride along on this\nsuccess. Now we are stuck with the name.\nAfter its adoption outside of Netscape, a standard document was written\nto describe the way the JavaScript language should work so that the various\npieces of software that claimed to support JavaScript were actually talking\nabout the same language. This is called the ECMAScript standard, after the\nEcma International organization that did the standardization. In practice, the\nterms ECMAScript and JavaScript can be used interchangeably\u2014they are two\nnames for the same language.\nThere are those who will say terrible things about JavaScript. Many of these\nthings are true. When I was required to write something in JavaScript for the\nfirst time, I quickly came to despise it. It would accept almost anything I typed\nbut interpret it in a way that was completely different from what I meant. This\nhad a lot to do with the fact that I did not have a clue what I was doing, of\ncourse, but there is a real issue here: JavaScript is ridiculously liberal in what\nit allows. The idea behind this design was that it would make programming in\nJavaScript easier for beginners. In actuality, it mostly makes finding problems\nin your programs harder because the system will not point them out to you.\nThis flexibility also has its advantages, though. It leaves space for a lot of\ntechniques that are impossible in more rigid languages, and as you will see\n(for example in Chapter 10), it can be used to overcome some of JavaScript\u2019s\nshortcomings. After learning the language properly and working with it for a\nwhile, I have learned to actually like JavaScript.\nThere have been several versions of JavaScript. ECMAScript version 3 was\nthe widely supported version in the time of JavaScript\u2019s ascent to dominance,\nroughly between 2000 and 2010. During this time, work was underway on\nan ambitious version 4, which planned a number of radical improvements and\nextensions to the language. Changing a living, widely used language in such a\n6 radical way turned out to be politically di\ufb00icult, and work on the version 4 was\nabandoned in 2008, leading to a much less ambitious version 5, which made\nonly some uncontroversial improvements, coming out in 2009. Then in 2015\nversion 6 came out, a major update that included some of the ideas planned\nfor version 4. Since then we\u2019ve had new, small updates every year.\nThefactthatthelanguageisevolvingmeansthatbrowsershavetoconstantly\nkeep up, and if you\u2019re using an older browser, it may not support every feature.\nThe language designers are careful to not make any changes that could break\nexisting programs, so new browsers can still run old programs. In this book,\nI\u2019m using the 2017 version of JavaScript.\nWeb browsers are not the only platforms on which JavaScript is used. Some\ndatabases, such as MongoDB and CouchDB, use JavaScript as their scripting\nand query language. Several platforms for desktop and server programming,\nmost notably the Node.js project (the subject of Chapter 20), provide an envi-\nronment for programming JavaScript outside of the browser.\nCode, and what to do with it\nCode is the text that makes up programs. Most chapters in this book contain\nquite a lot of code. I believe reading code and writing code are indispensable\nparts of learning to program. Try to not just glance over the examples\u2014read\nthem attentively and understand them. This may be slow and confusing at\nfirst, but I promise that you\u2019ll quickly get the hang of it. The same goes for\nthe exercises. Don\u2019t assume you understand them until you\u2019ve actually written\na working solution.\nI recommend you try your solutions to exercises in an actual JavaScript\ninterpreter. That way, you\u2019ll get immediate feedback on whether what you are\ndoing is working, and, I hope, you\u2019ll be tempted to experiment and go beyond\nthe exercises.\nThe easiest way to run the example code in the book, and to experiment with\nit, istolookitupintheonlineversionofthebookathttps:\/\/eloquentjavascript.net.\nThere, you can click any code example to edit and run it and to see the output\nit produces. To work on the exercises, go to https:\/\/eloquentjavascript.net\/\ncode, which provides starting code for each coding exercise and allows you to\nlook at the solutions.\nIf you want to run the programs defined in this book outside of the book\u2019s\nwebsite, some care will be required. Many examples stand on their own and\nshould work in any JavaScript environment. But code in later chapters is\noften written for a specific environment (the browser or Node.js) and can run\n7 only there. In addition, many chapters define bigger programs, and the pieces\nof code that appear in them depend on each other or on external files. The\nsandbox on the website provides links to Zip files containing all the scripts and\ndata files necessary to run the code for a given chapter.\nOverview of this book\nThis book contains roughly three parts. The first 12 chapters discuss the\nJavaScript language. The next seven chapters are about web browsers and the\nway JavaScript is used to program them. Finally, two chapters are devoted to\nNode.js, another environment to program JavaScript in.\nThroughout the book, there are five project chapters, which describe larger\nexample programs to give you a taste of actual programming. In order of\nappearance, we will work through building a delivery robot, a programming\nlanguage, a platform game, a pixel paint program, and a dynamic website.\nThe language part of the book starts with four chapters that introduce the\nbasic structure of the JavaScript language. They introduce control structures\n(such as the while word you saw in this introduction), functions (writing your\nown building blocks), and data structures. After these, you will be able to write\nbasic programs. Next, Chapters 5 and 6 introduce techniques to use functions\nand objects to write more abstract code and keep complexity under control.\nAfter a first project chapter, the language part of the book continues with\nchapters on error handling and bug fixing, regular expressions (an important\ntool for working with text), modularity (another defense against complexity),\nand asynchronous programming (dealing with events that take time). The\nsecond project chapter concludes the first part of the book.\nThesecondpart, Chapters13to19, describesthetoolsthatbrowserJavaScript\nhas access to. You\u2019ll learn to display things on the screen (Chapters 14 and\n17), respond to user input (Chapter 15), and communicate over the network\n(Chapter 18). There are again two project chapters in this part.\nAfter that, Chapter 20 describes Node.js, and Chapter 21 builds a small\nwebsite using that tool.\nTypographic conventions\nIn this book, text written in a monospaced font will represent elements of\nprograms\u2014sometimes they are self-su\ufb00icient fragments, and sometimes they\njust refer to part of a nearby program. Programs (of which you have already\nseen a few) are written as follows:\n8 function factorial(n) {\nif (n == 0) {\nreturn 1;\n} else {\nreturn factorial(n - 1) * n;\n}\n}\nSometimes, to show the output that a program produces, the expected out-\nput is written after it, with two slashes and an arrow in front.\nconsole.log(factorial(8));\n\/\/ \u2192 40320\nGood luck!\n9 \u201cBelow the surface of the machine, the program moves. Without\neffort, it expands and contracts. In great harmony, electrons scatter\nand regroup. The forms on the monitor are but ripples on the water.\nThe essence stays invisibly below.\u201d\n\u2014Master Yuan-Ma, The Book of Programming\nChapter1\nValues, Types, and Operators\nInside the computer\u2019s world, there is only data. You can read data, modify\ndata, create new data\u2014but that which isn\u2019t data cannot be mentioned. All\nthis data is stored as long sequences of bits and is thus fundamentally alike.\nBits are any kind of two-valued things, usually described as zeros and ones.\nInside the computer, they take forms such as a high or low electrical charge,\na strong or weak signal, or a shiny or dull spot on the surface of a CD. Any\npiece of discrete information can be reduced to a sequence of zeros and ones\nand thus represented in bits.\nFor example, we can express the number 13 in bits. It works the same way\nas a decimal number, but instead of 10 different digits, you have only 2, and\nthe weight of each increases by a factor of 2 from right to left. Here are the\nbits that make up the number 13, with the weights of the digits shown below\nthem:\n0 0 0 0 1 1 0 1\n128 64 32 16 8 4 2 1\nSo that\u2019s the binary number 00001101. Its non-zero digits stand for 8, 4, and\n1, and add up to 13.\nValues\nImagine a sea of bits\u2014an ocean of them. A typical modern computer has more\nthan 30 billion bits in its volatile data storage (working memory). Nonvolatile\nstorage(theharddiskorequivalent)tendstohaveyetafewordersofmagnitude\nmore.\nTo be able to work with such quantities of bits without getting lost, we must\nseparate them into chunks that represent pieces of information. In a JavaScript\nenvironment, thosechunksarecalledvalues. Thoughallvaluesaremadeofbits,\nthey play different roles. Every value has a type that determines its role. Some\n10 values are numbers, some values are pieces of text, some values are functions,\nand so on.\nTo create a value, you must merely invoke its name. This is convenient. You\ndon\u2019t have to gather building material for your values or pay for them. You\njust call for one, and whoosh, you have it. They are not really created from\nthin air, of course. Every value has to be stored somewhere, and if you want to\nuse a gigantic amount of them at the same time, you might run out of memory.\nFortunately, this is a problem only if you need them all simultaneously. As\nsoon as you no longer use a value, it will dissipate, leaving behind its bits to\nbe recycled as building material for the next generation of values.\nThis chapter introduces the atomic elements of JavaScript programs, that is,\nthe simple value types and the operators that can act on such values.\nNumbers\nValues of the number type are, unsurprisingly, numeric values. In a JavaScript\nprogram, they are written as follows:\n13\nUse that in a program, and it will cause the bit pattern for the number 13\nto come into existence inside the computer\u2019s memory.\nJavaScript uses a fixed number of bits, 64 of them, to store a single number\nvalue. There are only so many patterns you can make with 64 bits, which means\nthat the number of different numbers that can be represented is limited. With\nN decimal digits, you can represent 10N numbers. Similarly, given 64 binary\ndigits, you can represent 264 different numbers, which is about 18 quintillion\n(an 18 with 18 zeros after it). That\u2019s a lot.\nComputer memory used to be much smaller, and people tended to use groups\nof 8 or 16 bits to represent their numbers. It was easy to accidentally overflow\nsuch small numbers\u2014to end up with a number that did not fit into the given\nnumber of bits. Today, even computers that fit in your pocket have plenty of\nmemory, so you are free to use 64-bit chunks, and you need to worry about\noverflow only when dealing with truly astronomical numbers.\nNot all whole numbers less than 18 quintillion fit in a JavaScript number,\nthough. Those bits also store negative numbers, so one bit indicates the sign of\nthe number. A bigger issue is that nonwhole numbers must also be represented.\nTo do this, some of the bits are used to store the position of the decimal point.\nThe actual maximum whole number that can be stored is more in the range of\n11 9 quadrillion (15 zeros)\u2014which is still pleasantly huge.\nFractional numbers are written by using a dot.\n9.81\nFor very big or very small numbers, you may also use scientific notation by\nadding an e (for exponent), followed by the exponent of the number.\n2.998e8\nThat is 2.998 \u00d7 108 = 299,800,000.\nCalculations with whole numbers (also called integers) smaller than the\naforementioned 9 quadrillion are guaranteed to always be precise. Unfortu-\nnately, calculations with fractional numbers are generally not. Just as \u03c0 (pi)\ncannot be precisely expressed by a finite number of decimal digits, many num-\nbers lose some precision when only 64 bits are available to store them. This\nis a shame, but it causes practical problems only in specific situations. The\nimportant thing is to be aware of it and treat fractional digital numbers as\napproximations, not as precise values.\nArithmetic\nThe main thing to do with numbers is arithmetic. Arithmetic operations such\nasadditionormultiplicationtaketwonumbervaluesandproduceanewnumber\nfrom them. Here is what they look like in JavaScript:\n100 + 4 * 11\nThe + and * symbols are called operators. The first stands for addition, and\nthe second stands for multiplication. Putting an operator between two values\nwill apply it to those values and produce a new value.\nBut does the example mean \u201cadd 4 and 100, and multiply the result by 11,\u201d\nor is the multiplication done before the adding? As you might have guessed,\nthe multiplication happens first. But as in mathematics, you can change this\nby wrapping the addition in parentheses.\n(100 + 4) * 11\nFor subtraction, there is the - operator, and division can be done with the \/\noperator.\n12 When operators appear together without parentheses, the order in which\nthey are applied is determined by the precedence of the operators. The example\nshows that multiplication comes before addition. The \/ operator has the same\nprecedence as *. Likewise for + and -. When multiple operators with the same\nprecedence appear next to each other, as in 1 - 2 + 1, they are applied left to\nright: (1 - 2)+ 1.\nThese rules of precedence are not something you should worry about. When\nin doubt, just add parentheses.\nThere is one more arithmetic operator, which you might not immediately\nrecognize. The % symbol is used to represent the remainder operation. X % Y\nis the remainder of dividing X by Y. For example, 314 % 100 produces 14, and\n144 % 12 gives 0. The remainder operator\u2019s precedence is the same as that of\nmultiplication and division. You\u2019ll also often see this operator referred to as\nmodulo.\nSpecial numbers\nThere are three special values in JavaScript that are considered numbers but\ndon\u2019t behave like normal numbers.\nThe first two are Infinity and -Infinity, which represent the positive and\nnegative infinities. Infinity - 1 is still Infinity, and so on. Don\u2019t put too\nmuch trust in infinity-based computation, though. It isn\u2019t mathematically\nsound, and it will quickly lead to the next special number: NaN.\nNaN stands for \u201cnot a number\u201d, even though it is a value of the number type.\nYou\u2019ll get this result when you, for example, try to calculate 0 \/ 0 (zero divided\nbyzero), Infinity - Infinity, oranynumberofothernumericoperationsthat\ndon\u2019t yield a meaningful result.\nStrings\nThe next basic data type is the string. Strings are used to represent text. They\nare written by enclosing their content in quotes.\n`Down on the sea`\n\"Lie on the ocean\"\n'Float on the ocean'\nYou can use single quotes, double quotes, or backticks to mark strings, as\nlong as the quotes at the start and the end of the string match.\n13 Almost anything can be put between quotes, and JavaScript will make a\nstring value out of it. But a few characters are more di\ufb00icult. You can imagine\nhow putting quotes between quotes might be hard. Newlines (the characters\nyou get when you press enter) can be included without escaping only when\nthe string is quoted with backticks (\\\u2018).\nTo make it possible to include such characters in a string, the following\nnotation is used: whenever a backslash (\\) is found inside quoted text, it\nindicates that the character after it has a special meaning. This is called\nescaping the character. A quote that is preceded by a backslash will not end\nthe string but be part of it. When an n character occurs after a backslash, it is\ninterpreted as a newline. Similarly, a t after a backslash means a tab character.\nTake the following string:\n\"This is the first line\\nAnd this is the second\"\nThe actual text contained is this:\nThis is the first line\nAnd this is the second\nThere are, of course, situations where you want a backslash in a string to\nbe just a backslash, not a special code. If two backslashes follow each other,\nthey will collapse together, and only one will be left in the resulting string\nvalue. This is how the string \u201cA newline character is written like \"\\n\".\u201d can\nbe expressed:\n\"A newline character is written like \\\"\\\\n\\\".\"\nStrings, too, have to be modeled as a series of bits to be able to exist inside\nthe computer. The way JavaScript does this is based on the Unicode standard.\nThis standard assigns a number to virtually every character you would ever\nneed, including characters from Greek, Arabic, Japanese, Armenian, and so\non. If we have a number for every character, a string can be described by a\nsequence of numbers.\nAnd that\u2019s what JavaScript does. But there\u2019s a complication: JavaScript\u2019s\nrepresentation uses 16 bits per string element, which can describe up to 216\ndifferent characters. But Unicode defines more characters than that\u2014about\ntwice as many, at this point. So some characters, such as many emoji, take\nup two \u201ccharacter positions\u201d in JavaScript strings. We\u2019ll come back to this in\n14 Chapter 5.\nStrings cannot be divided, multiplied, or subtracted, but the + operator can\nbe used on them. It does not add, but it concatenates\u2014it glues two strings\ntogether. The following line will produce the string \"concatenate\":\n\"con\" + \"cat\" + \"e\" + \"nate\"\nString values have a number of associated functions (methods) that can be\nused to perform other operations on them. I\u2019ll say more about these in Chapter\n4.\nStrings written with single or double quotes behave very much the same\u2014\nthe only difference is in which type of quote you need to escape inside of them.\nBacktick-quoted strings, usually called template literals, can do a few more\ntricks. Apart from being able to span lines, they can also embed other values.\n`half of 100 is ${100 \/ 2}`\nWhen you write something inside ${} in a template literal, its result will be\ncomputed, converted to a string, and included at that position. The example\nproduces \u201chalf of 100 is 50\u201d.\nUnary operators\nNot all operators are symbols. Some are written as words. One example is the\ntypeof operator, which produces a string value naming the type of the value\nyou give it.\nconsole.log(typeof 4.5)\n\/\/ \u2192 number\nconsole.log(typeof \"x\")\n\/\/ \u2192 string\nWe will use console.log in example code to indicate that we want to see the\nresult of evaluating something. More about that in the next chapter.\nThe other operators shown all operated on two values, but typeof takes only\none. Operators that use two values are called binary operators, while those that\ntake one are called unary operators. The minus operator can be used both as\na binary operator and as a unary operator.\nconsole.log(- (10 - 2))\n15 \/\/ \u2192 -8\nBoolean values\nIt is often useful to have a value that distinguishes between only two possibili-\nties, like \u201cyes\u201d and \u201cno\u201d or \u201con\u201d and \u201coff\u201d. For this purpose, JavaScript has a\nBoolean type, which has just two values, true and false, which are written as\nthose words.\nComparison\nHere is one way to produce Boolean values:\nconsole.log(3 > 2)\n\/\/ \u2192 true\nconsole.log(3 < 2)\n\/\/ \u2192 false\nThe > and < signs are the traditional symbols for \u201cis greater than\u201d and \u201cis\nless than\u201d, respectively. They are binary operators. Applying them results in\na Boolean value that indicates whether they hold true in this case.\nStrings can be compared in the same way.\nconsole.log(\"Aardvark\" < \"Zoroaster\")\n\/\/ \u2192 true\nThe way strings are ordered is roughly alphabetic but not really what you\u2019d\nexpect to see in a dictionary: uppercase letters are always \u201cless\u201d than lowercase\nones, so \"Z\" < \"a\", and nonalphabetic characters (!, -, and so on) are also\nincluded in the ordering. When comparing strings, JavaScript goes over the\ncharacters from left to right, comparing the Unicode codes one by one.\nOther similar operators are >= (greater than or equal to), <= (less than or\nequal to), == (equal to), and != (not equal to).\nconsole.log(\"Itchy\" != \"Scratchy\")\n\/\/ \u2192 true\nconsole.log(\"Apple\" == \"Orange\")\n\/\/ \u2192 false\n16 There is only one value in JavaScript that is not equal to itself, and that is\nNaN (\u201cnot a number\u201d).\nconsole.log(NaN == NaN)\n\/\/ \u2192 false\nNaN is supposed to denote the result of a nonsensical computation, and as\nsuch, it isn\u2019t equal to the result of any other nonsensical computations.\nLogical operators\nThere are also some operations that can be applied to Boolean values them-\nselves. JavaScript supports three logical operators: and, or, and not. These\ncan be used to \u201creason\u201d about Booleans.\nThe && operator represents logical and. It is a binary operator, and its result\nis true only if both the values given to it are true.\nconsole.log(true && false)\n\/\/ \u2192 false\nconsole.log(true && true)\n\/\/ \u2192 true\nThe || operator denotes logical or. It produces true if either of the values\ngiven to it is true.\nconsole.log(false || true)\n\/\/ \u2192 true\nconsole.log(false || false)\n\/\/ \u2192 false\nNot is written as an exclamation mark (!). It is a unary operator that flips\nthe value given to it\u2014!true produces false, and !false gives true.\nWhen mixing these Boolean operators with arithmetic and other operators,\nit is not always obvious when parentheses are needed. In practice, you can\nusually get by with knowing that of the operators we have seen so far, || has\nthe lowest precedence, then comes &&, then the comparison operators (>, ==,\nand so on), and then the rest. This order has been chosen such that, in typical\nexpressions like the following one, as few parentheses as possible are necessary:\n1 + 1 == 2 && 10 * 10 > 50\n17 The last logical operator I will discuss is not unary, not binary, but ternary,\noperating on three values. It is written with a question mark and a colon, like\nthis:\nconsole.log(true ? 1 : 2);\n\/\/ \u2192 1\nconsole.log(false ? 1 : 2);\n\/\/ \u2192 2\nThis one is called the conditional operator (or sometimes just the ternary\noperator since it is the only such operator in the language). The value on the\nleft of the question mark \u201cpicks\u201d which of the other two values will come out.\nWhen it is true, it chooses the middle value, and when it is false, it chooses the\nvalue on the right.\nEmpty values\nThere are two special values, written null and undefined, that are used to\ndenote the absence of a meaningful value. They are themselves values, but\nthey carry no information.\nMany operations in the language that don\u2019t produce a meaningful value\n(you\u2019ll see some later) yield undefined simply because they have to yield some\nvalue.\nThe difference in meaning between undefined and null is an accident of\nJavaScript\u2019s design, and it doesn\u2019t matter most of the time. In cases where\nyou actually have to concern yourself with these values, I recommend treating\nthem as mostly interchangeable.\nAutomatic type conversion\nIn the Introduction, I mentioned that JavaScript goes out of its way to accept\nalmost any program you give it, even programs that do odd things. This is\nnicely demonstrated by the following expressions:\nconsole.log(8 * null)\n\/\/ \u2192 0\nconsole.log(\"5\" - 1)\n\/\/ \u2192 4\nconsole.log(\"5\" + 1)\n\/\/ \u2192 51\nconsole.log(\"five\" * 2)\n18 \/\/ \u2192 NaN\nconsole.log(false == 0)\n\/\/ \u2192 true\nWhen an operator is applied to the \u201cwrong\u201d type of value, JavaScript will\nquietly convert that value to the type it needs, using a set of rules that often\naren\u2019t what you want or expect. This is called type coercion. The null in the\nfirst expression becomes 0, and the \"5\" in the second expression becomes 5\n(from string to number). Yet in the third expression, + tries string concate-\nnation before numeric addition, so the 1 is converted to \"1\" (from number to\nstring).\nWhen something that doesn\u2019t map to a number in an obvious way (such as\n\"five\" or undefined) is converted to a number, you get the value NaN. Further\narithmetic operations on NaN keep producing NaN, so if you find yourself getting\none of those in an unexpected place, look for accidental type conversions.\nWhen comparing values of the same type using ==, the outcome is easy to\npredict: you should get true when both values are the same, except in the case\nof NaN. But when the types differ, JavaScript uses a complicated and confusing\nset of rules to determine what to do. In most cases, it just tries to convert\none of the values to the other value\u2019s type. However, when null or undefined\noccurs on either side of the operator, it produces true only if both sides are one\nof null or undefined.\nconsole.log(null == undefined);\n\/\/ \u2192 true\nconsole.log(null == 0);\n\/\/ \u2192 false\nThat behavior is often useful. When you want to test whether a value has a\nreal value instead of null or undefined, you can compare it to null with the\n== (or !=) operator.\nBut what if you want to test whether something refers to the precise value\nfalse? Expressions like 0 == false and \"\" == false are also true because\nof automatic type conversion. When you do not want any type conversions\nto happen, there are two additional operators: === and !==. The first tests\nwhether a value is precisely equal to the other, and the second tests whether it\nis not precisely equal. So \"\" === false is false as expected.\nI recommend using the three-character comparison operators defensively to\nprevent unexpected type conversions from tripping you up. But when you\u2019re\ncertain the types on both sides will be the same, there is no problem with using\n19 the shorter operators.\nShort-circuiting of logical operators\nThe logical operators && and || handle values of different types in a peculiar\nway. They will convert the value on their left side to Boolean type in order\nto decide what to do, but depending on the operator and the result of that\nconversion, they will return either the original left-hand value or the right-\nhand value.\nThe || operator, for example, will return the value to its left when that can\nbe converted to true and will return the value on its right otherwise. This has\nthe expected effect when the values are Boolean and does something analogous\nfor values of other types.\nconsole.log(null || \"user\")\n\/\/ \u2192 user\nconsole.log(\"Agnes\" || \"user\")\n\/\/ \u2192 Agnes\nWe can use this functionality as a way to fall back on a default value. If you\nhave a value that might be empty, you can put || after it with a replacement\nvalue. If the initial value can be converted to false, you\u2019ll get the replacement\ninstead. The rules for converting strings and numbers to Boolean values state\nthat 0, NaN, and the empty string (\"\") count as false, while all the other values\ncount as true. So 0 || -1 produces -1, and \"\" || \"!?\" yields \"!?\".\nThe && operator works similarly but the other way around. When the value\ntoitsleftissomethingthatconvertstofalse, itreturnsthatvalue, andotherwise\nit returns the value on its right.\nAnother important property of these two operators is that the part to their\nright is evaluated only when necessary. In the case of true || X, no matter\nwhat X is\u2014even if it\u2019s a piece of program that does something terrible\u2014the\nresult will be true, and X is never evaluated. The same goes for false && X,\nwhich is false and will ignore X. This is called short-circuit evaluation.\nThe conditional operator works in a similar way. Of the second and third\nvalues, only the one that is selected is evaluated.\nSummary\nWe looked at four types of JavaScript values in this chapter: numbers, strings,\nBooleans, and undefined values.\n20 Such values are created by typing in their name (true, null) or value (13\n, \"abc\"). You can combine and transform values with operators. We saw\nbinary operators for arithmetic (+, -, *, \/, and %), string concatenation (+),\ncomparison (==, !=, ===, !==, <, >, <=, >=), and logic (&&, ||), as well as several\nunary operators (- to negate a number, ! to negate logically, and typeof to\nfind a value\u2019s type) and a ternary operator (?:) to pick one of two values based\non a third value.\nThis gives you enough information to use JavaScript as a pocket calculator\nbutnotmuchmore. Thenextchapterwillstarttyingtheseexpressionstogether\ninto basic programs.\n21 \u201cAnd my heart glows bright red under my filmy, translucent skin and\nthey have to administer 10cc of JavaScript to get me to come back.\n(I respond well to toxins in the blood.) Man, that stuff will kick the\npeaches right out your gills!\u201d\n\u2014_why, Why\u2019s (Poignant) Guide to Ruby\nChapter2\nProgram Structure\nIn this chapter, we will start to do things that can actually be called program-\nming. We will expand our command of the JavaScript language beyond the\nnouns and sentence fragments we\u2019ve seen so far, to the point where we can\nexpress meaningful prose.\nExpressions and statements\nIn Chapter 1, we made values and applied operators to them to get new values.\nCreating values like this is the main substance of any JavaScript program. But\nthat substance has to be framed in a larger structure to be useful. So that\u2019s\nwhat we\u2019ll cover next.\nA fragment of code that produces a value is called an expression. Every value\nthat is written literally (such as 22 or \"psychoanalysis\") is an expression. An\nexpression between parentheses is also an expression, as is a binary operator\napplied to two expressions or a unary operator applied to one.\nThis shows part of the beauty of a language-based interface. Expressions\ncan contain other expressions in a way similar to how subsentences in human\nlanguages are nested\u2014a subsentence can contain its own subsentences, and\nso on. This allows us to build expressions that describe arbitrarily complex\ncomputations.\nIf an expression corresponds to a sentence fragment, a JavaScript statement\ncorresponds to a full sentence. A program is a list of statements.\nThe simplest kind of statement is an expression with a semicolon after it.\nThis is a program:\n1;\n!false;\nIt is a useless program, though. An expression can be content to just produce\na value, which can then be used by the enclosing code. A statement stands on\n22 its own, so it amounts to something only if it affects the world. It could display\nsomethingonthescreen\u2014thatcountsaschangingtheworld\u2014oritcouldchange\nthe internal state of the machine in a way that will affect the statements that\ncome after it. These changes are called side effects. The statements in the\nprevious example just produce the values 1 and true and then immediately\nthrow them away. This leaves no impression on the world at all. When you\nrun this program, nothing observable happens.\nIn some cases, JavaScript allows you to omit the semicolon at the end of a\nstatement. In other cases, it has to be there, or the next line will be treated\nas part of the same statement. The rules for when it can be safely omitted\nare somewhat complex and error-prone. So in this book, every statement that\nneeds a semicolon will always get one. I recommend you do the same, at least\nuntil you\u2019ve learned more about the subtleties of missing semicolons.\nBindings\nHow does a program keep an internal state? How does it remember things?\nWe have seen how to produce new values from old values, but this does not\nchange the old values, and the new value has to be immediately used or it will\ndissipate again. To catch and hold values, JavaScript provides a thing called a\nbinding, or variable:\nlet caught = 5 * 5;\nThat\u2019s a second kind of statement. The special word (keyword) let indicates\nthat this sentence is going to define a binding. It is followed by the name of\nthe binding and, if we want to immediately give it a value, by an = operator\nand an expression.\nThe previous statement creates a binding called caught and uses it to grab\nhold of the number that is produced by multiplying 5 by 5.\nAfter a binding has been defined, its name can be used as an expression. The\nvalue of such an expression is the value the binding currently holds. Here\u2019s an\nexample:\nlet ten = 10;\nconsole.log(ten * ten);\n\/\/ \u2192 100\nWhen a binding points at a value, that does not mean it is tied to that\n23 value forever. The = operator can be used at any time on existing bindings to\ndisconnect them from their current value and have them point to a new one.\nlet mood = \"light\";\nconsole.log(mood);\n\/\/ \u2192 light\nmood = \"dark\";\nconsole.log(mood);\n\/\/ \u2192 dark\nYou should imagine bindings as tentacles, rather than boxes. They do not\ncontain values; they grasp them\u2014two bindings can refer to the same value.\nA program can access only the values that it still has a reference to. When\nyou need to remember something, you grow a tentacle to hold on to it or you\nreattach one of your existing tentacles to it.\nLet\u2019s look at another example. To remember the number of dollars that\nLuigi still owes you, you create a binding. And then when he pays back $35,\nyou give this binding a new value.\nlet luigisDebt = 140;\nluigisDebt = luigisDebt - 35;\nconsole.log(luigisDebt);\n\/\/ \u2192 105\nWhen you define a binding without giving it a value, the tentacle has nothing\nto grasp, so it ends in thin air. If you ask for the value of an empty binding,\nyou\u2019ll get the value undefined.\nA single let statement may define multiple bindings. The definitions must\nbe separated by commas.\nlet one = 1, two = 2;\nconsole.log(one + two);\n\/\/ \u2192 3\nThe words var and const can also be used to create bindings, in a way similar\nto let.\nvar name = \"Ayda\";\nconst greeting = \"Hello \";\nconsole.log(greeting + name);\n\/\/ \u2192 Hello Ayda\n24 The first, var (short for \u201cvariable\u201d), is the way bindings were declared in\npre-2015 JavaScript. I\u2019ll get back to the precise way it differs from let in the\nnext chapter. For now, remember that it mostly does the same thing, but we\u2019ll\nrarely use it in this book because it has some confusing properties.\nThe word const stands for constant. It defines a constant binding, which\npoints at the same value for as long as it lives. This is useful for bindings that\ngive a name to a value so that you can easily refer to it later.\nBinding names\nBinding names can be any word. Digits can be part of binding names\u2014catch22\nis a valid name, for example\u2014but the name must not start with a digit. A\nbinding name may include dollar signs ($) or underscores (_) but no other\npunctuation or special characters.\nWords with a special meaning, such as let, are keywords, and they may not\nbe used as binding names. There are also a number of words that are \u201creserved\nfor use\u201d in future versions of JavaScript, which also can\u2019t be used as binding\nnames. The full list of keywords and reserved words is rather long.\nbreak case catch class const continue debugger default\ndelete do else enum export extends false finally for\nfunction if implements import interface in instanceof let\nnew package private protected public return static super\nswitch this throw true try typeof var void while with yield\nDon\u2019t worry about memorizing this list. When creating a binding produces\nan unexpected syntax error, see whether you\u2019re trying to define a reserved word.\nThe environment\nThe collection of bindings and their values that exist at a given time is called\nthe environment. When a program starts up, this environment is not empty. It\nalwayscontainsbindingsthatarepartofthelanguagestandard, andmostofthe\ntime, it also has bindings that provide ways to interact with the surrounding\nsystem. For example, in a browser, there are functions to interact with the\ncurrently loaded website and to read mouse and keyboard input.\n25 Functions\nA lot of the values provided in the default environment have the type function.\nA function is a piece of program wrapped in a value. Such values can be applied\nin order to run the wrapped program. For example, in a browser environment,\nthe binding prompt holds a function that shows a little dialog box asking for\nuser input. It is used like this:\nprompt(\"Enter passcode\");\nExecuting a function is called invoking, calling, or applying it. You can\ncall a function by putting parentheses after an expression that produces a\nfunction value. Usually you\u2019ll directly use the name of the binding that holds\nthe function. The values between the parentheses are given to the program\ninside the function. In the example, the prompt function uses the string that\nwe give it as the text to show in the dialog box. Values given to functions are\ncalled arguments. Different functions might need a different number or different\ntypes of arguments.\nThe prompt function isn\u2019t used much in modern web programming, mostly\nbecause you have no control over the way the resulting dialog looks, but can\nbe helpful in toy programs and experiments.\nThe console.log function\nIn the examples, I used console.log to output values. Most JavaScript sys-\ntems (including all modern web browsers and Node.js) provide a console.log\nfunction that writes out its arguments to some text output device. In browsers,\nthe output lands in the JavaScript console. This part of the browser interface\nis hidden by default, but most browsers open it when you press F12 or, on a\nMac, command-option-I. If that does not work, search through the menus\nfor an item named Developer Tools or similar.\nThough binding names cannot contain period characters, console.log does\nhave one. This is because console.log isn\u2019t a simple binding. It is actually an\n26 expression that retrieves the log property from the value held by the console\nbinding. We\u2019ll find out exactly what this means in Chapter 4.\nReturn values\nShowing a dialog box or writing text to the screen is a side effect. A lot of\nfunctions are useful because of the side effects they produce. Functions may\nalso produce values, in which case they don\u2019t need to have a side effect to\nbe useful. For example, the function Math.max takes any amount of number\narguments and gives back the greatest.\nconsole.log(Math.max(2, 4));\n\/\/ \u2192 4\nWhen a function produces a value, it is said to return that value. Anything\nthat produces a value is an expression in JavaScript, which means function\ncalls can be used within larger expressions. Here a call to Math.min, which is\nthe opposite of Math.max, is used as part of a plus expression:\nconsole.log(Math.min(2, 4) + 100);\n\/\/ \u2192 102\nThe next chapter explains how to write your own functions.\nControl flow\nWhen your program contains more than one statement, the statements are\nexecuted as if they are a story, from top to bottom. This example program\nhas two statements. The first one asks the user for a number, and the second,\nwhich is executed after the first, shows the square of that number.\nlet theNumber = Number(prompt(\"Pick a number\"));\nconsole.log(\"Your number is the square root of \" +\ntheNumber * theNumber);\nThe function Number converts a value to a number. We need that conversion\nbecause the result of prompt is a string value, and we want a number. There\nare similar functions called String and Boolean that convert values to those\ntypes.\n27 Here is the rather trivial schematic representation of straight-line control\nflow:\nConditional execution\nNot all programs are straight roads. We may, for example, want to create\na branching road, where the program takes the proper branch based on the\nsituation at hand. This is called conditional execution.\nConditional execution is created with the if keyword in JavaScript. In the\nsimplecase, wewantsomecodetobeexecutedif, andonlyif, acertaincondition\nholds. We might, for example, want to show the square of the input only if the\ninput is actually a number.\nlet theNumber = Number(prompt(\"Pick a number\"));\nif (!Number.isNaN(theNumber)) {\nconsole.log(\"Your number is the square root of \" +\ntheNumber * theNumber);\n}\nWith this modification, if you enter \u201cparrot\u201d, no output is shown.\nThe if keyword executes or skips a statement depending on the value of\na Boolean expression. The deciding expression is written after the keyword,\nbetween parentheses, followed by the statement to execute.\nThe Number.isNaN function is a standard JavaScript function that returns\ntrue only if the argument it is given is NaN. The Number function happens to\nreturn NaN when you give it a string that doesn\u2019t represent a valid number.\nThus, the condition translates to \u201cunless theNumber is not-a-number, do this\u201d.\nThe statement after the if is wrapped in braces ({ and }) in this example.\nThe braces can be used to group any number of statements into a single state-\nment, called a block. You could also have omitted them in this case, since they\nhold only a single statement, but to avoid having to think about whether they\nare needed, most JavaScript programmers use them in every wrapped state-\nment like this. We\u2019ll mostly follow that convention in this book, except for the\noccasional one-liner.\n28 if (1 + 1 == 2) console.log(\"It's true\");\n\/\/ \u2192 It's true\nYou often won\u2019t just have code that executes when a condition holds true,\nbut also code that handles the other case. This alternate path is represented\nby the second arrow in the diagram. You can use the else keyword, together\nwith if, to create two separate, alternative execution paths.\nlet theNumber = Number(prompt(\"Pick a number\"));\nif (!Number.isNaN(theNumber)) {\nconsole.log(\"Your number is the square root of \" +\ntheNumber * theNumber);\n} else {\nconsole.log(\"Hey. Why didn't you give me a number?\");\n}\nIf you have more than two paths to choose from, you can \u201cchain\u201d multiple\nif\/else pairs together. Here\u2019s an example:\nlet num = Number(prompt(\"Pick a number\"));\nif (num < 10) {\nconsole.log(\"Small\");\n} else if (num < 100) {\nconsole.log(\"Medium\");\n} else {\nconsole.log(\"Large\");\n}\nThe program will first check whether num is less than 10. If it is, it chooses\nthat branch, shows \"Small\", and is done. If it isn\u2019t, it takes the else branch,\nwhich itself contains a second if. If the second condition (< 100) holds, that\nmeans the number is at least 10 but below 100, and \"Medium\" is shown. If it\ndoesn\u2019t, the second and last else branch is chosen.\nThe schema for this program looks something like this:\n29 while and do loops\nConsider a program that outputs all even numbers from 0 to 12. One way to\nwrite this is as follows:\nconsole.log(0);\nconsole.log(2);\nconsole.log(4);\nconsole.log(6);\nconsole.log(8);\nconsole.log(10);\nconsole.log(12);\nThat works, but the idea of writing a program is to make something less\nwork, not more. If we needed all even numbers less than 1,000, this approach\nwould be unworkable. What we need is a way to run a piece of code multiple\ntimes. This form of control flow is called a loop.\nLooping control flow allows us to go back to some point in the program where\nwe were before and repeat it with our current program state. If we combine\nthis with a binding that counts, we can do something like this:\nlet number = 0;\nwhile (number <= 12) {\nconsole.log(number);\nnumber = number + 2;\n}\n\/\/ \u2192 0\n\/\/ \u2192 2\n\/\/ \u2026 etcetera\nA statement starting with the keyword while creates a loop. The word while\nis followed by an expression in parentheses and then a statement, much like if.\nThe loop keeps entering that statement as long as the expression produces a\nvalue that gives true when converted to Boolean.\nThe number binding demonstrates the way a binding can track the progress\nof a program. Every time the loop repeats, number gets a value that is 2 more\nthan its previous value. At the beginning of every repetition, it is compared\n30 with the number 12 to decide whether the program\u2019s work is finished.\nAs an example that actually does something useful, we can now write a\nprogram that calculates and shows the value of 210 (2 to the 10th power). We\nuse two bindings: one to keep track of our result and one to count how often\nwe have multiplied this result by 2. The loop tests whether the second binding\nhas reached 10 yet and, if not, updates both bindings.\nlet result = 1;\nlet counter = 0;\nwhile (counter < 10) {\nresult = result * 2;\ncounter = counter + 1;\n}\nconsole.log(result);\n\/\/ \u2192 1024\nThe counter could also have started at 1 and checked for <= 10, but for\nreasons that will become apparent in Chapter 4, it is a good idea to get used\nto counting from 0.\nA do loop is a control structure similar to a while loop. It differs only on one\npoint: a do loop always executes its body at least once, and it starts testing\nwhether it should stop only after that first execution. To reflect this, the test\nappears after the body of the loop.\nlet yourName;\ndo {\nyourName = prompt(\"Who are you?\");\n} while (!yourName);\nconsole.log(yourName);\nThis program will force you to enter a name. It will ask again and again until\nit gets something that is not an empty string. Applying the ! operator will\nconvert a value to Boolean type before negating it, and all strings except \"\"\nconvert to true. This means the loop continues going round until you provide\na non-empty name.\nIndenting Code\nIn the examples, I\u2019ve been adding spaces in front of statements that are part\nof some larger statement. These spaces are not required\u2014the computer will\naccept the program just fine without them. In fact, even the line breaks in\n31 programs are optional. You could write a program as a single long line if you\nfelt like it.\nThe role of this indentation inside blocks is to make the structure of the\ncode stand out. In code where new blocks are opened inside other blocks,\nit can become hard to see where one block ends and another begins. With\nproper indentation, the visual shape of a program corresponds to the shape of\nthe blocks inside it. I like to use two spaces for every open block, but tastes\ndiffer\u2014some people use four spaces, and some people use tab characters. The\nimportant thing is that each new block adds the same amount of space.\nif (false != true) {\nconsole.log(\"That makes sense.\");\nif (1 < 2) {\nconsole.log(\"No surprise there.\");\n}\n}\nMost code editor programs will help by automatically indenting new lines\nthe proper amount.\nfor loops\nMany loops follow the pattern shown in the while examples. First a \u201ccounter\u201d\nbinding is created to track the progress of the loop. Then comes a while loop,\nusually with a test expression that checks whether the counter has reached\nits end value. At the end of the loop body, the counter is updated to track\nprogress.\nBecause this pattern is so common, JavaScript and similar languages provide\na slightly shorter and more comprehensive form, the for loop.\nfor (let number = 0; number <= 12; number = number + 2) {\nconsole.log(number);\n}\n\/\/ \u2192 0\n\/\/ \u2192 2\n\/\/ \u2026 etcetera\nThis program is exactly equivalent to the earlier even-number-printing exam-\nple. The only change is that all the statements that are related to the \u201cstate\u201d\nof the loop are grouped together after for.\n32 The parentheses after a for keyword must contain two semicolons. The part\nbefore the first semicolon initializes the loop, usually by defining a binding.\nThe second part is the expression that checks whether the loop must continue.\nThe final part updates the state of the loop after every iteration. In most cases,\nthis is shorter and clearer than a while construct.\nThis is the code that computes 210 using for instead of while:\nlet result = 1;\nfor (let counter = 0; counter < 10; counter = counter + 1) {\nresult = result * 2;\n}\nconsole.log(result);\n\/\/ \u2192 1024\nBreaking Out of a Loop\nHaving the looping condition produce false is not the only way a loop can fin-\nish. There is a special statement called break that has the effect of immediately\njumping out of the enclosing loop.\nThis program illustrates the break statement. It finds the first number that\nis both greater than or equal to 20 and divisible by 7.\nfor (let current = 20; ; current = current + 1) {\nif (current % 7 == 0) {\nconsole.log(current);\nbreak;\n}\n}\n\/\/ \u2192 21\nUsing the remainder (%) operator is an easy way to test whether a number\nis divisible by another number. If it is, the remainder of their division is zero.\nThe for construct in the example does not have a part that checks for the\nend of the loop. This means that the loop will never stop unless the break\nstatement inside is executed.\nIf you were to remove that break statement or you accidentally write an\nend condition that always produces true, your program would get stuck in an\ninfinite loop. A program stuck in an infinite loop will never finish running,\nwhich is usually a bad thing.\n33 The continue keyword is similar to break, in that it influences the progress\nof a loop. When continue is encountered in a loop body, control jumps out of\nthe body and continues with the loop\u2019s next iteration.\nUpdating bindings succinctly\nEspecially when looping, a program often needs to \u201cupdate\u201d a binding to hold\na value based on that binding\u2019s previous value.\ncounter = counter + 1;\nJavaScript provides a shortcut for this.\ncounter += 1;\nSimilar shortcuts work for many other operators, such as result *= 2 to\ndouble result or counter -= 1 to count downward.\nThis allows us to shorten our counting example a little more.\nfor (let number = 0; number <= 12; number += 2) {\nconsole.log(number);\n}\nFor counter += 1 and counter -= 1, there are even shorter equivalents:\ncounter++ and counter--.\nDispatching on a value with switch\nIt is not uncommon for code to look like this:\nif (x == \"value1\") action1();\nelse if (x == \"value2\") action2();\nelse if (x == \"value3\") action3();\nelse defaultAction();\nThere is a construct called switch that is intended to express such a \u201cdis-\npatch\u201d in a more direct way. Unfortunately, the syntax JavaScript uses for\nthis (which it inherited from the C\/Java line of programming languages) is\nsomewhat awkward\u2014a chain of if statements may look better. Here is an\nexample:\n34 switch (prompt(\"What is the weather like?\")) {\ncase \"rainy\":\nconsole.log(\"Remember to bring an umbrella.\");\nbreak;\ncase \"sunny\":\nconsole.log(\"Dress lightly.\");\ncase \"cloudy\":\nconsole.log(\"Go outside.\");\nbreak;\ndefault:\nconsole.log(\"Unknown weather type!\");\nbreak;\n}\nYou may put any number of case labels inside the block opened by switch.\nThe program will start executing at the label that corresponds to the value\nthat switch was given, or at default if no matching value is found. It will\ncontinue executing, even across other labels, until it reaches a break statement.\nIn some cases, such as the \"sunny\" case in the example, this can be used to\nshare some code between cases (it recommends going outside for both sunny\nand cloudy weather). But be careful\u2014it is easy to forget such a break, which\nwill cause the program to execute code you do not want executed.\nCapitalization\nBinding names may not contain spaces, yet it is often helpful to use multiple\nwords to clearly describe what the binding represents. These are pretty much\nyour choices for writing a binding name with several words in it:\nfuzzylittleturtle\nfuzzy_little_turtle\nFuzzyLittleTurtle\nfuzzyLittleTurtle\nThe first style can be hard to read. I rather like the look of the underscores,\nthough that style is a little painful to type. The standard JavaScript functions,\nand most JavaScript programmers, follow the bottom style\u2014they capitalize\nevery word except the first. It is not hard to get used to little things like that,\nand code with mixed naming styles can be jarring to read, so we follow this\nconvention.\nIn a few cases, such as the Number function, the first letter of a binding is\n35 also capitalized. This was done to mark this function as a constructor. What\na constructor is will become clear in Chapter 6. For now, the important thing\nis not to be bothered by this apparent lack of consistency.\nComments\nOften, raw code does not convey all the information you want a program to\nconvey to human readers, or it conveys it in such a cryptic way that people\nmight not understand it. At other times, you might just want to include some\nrelated thoughts as part of your program. This is what comments are for.\nA comment is a piece of text that is part of a program but is completely\nignored by the computer. JavaScript has two ways of writing comments. To\nwrite a single-line comment, you can use two slash characters (\/\/) and then\nthe comment text after it.\nlet accountBalance = calculateBalance(account);\n\/\/ It's a green hollow where a river sings\naccountBalance.adjust();\n\/\/ Madly catching white tatters in the grass.\nlet report = new Report();\n\/\/ Where the sun on the proud mountain rings:\naddToReport(accountBalance, report);\n\/\/ It's a little valley, foaming like light in a glass.\nA \/\/ comment goes only to the end of the line. A section of text between\n\/* and *\/ will be ignored in its entirety, regardless of whether it contains line\nbreaks. This is useful for adding blocks of information about a file or a chunk\nof program.\n\/*\nI first found this number scrawled on the back of an old\nnotebook. Since then, it has often dropped by, showing up in\nphone numbers and the serial numbers of products that I've\nbought. It obviously likes me, so I've decided to keep it.\n*\/\nconst myNumber = 11213;\n36 Summary\nYou now know that a program is built out of statements, which themselves\nsometimes contain more statements. Statements tend to contain expressions,\nwhich themselves can be built out of smaller expressions.\nPutting statements after one another gives you a program that is executed\nfrom top to bottom. You can introduce disturbances in the flow of control\nby using conditional (if, else, and switch) and looping (while, do, and for)\nstatements.\nBindings can be used to file pieces of data under a name, and they are useful\nfor tracking state in your program. The environment is the set of bindings\nthat are defined. JavaScript systems always put a number of useful standard\nbindings into your environment.\nFunctions are special values that encapsulate a piece of program. You can\ninvoke them by writing functionName(argument1, argument2). Such a function\ncall is an expression and may produce a value.\nExercises\nIf you are unsure how to test your solutions to the exercises, refer to the Intro-\nduction.\nEach exercise starts with a problem description. Read this description and\ntry to solve the exercise. If you run into problems, consider reading the hints\nat the end of the book. Full solutions to the exercises are not included in this\nbook, but you can find them online at https:\/\/eloquentjavascript.net\/code. If\nyou want to learn something from the exercises, I recommend looking at the\nsolutions only after you\u2019ve solved the exercise, or at least after you\u2019ve attacked\nit long and hard enough to have a slight headache.\nLooping a triangle\nWrite a loop that makes seven calls to console.log to output the following\ntriangle:\n#\n##\n###\n####\n#####\n######\n#######\n37 It may be useful to know that you can find the length of a string by writing\n.length after it.\nlet abc = \"abc\";\nconsole.log(abc.length);\n\/\/ \u2192 3\nFizzBuzz\nWrite a program that uses console.log to print all the numbers from 1 to 100,\nwith two exceptions. For numbers divisible by 3, print \"Fizz\" instead of the\nnumber, and for numbers divisible by 5 (and not 3), print \"Buzz\" instead.\nWhen you have that working, modify your program to print \"FizzBuzz\" for\nnumbers that are divisible by both 3 and 5 (and still print \"Fizz\" or \"Buzz\"\nfor numbers divisible by only one of those).\n(This is actually an interview question that has been claimed to weed out\na significant percentage of programmer candidates. So if you solved it, your\nlabor market value just went up.)\nChessboard\nWriteaprogramthatcreatesastringthatrepresentsan8\u00d78grid, usingnewline\ncharacters to separate lines. At each position of the grid there is either a space\nor a \"#\" character. The characters should form a chessboard.\nPassing this string to console.log should show something like this:\n# # # #\n# # # #\n# # # #\n# # # #\n# # # #\n# # # #\n# # # #\n# # # #\nWhen you have a program that generates this pattern, define a binding size\n= 8 and change the program so that it works for any size, outputting a grid\nof the given width and height.\n38 \u201cPeople think that computer science is the art of geniuses but the\nactual reality is the opposite, just many people doing things that\nbuild on each other, like a wall of mini stones.\u201d\n\u2014Donald Knuth\nChapter3\nFunctions\nFunctions are the bread and butter of JavaScript programming. The concept\nof wrapping a piece of program in a value has many uses. It gives us a way\nto structure larger programs, to reduce repetition, to associate names with\nsubprograms, and to isolate these subprograms from each other.\nThe most obvious application of functions is defining new vocabulary. Cre-\nating new words in prose is usually bad style. But in programming, it is\nindispensable.\nTypical adult English speakers have some 20,000 words in their vocabulary.\nFew programming languages come with 20,000 commands built in. And the\nvocabulary that is available tends to be more precisely defined, and thus less\nflexible, than in human language. Therefore, we usually have to introduce new\nconcepts to avoid repeating ourselves too much.\nDefining a function\nA function definition is a regular binding where the value of the binding is\na function. For example, this code defines square to refer to a function that\nproduces the square of a given number:\nconst square = function(x) {\nreturn x * x;\n};\nconsole.log(square(12));\n\/\/ \u2192 144\nAfunctioniscreatedwithanexpressionthatstartswiththekeywordfunction\n. Functions have a set of parameters (in this case, only x) and a body, which\ncontains the statements that are to be executed when the function is called.\nThe function body of a function created this way must always be wrapped in\nbraces, even when it consists of only a single statement.\n39 A function can have multiple parameters or no parameters at all. In the\nfollowingexample, makeNoisedoesnotlistanyparameternames, whereaspower\nlists two:\nconst makeNoise = function() {\nconsole.log(\"Pling!\");\n};\nmakeNoise();\n\/\/ \u2192 Pling!\nconst power = function(base, exponent) {\nlet result = 1;\nfor (let count = 0; count < exponent; count++) {\nresult *= base;\n}\nreturn result;\n};\nconsole.log(power(2, 10));\n\/\/ \u2192 1024\nSome functions produce a value, such as power and square, and some don\u2019t,\nsuch as makeNoise, whose only result is a side effect. A return statement\ndetermines the value the function returns. When control comes across such\na statement, it immediately jumps out of the current function and gives the\nreturned value to the code that called the function. A return keyword without\nan expression after it will cause the function to return undefined. Functions\nthat don\u2019t have a return statement at all, such as makeNoise, similarly return\nundefined.\nParameters to a function behave like regular bindings, but their initial values\nare given by the caller of the function, not the code in the function itself.\nBindings and scopes\nEach binding has a scope, which is the part of the program in which the binding\nis visible. For bindings defined outside of any function or block, the scope is\nthe whole program\u2014you can refer to such bindings wherever you want. These\nare called global.\nBut bindings created for function parameters or declared inside a function\ncan be referenced only in that function, so they are known as local bindings.\n40 Every time the function is called, new instances of these bindings are created.\nThis provides some isolation between functions\u2014each function call acts in its\nown little world (its local environment) and can often be understood without\nknowing a lot about what\u2019s going on in the global environment.\nBindings declared with let and const are in fact local to the block that they\nare declared in, so if you create one of those inside of a loop, the code before and\nafter the loop cannot \u201csee\u201d it. In pre-2015 JavaScript, only functions created\nnew scopes, so old-style bindings, created with the var keyword, are visible\nthroughout the whole function that they appear in\u2014or throughout the global\nscope, if they are not in a function.\nlet x = 10;\nif (true) {\nlet y = 20;\nvar z = 30;\nconsole.log(x + y + z);\n\/\/ \u2192 60\n}\n\/\/ y is not visible here\nconsole.log(x + z);\n\/\/ \u2192 40\nEach scope can \u201clook out\u201d into the scope around it, so x is visible inside the\nblock in the example. The exception is when multiple bindings have the same\nname\u2014in that case, code can see only the innermost one. For example, when\nthe code inside the halve function refers to n, it is seeing its own n, not the\nglobal n.\nconst halve = function(n) {\nreturn n \/ 2;\n};\nlet n = 10;\nconsole.log(halve(100));\n\/\/ \u2192 50\nconsole.log(n);\n\/\/ \u2192 10\n41 Nested scope\nJavaScriptdistinguishesnotjustglobal andlocal bindings. Blocksandfunctions\ncan be created inside other blocks and functions, producing multiple degrees\nof locality.\nFor example, this function\u2014which outputs the ingredients needed to make\na batch of hummus\u2014has another function inside it:\nconst hummus = function(factor) {\nconst ingredient = function(amount, unit, name) {\nlet ingredientAmount = amount * factor;\nif (ingredientAmount > 1) {\nunit += \"s\";\n}\nconsole.log(`${ingredientAmount} ${unit} ${name}`);\n};\ningredient(1, \"can\", \"chickpeas\");\ningredient(0.25, \"cup\", \"tahini\");\ningredient(0.25, \"cup\", \"lemon juice\");\ningredient(1, \"clove\", \"garlic\");\ningredient(2, \"tablespoon\", \"olive oil\");\ningredient(0.5, \"teaspoon\", \"cumin\");\n};\nThe code inside the ingredient function can see the factor binding from\nthe outer function. But its local bindings, such as unit or ingredientAmount,\nare not visible in the outer function.\nThe set of bindings visible inside a block is determined by the place of that\nblock in the program text. Each local scope can also see all the local scopes that\ncontain it, and all scopes can see the global scope. This approach to binding\nvisibility is called lexical scoping.\nFunctions as values\nA function binding usually simply acts as a name for a specific piece of the\nprogram. Such a binding is defined once and never changed. This makes it\neasy to confuse the function and its name.\nBut the two are different. A function value can do all the things that other\nvalues can do\u2014you can use it in arbitrary expressions, not just call it. It is\npossible to store a function value in a new binding, pass it as an argument to\na function, and so on. Similarly, a binding that holds a function is still just a\nregular binding and can, if not constant, be assigned a new value, like so:\n42 let launchMissiles = function() {\nmissileSystem.launch(\"now\");\n};\nif (safeMode) {\nlaunchMissiles = function() {\/* do nothing *\/};\n}\nIn Chapter 5, we will discuss the interesting things that can be done by\npassing around function values to other functions.\nDeclaration notation\nThere is a slightly shorter way to create a function binding. When the function\nkeyword is used at the start of a statement, it works differently.\nfunction square(x) {\nreturn x * x;\n}\nThis is a function declaration. The statement defines the binding square and\npoints it at the given function. It is slightly easier to write and doesn\u2019t require\na semicolon after the function.\nThere is one subtlety with this form of function definition.\nconsole.log(\"The future says:\", future());\nfunction future() {\nreturn \"You'll never have flying cars\";\n}\nThe preceding code works, even though the function is defined below the code\nthat uses it. Function declarations are not part of the regular top-to-bottom\nflow of control. They are conceptually moved to the top of their scope and can\nbe used by all the code in that scope. This is sometimes useful because it offers\nthe freedom to order code in a way that seems meaningful, without worrying\nabout having to define all functions before they are used.\n43 Arrow functions\nThere\u2019s a third notation for functions, which looks very different from the\nothers. Instead of the function keyword, it uses an arrow (=>) made up of an\nequal sign and a greater-than character (not to be confused with the greater-\nthan-or-equal operator, which is written >=).\nconst power = (base, exponent) => {\nlet result = 1;\nfor (let count = 0; count < exponent; count++) {\nresult *= base;\n}\nreturn result;\n};\nThe arrow comes after the list of parameters and is followed by the function\u2019s\nbody. It expresses something like \u201cthis input (the parameters) produces this\nresult (the body)\u201d.\nWhen there is only one parameter name, you can omit the parentheses\naround the parameter list. If the body is a single expression, rather than a\nblock in braces, that expression will be returned from the function. So, these\ntwo definitions of square do the same thing:\nconst square1 = (x) => { return x * x; };\nconst square2 = x => x * x;\nWhen an arrow function has no parameters at all, its parameter list is just\nan empty set of parentheses.\nconst horn = () => {\nconsole.log(\"Toot\");\n};\nThere\u2019s no deep reason to have both arrow functions and function expres-\nsions in the language. Apart from a minor detail, which we\u2019ll discuss in Chapter\n6, they do the same thing. Arrow functions were added in 2015, mostly to make\nit possible to write small function expressions in a less verbose way. We\u2019ll be\nusing them a lot in Chapter 5.\n44 The call stack\nThe way control flows through functions is somewhat involved. Let\u2019s take a\ncloser look at it. Here is a simple program that makes a few function calls:\nfunction greet(who) {\nconsole.log(\"Hello \" + who);\n}\ngreet(\"Harry\");\nconsole.log(\"Bye\");\nA run through this program goes roughly like this: the call to greet causes\ncontrol to jump to the start of that function (line 2). The function calls console\n.log, which takes control, does its job, and then returns control to line 2. There\nit reaches the end of the greet function, so it returns to the place that called it,\nwhich is line 4. The line after that calls console.log again. After that returns,\nthe program reaches its end.\nWe could show the flow of control schematically like this:\nnot in function\nin greet\nin console.log\nin greet\nnot in function\nin console.log\nnot in function\nBecause a function has to jump back to the place that called it when it re-\nturns, the computer must remember the context from which the call happened.\nIn one case, console.log has to return to the greet function when it is done.\nIn the other case, it returns to the end of the program.\nThe place where the computer stores this context is the call stack. Every\ntime a function is called, the current context is stored on top of this stack.\nWhen a function returns, it removes the top context from the stack and uses\nthat context to continue execution.\nStoring this stack requires space in the computer\u2019s memory. When the stack\ngrows too big, the computer will fail with a message like \u201cout of stack space\u201d\nor \u201ctoo much recursion\u201d. The following code illustrates this by asking the\ncomputer a really hard question that causes an infinite back-and-forth between\ntwo functions. Rather, it would be infinite, if the computer had an infinite\nstack. As it is, we will run out of space, or \u201cblow the stack\u201d.\n45 function chicken() {\nreturn egg();\n}\nfunction egg() {\nreturn chicken();\n}\nconsole.log(chicken() + \" came first.\");\n\/\/ \u2192 ??\nOptional Arguments\nThe following code is allowed and executes without any problem:\nfunction square(x) { return x * x; }\nconsole.log(square(4, true, \"hedgehog\"));\n\/\/ \u2192 16\nWe defined square with only one parameter. Yet when we call it with three,\nthe language doesn\u2019t complain. It ignores the extra arguments and computes\nthe square of the first one.\nJavaScript is extremely broad-minded about the number of arguments you\npass to a function. If you pass too many, the extra ones are ignored. If you\npass too few, the missing parameters get assigned the value undefined.\nThe downside of this is that it is possible\u2014likely, even\u2014that you\u2019ll acciden-\ntally pass the wrong number of arguments to functions. And no one will tell\nyou about it.\nThe upside is that this behavior can be used to allow a function to be called\nwith different numbers of arguments. For example, this minus function tries to\nimitate the - operator by acting on either one or two arguments:\nfunction minus(a, b) {\nif (b === undefined) return -a;\nelse return a - b;\n}\nconsole.log(minus(10));\n\/\/ \u2192 -10\nconsole.log(minus(10, 5));\n\/\/ \u2192 5\n46 If you write an = operator after a parameter, followed by an expression, the\nvalue of that expression will replace the argument when it is not given.\nFor example, this version of power makes its second argument optional. If\nyou don\u2019t provide it or pass the value undefined, it will default to two, and the\nfunction will behave like square.\nfunction power(base, exponent = 2) {\nlet result = 1;\nfor (let count = 0; count < exponent; count++) {\nresult *= base;\n}\nreturn result;\n}\nconsole.log(power(4));\n\/\/ \u2192 16\nconsole.log(power(2, 6));\n\/\/ \u2192 64\nIn the next chapter, we will see a way in which a function body can get at\nthe whole list of arguments it was passed. This is helpful because it makes\nit possible for a function to accept any number of arguments. For example,\nconsole.log does this\u2014it outputs all of the values it is given.\nconsole.log(\"C\", \"O\", 2);\n\/\/ \u2192 C O 2\nClosure\nThe ability to treat functions as values, combined with the fact that local\nbindings are re-created every time a function is called, brings up an interesting\nquestion. What happens to local bindings when the function call that created\nthem is no longer active?\nThefollowingcodeshowsanexampleofthis. Itdefinesafunction, wrapValue,\nthat creates a local binding. It then returns a function that accesses and returns\nthis local binding.\nfunction wrapValue(n) {\nlet local = n;\nreturn () => local;\n}\n47 let wrap1 = wrapValue(1);\nlet wrap2 = wrapValue(2);\nconsole.log(wrap1());\n\/\/ \u2192 1\nconsole.log(wrap2());\n\/\/ \u2192 2\nThis is allowed and works as you\u2019d hope\u2014both instances of the binding can\nstill be accessed. This situation is a good demonstration of the fact that local\nbindings are created anew for every call, and different calls can\u2019t trample on\none another\u2019s local bindings.\nThis feature\u2014being able to reference a specific instance of a local binding in\nan enclosing scope\u2014is called closure. A function that references bindings from\nlocal scopes around it is called a closure. This behavior not only frees you from\nhaving to worry about lifetimes of bindings but also makes it possible to use\nfunction values in some creative ways.\nWith a slight change, we can turn the previous example into a way to create\nfunctions that multiply by an arbitrary amount.\nfunction multiplier(factor) {\nreturn number => number * factor;\n}\nlet twice = multiplier(2);\nconsole.log(twice(5));\n\/\/ \u2192 10\nThe explicit local binding from the wrapValue example isn\u2019t really needed\nsince a parameter is itself a local binding.\nThinking about programs like this takes some practice. A good mental model\nis to think of function values as containing both the code in their body and the\nenvironment in which they are created. When called, the function body sees\nthe environment in which it was created, not the environment in which it is\ncalled.\nIn the example, multiplier is called and creates an environment in which its\nfactor parameter is bound to 2. The function value it returns, which is stored\nin twice, remembers this environment. So when that is called, it multiplies its\nargument by 2.\n48 Recursion\nIt is perfectly okay for a function to call itself, as long as it doesn\u2019t do it so\noften that it overflows the stack. A function that calls itself is called recursive.\nRecursion allows some functions to be written in a different style. Take, for\nexample, this alternative implementation of power:\nfunction power(base, exponent) {\nif (exponent == 0) {\nreturn 1;\n} else {\nreturn base * power(base, exponent - 1);\n}\n}\nconsole.log(power(2, 3));\n\/\/ \u2192 8\nThis is rather close to the way mathematicians define exponentiation and\narguably describes the concept more clearly than the looping variant. The\nfunction calls itself multiple times with ever smaller exponents to achieve the\nrepeated multiplication.\nBut this implementation has one problem: in typical JavaScript implementa-\ntions, it\u2019s about three times slower than the looping version. Running through\na simple loop is generally cheaper than calling a function multiple times.\nThe dilemma of speed versus elegance is an interesting one. You can see it as\na kind of continuum between human-friendliness and machine-friendliness. Al-\nmost any program can be made faster by making it bigger and more convoluted.\nThe programmer has to decide on an appropriate balance.\nIn the case of the power function, the inelegant (looping) version is still fairly\nsimple and easy to read. It doesn\u2019t make much sense to replace it with the\nrecursive version. Often, though, a program deals with such complex concepts\nthat giving up some e\ufb00iciency in order to make the program more straightfor-\nward is helpful.\nWorrying about e\ufb00iciency can be a distraction. It\u2019s yet another factor that\ncomplicates program design, and when you\u2019re doing something that\u2019s already\ndi\ufb00icult, that extra thing to worry about can be paralyzing.\nTherefore, always start by writing something that\u2019s correct and easy to un-\nderstand. If you\u2019re worried that it\u2019s too slow\u2014which it usually isn\u2019t since\nmost code simply isn\u2019t executed often enough to take any significant amount\nof time\u2014you can measure afterward and improve it if necessary.\n49 Recursion is not always just an ine\ufb00icient alternative to looping. Some prob-\nlems really are easier to solve with recursion than with loops. Most often these\nare problems that require exploring or processing several \u201cbranches\u201d, each of\nwhich might branch out again into even more branches.\nConsider this puzzle: by starting from the number 1 and repeatedly either\nadding 5 or multiplying by 3, an infinite set of numbers can be produced. How\nwould you write a function that, given a number, tries to find a sequence of\nsuch additions and multiplications that produces that number?\nFor example, the number 13 could be reached by first multiplying by 3 and\nthen adding 5 twice, whereas the number 15 cannot be reached at all.\nHere is a recursive solution:\nfunction findSolution(target) {\nfunction find(current, history) {\nif (current == target) {\nreturn history;\n} else if (current > target) {\nreturn null;\n} else {\nreturn find(current + 5, `(${history} + 5)`) ||\nfind(current * 3, `(${history} * 3)`);\n}\n}\nreturn find(1, \"1\");\n}\nconsole.log(findSolution(24));\n\/\/ \u2192 (((1 * 3) + 5) * 3)\nNote that this program doesn\u2019t necessarily find the shortest sequence of op-\nerations. It is satisfied when it finds any sequence at all.\nIt is okay if you don\u2019t see how it works right away. Let\u2019s work through it,\nsince it makes for a great exercise in recursive thinking.\nThe inner function find does the actual recursing. It takes two arguments:\nthe current number and a string that records how we reached this number. If\nit finds a solution, it returns a string that shows how to get to the target. If\nno solution can be found starting from this number, it returns null.\nTo do this, the function performs one of three actions. If the current number\nis the target number, the current history is a way to reach that target, so it\nis returned. If the current number is greater than the target, there\u2019s no sense\nin further exploring this branch because both adding and multiplying will only\n50 make the number bigger, so it returns null. Finally, if we\u2019re still below the\ntargetnumber, thefunctiontriesbothpossiblepathsthatstartfromthecurrent\nnumber by calling itself twice, once for addition and once for multiplication. If\nthe first call returns something that is not null, it is returned. Otherwise, the\nsecond call is returned, regardless of whether it produces a string or null.\nTo better understand how this function produces the effect we\u2019re looking for,\nlet\u2019s look at all the calls to find that are made when searching for a solution\nfor the number 13.\nfind(1, \"1\")\nfind(6, \"(1 + 5)\")\nfind(11, \"((1 + 5) + 5)\")\nfind(16, \"(((1 + 5) + 5) + 5)\")\ntoo big\nfind(33, \"(((1 + 5) + 5) * 3)\")\ntoo big\nfind(18, \"((1 + 5) * 3)\")\ntoo big\nfind(3, \"(1 * 3)\")\nfind(8, \"((1 * 3) + 5)\")\nfind(13, \"(((1 * 3) + 5) + 5)\")\nfound!\nThe indentation indicates the depth of the call stack. The first time find is\ncalled, it starts by calling itself to explore the solution that starts with (1 + 5).\nThat call will further recurse to explore every continued solution that yields a\nnumber less than or equal to the target number. Since it doesn\u2019t find one that\nhits the target, it returns null back to the first call. There the || operator\ncauses the call that explores (1 * 3) to happen. This search has more luck\u2014\nits first recursive call, through yet another recursive call, hits upon the target\nnumber. That innermost call returns a string, and each of the || operators\nin the intermediate calls passes that string along, ultimately returning the\nsolution.\nGrowing functions\nThere are two more or less natural ways for functions to be introduced into\nprograms.\nThe first is that you find yourself writing similar code multiple times. You\u2019d\nprefer not to do that. Having more code means more space for mistakes to\nhide and more material to read for people trying to understand the program.\n51 So you take the repeated functionality, find a good name for it, and put it into\na function.\nThe second way is that you find you need some functionality that you haven\u2019t\nwritten yet and that sounds like it deserves its own function. You\u2019ll start by\nnaming the function, and then you\u2019ll write its body. You might even start\nwriting code that uses the function before you actually define the function\nitself.\nHow di\ufb00icult it is to find a good name for a function is a good indication\nof how clear a concept it is that you\u2019re trying to wrap. Let\u2019s go through an\nexample.\nWe want to write a program that prints two numbers: the numbers of cows\nand chickens on a farm, with the words Cows and Chickens after them and zeros\npadded before both numbers so that they are always three digits long.\n007 Cows\n011 Chickens\nThis asks for a function of two arguments\u2014the number of cows and the\nnumber of chickens. Let\u2019s get coding.\nfunction printFarmInventory(cows, chickens) {\nlet cowString = String(cows);\nwhile (cowString.length < 3) {\ncowString = \"0\" + cowString;\n}\nconsole.log(`${cowString} Cows`);\nlet chickenString = String(chickens);\nwhile (chickenString.length < 3) {\nchickenString = \"0\" + chickenString;\n}\nconsole.log(`${chickenString} Chickens`);\n}\nprintFarmInventory(7, 11);\nWriting.lengthaftera string expression will giveus the length of that string.\nThus, the while loops keep adding zeros in front of the number strings until\nthey are at least three characters long.\nMission accomplished! But just as we are about to send the farmer the code\n(along with a hefty invoice), she calls and tells us she\u2019s also started keeping\npigs, and couldn\u2019t we please extend the software to also print pigs?\nWe sure can. But just as we\u2019re in the process of copying and pasting those\n52 four lines one more time, we stop and reconsider. There has to be a better way.\nHere\u2019s a first attempt:\nfunction printZeroPaddedWithLabel(number, label) {\nlet numberString = String(number);\nwhile (numberString.length < 3) {\nnumberString = \"0\" + numberString;\n}\nconsole.log(`${numberString} ${label}`);\n}\nfunction printFarmInventory(cows, chickens, pigs) {\nprintZeroPaddedWithLabel(cows, \"Cows\");\nprintZeroPaddedWithLabel(chickens, \"Chickens\");\nprintZeroPaddedWithLabel(pigs, \"Pigs\");\n}\nprintFarmInventory(7, 11, 3);\nIt works! But that name, printZeroPaddedWithLabel, is a little awkward.\nIt conflates three things\u2014printing, zero-padding, and adding a label\u2014into a\nsingle function.\nInstead of lifting out the repeated part of our program wholesale, let\u2019s try\nto pick out a single concept.\nfunction zeroPad(number, width) {\nlet string = String(number);\nwhile (string.length < width) {\nstring = \"0\" + string;\n}\nreturn string;\n}\nfunction printFarmInventory(cows, chickens, pigs) {\nconsole.log(`${zeroPad(cows, 3)} Cows`);\nconsole.log(`${zeroPad(chickens, 3)} Chickens`);\nconsole.log(`${zeroPad(pigs, 3)} Pigs`);\n}\nprintFarmInventory(7, 16, 3);\nA function with a nice, obvious name like zeroPad makes it easier for someone\nwho reads the code to figure out what it does. And such a function is useful in\n53 more situations than just this specific program. For example, you could use it\nto help print nicely aligned tables of numbers.\nHow smart and versatile should our function be? We could write anything,\nfrom a terribly simple function that can only pad a number to be three charac-\nters wide to a complicated generalized number-formatting system that handles\nfractional numbers, negative numbers, alignment of decimal dots, padding with\ndifferent characters, and so on.\nA useful principle is to not add cleverness unless you are absolutely sure\nyou\u2019re going to need it. It can be tempting to write general \u201cframeworks\u201d for\nevery bit of functionality you come across. Resist that urge. You won\u2019t get any\nreal work done\u2014you\u2019ll just be writing code that you never use.\nFunctions and side effects\nFunctions can be roughly divided into those that are called for their side effects\nand those that are called for their return value. (Though it is definitely also\npossible to both have side effects and return a value.)\nThe first helper function in the farm example, printZeroPaddedWithLabel,\nis called for its side effect: it prints a line. The second version, zeroPad, is\ncalled for its return value. It is no coincidence that the second is useful in more\nsituations than the first. Functions that create values are easier to combine in\nnew ways than functions that directly perform side effects.\nA pure function is a specific kind of value-producing function that not only\nhas no side effects but also doesn\u2019t rely on side effects from other code\u2014for\nexample, it doesn\u2019t read global bindings whose value might change. A pure\nfunction has the pleasant property that, when called with the same arguments,\nit always produces the same value (and doesn\u2019t do anything else). A call to\nsuch a function can be substituted by its return value without changing the\nmeaning of the code. When you are not sure that a pure function is working\ncorrectly, you can test it by simply calling it and know that if it works in that\ncontext, it will work in any context. Nonpure functions tend to require more\nscaffolding to test.\nStill, there\u2019s no need to feel bad when writing functions that are not pure or\nto wage a holy war to purge them from your code. Side effects are often useful.\nThere\u2019d be no way to write a pure version of console.log, for example, and\nconsole.log is good to have. Some operations are also easier to express in an\ne\ufb00icient way when we use side effects, so computing speed can be a reason to\navoid purity.\n54 Summary\nThis chapter taught you how to write your own functions. The function key-\nword, when used as an expression, can create a function value. When used as\na statement, it can be used to declare a binding and give it a function as its\nvalue. Arrow functions are yet another way to create functions.\n\/\/ Define f to hold a function value\nconst f = function(a) {\nconsole.log(a + 2);\n};\n\/\/ Declare g to be a function\nfunction g(a, b) {\nreturn a * b * 3.5;\n}\n\/\/ A less verbose function value\nlet h = a => a % 3;\nA key aspect in understanding functions is understanding scopes. Each block\ncreates a new scope. Parameters and bindings declared in a given scope are\nlocal and not visible from the outside. Bindings declared with var behave\ndifferently\u2014they end up in the nearest function scope or the global scope.\nSeparating the tasks your program performs into different functions is help-\nful. You won\u2019t have to repeat yourself as much, and functions can help organize\na program by grouping code into pieces that do specific things.\nExercises\nMinimum\nThe previous chapter introduced the standard function Math.min that returns\nits smallest argument. We can build something like that now. Write a function\nmin that takes two arguments and returns their minimum.\nRecursion\nWe\u2019ve seen that % (the remainder operator) can be used to test whether a\nnumber is even or odd by using % 2 to see whether it\u2019s divisible by two. Here\u2019s\nanother way to define whether a positive whole number is even or odd:\n55 \u2022 Zero is even.\n\u2022 One is odd.\n\u2022 For any other number N, its evenness is the same as N - 2.\nDefine a recursive function isEven corresponding to this description. The\nfunctionshouldacceptasingleparameter(apositive, wholenumber)andreturn\na Boolean.\nTest it on 50 and 75. See how it behaves on -1. Why? Can you think of a\nway to fix this?\nBean counting\nYou can get the Nth character, or letter, from a string by writing \"string\"[N].\nThe returned value will be a string containing only one character (for example,\n\"b\"). The first character has position 0, which causes the last one to be found at\nposition string.length - 1. In other words, a two-character string has length\n2, and its characters have positions 0 and 1.\nWrite a function countBs that takes a string as its only argument and returns\na number that indicates how many uppercase \u201cB\u201d characters there are in the\nstring.\nNext, write a function called countChar that behaves like countBs, except\nit takes a second argument that indicates the character that is to be counted\n(rather than counting only uppercase \u201cB\u201d characters). Rewrite countBs to\nmake use of this new function.\n56 \u201cOn two occasions I have been asked, \u2018Pray, Mr. Babbage, if you put\ninto the machine wrong figures, will the right answers come out?\u2019\n[...] I am not able rightly to apprehend the kind of confusion of ideas\nthat could provoke such a question.\u201d\n\u2014Charles Babbage, Passages from the Life of a Philosopher (1864)\nChapter4\nData Structures: Objects and Arrays\nNumbers, Booleans, and strings are the atoms that data structures are built\nfrom. Many types of information require more than one atom, though. Ob-\njects allow us to group values\u2014including other objects\u2014to build more complex\nstructures.\nThe programs we have built so far have been limited by the fact that they\nwere operating only on simple data types. This chapter will introduce basic\ndata structures. By the end of it, you\u2019ll know enough to start writing useful\nprograms.\nThe chapter will work through a more or less realistic programming example,\nintroducing concepts as they apply to the problem at hand. The example code\nwill often build on functions and bindings that were introduced earlier in the\ntext.\nTheonlinecodingsandboxforthebook(https:\/\/eloquentjavascript.net\/code)\nprovides a way to run code in the context of a specific chapter. If you decide to\nwork through the examples in another environment, be sure to first download\nthe full code for this chapter from the sandbox page.\nThe weresquirrel\nEvery now and then, usually between 8 p.m. and 10 p.m., Jacques finds himself\ntransforming into a small furry rodent with a bushy tail.\nOn one hand, Jacques is quite glad that he doesn\u2019t have classic lycanthropy.\nTurning into a squirrel does cause fewer problems than turning into a wolf.\nInstead of having to worry about accidentally eating the neighbor (that would\nbe awkward), he worries about being eaten by the neighbor\u2019s cat. After two\noccasions where he woke up on a precariously thin branch in the crown of an\noak, naked and disoriented, he has taken to locking the doors and windows of\nhis room at night and putting a few walnuts on the floor to keep himself busy.\nThat takes care of the cat and tree problems. But Jacques would prefer to\nget rid of his condition entirely. The irregular occurrences of the transformation\n57 make him suspect that they might be triggered by something. For a while, he\nbelieved that it happened only on days when he had been near oak trees. But\navoiding oak trees did not stop the problem.\nSwitching to a more scientific approach, Jacques has started keeping a daily\nlog of everything he does on a given day and whether he changed form. With\nthis data he hopes to narrow down the conditions that trigger the transforma-\ntions.\nThe first thing he needs is a data structure to store this information.\nData sets\nTo work with a chunk of digital data, we\u2019ll first have to find a way to represent\nit in our machine\u2019s memory. Say, for example, that we want to represent a\ncollection of the numbers 2, 3, 5, 7, and 11.\nWe could get creative with strings\u2014after all, strings can have any length, so\nwecanputalotofdataintothem\u2014anduse\"2 3 5 7 11\"asourrepresentation.\nBut this is awkward. You\u2019d have to somehow extract the digits and convert\nthem back to numbers to access them.\nFortunately, JavaScriptprovidesadatatypespecificallyforstoringsequences\nof values. It is called an array and is written as a list of values between square\nbrackets, separated by commas.\nlet listOfNumbers = [2, 3, 5, 7, 11];\nconsole.log(listOfNumbers[2]);\n\/\/ \u2192 5\nconsole.log(listOfNumbers[0]);\n\/\/ \u2192 2\nconsole.log(listOfNumbers[2 - 1]);\n\/\/ \u2192 3\nThe notation for getting at the elements inside an array also uses square\nbrackets. A pair of square brackets immediately after an expression, with\nanother expression inside of them, will look up the element in the left-hand\nexpressionthatcorrespondstotheindex givenbytheexpressioninthebrackets.\nThe first index of an array is zero, not one. So the first element is retrieved\nwith listOfNumbers[0]. Zero-based counting has a long tradition in technology\nand in certain ways makes a lot of sense, but it takes some getting used to.\nThink of the index as the amount of items to skip, counting from the start of\nthe array.\n58 Properties\nWe\u2019ve seen a few suspicious-looking expressions like myString.length (to get\nthe length of a string) and Math.max (the maximum function) in past chapters.\nThese are expressions that access a property of some value. In the first case,\nwe access the length property of the value in myString. In the second, we\naccess the property named max in the Math object (which is a collection of\nmathematics-related constants and functions).\nAlmost all JavaScript values have properties. The exceptions are null and\nundefined. If you try to access a property on one of these nonvalues, you get\nan error.\nnull.length;\n\/\/ \u2192 TypeError: null has no properties\nThe two main ways to access properties in JavaScript are with a dot and with\nsquare brackets. Both value.x and value[x] access a property on value\u2014but\nnot necessarily the same property. The difference is in how x is interpreted.\nWhen using a dot, the word after the dot is the literal name of the property.\nWhenusingsquare brackets, theexpression betweenthebracketsis evaluated to\nget the property name. Whereas value.x fetches the property of value named\n\u201cx\u201d, value[x] tries to evaluate the expression x and uses the result, converted\nto a string, as the property name.\nSo if you know that the property you are interested in is called color, you say\nvalue.color. If you want to extract the property named by the value held in\nthe binding i, you say value[i]. Property names are strings. They can be any\nstring, but the dot notation works only with names that look like valid binding\nnames. So if you want to access a property named 2 or John Doe, you must\nuse square brackets: value[2] or value[\"John Doe\"].\nThe elements in an array are stored as the array\u2019s properties, using numbers\nas property names. Because you can\u2019t use the dot notation with numbers and\nusually want to use a binding that holds the index anyway, you have to use the\nbracket notation to get at them.\nThe length property of an array tells us how many elements it has. This\nproperty name is a valid binding name, and we know its name in advance, so\nto find the length of an array, you typically write array.length because that\u2019s\neasier to write than array[\"length\"].\n59 Methods\nBoth string and array values contain, in addition to the length property, a\nnumber of properties that hold function values.\nlet doh = \"Doh\";\nconsole.log(typeof doh.toUpperCase);\n\/\/ \u2192 function\nconsole.log(doh.toUpperCase());\n\/\/ \u2192 DOH\nEvery string has a toUpperCase property. When called, it will return a copy\nof the string in which all letters have been converted to uppercase. There is\nalso toLowerCase, going the other way.\nInterestingly, even though the call to toUpperCase does not pass any argu-\nments, the function somehow has access to the string \"Doh\", the value whose\nproperty we called. How this works is described in Chapter 6.\nProperties that contain functions are generally called methods of the value\nthey belong to, as in \u201ctoUpperCase is a method of a string\u201d.\nThis example demonstrates two methods you can use to manipulate arrays:\nlet sequence = [1, 2, 3];\nsequence.push(4);\nsequence.push(5);\nconsole.log(sequence);\n\/\/ \u2192 [1, 2, 3, 4, 5]\nconsole.log(sequence.pop());\n\/\/ \u2192 5\nconsole.log(sequence);\n\/\/ \u2192 [1, 2, 3, 4]\nThe push method adds values to the end of an array, and the pop method\ndoes the opposite, removing the last value in the array and returning it.\nThese somewhat silly names are the traditional terms for operations on a\nstack. A stack, in programming, is a data structure that allows you to push\nvalues into it and pop them out again in the opposite order so that the thing\nthat was added last is removed first. These are common in programming\u2014you\nmight remember the function call stack from the previous chapter, which is an\ninstance of the same idea.\n60 Objects\nBack to the weresquirrel. A set of daily log entries can be represented as an\narray. But the entries do not consist of just a number or a string\u2014each entry\nneeds to store a list of activities and a Boolean value that indicates whether\nJacques turned into a squirrel or not. Ideally, we would like to group these\ntogether into a single value and then put those grouped values into an array of\nlog entries.\nValues of the type object are arbitrary collections of properties. One way to\ncreate an object is by using braces as an expression.\nlet day1 = {\nsquirrel: false,\nevents: [\"work\", \"touched tree\", \"pizza\", \"running\"]\n};\nconsole.log(day1.squirrel);\n\/\/ \u2192 false\nconsole.log(day1.wolf);\n\/\/ \u2192 undefined\nday1.wolf = false;\nconsole.log(day1.wolf);\n\/\/ \u2192 false\nInside the braces, there is a list of properties separated by commas. Each\nproperty has a name followed by a colon and a value. When an object is written\nover multiple lines, indenting it like in the example helps with readability.\nProperties whose names aren\u2019t valid binding names or valid numbers have to\nbe quoted.\nlet descriptions = {\nwork: \"Went to work\",\n\"touched tree\": \"Touched a tree\"\n};\nThis means that braces have two meanings in JavaScript. At the start of\na statement, they start a block of statements. In any other position, they\ndescribe an object. Fortunately, it is rarely useful to start a statement with an\nobject in braces, so the ambiguity between these two is not much of a problem.\nReading a property that doesn\u2019t exist will give you the value undefined.\nIt is possible to assign a value to a property expression with the = operator.\nThis will replace the property\u2019s value if it already existed or create a new\n61 property on the object if it didn\u2019t.\nTo briefly return to our tentacle model of bindings\u2014property bindings are\nsimilar. They grasp values, but other bindings and properties might be holding\nontothosesamevalues. Youmaythinkofobjectsasoctopuseswithanynumber\nof tentacles, each of which has a name tattooed on it.\nThe delete operator cuts off a tentacle from such an octopus. It is a unary\noperator that, when applied to an object property, will remove the named\nproperty from the object. This is not a common thing to do, but it is possible.\nlet anObject = {left: 1, right: 2};\nconsole.log(anObject.left);\n\/\/ \u2192 1\ndelete anObject.left;\nconsole.log(anObject.left);\n\/\/ \u2192 undefined\nconsole.log(\"left\" in anObject);\n\/\/ \u2192 false\nconsole.log(\"right\" in anObject);\n\/\/ \u2192 true\nThe binary in operator, when applied to a string and an object, tells you\nwhether that object has a property with that name. The difference between\nsetting a property to undefined and actually deleting it is that, in the first\ncase, the object still has the property (it just doesn\u2019t have a very interesting\nvalue), whereas in the second case the property is no longer present and in will\nreturn false.\nTo find out what properties an object has, you can use the Object.keys\nfunction. You give it an object, and it returns an array of strings\u2014the object\u2019s\nproperty names.\nconsole.log(Object.keys({x: 0, y: 0, z: 2}));\n\/\/ \u2192 [\"x\", \"y\", \"z\"]\nThere\u2019s an Object.assign function that copies all properties from one object\ninto another.\nlet objectA = {a: 1, b: 2};\nObject.assign(objectA, {b: 3, c: 4});\nconsole.log(objectA);\n\/\/ \u2192 {a: 1, b: 3, c: 4}\n62 Arrays, then, are just a kind of object specialized for storing sequences of\nthings. If you evaluate typeof [], it produces \"object\". You can see them as\nlong, flat octopuses with all their tentacles in a neat row, labeled with numbers.\nWe will represent the journal that Jacques keeps as an array of objects.\nlet journal = [\n{events: [\"work\", \"touched tree\", \"pizza\",\n\"running\", \"television\"],\nsquirrel: false},\n{events: [\"work\", \"ice cream\", \"cauliflower\",\n\"lasagna\", \"touched tree\", \"brushed teeth\"],\nsquirrel: false},\n{events: [\"weekend\", \"cycling\", \"break\", \"peanuts\",\n\"beer\"],\nsquirrel: true},\n\/* and so on... *\/\n];\nMutability\nWe will get to actual programming real soon now. First there\u2019s one more piece\nof theory to understand.\nWe saw that object values can be modified. The types of values discussed in\nearlier chapters, such as numbers, strings, and Booleans, are all immutable\u2014it\nis impossible to change values of those types. You can combine them and derive\nnew values from them, but when you take a specific string value, that value\nwill always remain the same. The text inside it cannot be changed. If you\nhave a string that contains \"cat\", it is not possible for other code to change a\ncharacter in your string to make it spell \"rat\".\nObjects work differently. You can change their properties, causing a single\nobject value to have different content at different times.\nWhen we have two numbers, 120 and 120, we can consider them precisely\nthe same number, whether or not they refer to the same physical bits. With\nobjects, there is a difference between having two references to the same object\nand having two different objects that contain the same properties. Consider\nthe following code:\nlet object1 = {value: 10};\nlet object2 = object1;\nlet object3 = {value: 10};\n63 console.log(object1 == object2);\n\/\/ \u2192 true\nconsole.log(object1 == object3);\n\/\/ \u2192 false\nobject1.value = 15;\nconsole.log(object2.value);\n\/\/ \u2192 15\nconsole.log(object3.value);\n\/\/ \u2192 10\nThe object1 and object2 bindings grasp the same object, which is why\nchanging object1 also changes the value of object2. They are said to have the\nsame identity. The binding object3 points to a different object, which initially\ncontains the same properties as object1 but lives a separate life.\nBindings can also be changeable or constant, but this is separate from the\nway their values behave. Even though number values don\u2019t change, you can\nuse a let binding to keep track of a changing number by changing the value\nthe binding points at. Similarly, though a const binding to an object can itself\nnot be changed and will continue to point at the same object, the contents of\nthat object might change.\nconst score = {visitors: 0, home: 0};\n\/\/ This is okay\nscore.visitors = 1;\n\/\/ This isn't allowed\nscore = {visitors: 1, home: 1};\nWhen you compare objects with JavaScript\u2019s == operator, it compares by\nidentity: it will produce true only if both objects are precisely the same value.\nComparing different objects will return false, even if they have identical prop-\nerties. There is no \u201cdeep\u201d comparison operation built into JavaScript, which\ncompares objects by contents, but it is possible to write it yourself (which is\none of the exercises at the end of this chapter).\nThe lycanthrope's log\nSo, Jacques starts up his JavaScript interpreter and sets up the environment\nhe needs to keep his journal.\nlet journal = [];\n64 function addEntry(events, squirrel) {\njournal.push({events, squirrel});\n}\nNote that the object added to the journal looks a little odd. Instead of\ndeclaring properties like events: events, it just gives a property name. This\nis shorthand that means the same thing\u2014if a property name in brace notation\nisn\u2019t followed by a value, its value is taken from the binding with the same\nname.\nSo then, every evening at 10 p.m.\u2014or sometimes the next morning, after\nclimbing down from the top shelf of his bookcase\u2014Jacques records the day.\naddEntry([\"work\", \"touched tree\", \"pizza\", \"running\",\n\"television\"], false);\naddEntry([\"work\", \"ice cream\", \"cauliflower\", \"lasagna\",\n\"touched tree\", \"brushed teeth\"], false);\naddEntry([\"weekend\", \"cycling\", \"break\", \"peanuts\",\n\"beer\"], true);\nOnce he has enough data points, he intends to use statistics to find out which\nof these events may be related to the squirrelifications.\nCorrelation is a measure of dependence between statistical variables. A sta-\ntistical variable is not quite the same as a programming variable. In statistics\nyou typically have a set of measurements, and each variable is measured for\nevery measurement. Correlation between variables is usually expressed as a\nvalue that ranges from -1 to 1. Zero correlation means the variables are not\nrelated. A correlation of one indicates that the two are perfectly related\u2014if\nyou know one, you also know the other. Negative one also means that the\nvariables are perfectly related but that they are opposites\u2014when one is true,\nthe other is false.\nTo compute the measure of correlation between two Boolean variables, we\ncan use the phi coe\ufb00icient (\u03c6). This is a formula whose input is a frequency\ntable containing the number of times the different combinations of the variables\nwere observed. The output of the formula is a number between -1 and 1 that\ndescribes the correlation.\nWe could take the event of eating pizza and put that in a frequency table\nlike this, where each number indicates the amount of times that combination\noccurred in our measurements:\n65 76 9\nNo squirrel, no pizza No squirrel, pizza\n4 1\nSquirrel, no pizza Squirrel, pizza\nIf we call that table n, we can compute \u03c6 using the following formula:\nn n \u2212n n\n\u03c6 =\n\u221a11 00 10 01\n(4.1)\nn 1\u2022n 0\u2022n\u20221n\u20220\n(If at this point you\u2019re putting the book down to focus on a terrible flashback\nto 10th grade math class\u2014hold on! I do not intend to torture you with endless\npages of cryptic notation\u2014it\u2019s just this one formula for now. And even with\nthis one, all we do is turn it into JavaScript.)\nThe notation n indicates the number of measurements where the first vari-\n01\nable (squirrelness) is false (0) and the second variable (pizza) is true (1). In\nthe pizza table, n is 9.\n01\nThe value n 1\u2022 refers to the sum of all measurements where the first variable\nis true, which is 5 in the example table. Likewise, n\u20220 refers to the sum of the\nmeasurements where the second variable is false.\nSo for the pizza table, the part above the division line (the dividend) would\nbe 1\u00d776\u22124\u00d79 = 40, and the part below it (the divisor) would be the square\n\u221a\nroot of 5\u00d785\u00d710\u00d780, or 340000. This comes out to \u03c6 \u2248 0.069, which is tiny.\nEating pizza does not appear to have influence on the transformations.\nComputing correlation\nWe can represent a two-by-two table in JavaScript with a four-element array\n([76, 9, 4, 1]). Wecouldalso use other representations, suchas an arraycon-\ntaining two two-element arrays ([[76, 9], [4, 1]]) or an object with property\nnames like \"11\" and \"01\", but the flat array is simple and makes the expres-\nsions that access the table pleasantly short. We\u2019ll interpret the indices to the\narray as two-bit binary numbers, where the leftmost (most significant) digit\nrefers to the squirrel variable and the rightmost (least significant) digit refers\nto the event variable. For example, the binary number 10 refers to the case\n66 where Jacques did turn into a squirrel, but the event (say, \u201cpizza\u201d) didn\u2019t oc-\ncur. This happened four times. And since binary 10 is 2 in decimal notation,\nwe will store this number at index 2 of the array.\nThis is the function that computes the \u03c6 coe\ufb00icient from such an array:\nfunction phi(table) {\nreturn (table[3] * table[0] - table[2] * table[1]) \/\nMath.sqrt((table[2] + table[3]) *\n(table[0] + table[1]) *\n(table[1] + table[3]) *\n(table[0] + table[2]));\n}\nconsole.log(phi([76, 9, 4, 1]));\n\/\/ \u2192 0.068599434\nThis is a direct translation of the \u03c6 formula into JavaScript. Math.sqrt\nis the square root function, as provided by the Math object in a standard\nJavaScript environment. We have to add two fields from the table to get fields\nlike n 1\u2022 because the sums of rows or columns are not stored directly in our data\nstructure.\nJacques kept his journal for three months. The resulting data set is available\nin the coding sandbox for this chapter (https:\/\/eloquentjavascript.net\/code#4),\nwhere it is stored in the JOURNAL binding and in a downloadable file.\nTo extract a two-by-two table for a specific event from the journal, we must\nloop over all the entries and tally how many times the event occurs in relation\nto squirrel transformations.\nfunction tableFor(event, journal) {\nlet table = [0, 0, 0, 0];\nfor (let i = 0; i < journal.length; i++) {\nlet entry = journal[i], index = 0;\nif (entry.events.includes(event)) index += 1;\nif (entry.squirrel) index += 2;\ntable[index] += 1;\n}\nreturn table;\n}\nconsole.log(tableFor(\"pizza\", JOURNAL));\n\/\/ \u2192 [76, 9, 4, 1]\n67 Arrays have an includes method that checks whether a given value exists in\nthe array. The function uses that to determine whether the event name it is\ninterested in is part of the event list for a given day.\nThe body of the loop in tableFor figures out which box in the table each\njournal entry falls into by checking whether the entry contains the specific event\nit\u2019s interested in and whether the event happens alongside a squirrel incident.\nThe loop then adds one to the correct box in the table.\nWe now have the tools we need to compute individual correlations. The only\nstep remaining is to find a correlation for every type of event that was recorded\nand see whether anything stands out.\nArray loops\nIn the tableFor function, there\u2019s a loop like this:\nfor (let i = 0; i < JOURNAL.length; i++) {\nlet entry = JOURNAL[i];\n\/\/ Do something with entry\n}\nThis kind of loop is common in classical JavaScript\u2014going over arrays one\nelement at a time is something that comes up a lot, and to do that you\u2019d run\na counter over the length of the array and pick out each element in turn.\nThere is a simpler way to write such loops in modern JavaScript.\nfor (let entry of JOURNAL) {\nconsole.log(`${entry.events.length} events.`);\n}\nWhen a for loop looks like this, with the word of after a variable definition,\nit will loop over the elements of the value given after of. This works not only\nfor arrays but also for strings and some other data structures. We\u2019ll discuss\nhow it works in Chapter 6.\nThe final analysis\nWe need to compute a correlation for every type of event that occurs in the\ndata set. To do that, we first need to find every type of event.\nfunction journalEvents(journal) {\n68 let events = [];\nfor (let entry of journal) {\nfor (let event of entry.events) {\nif (!events.includes(event)) {\nevents.push(event);\n}\n}\n}\nreturn events;\n}\nconsole.log(journalEvents(JOURNAL));\n\/\/ \u2192 [\"carrot\", \"exercise\", \"weekend\", \"bread\", \u2026]\nBy going over all the events and adding those that aren\u2019t already in there to\nthe events array, the function collects every type of event.\nUsing that, we can see all the correlations.\nfor (let event of journalEvents(JOURNAL)) {\nconsole.log(event + \":\", phi(tableFor(event, JOURNAL)));\n}\n\/\/ \u2192 carrot: 0.0140970969\n\/\/ \u2192 exercise: 0.0685994341\n\/\/ \u2192 weekend: 0.1371988681\n\/\/ \u2192 bread: -0.0757554019\n\/\/ \u2192 pudding: -0.0648203724\n\/\/ and so on...\nMost correlations seem to lie close to zero. Eating carrots, bread, or pudding\napparently does not trigger squirrel-lycanthropy. It does seem to occur some-\nwhat more often on weekends. Let\u2019s filter the results to show only correlations\ngreater than 0.1 or less than -0.1.\nfor (let event of journalEvents(JOURNAL)) {\nlet correlation = phi(tableFor(event, JOURNAL));\nif (correlation > 0.1 || correlation < -0.1) {\nconsole.log(event + \":\", correlation);\n}\n}\n\/\/ \u2192 weekend: 0.1371988681\n\/\/ \u2192 brushed teeth: -0.3805211953\n\/\/ \u2192 candy: 0.1296407447\n\/\/ \u2192 work: -0.1371988681\n69 \/\/ \u2192 spaghetti: 0.2425356250\n\/\/ \u2192 reading: 0.1106828054\n\/\/ \u2192 peanuts: 0.5902679812\nAha! There are two factors with a correlation that\u2019s clearly stronger than\nthe others. Eating peanuts has a strong positive effect on the chance of turning\ninto a squirrel, whereas brushing his teeth has a significant negative effect.\nInteresting. Let\u2019s try something.\nfor (let entry of JOURNAL) {\nif (entry.events.includes(\"peanuts\") &&\n!entry.events.includes(\"brushed teeth\")) {\nentry.events.push(\"peanut teeth\");\n}\n}\nconsole.log(phi(tableFor(\"peanut teeth\", JOURNAL)));\n\/\/ \u2192 1\nThat\u2019s a strong result. The phenomenon occurs precisely when Jacques eats\npeanuts and fails to brush his teeth. If only he weren\u2019t such a slob about dental\nhygiene, he\u2019d have never even noticed his affliction.\nKnowing this, Jacques stops eating peanuts altogether and finds that his\ntransformations don\u2019t come back.\nFor a few years, things go great for Jacques. But at some point he loses his\njob. Because he lives in a nasty country where having no job means having\nno medical services, he is forced to take employment with a circus where he\nperforms as The Incredible Squirrelman, stu\ufb00ing his mouth with peanut butter\nbefore every show.\nOne day, fed up with this pitiful existence, Jacques fails to change back into\nhis human form, hops through a crack in the circus tent, and vanishes into the\nforest. He is never seen again.\nFurther arrayology\nBefore finishing the chapter, I want to introduce you to a few more object-\nrelated concepts. I\u2019ll start by introducing some generally useful array methods.\nWe saw push and pop, which add and remove elements at the end of an array,\nearlier in this chapter. The corresponding methods for adding and removing\nthings at the start of an array are called unshift and shift.\n70 let todoList = [];\nfunction remember(task) {\ntodoList.push(task);\n}\nfunction getTask() {\nreturn todoList.shift();\n}\nfunction rememberUrgently(task) {\ntodoList.unshift(task);\n}\nThat program manages a queue of tasks. You add tasks to the end of the\nqueue by calling remember(\"groceries\"), and when you\u2019re ready to do some-\nthing, you call getTask() to get (and remove) the front item from the queue.\nThe rememberUrgently function also adds a task but adds it to the front instead\nof the back of the queue.\nTosearchforaspecificvalue, arraysprovideanindexOfmethod. Themethod\nsearches through the array from the start to the end and returns the index at\nwhich the requested value was found\u2014or -1 if it wasn\u2019t found. To search from\nthe end instead of the start, there\u2019s a similar method called lastIndexOf.\nconsole.log([1, 2, 3, 2, 1].indexOf(2));\n\/\/ \u2192 1\nconsole.log([1, 2, 3, 2, 1].lastIndexOf(2));\n\/\/ \u2192 3\nBoth indexOf and lastIndexOf take an optional second argument that indi-\ncates where to start searching.\nAnother fundamental array method is slice, which takes start and end in-\ndices and returns an array that has only the elements between them. The start\nindex is inclusive, the end index exclusive.\nconsole.log([0, 1, 2, 3, 4].slice(2, 4));\n\/\/ \u2192 [2, 3]\nconsole.log([0, 1, 2, 3, 4].slice(2));\n\/\/ \u2192 [2, 3, 4]\nWhen the end index is not given, slice will take all of the elements after the\nstart index. You can also omit the start index to copy the entire array.\nThe concat method can be used to glue arrays together to create a new array,\nsimilar to what the + operator does for strings.\n71 The following example shows both concat and slice in action. It takes an\narray and an index, and it returns a new array that is a copy of the original\narray with the element at the given index removed.\nfunction remove(array, index) {\nreturn array.slice(0, index)\n.concat(array.slice(index + 1));\n}\nconsole.log(remove([\"a\", \"b\", \"c\", \"d\", \"e\"], 2));\n\/\/ \u2192 [\"a\", \"b\", \"d\", \"e\"]\nIf you pass concat an argument that is not an array, that value will be added\nto the new array as if it were a one-element array.\nStrings and their properties\nWe can read properties like length and toUpperCase from string values. But if\nyou try to add a new property, it doesn\u2019t stick.\nlet kim = \"Kim\";\nkim.age = 88;\nconsole.log(kim.age);\n\/\/ \u2192 undefined\nValues of type string, number, and Boolean are not objects, and though\nthe language doesn\u2019t complain if you try to set new properties on them, it\ndoesn\u2019t actually store those properties. As mentioned earlier, such values are\nimmutable and cannot be changed.\nBut these types do have built-in properties. Every string value has a number\nof methods. Some very useful ones are slice and indexOf, which resemble the\narray methods of the same name.\nconsole.log(\"coconuts\".slice(4, 7));\n\/\/ \u2192 nut\nconsole.log(\"coconut\".indexOf(\"u\"));\n\/\/ \u2192 5\nOne difference is that a string\u2019s indexOf can search for a string containing\nmore than one character, whereas the corresponding array method looks only\nfor a single element.\n72 console.log(\"one two three\".indexOf(\"ee\"));\n\/\/ \u2192 11\nThe trim method removes whitespace (spaces, newlines, tabs, and similar\ncharacters) from the start and end of a string.\nconsole.log(\" okay \\n \".trim());\n\/\/ \u2192 okay\nThe zeroPad function from the previous chapter also exists as a method.\nIt is called padStart and takes the desired length and padding character as\narguments.\nconsole.log(String(6).padStart(3, \"0\"));\n\/\/ \u2192 006\nYou can split a string on every occurrence of another string with split and\njoin it again with join.\nlet sentence = \"Secretarybirds specialize in stomping\";\nlet words = sentence.split(\" \");\nconsole.log(words);\n\/\/ \u2192 [\"Secretarybirds\", \"specialize\", \"in\", \"stomping\"]\nconsole.log(words.join(\". \"));\n\/\/ \u2192 Secretarybirds. specialize. in. stomping\nA string can be repeated with the repeat method, which creates a new string\ncontaining multiple copies of the original string, glued together.\nconsole.log(\"LA\".repeat(3));\n\/\/ \u2192 LALALA\nWe have already seen the string type\u2019s length property. Accessing the indi-\nvidual characters in a string looks like accessing array elements (with a caveat\nthat we\u2019ll discuss in Chapter 5).\nlet string = \"abc\";\nconsole.log(string.length);\n\/\/ \u2192 3\nconsole.log(string[1]);\n\/\/ \u2192 b\n73 Rest parameters\nIt can be useful for a function to accept any number of arguments. For example,\nMath.max computes the maximum of all the arguments it is given.\nTo write such a function, you put three dots before the function\u2019s last pa-\nrameter, like this:\nfunction max(...numbers) {\nlet result = -Infinity;\nfor (let number of numbers) {\nif (number > result) result = number;\n}\nreturn result;\n}\nconsole.log(max(4, 1, 9, -2));\n\/\/ \u2192 9\nWhen such a function is called, the rest parameter is bound to an array\ncontaining all further arguments. If there are other parameters before it, their\nvalues aren\u2019t part of that array. When, as in max, it is the only parameter, it\nwill hold all arguments.\nYou can use a similar three-dot notation to call a function with an array of\narguments.\nlet numbers = [5, 1, 7];\nconsole.log(max(...numbers));\n\/\/ \u2192 7\nThis \u201cspreads\u201d out the array into the function call, passing its elements as\nseparate arguments. It is possible to include an array like that along with other\narguments, as in max(9, ...numbers, 2).\nSquare bracket array notation similarly allows the triple-dot operator to\nspread another array into the new array.\nlet words = [\"never\", \"fully\"];\nconsole.log([\"will\", ...words, \"understand\"]);\n\/\/ \u2192 [\"will\", \"never\", \"fully\", \"understand\"]\n74 The Math object\nAs we\u2019ve seen, Math is a grab bag of number-related utility functions, such as\nMath.max (maximum), Math.min (minimum), and Math.sqrt (square root).\nThe Math object is used as a container to group a bunch of related function-\nality. There is only one Math object, and it is almost never useful as a value.\nRather, it provides a namespace so that all these functions and values do not\nhave to be global bindings.\nHaving too many global bindings \u201cpollutes\u201d the namespace. The more names\nhave been taken, the more likely you are to accidentally overwrite the value of\nsome existing binding. For example, it\u2019s not unlikely to want to name some-\nthing max in one of your programs. Since JavaScript\u2019s built-in max function is\ntucked safely inside the Math object, we don\u2019t have to worry about overwriting\nit.\nMany languages will stop you, or at least warn you, when you are defining\na binding with a name that is already taken. JavaScript does this for bindings\nyou declared with let or const but\u2014perversely\u2014not for standard bindings nor\nfor bindings declared with var or function.\nBack to the Math object. If you need to do trigonometry, Math can help. It\ncontains cos (cosine), sin (sine), and tan (tangent), as well as their inverse\nfunctions, acos, asin, and atan, respectively. The number \u03c0 (pi)\u2014or at least\nthe closest approximation that fits in a JavaScript number\u2014is available as Math\n.PI. There is an old programming tradition of writing the names of constant\nvalues in all caps.\nfunction randomPointOnCircle(radius) {\nlet angle = Math.random() * 2 * Math.PI;\nreturn {x: radius * Math.cos(angle),\ny: radius * Math.sin(angle)};\n}\nconsole.log(randomPointOnCircle(2));\n\/\/ \u2192 {x: 0.3667, y: 1.966}\nIf sines and cosines are not something you are familiar with, don\u2019t worry.\nWhen they are used in this book, in Chapter 14, I\u2019ll explain them.\nThe previous example used Math.random. This is a function that returns a\nnew pseudorandom number between zero (inclusive) and one (exclusive) every\ntime you call it.\nconsole.log(Math.random());\n\/\/ \u2192 0.36993729369714856\n75 console.log(Math.random());\n\/\/ \u2192 0.727367032552138\nconsole.log(Math.random());\n\/\/ \u2192 0.40180766698904335\nThough computers are deterministic machines\u2014they always react the same\nway if given the same input\u2014it is possible to have them produce numbers\nthat appear random. To do that, the machine keeps some hidden value, and\nwhenever you ask for a new random number, it performs complicated com-\nputations on this hidden value to create a new value. It stores a new value\nand returns some number derived from it. That way, it can produce ever new,\nhard-to-predict numbers in a way that seems random.\nIf we want a whole random number instead of a fractional one, we can use\nMath.floor (which rounds down to the nearest whole number) on the result of\nMath.random.\nconsole.log(Math.floor(Math.random() * 10));\n\/\/ \u2192 2\nMultiplying the random number by 10 gives us a number greater than or\nequal to 0 and below 10. Since Math.floor rounds down, this expression will\nproduce, with equal chance, any number from 0 through 9.\nThere are also the functions Math.ceil (for \u201cceiling\u201d, which rounds up to\na whole number), Math.round (to the nearest whole number), and Math.abs,\nwhich takes the absolute value of a number, meaning it negates negative values\nbut leaves positive ones as they are.\nDestructuring\nLet\u2019s go back to the phi function for a moment.\nfunction phi(table) {\nreturn (table[3] * table[0] - table[2] * table[1]) \/\nMath.sqrt((table[2] + table[3]) *\n(table[0] + table[1]) *\n(table[1] + table[3]) *\n(table[0] + table[2]));\n}\nOne of the reasons this function is awkward to read is that we have a binding\n76 pointing at our array, but we\u2019d much prefer to have bindings for the elements\nof the array, that is, let n00 = table[0] and so on. Fortunately, there is a\nsuccinct way to do this in JavaScript.\nfunction phi([n00, n01, n10, n11]) {\nreturn (n11 * n00 - n10 * n01) \/\nMath.sqrt((n10 + n11) * (n00 + n01) *\n(n01 + n11) * (n00 + n10));\n}\nThis also works for bindings created with let, var, or const. If you know the\nvalue you are binding is an array, you can use square brackets to \u201clook inside\u201d\nof the value, binding its contents.\nA similar trick works for objects, using braces instead of square brackets.\nlet {name} = {name: \"Faraji\", age: 23};\nconsole.log(name);\n\/\/ \u2192 Faraji\nNote that if you try to destructure null or undefined, you get an error, much\nas you would if you directly try to access a property of those values.\nJSON\nBecause properties only grasp their value, rather than contain it, objects and\narrays are stored in the computer\u2019s memory as sequences of bits holding the\naddresses\u2014the place in memory\u2014of their contents. So an array with another\narray inside of it consists of (at least) one memory region for the inner array,\nand another for the outer array, containing (among other things) a binary\nnumber that represents the position of the inner array.\nIf you want to save data in a file for later or send it to another computer over\nthe network, you have to somehow convert these tangles of memory addresses\nto a description that can be stored or sent. You could send over your entire\ncomputer memory along with the address of the value you\u2019re interested in, I\nsuppose, but that doesn\u2019t seem like the best approach.\nWhat we can do is serialize the data. That means it is converted into a\nflat description. A popular serialization format is called JSON (pronounced\n\u201cJason\u201d), which stands for JavaScript Object Notation. It is widely used as a\ndata storage and communication format on the Web, even in languages other\nthan JavaScript.\n77 JSON looks similar to JavaScript\u2019s way of writing arrays and objects, with a\nfew restrictions. All property names have to be surrounded by double quotes,\nand only simple data expressions are allowed\u2014no function calls, bindings, or\nanything that involves actual computation. Comments are not allowed in\nJSON.\nA journal entry might look like this when represented as JSON data:\n{\n\"squirrel\": false,\n\"events\": [\"work\", \"touched tree\", \"pizza\", \"running\"]\n}\nJavaScript gives us the functions JSON.stringify and JSON.parse to convert\ndata to and from this format. The first takes a JavaScript value and returns\na JSON-encoded string. The second takes such a string and converts it to the\nvalue it encodes.\nlet string = JSON.stringify({squirrel: false,\nevents: [\"weekend\"]});\nconsole.log(string);\n\/\/ \u2192 {\"squirrel\":false,\"events\":[\"weekend\"]}\nconsole.log(JSON.parse(string).events);\n\/\/ \u2192 [\"weekend\"]\nSummary\nObjects and arrays (which are a specific kind of object) provide ways to group\nseveral values into a single value. Conceptually, this allows us to put a bunch\nof related things in a bag and run around with the bag, instead of wrapping\nour arms around all of the individual things and trying to hold on to them\nseparately.\nMost values in JavaScript have properties, the exceptions being null and\nundefined. Properties are accessed using value.prop or value[\"prop\"]. Ob-\njects tend to use names for their properties and store more or less a fixed set\nof them. Arrays, on the other hand, usually contain varying amounts of con-\nceptually identical values and use numbers (starting from 0) as the names of\ntheir properties.\nThere are some named properties in arrays, such as length and a number of\nmethods. Methods are functions that live in properties and (usually) act on\n78 the value they are a property of.\nYou can iterate over arrays using a special kind of for loop\u2014for (let\nelement of array).\nExercises\nThe sum of a range\nThe introduction of this book alluded to the following as a nice way to compute\nthe sum of a range of numbers:\nconsole.log(sum(range(1, 10)));\nWrite a range function that takes two arguments, start and end, and returns\nan array containing all the numbers from start up to (and including) end.\nNext, write a sum function that takes an array of numbers and returns the\nsum of these numbers. Run the example program and see whether it does\nindeed return 55.\nAs a bonus assignment, modify your range function to take an optional third\nargument that indicates the \u201cstep\u201d value used when building the array. If no\nstep is given, the elements go up by increments of one, corresponding to the\nold behavior. The function call range(1, 10, 2) should return [1, 3, 5, 7,\n9]. Make sure it also works with negative step values so that range(5, 2, -1)\nproduces [5, 4, 3, 2].\nReversing an array\nArrays have a reverse method that changes the array by inverting the order in\nwhich its elements appear. For this exercise, write two functions, reverseArray\nand reverseArrayInPlace. The first, reverseArray, takes an array as argument\nand produces a new array that has the same elements in the inverse order. The\nsecond, reverseArrayInPlace, does what the reverse method does: it modifies\nthe array given as argument by reversing its elements. Neither may use the\nstandard reverse method.\nThinking back to the notes about side effects and pure functions in the\nprevious chapter, which variant do you expect to be useful in more situations?\nWhich one runs faster?\n79 A list\nObjects, as generic blobs of values, can be used to build all sorts of data struc-\ntures. A common data structure is the list (not to be confused with array). A\nlist is a nested set of objects, with the first object holding a reference to the\nsecond, the second to the third, and so on.\nlet list = {\nvalue: 1,\nrest: {\nvalue: 2,\nrest: {\nvalue: 3,\nrest: null\n}\n}\n};\nThe resulting objects form a chain, like this:\nvalue: 1\nvalue: 2\nrest: value: 3\nrest:\nrest: null\nA nice thing about lists is that they can share parts of their structure. For\nexample, if I create two new values {value: 0, rest: list} and {value: -1,\nrest: list} (with list referring to the binding defined earlier), they are both\nindependent lists, but they share the structure that makes up their last three\nelements. The original list is also still a valid three-element list.\nWrite a function arrayToList that builds up a list structure like the one\nshown when given [1, 2, 3] as argument. Also write a listToArray function\nthat produces an array from a list. Then add a helper function prepend, which\ntakes an element and a list and creates a new list that adds the element to the\nfront of the input list, and nth, which takes a list and a number and returns\nthe element at the given position in the list (with zero referring to the first\nelement) or undefined when there is no such element.\nIf you haven\u2019t already, also write a recursive version of nth.\nDeep comparison\nThe == operator compares objects by identity. But sometimes you\u2019d prefer to\ncompare the values of their actual properties.\n80 WriteafunctiondeepEqualthattakestwovaluesandreturnstrueonlyifthey\nare the same value or are objects with the same properties, where the values\nof the properties are equal when compared with a recursive call to deepEqual.\nTo find out whether values should be compared directly (use the === operator\nfor that) or have their properties compared, you can use the typeof operator.\nIf it produces \"object\" for both values, you should do a deep comparison.\nBut you have to take one silly exception into account: because of a historical\naccident, typeof null also produces \"object\".\nThe Object.keys function will be useful when you need to go over the prop-\nerties of objects to compare them.\n81 \u201cThere are two ways of constructing a software design: One way is\nto make it so simple that there are obviously no deficiencies, and the\nother way is to make it so complicated that there are no obvious\ndeficiencies.\u201d\n\u2014C.A.R. Hoare, 1980 ACM Turing Award Lecture\nChapter5\nHigher-Order Functions\nA large program is a costly program, and not just because of the time it takes\nto build. Size almost always involves complexity, and complexity confuses\nprogrammers. Confused programmers, in turn, introduce mistakes (bugs) into\nprograms. A large program then provides a lot of space for these bugs to hide,\nmaking them hard to find.\nLet\u2019s briefly go back to the final two example programs in the introduction.\nThe first is self-contained and six lines long.\nlet total = 0, count = 1;\nwhile (count <= 10) {\ntotal += count;\ncount += 1;\n}\nconsole.log(total);\nThe second relies on two external functions and is one line long.\nconsole.log(sum(range(1, 10)));\nWhich one is more likely to contain a bug?\nIf we count the size of the definitions of sum and range, the second program\nis also big\u2014even bigger than the first. But still, I\u2019d argue that it is more likely\nto be correct.\nItismorelikelytobecorrectbecausethesolutionisexpressedinavocabulary\nthat corresponds to the problem being solved. Summing a range of numbers\nisn\u2019t about loops and counters. It is about ranges and sums.\nThe definitions of this vocabulary (the functions sum and range) will still\ninvolve loops, counters, and other incidental details. But because they are\nexpressing simpler concepts than the program as a whole, they are easier to\nget right.\n82 Abstraction\nIn the context of programming, these kinds of vocabularies are usually called\nabstractions. Abstractions hide details and give us the ability to talk about\nproblems at a higher (or more abstract) level.\nAs an analogy, compare these two recipes for pea soup. The first one goes\nlike this:\nPut 1 cup of dried peas per person into a container. Add water\nuntil the peas are well covered. Leave the peas in water for at least\n12 hours. Take the peas out of the water and put them in a cooking\npan. Add 4 cups of water per person. Cover the pan and keep the\npeas simmering for two hours. Take half an onion per person. Cut\nit into pieces with a knife. Add it to the peas. Take a stalk of\ncelery per person. Cut it into pieces with a knife. Add it to the\npeas. Take a carrot per person. Cut it into pieces. With a knife!\nAdd it to the peas. Cook for 10 more minutes.\nAnd this is the second recipe:\nPer person: 1 cup dried split peas, half a chopped onion, a stalk of\ncelery, and a carrot.\nSoak peas for 12 hours. Simmer for 2 hours in 4 cups of water (per\nperson). Chop and add vegetables. Cook for 10 more minutes.\nThe second is shorter and easier to interpret. But you do need to understand\na few more cooking-related words such as soak, simmer, chop, and, I guess,\nvegetable.\nWhen programming, we can\u2019t rely on all the words we need to be waiting for\nus in the dictionary. Thus, we might fall into the pattern of the first recipe\u2014\nwork out the precise steps the computer has to perform, one by one, blind to\nthe higher-level concepts that they express.\nIt is a useful skill, in programming, to notice when you are working at too\nlow a level of abstraction.\nAbstracting repetition\nPlain functions, as we\u2019ve seen them so far, are a good way to build abstractions.\nBut sometimes they fall short.\nIt is common for a program to do something a given number of times. You\ncan write a for loop for that, like this:\n83 for (let i = 0; i < 10; i++) {\nconsole.log(i);\n}\nCan we abstract \u201cdoing something N times\u201d as a function? Well, it\u2019s easy\nto write a function that calls console.log N times.\nfunction repeatLog(n) {\nfor (let i = 0; i < n; i++) {\nconsole.log(i);\n}\n}\nBut what if we want to do something other than logging the numbers? Since\n\u201cdoing something\u201d can be represented as a function and functions are just\nvalues, we can pass our action as a function value.\nfunction repeat(n, action) {\nfor (let i = 0; i < n; i++) {\naction(i);\n}\n}\nrepeat(3, console.log);\n\/\/ \u2192 0\n\/\/ \u2192 1\n\/\/ \u2192 2\nWe don\u2019t have to pass a predefined function to repeat. Often, it is easier to\ncreate a function value on the spot instead.\nlet labels = [];\nrepeat(5, i => {\nlabels.push(`Unit ${i + 1}`);\n});\nconsole.log(labels);\n\/\/ \u2192 [\"Unit 1\", \"Unit 2\", \"Unit 3\", \"Unit 4\", \"Unit 5\"]\nThis is structured a little like a for loop\u2014it first describes the kind of loop\nand then provides a body. However, the body is now written as a function\nvalue, which is wrapped in the parentheses of the call to repeat. This is why\nit has to be closed with the closing brace and closing parenthesis. In cases like\n84 this example, where the body is a single small expression, you could also omit\nthe braces and write the loop on a single line.\nHigher-order functions\nFunctions that operate on other functions, either by taking them as arguments\nor by returning them, are called higher-order functions. Since we have already\nseen that functions are regular values, there is nothing particularly remarkable\nabout the fact that such functions exist. The term comes from mathemat-\nics, where the distinction between functions and other values is taken more\nseriously.\nHigher-order functions allow us to abstract over actions, not just values.\nThey come in several forms. For example, we can have functions that create\nnew functions.\nfunction greaterThan(n) {\nreturn m => m > n;\n}\nlet greaterThan10 = greaterThan(10);\nconsole.log(greaterThan10(11));\n\/\/ \u2192 true\nAnd we can have functions that change other functions.\nfunction noisy(f) {\nreturn (...args) => {\nconsole.log(\"calling with\", args);\nlet result = f(...args);\nconsole.log(\"called with\", args, \", returned\", result);\nreturn result;\n};\n}\nnoisy(Math.min)(3, 2, 1);\n\/\/ \u2192 calling with [3, 2, 1]\n\/\/ \u2192 called with [3, 2, 1] , returned 1\nWe can even write functions that provide new types of control flow.\nfunction unless(test, then) {\nif (!test) then();\n}\n85 repeat(3, n => {\nunless(n % 2 == 1, () => {\nconsole.log(n, \"is even\");\n});\n});\n\/\/ \u2192 0 is even\n\/\/ \u2192 2 is even\nThere is a built-in array method, forEach, that provides something like a\nfor\/of loop as a higher-order function.\n[\"A\", \"B\"].forEach(l => console.log(l));\n\/\/ \u2192 A\n\/\/ \u2192 B\nScript data set\nOne area where higher-order functions shine is data processing. To process\ndata, we\u2019ll need some actual data. This chapter will use a data set about\nscripts\u2014writing systems such as Latin, Cyrillic, or Arabic.\nRemember Unicode from Chapter 1, the system that assigns a number to\neach character in written language? Most of these characters are associated\nwith a specific script. The standard contains 140 different scripts\u201481 are still\nin use today, and 59 are historic.\nThough I can fluently read only Latin characters, I appreciate the fact that\npeople are writing texts in at least 80 other writing systems, many of which I\nwouldn\u2019t even recognize. For example, here\u2019s a sample of Tamil handwriting:\nThe example data set contains some pieces of information about the 140\nscripts defined in Unicode. It is available in the coding sandbox for this chapter\n(https:\/\/eloquentjavascript.net\/code#5) as the SCRIPTS binding. The binding\ncontains an array of objects, each of which describes a script.\n{\nname: \"Coptic\",\nranges: [[994, 1008], [11392, 11508], [11513, 11520]],\n86 direction: \"ltr\",\nyear: -200,\nliving: false,\nlink: \"https:\/\/en.wikipedia.org\/wiki\/Coptic_alphabet\"\n}\nSuch an object tells us the name of the script, the Unicode ranges assigned to\nit, the direction in which it is written, the (approximate) origin time, whether\nit is still in use, and a link to more information. The direction may be \"ltr\"\nfor left to right, \"rtl\" for right to left (the way Arabic and Hebrew text are\nwritten), or \"ttb\" for top to bottom (as with Mongolian writing).\nThe ranges property contains an array of Unicode character ranges, each of\nwhich is a two-element array containing a lower bound and an upper bound.\nAny character codes within these ranges are assigned to the script. The lower\nbound is inclusive (code 994 is a Coptic character), and the upper bound is\nnon-inclusive (code 1008 isn\u2019t).\nFiltering arrays\nTo find the scripts in the data set that are still in use, the following function\nmight be helpful. It filters out the elements in an array that don\u2019t pass a test.\nfunction filter(array, test) {\nlet passed = [];\nfor (let element of array) {\nif (test(element)) {\npassed.push(element);\n}\n}\nreturn passed;\n}\nconsole.log(filter(SCRIPTS, script => script.living));\n\/\/ \u2192 [{name: \"Adlam\", \u2026}, \u2026]\nThe function uses the argument named test, a function value, to fill a \u201cgap\u201d\nin the computation\u2014the process of deciding which elements to collect.\nNote how the filter function, rather than deleting elements from the ex-\nisting array, builds up a new array with only the elements that pass the test.\nThis function is pure. It does not modify the array it is given.\nLike forEach, filter is a standard array method. The example defined the\n87 function only to show what it does internally. From now on, we\u2019ll use it like\nthis instead:\nconsole.log(SCRIPTS.filter(s => s.direction == \"ttb\"));\n\/\/ \u2192 [{name: \"Mongolian\", \u2026}, \u2026]\nTransforming with map\nSay we have an array of objects representing scripts, produced by filtering the\nSCRIPTS array somehow. But we want an array of names, which is easier to\ninspect.\nThe map method transforms an array by applying a function to all of its\nelements and building a new array from the returned values. The new array\nwill have the same length as the input array, but its content will have been\nmapped to a new form by the function.\nfunction map(array, transform) {\nlet mapped = [];\nfor (let element of array) {\nmapped.push(transform(element));\n}\nreturn mapped;\n}\nlet rtlScripts = SCRIPTS.filter(s => s.direction == \"rtl\");\nconsole.log(map(rtlScripts, s => s.name));\n\/\/ \u2192 [\"Adlam\", \"Arabic\", \"Imperial Aramaic\", \u2026]\nLike forEach and filter, map is a standard array method.\nSummarizing with reduce\nAnother common thing to do with arrays is to compute a single value from\nthem. Our recurring example, summing a collection of numbers, is an instance\nof this. Another example is finding the script with the most characters.\nThehigher-orderoperationthatrepresentsthispatterniscalledreduce(some-\ntimes also called fold). It builds a value by repeatedly taking a single element\nfrom the array and combining it with the current value. When summing num-\nbers, you\u2019d start with the number zero and, for each element, add that to the\n88 sum.\nThe parameters to reduce are, apart from the array, a combining function\nand a start value. This function is a little less straightforward than filter and\nmap, so take a close look at it:\nfunction reduce(array, combine, start) {\nlet current = start;\nfor (let element of array) {\ncurrent = combine(current, element);\n}\nreturn current;\n}\nconsole.log(reduce([1, 2, 3, 4], (a, b) => a + b, 0));\n\/\/ \u2192 10\nThe standard array method reduce, which of course corresponds to this\nfunction, has an added convenience. If your array contains at least one element,\nyou are allowed to leave off the start argument. The method will take the first\nelement of the array as its start value and start reducing at the second element.\nconsole.log([1, 2, 3, 4].reduce((a, b) => a + b));\n\/\/ \u2192 10\nTo use reduce (twice) to find the script with the most characters, we can\nwrite something like this:\nfunction characterCount(script) {\nreturn script.ranges.reduce((count, [from, to]) => {\nreturn count + (to - from);\n}, 0);\n}\nconsole.log(SCRIPTS.reduce((a, b) => {\nreturn characterCount(a) < characterCount(b) ? b : a;\n}));\n\/\/ \u2192 {name: \"Han\", \u2026}\nThe characterCount function reduces the ranges assigned to a script by sum-\nming their sizes. Note the use of destructuring in the parameter list of the\nreducer function. The second call to reduce then uses this to find the largest\nscript by repeatedly comparing two scripts and returning the larger one.\n89 The Han script has more than 89,000 characters assigned to it in the Unicode\nstandard, making it by far the biggest writing system in the data set. Han\nis a script (sometimes) used for Chinese, Japanese, and Korean text. Those\nlanguages share a lot of characters, though they tend to write them differently.\nThe (U.S.-based) Unicode Consortium decided to treat them as a single writing\nsystem to save character codes. This is called Han unification and still makes\nsome people very angry.\nComposability\nConsider how we would have written the previous example (finding the biggest\nscript) without higher-order functions. The code is not that much worse.\nlet biggest = null;\nfor (let script of SCRIPTS) {\nif (biggest == null ||\ncharacterCount(biggest) < characterCount(script)) {\nbiggest = script;\n}\n}\nconsole.log(biggest);\n\/\/ \u2192 {name: \"Han\", \u2026}\nThere are a few more bindings, and the program is four lines longer. But it\nis still very readable.\nHigher-order functions start to shine when you need to compose operations.\nAs an example, let\u2019s write code that finds the average year of origin for living\nand dead scripts in the data set.\nfunction average(array) {\nreturn array.reduce((a, b) => a + b) \/ array.length;\n}\nconsole.log(Math.round(average(\nSCRIPTS.filter(s => s.living).map(s => s.year))));\n\/\/ \u2192 1165\nconsole.log(Math.round(average(\nSCRIPTS.filter(s => !s.living).map(s => s.year))));\n\/\/ \u2192 204\nSo the dead scripts in Unicode are, on average, older than the living ones.\n90 This is not a terribly meaningful or surprising statistic. But I hope you\u2019ll agree\nthat the code used to compute it isn\u2019t hard to read. You can see it as a pipeline:\nwe start with all scripts, filter out the living (or dead) ones, take the years from\nthose, average them, and round the result.\nYou could definitely also write this computation as one big loop.\nlet total = 0, count = 0;\nfor (let script of SCRIPTS) {\nif (script.living) {\ntotal += script.year;\ncount += 1;\n}\n}\nconsole.log(Math.round(total \/ count));\n\/\/ \u2192 1165\nBut it is harder to see what was being computed and how. And because\nintermediate results aren\u2019t represented as coherent values, it\u2019d be a lot more\nwork to extract something like average into a separate function.\nIn terms of what the computer is actually doing, these two approaches are\nalso quite different. The first will build up new arrays when running filter\nand map, whereas the second computes only some numbers, doing less work.\nYou can usually afford the readable approach, but if you\u2019re processing huge\narrays, and doing so many times, the less abstract style might be worth the\nextra speed.\nStrings and character codes\nOne use of the data set would be figuring out what script a piece of text is\nusing. Let\u2019s go through a program that does this.\nRemember that each script has an array of character code ranges associated\nwith it. So given a character code, we could use a function like this to find the\ncorresponding script (if any):\nfunction characterScript(code) {\nfor (let script of SCRIPTS) {\nif (script.ranges.some(([from, to]) => {\nreturn code >= from && code < to;\n})) {\nreturn script;\n}\n}\n91 return null;\n}\nconsole.log(characterScript(121));\n\/\/ \u2192 {name: \"Latin\", \u2026}\nThe some method is another higher-order function. It takes a test function\nand tells you whether that function returns true for any of the elements in the\narray.\nBut how do we get the character codes in a string?\nIn Chapter 1 I mentioned that JavaScript strings are encoded as a sequence\nof 16-bit numbers. These are called code units. A Unicode character code\nwas initially supposed to fit within such a unit (which gives you a little over\n65,000 characters). When it became clear that wasn\u2019t going to be enough,\nmany people balked at the need to use more memory per character. To address\nthese concerns, UTF-16, the format used by JavaScript strings, was invented.\nIt describes most common characters using a single 16-bit code unit but uses\na pair of two such units for others.\nUTF-16 is generally considered a bad idea today. It seems almost inten-\ntionally designed to invite mistakes. It\u2019s easy to write programs that pretend\ncode units and characters are the same thing. And if your language doesn\u2019t use\ntwo-unit characters, that will appear to work just fine. But as soon as some-\none tries to use such a program with some less common Chinese characters,\nit breaks. Fortunately, with the advent of emoji, everybody has started us-\ning two-unit characters, and the burden of dealing with such problems is more\nfairly distributed.\nUnfortunately, obvious operations on JavaScript strings, such as getting their\nlength through the length property and accessing their content using square\nbrackets, deal only with code units.\n\/\/ Two emoji characters, horse and shoe\n\ud83d\udc34\ud83d\udc5f\nlet horseShoe = \" \";\nconsole.log(horseShoe.length);\n\/\/ \u2192 4\nconsole.log(horseShoe[0]);\n\/\/ \u2192 (Invalid half-character)\nconsole.log(horseShoe.charCodeAt(0));\n\/\/ \u2192 55357 (Code of the half-character)\nconsole.log(horseShoe.codePointAt(0));\n\/\/ \u2192 128052 (Actual code for horse emoji)\n92 JavaScript\u2019s charCodeAt method gives you a code unit, not a full character\ncode. The codePointAt method, added later, does give a full Unicode character.\nSo we could use that to get characters from a string. But the argument passed\nto codePointAt is still an index into the sequence of code units. So to run over\nall characters in a string, we\u2019d still need to deal with the question of whether\na character takes up one or two code units.\nIn the previous chapter, I mentioned that a for\/of loop can also be used on\nstrings. Like codePointAt, this type of loop was introduced at a time where\npeople were acutely aware of the problems with UTF-16. When you use it to\nloop over a string, it gives you real characters, not code units.\n\ud83c\udf39\ud83d\udc09\nlet roseDragon = \" \";\nfor (let char of roseDragon) {\nconsole.log(char);\n}\n\ud83c\udf39\n\/\/ \u2192\n\ud83d\udc09\n\/\/ \u2192\nIf you have a character (which will be a string of one or two code units), you\ncan use codePointAt(0) to get its code.\nRecognizing text\nWe have a characterScript function and a way to correctly loop over charac-\nters. The next step is to count the characters that belong to each script. The\nfollowing counting abstraction will be useful there:\nfunction countBy(items, groupName) {\nlet counts = [];\nfor (let item of items) {\nlet name = groupName(item);\nlet known = counts.findIndex(c => c.name == name);\nif (known == -1) {\ncounts.push({name, count: 1});\n} else {\ncounts[known].count++;\n}\n}\nreturn counts;\n}\nconsole.log(countBy([1, 2, 3, 4, 5], n => n > 2));\n93 \/\/ \u2192 [{name: false, count: 2}, {name: true, count: 3}]\nThe countBy function expects a collection (anything that we can loop over\nwith for\/of) and a function that computes a group name for a given element.\nIt returns an array of objects, each of which names a group and tells you the\nnumber of elements that were found in that group.\nIt uses another array method\u2014findIndex. This method is somewhat like\nindexOf, but instead of looking for a specific value, it finds the first value for\nwhich the given function returns true. Like indexOf, it returns -1 when no such\nelement is found.\nUsing countBy, we can write the function that tells us which scripts are used\nin a piece of text.\nfunction textScripts(text) {\nlet scripts = countBy(text, char => {\nlet script = characterScript(char.codePointAt(0));\nreturn script ? script.name : \"none\";\n}).filter(({name}) => name != \"none\");\nlet total = scripts.reduce((n, {count}) => n + count, 0);\nif (total == 0) return \"No scripts found\";\nreturn scripts.map(({name, count}) => {\nreturn `${Math.round(count * 100 \/ total)}% ${name}`;\n}).join(\", \");\n}\nconsole.log(textScripts('\u82f1\u56fd\u7684\u72d7\u8bf4\"woof\", \u4fc4\u7f57\u65af\u7684\u72d7\u8bf4\"\u0442\u044f\u0432\"'));\n\/\/ \u2192 61% Han, 22% Latin, 17% Cyrillic\nThe function first counts the characters by name, using characterScript to\nassign them a name and falling back to the string \"none\" for characters that\naren\u2019t part of any script. The filter call drops the entry for \"none\" from the\nresulting array since we aren\u2019t interested in those characters.\nTo be able to compute percentages, we first need the total number of char-\nacters that belong to a script, which we can compute with reduce. If no such\ncharacters are found, the function returns a specific string. Otherwise, it trans-\nforms the counting entries into readable strings with map and then combines\nthem with join.\n94 Summary\nBeing able to pass function values to other functions is a deeply useful aspect\nof JavaScript. It allows us to write functions that model computations with\n\u201cgaps\u201d in them. The code that calls these functions can fill in the gaps by\nproviding function values.\nArrays provide a number of useful higher-order methods. You can use\nforEach to loop over the elements in an array. The filter method returns\na new array containing only the elements that pass the predicate function.\nTransforming an array by putting each element through a function is done\nwith map. You can use reduce to combine all the elements in an array into\na single value. The some method tests whether any element matches a given\npredicate function. And findIndex finds the position of the first element that\nmatches a predicate.\nExercises\nFlattening\nUse the reduce method in combination with the concat method to \u201cflatten\u201d\nan array of arrays into a single array that has all the elements of the original\narrays.\nYour own loop\nWrite a higher-order function loop that provides something like a for loop\nstatement. It takes a value, a test function, an update function, and a body\nfunction. Each iteration, it first runs the test function on the current loop value\nand stops if that returns false. Then it calls the body function, giving it the\ncurrent value. Finally, it calls the update function to create a new value and\nstarts from the beginning.\nWhen defining the function, you can use a regular loop to do the actual\nlooping.\nEverything\nAnalogous to the some method, arrays also have an every method. This one\nreturns true when the given function returns true for every element in the array.\nIn a way, some is a version of the || operator that acts on arrays, and every is\nlike the && operator.\n95 Implement every as a function that takes an array and a predicate function\nas parameters. Write two versions, one using a loop and one using the some\nmethod.\nDominant writing direction\nWrite a function that computes the dominant writing direction in a string of\ntext. Remember that each script object has a direction property that can be\n\"ltr\" (left to right), \"rtl\" (right to left), or \"ttb\" (top to bottom).\nThe dominant direction is the direction of a majority of the characters that\nhave a script associated with them. The characterScript and countBy func-\ntions defined earlier in the chapter are probably useful here.\n96 \u201cAn abstract data type is realized by writing a special kind of program\n[\u2026] which defines the type in terms of the operations which can be\nperformed on it.\u201d\n\u2014Barbara Liskov, Programming with Abstract Data Types\nChapter6\nThe Secret Life of Objects\nChapter 4 introduced JavaScript\u2019s objects. In programming culture, we have a\nthing called object-oriented programming, a set of techniques that use objects\n(and related concepts) as the central principle of program organization.\nThough no one really agrees on its precise definition, object-oriented pro-\ngramming has shaped the design of many programming languages, including\nJavaScript. This chapter will describe the way these ideas can be applied in\nJavaScript.\nEncapsulation\nThecoreideainobject-orientedprogrammingistodivideprogramsintosmaller\npieces and make each piece responsible for managing its own state.\nThis way, some knowledge about the way a piece of the program works can\nbe kept local to that piece. Someone working on the rest of the program does\nnot have to remember or even be aware of that knowledge. Whenever these\nlocal details change, only the code directly around it needs to be updated.\nDifferent pieces of such a program interact with each other through inter-\nfaces, limited sets of functions or bindings that provide useful functionality at\na more abstract level, hiding their precise implementation.\nSuch program pieces are modeled using objects. Their interface consists of a\nspecific set of methods and properties. Properties that are part of the interface\nare called public. The others, which outside code should not be touching, are\ncalled private.\nMany languages provide a way to distinguish public and private properties\nandpreventoutsidecodefromaccessingtheprivateonesaltogether. JavaScript,\nonce again taking the minimalist approach, does not\u2014not yet at least. There\nis work underway to add this to the language.\nEven though the language doesn\u2019t have this distinction built in, JavaScript\nprogrammers are successfully using this idea. Typically, the available interface\nis described in documentation or comments. It is also common to put an\n97 underscore (_) character at the start of property names to indicate that those\nproperties are private.\nSeparating interface from implementation is a great idea. It is usually called\nencapsulation.\nMethods\nMethods are nothing more than properties that hold function values. This is a\nsimple method:\nlet rabbit = {};\nrabbit.speak = function(line) {\nconsole.log(`The rabbit says '${line}'`);\n};\nrabbit.speak(\"I'm alive.\");\n\/\/ \u2192 The rabbit says 'I'm alive.'\nUsually a method needs to do something with the object it was called on.\nWhen a function is called as a method\u2014looked up as a property and immedi-\nately called, as in object.method()\u2014the binding called this in its body auto-\nmatically points at the object that it was called on.\nfunction speak(line) {\nconsole.log(`The ${this.type} rabbit says '${line}'`);\n}\nlet whiteRabbit = {type: \"white\", speak};\nlet hungryRabbit = {type: \"hungry\", speak};\nwhiteRabbit.speak(\"Oh my ears and whiskers, \" +\n\"how late it's getting!\");\n\/\/ \u2192 The white rabbit says 'Oh my ears and whiskers, how\n\/\/ late it's getting!'\nhungryRabbit.speak(\"I could use a carrot right now.\");\n\/\/ \u2192 The hungry rabbit says 'I could use a carrot right now.'\nYou can think of this as an extra parameter that is passed in a different\nway. If you want to pass it explicitly, you can use a function\u2019s call method,\nwhich takes the this value as its first argument and treats further arguments\nas normal parameters.\nspeak.call(hungryRabbit, \"Burp!\");\n98 \/\/ \u2192 The hungry rabbit says 'Burp!'\nSince each function has its own this binding, whose value depends on the\nway it is called, you cannot refer to the this of the wrapping scope in a regular\nfunction defined with the function keyword.\nArrow functions are different\u2014they do not bind their own this but can see\nthe this binding of the scope around them. Thus, you can do something like\nthe following code, which references this from inside a local function:\nfunction normalize() {\nconsole.log(this.coords.map(n => n \/ this.length));\n}\nnormalize.call({coords: [0, 2, 3], length: 5});\n\/\/ \u2192 [0, 0.4, 0.6]\nIf I had written the argument to map using the function keyword, the code\nwouldn\u2019t work.\nPrototypes\nWatch closely.\nlet empty = {};\nconsole.log(empty.toString);\n\/\/ \u2192 function toString()\u2026{}\nconsole.log(empty.toString());\n\/\/ \u2192 [object Object]\nI pulled a property out of an empty object. Magic!\nWell, not really. I have simply been withholding information about the way\nJavaScript objects work. In addition to their set of properties, most objects\nalso have a prototype. A prototype is another object that is used as a fallback\nsource of properties. When an object gets a request for a property that it does\nnot have, its prototype will be searched for the property, then the prototype\u2019s\nprototype, and so on.\nSo who is the prototype of that empty object? It is the great ancestral\nprototype, the entity behind almost all objects, Object.prototype.\nconsole.log(Object.getPrototypeOf({}) ==\nObject.prototype);\n99 \/\/ \u2192 true\nconsole.log(Object.getPrototypeOf(Object.prototype));\n\/\/ \u2192 null\nAs you guess, Object.getPrototypeOf returns the prototype of an object.\nThe prototype relations of JavaScript objects form a tree-shaped structure,\nand at the root of this structure sits Object.prototype. It provides a few\nmethods that show up in all objects, such as toString, which converts an\nobject to a string representation.\nMany objects don\u2019t directly have Object.prototype as their prototype but\ninstead have another object that provides a different set of default proper-\nties. Functions derive from Function.prototype, and arrays derive from Array\n.prototype.\nconsole.log(Object.getPrototypeOf(Math.max) ==\nFunction.prototype);\n\/\/ \u2192 true\nconsole.log(Object.getPrototypeOf([]) ==\nArray.prototype);\n\/\/ \u2192 true\nSuch a prototype object will itself have a prototype, often Object.prototype,\nso that it still indirectly provides methods like toString.\nYou can use Object.create to create an object with a specific prototype.\nlet protoRabbit = {\nspeak(line) {\nconsole.log(`The ${this.type} rabbit says '${line}'`);\n}\n};\nlet killerRabbit = Object.create(protoRabbit);\nkillerRabbit.type = \"killer\";\nkillerRabbit.speak(\"SKREEEE!\");\n\/\/ \u2192 The killer rabbit says 'SKREEEE!'\nA property like speak(line) in an object expression is a shorthand way of\ndefining a method. It creates a property called speak and gives it a function\nas its value.\nThe\u201cproto\u201drabbitactsasacontainerforthepropertiesthataresharedbyall\nrabbits. An individual rabbit object, like the killer rabbit, contains properties\nthat apply only to itself\u2014in this case its type\u2014and derives shared properties\n100 from its prototype.\nClasses\nJavaScript\u2019s prototype system can be interpreted as a somewhat informal take\non an object-oriented concept called classes. A class defines the shape of a\ntype of object\u2014what methods and properties it has. Such an object is called\nan instance of the class.\nPrototypes are useful for defining properties for which all instances of a class\nshare the same value, such as methods. Properties that differ per instance,\nsuch as our rabbits\u2019 type property, need to be stored directly in the objects\nthemselves.\nSo to create an instance of a given class, you have to make an object that\nderives from the proper prototype, but you also have to make sure it, itself, has\nthe properties that instances of this class are supposed to have. This is what a\nconstructor function does.\nfunction makeRabbit(type) {\nlet rabbit = Object.create(protoRabbit);\nrabbit.type = type;\nreturn rabbit;\n}\nJavaScript provides a way to make defining this type of function easier. If\nyou put the keyword new in front of a function call, the function is treated as\na constructor. This means that an object with the right prototype is automat-\nically created, bound to this in the function, and returned at the end of the\nfunction.\nThe prototype object used when constructing objects is found by taking the\nprototype property of the constructor function.\nfunction Rabbit(type) {\nthis.type = type;\n}\nRabbit.prototype.speak = function(line) {\nconsole.log(`The ${this.type} rabbit says '${line}'`);\n};\nlet weirdRabbit = new Rabbit(\"weird\");\nConstructors (all functions, in fact) automatically get a property named\n101 prototype, which by default holds a plain, empty object that derives from\nObject.prototype. You can overwrite it with a new object if you want. Or you\ncan add properties to the existing object, as the example does.\nBy convention, the names of constructors are capitalized so that they can\neasily be distinguished from other functions.\nIt is important to understand the distinction between the way a prototype\nis associated with a constructor (through its prototype property) and the way\nobjects have a prototype (which can be found with Object.getPrototypeOf).\nThe actual prototype of a constructor is Function.prototype since constructors\nare functions. Its prototype property holds the prototype used for instances\ncreated through it.\nconsole.log(Object.getPrototypeOf(Rabbit) ==\nFunction.prototype);\n\/\/ \u2192 true\nconsole.log(Object.getPrototypeOf(weirdRabbit) ==\nRabbit.prototype);\n\/\/ \u2192 true\nClass notation\nSo JavaScript classes are constructor functions with a prototype property. That\nis how they work, and until 2015, that was how you had to write them. These\ndays, we have a less awkward notation.\nclass Rabbit {\nconstructor(type) {\nthis.type = type;\n}\nspeak(line) {\nconsole.log(`The ${this.type} rabbit says '${line}'`);\n}\n}\nlet killerRabbit = new Rabbit(\"killer\");\nlet blackRabbit = new Rabbit(\"black\");\nThe class keyword starts a class declaration, which allows us to define a\nconstructor and a set of methods all in a single place. Any number of methods\nmay be written inside the declaration\u2019s braces. The one named constructor\n102 is treated specially. It provides the actual constructor function, which will be\nbound to the name Rabbit. The others are packaged into that constructor\u2019s\nprototype. Thus, the earlier class declaration is equivalent to the constructor\ndefinition from the previous section. It just looks nicer.\nClassdeclarationscurrentlyallowonlymethods\u2014propertiesthatholdfunctions\u2014\nto be added to the prototype. This can be somewhat inconvenient when you\nwant to save a non-function value in there. The next version of the language\nwill probably improve this. For now, you can create such properties by directly\nmanipulating the prototype after you\u2019ve defined the class.\nLike function, class can be used both in statements and in expressions.\nWhen used as an expression, it doesn\u2019t define a binding but just produces the\nconstructor as a value. You are allowed to omit the class name in a class\nexpression.\nlet object = new class { getWord() { return \"hello\"; } };\nconsole.log(object.getWord());\n\/\/ \u2192 hello\nOverriding derived properties\nWhen you add a property to an object, whether it is present in the prototype or\nnot, the property is added to the object itself. If there was already a property\nwith the same name in the prototype, this property will no longer affect the\nobject, as it is now hidden behind the object\u2019s own property.\nRabbit.prototype.teeth = \"small\";\nconsole.log(killerRabbit.teeth);\n\/\/ \u2192 small\nkillerRabbit.teeth = \"long, sharp, and bloody\";\nconsole.log(killerRabbit.teeth);\n\/\/ \u2192 long, sharp, and bloody\nconsole.log(blackRabbit.teeth);\n\/\/ \u2192 small\nconsole.log(Rabbit.prototype.teeth);\n\/\/ \u2192 small\nThe following diagram sketches the situation after this code has run. The\nRabbit and Object prototypes lie behind killerRabbit as a kind of backdrop,\nwhere properties that are not found in the object itself can be looked up.\n103 Rabbit\nprototype\nObject\nkillerRabbit\ncreate: <function>\nteeth:\"long,sharp,...\"\nprototype\ntype: \"killer\"\n...\nteeth: \"small\"\nspeak: <function>\ntoString: <function>\n...\nOverridingpropertiesthatexistinaprototypecanbeausefulthingtodo. As\nthe rabbit teeth example shows, overriding can be used to express exceptional\nproperties in instances of a more generic class of objects, while letting the\nnonexceptional objects take a standard value from their prototype.\nOverriding is also used to give the standard function and array prototypes a\ndifferent toString method than the basic object prototype.\nconsole.log(Array.prototype.toString ==\nObject.prototype.toString);\n\/\/ \u2192 false\nconsole.log([1, 2].toString());\n\/\/ \u2192 1,2\nCalling toString on an array gives a result similar to calling .join(\",\") on\nit\u2014it puts commas between the values in the array. Directly calling Object.\nprototype.toString with an array produces a different string. That function\ndoesn\u2019t know about arrays, so it simply puts the word object and the name of\nthe type between square brackets.\nconsole.log(Object.prototype.toString.call([1, 2]));\n\/\/ \u2192 [object Array]\nMaps\nWe saw the word map used in the previous chapter for an operation that trans-\nforms a data structure by applying a function to its elements. Confusing as it\nis, in programming the same word is also used for a related but rather different\nthing.\nA map (noun) is a data structure that associates values (the keys) with other\nvalues. For example, you might want to map names to ages. It is possible to\nuse objects for this.\n104 let ages = {\nBoris: 39,\nLiang: 22,\nJ\u00falia: 62\n};\nconsole.log(`J\u00falia is ${ages[\"J\u00falia\"]}`);\n\/\/ \u2192 J\u00falia is 62\nconsole.log(\"Is Jack's age known?\", \"Jack\" in ages);\n\/\/ \u2192 Is Jack's age known? false\nconsole.log(\"Is toString's age known?\", \"toString\" in ages);\n\/\/ \u2192 Is toString's age known? true\nHere, the object\u2019s property names are the people\u2019s names, and the property\nvalues are their ages. But we certainly didn\u2019t list anybody named toString in\nour map. Yet, because plain objects derive from Object.prototype, it looks\nlike the property is there.\nAs such, using plain objects as maps is dangerous. There are several possible\nways to avoid this problem. First, it is possible to create objects with no\nprototype. If you pass null to Object.create, the resulting object will not\nderive from Object.prototype and can safely be used as a map.\nconsole.log(\"toString\" in Object.create(null));\n\/\/ \u2192 false\nObject property names must be strings. If you need a map whose keys can\u2019t\neasily be converted to strings\u2014such as objects\u2014you cannot use an object as\nyour map.\nFortunately, JavaScript comes with a class called Map that is written for this\nexact purpose. It stores a mapping and allows any type of keys.\nlet ages = new Map();\nages.set(\"Boris\", 39);\nages.set(\"Liang\", 22);\nages.set(\"J\u00falia\", 62);\nconsole.log(`J\u00falia is ${ages.get(\"J\u00falia\")}`);\n\/\/ \u2192 J\u00falia is 62\nconsole.log(\"Is Jack's age known?\", ages.has(\"Jack\"));\n\/\/ \u2192 Is Jack's age known? false\nconsole.log(ages.has(\"toString\"));\n\/\/ \u2192 false\n105 The methods set, get, and has are part of the interface of the Map object.\nWriting a data structure that can quickly update and search a large set of\nvalues isn\u2019t easy, but we don\u2019t have to worry about that. Someone else did it\nfor us, and we can go through this simple interface to use their work.\nIf you do have a plain object that you need to treat as a map for some reason,\nit is useful to know that Object.keys returns only an object\u2019s own keys, not\nthose in the prototype. As an alternative to the in operator, you can use the\nhasOwnProperty method, which ignores the object\u2019s prototype.\nconsole.log({x: 1}.hasOwnProperty(\"x\"));\n\/\/ \u2192 true\nconsole.log({x: 1}.hasOwnProperty(\"toString\"));\n\/\/ \u2192 false\nPolymorphism\nWhen you call the String function (which converts a value to a string) on an\nobject, it will call the toString method on that object to try to create a mean-\ningful string from it. I mentioned that some of the standard prototypes define\ntheir own version of toString so they can create a string that contains more\nuseful information than \"[object Object]\". You can also do that yourself.\nRabbit.prototype.toString = function() {\nreturn `a ${this.type} rabbit`;\n};\nconsole.log(String(blackRabbit));\n\/\/ \u2192 a black rabbit\nThis is a simple instance of a powerful idea. When a piece of code is written\nto work with objects that have a certain interface\u2014in this case, a toString\nmethod\u2014any kind of object that happens to support this interface can be\nplugged into the code, and it will just work.\nThis technique is called polymorphism. Polymorphic code can work with\nvalues of different shapes, as long as they support the interface it expects.\nI mentioned in Chapter 4 that a for\/of loop can loop over several kinds of\ndata structures. This is another case of polymorphism\u2014such loops expect the\ndata structure to expose a specific interface, which arrays and strings do. And\n106 we can also add this interface to our own objects! But before we can do that,\nwe need to know what symbols are.\nSymbols\nIt is possible for multiple interfaces to use the same property name for different\nthings. Forexample, IcoulddefineaninterfaceinwhichthetoStringmethodis\nsupposed to convert the object into a piece of yarn. It would not be possible for\nan object to conform to both that interface and the standard use of toString.\nThat would be a bad idea, and this problem isn\u2019t that common. Most\nJavaScript programmers simply don\u2019t think about it. But the language de-\nsigners, whose job it is to think about this stuff, have provided us with a\nsolution anyway.\nWhen I claimed that property names are strings, that wasn\u2019t entirely ac-\ncurate. They usually are, but they can also be symbols. Symbols are values\ncreated with the Symbol function. Unlike strings, newly created symbols are\nunique\u2014you cannot create the same symbol twice.\nlet sym = Symbol(\"name\");\nconsole.log(sym == Symbol(\"name\"));\n\/\/ \u2192 false\nRabbit.prototype[sym] = 55;\nconsole.log(blackRabbit[sym]);\n\/\/ \u2192 55\nThe string you pass to Symbol is included when you convert it to a string\nand can make it easier to recognize a symbol when, for example, showing it in\nthe console. But it has no meaning beyond that\u2014multiple symbols may have\nthe same name.\nBeing both unique and usable as property names makes symbols suitable\nfor defining interfaces that can peacefully live alongside other properties, no\nmatter what their names are.\nconst toStringSymbol = Symbol(\"toString\");\nArray.prototype[toStringSymbol] = function() {\nreturn `${this.length} cm of blue yarn`;\n};\nconsole.log([1, 2].toString());\n\/\/ \u2192 1,2\nconsole.log([1, 2][toStringSymbol]());\n107 \/\/ \u2192 2 cm of blue yarn\nIt is possible to include symbol properties in object expressions and classes\nby using square brackets around the property name. That causes the property\nname to be evaluated, much like the square bracket property access notation,\nwhich allows us to refer to a binding that holds the symbol.\nlet stringObject = {\n[toStringSymbol]() { return \"a jute rope\"; }\n};\nconsole.log(stringObject[toStringSymbol]());\n\/\/ \u2192 a jute rope\nThe iterator interface\nThe object given to a for\/of loop is expected to be iterable. This means it has\na method named with the Symbol.iterator symbol (a symbol value defined by\nthe language, stored as a property of the Symbol function).\nWhen called, that method should return an object that provides a second\ninterface, iterator. This is the actual thing that iterates. It has a next method\nthat returns the next result. That result should be an object with a value\nproperty that provides the next value, if there is one, and a done property,\nwhich should be true when there are no more results and false otherwise.\nNote that the next, value, and done property names are plain strings, not\nsymbols. Only Symbol.iterator, which is likely to be added to a lot of different\nobjects, is an actual symbol.\nWe can directly use this interface ourselves.\nlet okIterator = \"OK\"[Symbol.iterator]();\nconsole.log(okIterator.next());\n\/\/ \u2192 {value: \"O\", done: false}\nconsole.log(okIterator.next());\n\/\/ \u2192 {value: \"K\", done: false}\nconsole.log(okIterator.next());\n\/\/ \u2192 {value: undefined, done: true}\nLet\u2019s implement an iterable data structure. We\u2019ll build a matrix class, acting\nas a two-dimensional array.\n108 class Matrix {\nconstructor(width, height, element = (x, y) => undefined) {\nthis.width = width;\nthis.height = height;\nthis.content = [];\nfor (let y = 0; y < height; y++) {\nfor (let x = 0; x < width; x++) {\nthis.content[y * width + x] = element(x, y);\n}\n}\n}\nget(x, y) {\nreturn this.content[y * this.width + x];\n}\nset(x, y, value) {\nthis.content[y * this.width + x] = value;\n}\n}\nThe class stores its content in a single array of width \u00d7 height elements. The\nelements are stored row by row, so, for example, the third element in the fifth\nrow is (using zero-based indexing) stored at position 4 \u00d7 width + 2.\nThe constructor function takes a width, a height, and an optional element\nfunction that will be used to fill in the initial values. There are get and set\nmethods to retrieve and update elements in the matrix.\nWhen looping over a matrix, you are usually interested in the position of the\nelements as well as the elements themselves, so we\u2019ll have our iterator produce\nobjects with x, y, and value properties.\nclass MatrixIterator {\nconstructor(matrix) {\nthis.x = 0;\nthis.y = 0;\nthis.matrix = matrix;\n}\nnext() {\nif (this.y == this.matrix.height) return {done: true};\nlet value = {x: this.x,\ny: this.y,\nvalue: this.matrix.get(this.x, this.y)};\n109 this.x++;\nif (this.x == this.matrix.width) {\nthis.x = 0;\nthis.y++;\n}\nreturn {value, done: false};\n}\n}\nThe class tracks the progress of iterating over a matrix in its x and y prop-\nerties. The next method starts by checking whether the bottom of the matrix\nhas been reached. If it hasn\u2019t, it first creates the object holding the current\nvalue and then updates its position, moving to the next row if necessary.\nLet\u2019s set up the Matrix class to be iterable. Throughout this book, I\u2019ll oc-\ncasionally use after-the-fact prototype manipulation to add methods to classes\nso that the individual pieces of code remain small and self-contained. In a reg-\nular program, where there is no need to split the code into small pieces, you\u2019d\ndeclare these methods directly in the class instead.\nMatrix.prototype[Symbol.iterator] = function() {\nreturn new MatrixIterator(this);\n};\nWe can now loop over a matrix with for\/of.\nlet matrix = new Matrix(2, 2, (x, y) => `value ${x},${y}`);\nfor (let {x, y, value} of matrix) {\nconsole.log(x, y, value);\n}\n\/\/ \u2192 0 0 value 0,0\n\/\/ \u2192 1 0 value 1,0\n\/\/ \u2192 0 1 value 0,1\n\/\/ \u2192 1 1 value 1,1\nGetters, setters, and statics\nInterfaces often consist mostly of methods, but it is also okay to include prop-\nerties that hold non-function values. For example, Map objects have a size\nproperty that tells you how many keys are stored in them.\nIt is not even necessary for such an object to compute and store such a\n110 property directly in the instance. Even properties that are accessed directly\nmay hide a method call. Such methods are called getters, and they are defined\nby writing get in front of the method name in an object expression or class\ndeclaration.\nlet varyingSize = {\nget size() {\nreturn Math.floor(Math.random() * 100);\n}\n};\nconsole.log(varyingSize.size);\n\/\/ \u2192 73\nconsole.log(varyingSize.size);\n\/\/ \u2192 49\nWhenever someone reads from this object\u2019s size property, the associated\nmethod is called. You can do a similar thing when a property is written to,\nusing a setter.\nclass Temperature {\nconstructor(celsius) {\nthis.celsius = celsius;\n}\nget fahrenheit() {\nreturn this.celsius * 1.8 + 32;\n}\nset fahrenheit(value) {\nthis.celsius = (value - 32) \/ 1.8;\n}\nstatic fromFahrenheit(value) {\nreturn new Temperature((value - 32) \/ 1.8);\n}\n}\nlet temp = new Temperature(22);\nconsole.log(temp.fahrenheit);\n\/\/ \u2192 71.6\ntemp.fahrenheit = 86;\nconsole.log(temp.celsius);\n\/\/ \u2192 30\n111 The Temperature class allows you to read and write the temperature in either\ndegrees Celsius or degrees Fahrenheit, but internally it stores only Celsius and\nautomatically converts to and from Celsius in the fahrenheit getter and setter.\nSometimes you want to attach some properties directly to your constructor\nfunction, rather than to the prototype. Such methods won\u2019t have access to\na class instance but can, for example, be used to provide additional ways to\ncreate instances.\nInside a class declaration, methods that have static written before their\nname are stored on the constructor. So the Temperature class allows you to\nwrite Temperature.fromFahrenheit(100) to create a temperature using degrees\nFahrenheit.\nInheritance\nSome matrices are known to be symmetric. If you mirror a symmetric matrix\naround its top-left-to-bottom-right diagonal, it stays the same. In other words,\nthe value stored at x,y is always the same as that at y,x.\nImagine we need a data structure like Matrix but one that enforces the fact\nthat the matrix is and remains symmetrical. We could write it from scratch,\nbut that would involve repeating some code very similar to what we already\nwrote.\nJavaScript\u2019s prototype system makes it possible to create a new class, much\nlike the old class, but with new definitions for some of its properties. The\nprototype for the new class derives from the old prototype but adds a new\ndefinition for, say, the set method.\nIn object-oriented programming terms, this is called inheritance. The new\nclass inherits properties and behavior from the old class.\nclass SymmetricMatrix extends Matrix {\nconstructor(size, element = (x, y) => undefined) {\nsuper(size, size, (x, y) => {\nif (x < y) return element(y, x);\nelse return element(x, y);\n});\n}\nset(x, y, value) {\nsuper.set(x, y, value);\nif (x != y) {\nsuper.set(y, x, value);\n}\n}\n112 }\nlet matrix = new SymmetricMatrix(5, (x, y) => `${x},${y}`);\nconsole.log(matrix.get(2, 3));\n\/\/ \u2192 3,2\nThe use of the word extends indicates that this class shouldn\u2019t be directly\nbased on the default Object prototype but on some other class. This is called\nthe superclass. The derived class is the subclass.\nTo initialize a SymmetricMatrix instance, the constructor calls its superclass\u2019s\nconstructor through the super keyword. This is necessary because if this new\nobject is to behave (roughly) like a Matrix, it is going to need the instance\nproperties that matrices have. To ensure the matrix is symmetrical, the con-\nstructor wraps the element function to swap the coordinates for values below\nthe diagonal.\nThe set method again uses super but this time not to call the constructor\nbut to call a specific method from the superclass\u2019s set of methods. We are\nredefining set but do want to use the original behavior. Because this.set\nrefers to the new set method, calling that wouldn\u2019t work. Inside class methods,\nsuper provides a way to call methods as they were defined in the superclass.\nInheritance allows us to build slightly different data types from existing data\ntypes with relatively little work. It is a fundamental part of the object-oriented\ntradition, alongside encapsulation and polymorphism. But while the latter two\narenowgenerallyregardedaswonderfulideas, inheritanceismorecontroversial.\nWhereas encapsulation and polymorphism can be used to separate pieces\nof code from each other, reducing the tangledness of the overall program, in-\nheritance fundamentally ties classes together, creating more tangle. When\ninheriting from a class, you usually have to know more about how it works\nthan when simply using it. Inheritance can be a useful tool, and I use it now\nand then in my own programs, but it shouldn\u2019t be the first tool you reach for,\nand you probably shouldn\u2019t actively go looking for opportunities to construct\nclass hierarchies (family trees of classes).\nThe instanceof operator\nIt is occasionally useful to know whether an object was derived from a specific\nclass. For this, JavaScript provides a binary operator called instanceof.\nconsole.log(\nnew SymmetricMatrix(2) instanceof SymmetricMatrix);\n113 \/\/ \u2192 true\nconsole.log(new SymmetricMatrix(2) instanceof Matrix);\n\/\/ \u2192 true\nconsole.log(new Matrix(2, 2) instanceof SymmetricMatrix);\n\/\/ \u2192 false\nconsole.log([1] instanceof Array);\n\/\/ \u2192 true\nThe operator will see through inherited types, so a SymmetricMatrix is an\ninstance of Matrix. The operator can also be applied to standard constructors\nlike Array. Almost every object is an instance of Object.\nSummary\nSo objects do more than just hold their own properties. They have prototypes,\nwhich are other objects. They\u2019ll act as if they have properties they don\u2019t have\nas long as their prototype has that property. Simple objects have Object.\nprototype as their prototype.\nConstructors, which are functions whose names usually start with a capital\nletter, can be used with the new operator to create new objects. The new\nobject\u2019s prototype will be the object found in the prototype property of the\nconstructor. You can make good use of this by putting the properties that all\nvalues of a given type share into their prototype. There\u2019s a class notation that\nprovides a clear way to define a constructor and its prototype.\nYou can define getters and setters to secretly call methods every time an\nobject\u2019s property is accessed. Static methods are methods stored in a class\u2019s\nconstructor, rather than its prototype.\nThe instanceof operator can, given an object and a constructor, tell you\nwhether that object is an instance of that constructor.\nOne useful thing to do with objects is to specify an interface for them and\ntell everybody that they are supposed to talk to your object only through that\ninterface. Therestofthedetailsthatmakeupyourobjectarenowencapsulated,\nhidden behind the interface.\nMore than one type may implement the same interface. Code written to use\nan interface automatically knows how to work with any number of different\nobjects that provide the interface. This is called polymorphism.\nWhen implementing multiple classes that differ in only some details, it can\nbe helpful to write the new classes as subclasses of an existing class, inheriting\npart of its behavior.\n114 Exercises\nA vector type\nWrite a class Vec that represents a vector in two-dimensional space. It takes\nx and y parameters (numbers), which it should save to properties of the same\nname.\nGive the Vec prototype two methods, plus and minus, that take another\nvector as a parameter and return a new vector that has the sum or difference\nof the two vectors\u2019 (this and the parameter) x and y values.\nAdd a getter property length to the prototype that computes the length of\nthe vector\u2014that is, the distance of the point (x, y) from the origin (0, 0).\nGroups\nThe standard JavaScript environment provides another data structure called\nSet. Like an instance of Map, a set holds a collection of values. Unlike Map, it\ndoes not associate other values with those\u2014it just tracks which values are part\nof the set. A value can be part of a set only once\u2014adding it again doesn\u2019t have\nany effect.\nWrite a class called Group (since Set is already taken). Like Set, it has add,\ndelete, and has methods. Its constructor creates an empty group, add adds\na value to the group (but only if it isn\u2019t already a member), delete removes\nits argument from the group (if it was a member), and has returns a Boolean\nvalue indicating whether its argument is a member of the group.\nUse the === operator, or something equivalent such as indexOf, to determine\nwhether two values are the same.\nGive the class a static from method that takes an iterable object as argument\nand creates a group that contains all the values produced by iterating over it.\nIterable groups\nMake the Group class from the previous exercise iterable. Refer to the section\nabout the iterator interface earlier in the chapter if you aren\u2019t clear on the\nexact form of the interface anymore.\nIf you used an array to represent the group\u2019s members, don\u2019t just return the\niterator created by calling the Symbol.iterator method on the array. That\nwould work, but it defeats the purpose of this exercise.\nItisokayifyouriteratorbehavesstrangelywhenthegroupismodifiedduring\niteration.\n115 Borrowing a method\nEarlier in the chapter I mentioned that an object\u2019s hasOwnProperty can be\nused as a more robust alternative to the in operator when you want to ignore\nthe prototype\u2019s properties. But what if your map needs to include the word\n\"hasOwnProperty\"? You won\u2019t be able to call that method anymore because\nthe object\u2019s own property hides the method value.\nCan you think of a way to call hasOwnProperty on an object that has its own\nproperty by that name?\n116 \u201c[...] the question of whether Machines Can Think [...] is about as\nrelevant as the question of whether Submarines Can Swim.\u201d\n\u2014Edsger Dijkstra, The Threats to Computing Science\nChapter7\nProject: A Robot\nIn \u201cproject\u201d chapters, I\u2019ll stop pummeling you with new theory for a brief mo-\nment, and instead we\u2019ll work through a program together. Theory is necessary\nto learn to program, but reading and understanding actual programs is just as\nimportant.\nOur project in this chapter is to build an automaton, a little program that\nperforms a task in a virtual world. Our automaton will be a mail-delivery robot\npicking up and dropping off parcels.\nMeadowfield\nThe village of Meadowfield isn\u2019t very big. It consists of 11 places with 14 roads\nbetween them. It can be described with this array of roads:\nconst roads = [\n\"Alice's House-Bob's House\", \"Alice's House-Cabin\",\n\"Alice's House-Post Office\", \"Bob's House-Town Hall\",\n\"Daria's House-Ernie's House\", \"Daria's House-Town Hall\",\n\"Ernie's House-Grete's House\", \"Grete's House-Farm\",\n\"Grete's House-Shop\", \"Marketplace-Farm\",\n\"Marketplace-Post Office\", \"Marketplace-Shop\",\n\"Marketplace-Town Hall\", \"Shop-Town Hall\"\n];\n117 The network of roads in the village forms a graph. A graph is a collection of\npoints (places in the village) with lines between them (roads). This graph will\nbe the world that our robot moves through.\nThe array of strings isn\u2019t very easy to work with. What we\u2019re interested in\nis the destinations that we can reach from a given place. Let\u2019s convert the list\nof roads to a data structure that, for each place, tells us what can be reached\nfrom there.\nfunction buildGraph(edges) {\nlet graph = Object.create(null);\nfunction addEdge(from, to) {\nif (graph[from] == null) {\ngraph[from] = [to];\n} else {\ngraph[from].push(to);\n}\n}\nfor (let [from, to] of edges.map(r => r.split(\"-\"))) {\naddEdge(from, to);\naddEdge(to, from);\n}\nreturn graph;\n}\nconst roadGraph = buildGraph(roads);\nGiven an array of edges, buildGraph creates a map object that, for each node,\n118 stores an array of connected nodes.\nIt uses the split method to go from the road strings, which have the form\n\"Start-End\", to two-element arrays containing the start and end as separate\nstrings.\nThe task\nOur robot will be moving around the village. There are parcels in various\nplaces, each addressed to some other place. The robot picks up parcels when\nit comes to them and delivers them when it arrives at their destinations.\nThe automaton must decide, at each point, where to go next. It has finished\nits task when all parcels have been delivered.\nTo be able to simulate this process, we must define a virtual world that can\ndescribe it. This model tells us where the robot is and where the parcels are.\nWhen the robot has decided to move somewhere, we need to update the model\nto reflect the new situation.\nIf you\u2019re thinking in terms of object-oriented programming, your first impulse\nmight be to start defining objects for the various elements in the world: a class\nfor the robot, one for a parcel, maybe one for places. These could then hold\nproperties that describe their current state, such as the pile of parcels at a\nlocation, which we could change when updating the world.\nThis is wrong.\nAt least, it usually is. The fact that something sounds like an object does not\nautomatically mean that it should be an object in your program. Reflexively\nwriting classes for every concept in your application tends to leave you with a\ncollection of interconnected objects that each have their own internal, changing\nstate. Such programs are often hard to understand and thus easy to break.\nInstead, let\u2019s condense the village\u2019s state down to the minimal set of values\nthat define it. There\u2019s the robot\u2019s current location and the collection of unde-\nlivered parcels, each of which has a current location and a destination address.\nThat\u2019s it.\nAnd while we\u2019re at it, let\u2019s make it so that we don\u2019t change this state when\nthe robot moves but rather compute a new state for the situation after the\nmove.\nclass VillageState {\nconstructor(place, parcels) {\nthis.place = place;\nthis.parcels = parcels;\n}\n119 move(destination) {\nif (!roadGraph[this.place].includes(destination)) {\nreturn this;\n} else {\nlet parcels = this.parcels.map(p => {\nif (p.place != this.place) return p;\nreturn {place: destination, address: p.address};\n}).filter(p => p.place != p.address);\nreturn new VillageState(destination, parcels);\n}\n}\n}\nThe move method is where the action happens. It first checks whether there\nis a road going from the current place to the destination, and if not, it returns\nthe old state since this is not a valid move.\nThenitcreatesanewstatewiththedestinationastherobot\u2019snewplace. But\nit also needs to create a new set of parcels\u2014parcels that the robot is carrying\n(that are at the robot\u2019s current place) need to be moved along to the new place.\nAnd parcels that are addressed to the new place need to be delivered\u2014that is,\nthey need to be removed from the set of undelivered parcels. The call to map\ntakes care of the moving, and the call to filter does the delivering.\nParcel objects aren\u2019t changed when they are moved but re-created. The move\nmethod gives us a new village state but leaves the old one entirely intact.\nlet first = new VillageState(\n\"Post Office\",\n[{place: \"Post Office\", address: \"Alice's House\"}]\n);\nlet next = first.move(\"Alice's House\");\nconsole.log(next.place);\n\/\/ \u2192 Alice's House\nconsole.log(next.parcels);\n\/\/ \u2192 []\nconsole.log(first.place);\n\/\/ \u2192 Post Office\nThe move causes the parcel to be delivered, and this is reflected in the next\nstate. But the initial state still describes the situation where the robot is at\nthe post o\ufb00ice and the parcel is undelivered.\n120 Persistent data\nData structures that don\u2019t change are called immutable or persistent. They\nbehave a lot like strings and numbers in that they are who they are and stay\nthat way, rather than containing different things at different times.\nIn JavaScript, just about everything can be changed, so working with values\nthat are supposed to be persistent requires some restraint. There is a function\ncalled Object.freeze that changes an object so that writing to its properties\nis ignored. You could use that to make sure your objects aren\u2019t changed, if\nyou want to be careful. Freezing does require the computer to do some extra\nwork, and having updates ignored is just about as likely to confuse someone as\nhaving them do the wrong thing. So I usually prefer to just tell people that a\ngiven object shouldn\u2019t be messed with and hope they remember it.\nlet object = Object.freeze({value: 5});\nobject.value = 10;\nconsole.log(object.value);\n\/\/ \u2192 5\nWhy am I going out of my way to not change objects when the language is\nobviously expecting me to?\nBecause it helps me understand my programs. This is about complexity\nmanagement again. When the objects in my system are fixed, stable things,\nI can consider operations on them in isolation\u2014moving to Alice\u2019s house from\na given start state always produces the same new state. When objects change\nover time, that adds a whole new dimension of complexity to this kind of\nreasoning.\nFor a small system like the one we are building in this chapter, we could\nhandle that bit of extra complexity. But the most important limit on what kind\nof systems we can build is how much we can understand. Anything that makes\nyour code easier to understand makes it possible to build a more ambitious\nsystem.\nUnfortunately, although understanding a system built on persistent data\nstructures is easier, designing one, especially when your programming language\nisn\u2019t helping, can be a little harder. We\u2019ll look for opportunities to use persis-\ntent data structures in this book, but we\u2019ll also be using changeable ones.\n121 Simulation\nA delivery robot looks at the world and decides in which direction it wants\nto move. As such, we could say that a robot is a function that takes a\nVillageState object and returns the name of a nearby place.\nBecause we want robots to be able to remember things, so that they can\nmake and execute plans, we also pass them their memory and allow them to\nreturn a new memory. Thus, the thing a robot returns is an object containing\nboth the direction it wants to move in and a memory value that will be given\nback to it the next time it is called.\nfunction runRobot(state, robot, memory) {\nfor (let turn = 0;; turn++) {\nif (state.parcels.length == 0) {\nconsole.log(`Done in ${turn} turns`);\nbreak;\n}\nlet action = robot(state, memory);\nstate = state.move(action.direction);\nmemory = action.memory;\nconsole.log(`Moved to ${action.direction}`);\n}\n}\nConsider what a robot has to do to \u201csolve\u201d a given state. It must pick up\nall parcels by visiting every location that has a parcel and deliver them by\nvisiting every location that a parcel is addressed to, but only after picking up\nthe parcel.\nWhat is the dumbest strategy that could possibly work? The robot could\njust walk in a random direction every turn. That means, with great likelihood,\nit will eventually run into all parcels and then also at some point reach the\nplace where they should be delivered.\nHere\u2019s what that could look like:\nfunction randomPick(array) {\nlet choice = Math.floor(Math.random() * array.length);\nreturn array[choice];\n}\nfunction randomRobot(state) {\nreturn {direction: randomPick(roadGraph[state.place])};\n}\n122 Remember that Math.random() returns a number between zero and one\u2014but\nalways below one. Multiplying such a number by the length of an array and\nthen applying Math.floor to it gives us a random index for the array.\nSince this robot does not need to remember anything, it ignores its second\nargument (remember that JavaScript functions can be called with extra argu-\nments without ill effects) and omits the memory property in its returned object.\nTo put this sophisticated robot to work, we\u2019ll first need a way to create a\nnew state with some parcels. A static method (written here by directly adding\na property to the constructor) is a good place to put that functionality.\nVillageState.random = function(parcelCount = 5) {\nlet parcels = [];\nfor (let i = 0; i < parcelCount; i++) {\nlet address = randomPick(Object.keys(roadGraph));\nlet place;\ndo {\nplace = randomPick(Object.keys(roadGraph));\n} while (place == address);\nparcels.push({place, address});\n}\nreturn new VillageState(\"Post Office\", parcels);\n};\nWe don\u2019t want any parcels that are sent from the same place that they are\naddressed to. For this reason, the do loop keeps picking new places when it\ngets one that\u2019s equal to the address.\nLet\u2019s start up a virtual world.\nrunRobot(VillageState.random(), randomRobot);\n\/\/ \u2192 Moved to Marketplace\n\/\/ \u2192 Moved to Town Hall\n\/\/ \u2192\u2026\n\/\/ \u2192 Done in 63 turns\nIt takes the robot a lot of turns to deliver the parcels because it isn\u2019t planning\nahead very well. We\u2019ll address that soon.\n123 The mail truck's route\nWe should be able to do a lot better than the random robot. An easy improve-\nment would be to take a hint from the way real-world mail delivery works. If\nwe find a route that passes all places in the village, the robot could run that\nroute twice, at which point it is guaranteed to be done. Here is one such route\n(starting from the post o\ufb00ice):\nconst mailRoute = [\n\"Alice's House\", \"Cabin\", \"Alice's House\", \"Bob's House\",\n\"Town Hall\", \"Daria's House\", \"Ernie's House\",\n\"Grete's House\", \"Shop\", \"Grete's House\", \"Farm\",\n\"Marketplace\", \"Post Office\"\n];\nTo implement the route-following robot, we\u2019ll need to make use of robot\nmemory. The robot keeps the rest of its route in its memory and drops the\nfirst element every turn.\nfunction routeRobot(state, memory) {\nif (memory.length == 0) {\nmemory = mailRoute;\n}\nreturn {direction: memory[0], memory: memory.slice(1)};\n}\nThis robot is a lot faster already. It\u2019ll take a maximum of 26 turns (twice\nthe 13-step route) but usually less.\nPathfinding\nStill, I wouldn\u2019t really call blindly following a fixed route intelligent behavior.\nThe robot could work more e\ufb00iciently if it adjusted its behavior to the actual\nwork that needs to be done.\nTo do that, it has to be able to deliberately move toward a given parcel or\ntoward the location where a parcel has to be delivered. Doing that, even when\nthe goal is more than one move away, will require some kind of route-finding\nfunction.\nThe problem of finding a route through a graph is a typical search problem.\nWe can tell whether a given solution (a route) is a valid solution, but we can\u2019t\n124 directly compute the solution the way we could for 2 + 2. Instead, we have to\nkeep creating potential solutions until we find one that works.\nThe number of possible routes through a graph is infinite. But when search-\ning for a route from A to B, we are interested only in the ones that start at\nA. We also don\u2019t care about routes that visit the same place twice\u2014those are\ndefinitely not the most e\ufb00icient route anywhere. So that cuts down on the\nnumber of routes that the route finder has to consider.\nIn fact, we are mostly interested in the shortest route. So we want to make\nsure we look at short routes before we look at longer ones. A good approach\nwould be to \u201cgrow\u201d routes from the starting point, exploring every reachable\nplace that hasn\u2019t been visited yet, until a route reaches the goal. That way,\nwe\u2019ll only explore routes that are potentially interesting, and we\u2019ll find the\nshortest route (or one of the shortest routes, if there are more than one) to the\ngoal.\nHere is a function that does this:\nfunction findRoute(graph, from, to) {\nlet work = [{at: from, route: []}];\nfor (let i = 0; i < work.length; i++) {\nlet {at, route} = work[i];\nfor (let place of graph[at]) {\nif (place == to) return route.concat(place);\nif (!work.some(w => w.at == place)) {\nwork.push({at: place, route: route.concat(place)});\n}\n}\n}\n}\nThe exploring has to be done in the right order\u2014the places that were reached\nfirst have to be explored first. We can\u2019t immediately explore a place as soon\nas we reach it because that would mean places reached from there would also\nbe explored immediately, and so on, even though there may be other, shorter\npaths that haven\u2019t yet been explored.\nTherefore, the function keeps a work list. This is an array of places that\nshould be explored next, along with the route that got us there. It starts with\njust the start position and an empty route.\nThe search then operates by taking the next item in the list and exploring\nthat, which means all roads going from that place are looked at. If one of them\nis the goal, a finished route can be returned. Otherwise, if we haven\u2019t looked\nat this place before, a new item is added to the list. If we have looked at it\n125 before, since we are looking at short routes first, we\u2019ve found either a longer\nroute to that place or one precisely as long as the existing one, and we don\u2019t\nneed to explore it.\nYou can visually imagine this as a web of known routes crawling out from the\nstart location, growing evenly on all sides (but never tangling back into itself).\nAs soon as the first thread reaches the goal location, that thread is traced back\nto the start, giving us our route.\nOur code doesn\u2019t handle the situation where there are no more work items\non the work list because we know that our graph is connected, meaning that\nevery location can be reached from all other locations. We\u2019ll always be able to\nfind a route between two points, and the search can\u2019t fail.\nfunction goalOrientedRobot({place, parcels}, route) {\nif (route.length == 0) {\nlet parcel = parcels[0];\nif (parcel.place != place) {\nroute = findRoute(roadGraph, place, parcel.place);\n} else {\nroute = findRoute(roadGraph, place, parcel.address);\n}\n}\nreturn {direction: route[0], memory: route.slice(1)};\n}\nThis robot uses its memory value as a list of directions to move in, just like\nthe route-following robot. Whenever that list is empty, it has to figure out\nwhat to do next. It takes the first undelivered parcel in the set and, if that\nparcel hasn\u2019t been picked up yet, plots a route toward it. If the parcel has been\npicked up, it still needs to be delivered, so the robot creates a route toward the\ndelivery address instead.\nThis robot usually finishes the task of delivering 5 parcels in about 16 turns.\nThat\u2019s slightly better than routeRobot but still definitely not optimal.\nExercises\nMeasuring a robot\nIt\u2019s hard to objectively compare robots by just letting them solve a few sce-\nnarios. Maybe one robot just happened to get easier tasks or the kind of tasks\nthat it is good at, whereas the other didn\u2019t.\nWrite a function compareRobots that takes two robots (and their starting\n126 memory). It should generate 100 tasks and let each of the robots solve each\nof these tasks. When done, it should output the average number of steps each\nrobot took per task.\nFor the sake of fairness, make sure you give each task to both robots, rather\nthan generating different tasks per robot.\nRobot efficiency\nCanyouwritearobotthatfinishesthedeliverytaskfasterthangoalOrientedRobot\n? If you observe that robot\u2019s behavior, what obviously stupid things does it\ndo? How could those be improved?\nIfyousolvedthepreviousexercise, youmightwanttouseyourcompareRobots\nfunction to verify whether you improved the robot.\nPersistent group\nMost data structures provided in a standard JavaScript environment aren\u2019t\nvery well suited for persistent use. Arrays have slice and concat methods,\nwhich allow us to easily create new arrays without damaging the old one. But\nSet, for example, has no methods for creating a new set with an item added or\nremoved.\nWrite a new class PGroup, similar to the Group class from Chapter 6, which\nstores a set of values. Like Group, it has add, delete, and has methods.\nIts add method, however, should return a new PGroup instance with the given\nmember added and leave the old one unchanged. Similarly, delete creates a\nnew instance without a given member.\nThe class should work for values of any type, not just strings. It does not\nhave to be e\ufb00icient when used with large amounts of values.\nThe constructor shouldn\u2019t be part of the class\u2019s interface (though you\u2019ll def-\ninitely want to use it internally). Instead, there is an empty instance, PGroup.\nempty, that can be used as a starting value.\nWhy do you need only one PGroup.empty value, rather than having a function\nthat creates a new, empty map every time?\n127 \u201cDebugging is twice as hard as writing the code in the first place.\nTherefore, if you write the code as cleverly as possible, you are, by\ndefinition, not smart enough to debug it.\u201d\n\u2014Brian Kernighan and P.J. Plauger, The Elements of Programming\nStyle\nChapter8\nBugs and Errors\nFlaws in computer programs are usually called bugs. It makes programmers\nfeel good to imagine them as little things that just happen to crawl into our\nwork. In reality, of course, we put them there ourselves.\nIf a program is crystallized thought, you can roughly categorize bugs into\nthose caused by the thoughts being confused and those caused by mistakes\nintroduced while converting a thought to code. The former type is generally\nharder to diagnose and fix than the latter.\nLanguage\nMany mistakes could be pointed out to us automatically by the computer, if it\nknew enough about what we\u2019re trying to do. But here JavaScript\u2019s looseness\nis a hindrance. Its concept of bindings and properties is vague enough that it\nwill rarely catch typos before actually running the program. And even then,\nit allows you to do some clearly nonsensical things without complaint, such as\ncomputing true * \"monkey\".\nThere are some things that JavaScript does complain about. Writing a pro-\ngram that does not follow the language\u2019s grammar will immediately make the\ncomputer complain. Other things, such as calling something that\u2019s not a func-\ntion or looking up a property on an undefined value, will cause an error to be\nreported when the program tries to perform the action.\nBut often, your nonsense computation will merely produce NaN (not a num-\nber) or an undefined value, while the program happily continues, convinced\nthat it\u2019s doing something meaningful. The mistake will manifest itself only\nlater, after the bogus value has traveled through several functions. It might\nnot trigger an error at all but silently cause the program\u2019s output to be wrong.\nFinding the source of such problems can be di\ufb00icult.\nThe process of finding mistakes\u2014bugs\u2014in programs is called debugging.\n128 Strict mode\nJavaScript can be made a little stricter by enabling strict mode. This is done by\nputting the string \"use strict\" at the top of a file or a function body. Here\u2019s\nan example:\nfunction canYouSpotTheProblem() {\n\"use strict\";\nfor (counter = 0; counter < 10; counter++) {\nconsole.log(\"Happy happy\");\n}\n}\ncanYouSpotTheProblem();\n\/\/ \u2192 ReferenceError: counter is not defined\nNormally, when you forget to put let in front of your binding, as with\ncounter in the example, JavaScript quietly creates a global binding and uses\nthat. In strict mode, an error is reported instead. This is very helpful. It should\nbe noted, though, that this doesn\u2019t work when the binding in question already\nexists as a global binding. In that case, the loop will still quietly overwrite the\nvalue of the binding.\nAnother change in strict mode is that the this binding holds the value\nundefined in functions that are not called as methods. When making such\na call outside of strict mode, this refers to the global scope object, which is\nan object whose properties are the global bindings. So if you accidentally call\na method or constructor incorrectly in strict mode, JavaScript will produce\nan error as soon as it tries to read something from this, rather than happily\nwriting to the global scope.\nFor example, consider the following code, which calls a constructor function\nwithout the new keyword so that its this will not refer to a newly constructed\nobject:\nfunction Person(name) { this.name = name; }\nlet ferdinand = Person(\"Ferdinand\"); \/\/ oops\nconsole.log(name);\n\/\/ \u2192 Ferdinand\nSo the bogus call to Person succeeded but returned an undefined value and\ncreated the global binding name. In strict mode, the result is different.\n\"use strict\";\n129 function Person(name) { this.name = name; }\nlet ferdinand = Person(\"Ferdinand\"); \/\/ forgot new\n\/\/ \u2192 TypeError: Cannot set property 'name' of undefined\nWe are immediately told that something is wrong. This is helpful.\nFortunately, constructors created with the class notation will always com-\nplain if they are called without new, making this less of a problem even in\nnon-strict mode.\nStrict mode does a few more things. It disallows giving a function multiple\nparameters with the same name and removes certain problematic language\nfeatures entirely (such as the with statement, which is so wrong it is not further\ndiscussed in this book).\nIn short, putting \"use strict\" at the top of your program rarely hurts and\nmight help you spot a problem.\nTypes\nSome languages want to know the types of all your bindings and expressions\nbefore even running a program. They will tell you right away when a type\nis used in an inconsistent way. JavaScript considers types only when actually\nrunning the program, and even there often tries to implicitly convert values to\nthe type it expects, so it\u2019s not much help.\nStill, types provide a useful framework for talking about programs. A lot of\nmistakes come from being confused about the kind of value that goes into or\ncomes out of a function. If you have that information written down, you\u2019re less\nlikely to get confused.\nYou could add a comment like the following before the goalOrientedRobot\nfunction from the previous chapter to describe its type:\n\/\/ (VillageState, Array) \u2192 {direction: string, memory: Array}\nfunction goalOrientedRobot(state, memory) {\n\/\/ ...\n}\nThere are a number of different conventions for annotating JavaScript pro-\ngrams with types.\nOne thing about types is that they need to introduce their own complexity\nto be able to describe enough code to be useful. What do you think would be\nthe type of the randomPick function that returns a random element from an\n130 array? You\u2019d need to introduce a type variable, T, which can stand in for any\ntype, so that you can give randomPick a type like ([T])\u2192T (function from an\narray of Ts to a T).\nWhen the types of a program are known, it is possible for the computer to\ncheck them for you, pointing out mistakes before the program is run. There\nare several JavaScript dialects that add types to the language and check them.\nThe most popular one is called TypeScript. If you are interested in adding\nmore rigor to your programs, I recommend you give it a try.\nIn this book, we\u2019ll continue using raw, dangerous, untyped JavaScript code.\nTesting\nIf the language is not going to do much to help us find mistakes, we\u2019ll have to\nfind them the hard way: by running the program and seeing whether it does\nthe right thing.\nDoing this by hand, again and again, is a really bad idea. Not only is\nit annoying, it also tends to be ineffective since it takes too much time to\nexhaustively test everything every time you make a change.\nComputers are good at repetitive tasks, and testing is the ideal repetitive\ntask. Automated testing is the process of writing a program that tests another\nprogram. Writing tests is a bit more work than testing manually, but once\nyou\u2019ve done it, you gain a kind of superpower: it takes you only a few seconds\nto verify that your program still behaves properly in all the situations you\nwrote tests for. When you break something, you\u2019ll immediately notice, rather\nthan randomly running into it at some later time.\nTests usually take the form of little labeled programs that verify some aspect\nof your code. For example, a set of tests for the (standard, probably already\ntested by someone else) toUpperCase method might look like this:\nfunction test(label, body) {\nif (!body()) console.log(`Failed: ${label}`);\n}\ntest(\"convert Latin text to uppercase\", () => {\nreturn \"hello\".toUpperCase() == \"HELLO\";\n});\ntest(\"convert Greek text to uppercase\", () => {\nreturn \"\u03a7\u03b1\u03af\u03c1\u03b5\u03c4\u03b5\".toUpperCase() == \"\u03a7\u0391\u038a\u03a1\u0395\u03a4\u0395\";\n});\ntest(\"don't convert case-less characters\", () => {\nreturn \" \".toUpperCase() == \" \";\n\u0627\u0628\u062d\u0631\u0645 \u0627\u0628\u062d\u0631\u0645\n131 });\nWriting tests like this tends to produce rather repetitive, awkward code. For-\ntunately, there exist pieces of software that help you build and run collections\nof tests (test suites) by providing a language (in the form of functions and\nmethods) suited to expressing tests and by outputting informative information\nwhen a test fails. These are usually called test runners.\nSome code is easier to test than other code. Generally, the more external\nobjects that the code interacts with, the harder it is to set up the context in\nwhich to test it. The style of programming shown in the previous chapter,\nwhich uses self-contained persistent values rather than changing objects, tends\nto be easy to test.\nDebugging\nOnce you notice there is something wrong with your program because it mis-\nbehaves or produces errors, the next step is to figure out what the problem\nis.\nSometimes it is obvious. The error message will point at a specific line of\nyour program, and if you look at the error description and that line of code,\nyou can often see the problem.\nBut not always. Sometimes the line that triggered the problem is simply the\nfirst place where a flaky value produced elsewhere gets used in an invalid way.\nIf you have been solving the exercises in earlier chapters, you will probably\nhave already experienced such situations.\nThe following example program tries to convert a whole number to a string\nin a given base (decimal, binary, and so on) by repeatedly picking out the last\ndigit and then dividing the number to get rid of this digit. But the strange\noutput that it currently produces suggests that it has a bug.\nfunction numberToString(n, base = 10) {\nlet result = \"\", sign = \"\";\nif (n < 0) {\nsign = \"-\";\nn = -n;\n}\ndo {\nresult = String(n % base) + result;\nn \/= base;\n} while (n > 0);\nreturn sign + result;\n132 }\nconsole.log(numberToString(13, 10));\n\/\/ \u2192 1.5e-3231.3e-3221.3e-3211.3e-3201.3e-3191.3e\u2026-3181.3\nEven if you see the problem already, pretend for a moment that you don\u2019t.\nWe know that our program is malfunctioning, and we want to find out why.\nThis is where you must resist the urge to start making random changes to\nthe code to see whether that makes it better. Instead, think. Analyze what is\nhappening and come up with a theory of why it might be happening. Then,\nmake additional observations to test this theory\u2014or, if you don\u2019t yet have a\ntheory, make additional observations to help you come up with one.\nPutting a few strategic console.log calls into the program is a good way to\nget additional information about what the program is doing. In this case, we\nwant n to take the values 13, 1, and then 0. Let\u2019s write out its value at the\nstart of the loop.\n13\n1.3\n0.13\n0.013\u2026\n1.5e-323\nRight. Dividing 13 by 10 does not produce a whole number. Instead of n \/=\nbase, what we actually want is n = Math.floor(n \/ base) so that the number\nis properly \u201cshifted\u201d to the right.\nAn alternative to using console.log to peek into the program\u2019s behavior is to\nuse the debugger capabilities of your browser. Browsers come with the ability\nto set a breakpoint on a specific line of your code. When the execution of the\nprogram reaches a line with a breakpoint, it is paused, and you can inspect the\nvalues of bindings at that point. I won\u2019t go into details, as debuggers differ\nfrom browser to browser, but look in your browser\u2019s developer tools or search\nthe Web for more information.\nAnother way to set a breakpoint is to include a debugger statement (con-\nsisting of simply that keyword) in your program. If the developer tools of\nyour browser are active, the program will pause whenever it reaches such a\nstatement.\n133 Error propagation\nNot all problems can be prevented by the programmer, unfortunately. If your\nprogram communicates with the outside world in any way, it is possible to get\nmalformed input, to become overloaded with work, or to have the network fail.\nIf you\u2019re programming only for yourself, you can afford to just ignore such\nproblems until they occur. But if you build something that is going to be used\nby anybody else, you usually want the program to do better than just crash.\nSometimes the right thing to do is take the bad input in stride and continue\nrunning. In other cases, it is better to report to the user what went wrong and\nthen give up. But in either situation, the program has to actively do something\nin response to the problem.\nSay you have a function promptNumber that asks the user for a number and\nreturns it. What should it return if the user inputs \u201corange\u201d?\nOne option is to make it return a special value. Common choices for such\nvalues are null, undefined, or -1.\nfunction promptNumber(question) {\nlet result = Number(prompt(question));\nif (Number.isNaN(result)) return null;\nelse return result;\n}\nconsole.log(promptNumber(\"How many trees do you see?\"));\nNow any code that calls promptNumber must check whether an actual number\nwas read and, failing that, must somehow recover\u2014maybe by asking again or\nby filling in a default value. Or it could again return a special value to its caller\nto indicate that it failed to do what it was asked.\nIn many situations, mostly when errors are common and the caller should\nbe explicitly taking them into account, returning a special value is a good way\nto indicate an error. It does, however, have its downsides. First, what if the\nfunction can already return every possible kind of value? In such a function,\nyou\u2019ll have to do something like wrap the result in an object to be able to\ndistinguish success from failure.\nfunction lastElement(array) {\nif (array.length == 0) {\nreturn {failed: true};\n} else {\nreturn {element: array[array.length - 1]};\n}\n134 }\nThe second issue with returning special values is that it can lead to awkward\ncode. If a piece of code calls promptNumber 10 times, it has to check 10 times\nwhether null was returned. And if its response to finding null is to simply\nreturn null itself, callers of the function will in turn have to check for it, and\nso on.\nExceptions\nWhen a function cannot proceed normally, what we would like to do is just\nstop what we are doing and immediately jump to a place that knows how to\nhandle the problem. This is what exception handling does.\nExceptions are a mechanism that makes it possible for code that runs into\na problem to raise (or throw) an exception. An exception can be any value.\nRaising one somewhat resembles a super-charged return from a function: it\njumps out of not just the current function but also its callers, all the way down\nto the first call that started the current execution. This is called unwinding\nthe stack. You may remember the stack of function calls that was mentioned\nin Chapter 3. An exception zooms down this stack, throwing away all the call\ncontexts it encounters.\nIf exceptions always zoomed right down to the bottom of the stack, they\nwould not be of much use. They\u2019d just provide a novel way to blow up your\nprogram. Their power lies in the fact that you can set \u201cobstacles\u201d along the\nstack to catch the exception as it is zooming down. Once you\u2019ve caught an\nexception, you can do something with it to address the problem and then\ncontinue to run the program.\nHere\u2019s an example:\nfunction promptDirection(question) {\nlet result = prompt(question);\nif (result.toLowerCase() == \"left\") return \"L\";\nif (result.toLowerCase() == \"right\") return \"R\";\nthrow new Error(\"Invalid direction: \" + result);\n}\nfunction look() {\nif (promptDirection(\"Which way?\") == \"L\") {\nreturn \"a house\";\n} else {\nreturn \"two angry bears\";\n135 }\n}\ntry {\nconsole.log(\"You see\", look());\n} catch (error) {\nconsole.log(\"Something went wrong: \" + error);\n}\nThe throw keyword is used to raise an exception. Catching one is done by\nwrapping a piece of code in a try block, followed by the keyword catch. When\nthe code in the try block causes an exception to be raised, the catch block is\nevaluated, with the name in parentheses bound to the exception value. After\nthe catch block finishes\u2014or if the try block finishes without problems\u2014the\nprogram proceeds beneath the entire try\/catch statement.\nIn this case, we used the Error constructor to create our exception value.\nThis is a standard JavaScript constructor that creates an object with a message\nproperty. In most JavaScript environments, instances of this constructor also\ngather information about the call stack that existed when the exception was\ncreated, a so-called stack trace. This information is stored in the stack property\nand can be helpful when trying to debug a problem: it tells us the function\nwhere the problem occurred and which functions made the failing call.\nNotethatthelookfunctioncompletelyignoresthepossibilitythatpromptDirection\nmight go wrong. This is the big advantage of exceptions: error-handling code\nis necessary only at the point where the error occurs and at the point where it\nis handled. The functions in between can forget all about it.\nWell, almost...\nCleaning up after exceptions\nThe effect of an exception is another kind of control flow. Every action that\nmightcauseanexception, whichisprettymucheveryfunctioncallandproperty\naccess, might cause control to suddenly leave your code.\nThis means when code has several side effects, even if its \u201cregular\u201d control\nflow looks like they\u2019ll always all happen, an exception might prevent some of\nthem from taking place.\nHere is some really bad banking code.\nconst accounts = {\na: 100,\n136 b: 0,\nc: 20\n};\nfunction getAccount() {\nlet accountName = prompt(\"Enter an account name\");\nif (!accounts.hasOwnProperty(accountName)) {\nthrow new Error(`No such account: ${accountName}`);\n}\nreturn accountName;\n}\nfunction transfer(from, amount) {\nif (accounts[from] < amount) return;\naccounts[from] -= amount;\naccounts[getAccount()] += amount;\n}\nThe transfer function transfers a sum of money from a given account to\nanother, asking for the name of the other account in the process. If given an\ninvalid account name, getAccount throws an exception.\nBut transfer first removes the money from the account and then calls\ngetAccount before it adds it to another account. If it is broken off by an\nexception at that point, it\u2019ll just make the money disappear.\nThat code could have been written a little more intelligently, for example by\ncalling getAccount before it starts moving money around. But often problems\nlike this occur in more subtle ways. Even functions that don\u2019t look like they\nwill throw an exception might do so in exceptional circumstances or when they\ncontain a programmer mistake.\nOne way to address this is to use fewer side effects. Again, a programming\nstyle that computes new values instead of changing existing data helps. If a\npiece of code stops running in the middle of creating a new value, no one ever\nsees the half-finished value, and there is no problem.\nBut that isn\u2019t always practical. So there is another feature that try state-\nments have. They may be followed by a finally block either instead of or in\naddition to a catch block. A finally block says \u201cno matter what happens, run\nthis code after trying to run the code in the try block.\u201d\nfunction transfer(from, amount) {\nif (accounts[from] < amount) return;\nlet progress = 0;\ntry {\n137 accounts[from] -= amount;\nprogress = 1;\naccounts[getAccount()] += amount;\nprogress = 2;\n} finally {\nif (progress == 1) {\naccounts[from] += amount;\n}\n}\n}\nThisversionofthefunctiontracksitsprogress, andif, whenleaving, itnotices\nthat it was aborted at a point where it had created an inconsistent program\nstate, it repairs the damage it did.\nNote that even though the finally code is run when an exception is thrown\nin the try block, it does not interfere with the exception. After the finally\nblock runs, the stack continues unwinding.\nWriting programs that operate reliably even when exceptions pop up in un-\nexpected places is hard. Many people simply don\u2019t bother, and because ex-\nceptions are typically reserved for exceptional circumstances, the problem may\noccur so rarely that it is never even noticed. Whether that is a good thing or\na really bad thing depends on how much damage the software will do when it\nfails.\nSelective catching\nWhen an exception makes it all the way to the bottom of the stack without\nbeing caught, it gets handled by the environment. What this means differs\nbetween environments. In browsers, a description of the error typically gets\nwritten to the JavaScript console (reachable through the browser\u2019s Tools or\nDeveloper menu). Node.js, the browserless JavaScript environment we will\ndiscuss in Chapter 20, is more careful about data corruption. It aborts the\nwhole process when an unhandled exception occurs.\nFor programmer mistakes, just letting the error go through is often the best\nyou can do. An unhandled exception is a reasonable way to signal a broken\nprogram, and the JavaScript console will, on modern browsers, provide you\nwith some information about which function calls were on the stack when the\nproblem occurred.\nFor problems that are expected to happen during routine use, crashing with\nan unhandled exception is a terrible strategy.\n138 Invalid uses of the language, such as referencing a nonexistent binding, look-\ning up a property on null, or calling something that\u2019s not a function, will also\nresult in exceptions being raised. Such exceptions can also be caught.\nWhen a catch body is entered, all we know is that something in our try\nbody caused an exception. But we don\u2019t know what did or which exception it\ncaused.\nJavaScript (in a rather glaring omission) doesn\u2019t provide direct support for\nselectively catching exceptions: either you catch them all or you don\u2019t catch\nany. This makes it tempting to assume that the exception you get is the one\nyou were thinking about when you wrote the catch block.\nBut it might not be. Some other assumption might be violated, or you might\nhave introduced a bug that is causing an exception. Here is an example that\nattempts to keep on calling promptDirection until it gets a valid answer:\nfor (;;) {\ntry {\nlet dir = promtDirection(\"Where?\"); \/\/ \u2190 typo!\nconsole.log(\"You chose \", dir);\nbreak;\n} catch (e) {\nconsole.log(\"Not a valid direction. Try again.\");\n}\n}\nThe for (;;) construct is a way to intentionally create a loop that doesn\u2019t\nterminate on its own. We break out of the loop only when a valid direction is\ngiven. But we misspelled promptDirection, which will result in an \u201cundefined\nvariable\u201d error. Because the catch block completely ignores its exception value\n(e), assuming it knows what the problem is, it wrongly treats the binding error\nas indicating bad input. Not only does this cause an infinite loop, it \u201cburies\u201d\nthe useful error message about the misspelled binding.\nAs a general rule, don\u2019t blanket-catch exceptions unless it is for the purpose\nof \u201crouting\u201d them somewhere\u2014for example, over the network to tell another\nsystem that our program crashed. And even then, think carefully about how\nyou might be hiding information.\nSo we want to catch a specific kind of exception. We can do this by checking\nin the catch block whether the exception we got is the one we are interested\nin and rethrowing it otherwise. But how do we recognize an exception?\nWe could compare its message property against the error message we happen\nto expect. But that\u2019s a shaky way to write code\u2014we\u2019d be using information\nthat\u2019s intended for human consumption (the message) to make a programmatic\n139 decision. As soon as someone changes (or translates) the message, the code will\nstop working.\nRather, let\u2019s define a new type of error and use instanceof to identify it.\nclass InputError extends Error {}\nfunction promptDirection(question) {\nlet result = prompt(question);\nif (result.toLowerCase() == \"left\") return \"L\";\nif (result.toLowerCase() == \"right\") return \"R\";\nthrow new InputError(\"Invalid direction: \" + result);\n}\nThe new error class extends Error. It doesn\u2019t define its own constructor,\nwhich means that it inherits the Error constructor, which expects a string\nmessage as argument. In fact, it doesn\u2019t define anything at all\u2014the class is\nempty. InputError objects behave like Error objects, except that they have a\ndifferent class by which we can recognize them.\nNow the loop can catch these more carefully.\nfor (;;) {\ntry {\nlet dir = promptDirection(\"Where?\");\nconsole.log(\"You chose \", dir);\nbreak;\n} catch (e) {\nif (e instanceof InputError) {\nconsole.log(\"Not a valid direction. Try again.\");\n} else {\nthrow e;\n}\n}\n}\nThis will catch only instances of InputError and let unrelated exceptions\nthrough. If you reintroduce the typo, the undefined binding error will be prop-\nerly reported.\nAssertions\nAssertions are checks inside a program that verify that something is the way\nit is supposed to be. They are used not to handle situations that can come up\n140 in normal operation but to find programmer mistakes.\nIf, for example, firstElement is described as a function that should never be\ncalled on empty arrays, we might write it like this:\nfunction firstElement(array) {\nif (array.length == 0) {\nthrow new Error(\"firstElement called with []\");\n}\nreturn array[0];\n}\nNow, instead of silently returning undefined (which you get when reading\nan array property that does not exist), this will loudly blow up your program\nas soon as you misuse it. This makes it less likely for such mistakes to go\nunnoticed and easier to find their cause when they occur.\nI do not recommend trying to write assertions for every possible kind of bad\ninput. That\u2019d be a lot of work and would lead to very noisy code. You\u2019ll want\nto reserve them for mistakes that are easy to make (or that you find yourself\nmaking).\nSummary\nMistakes and bad input are facts of life. An important part of programming is\nfinding, diagnosing, and fixing bugs. Problems can become easier to notice if\nyou have an automated test suite or add assertions to your programs.\nProblems caused by factors outside the program\u2019s control should usually\nbe handled gracefully. Sometimes, when the problem can be handled locally,\nspecial return values are a good way to track them. Otherwise, exceptions may\nbe preferable.\nThrowing an exception causes the call stack to be unwound until the next\nenclosing try\/catch block or until the bottom of the stack. The exception\nvalue will be given to the catch block that catches it, which should verify that\nit is actually the expected kind of exception and then do something with it.\nTo help address the unpredictable control flow caused by exceptions, finally\nblocks can be used to ensure that a piece of code always runs when a block\nfinishes.\n141 Exercises\nRetry\nSay you have a function primitiveMultiply that in 20 percent of cases mul-\ntiplies two numbers and in the other 80 percent of cases raises an exception\nof type MultiplicatorUnitFailure. Write a function that wraps this clunky\nfunction and just keeps trying until a call succeeds, after which it returns the\nresult.\nMake sure you handle only the exceptions you are trying to handle.\nThe locked box\nConsider the following (rather contrived) object:\nconst box = {\nlocked: true,\nunlock() { this.locked = false; },\nlock() { this.locked = true; },\n_content: [],\nget content() {\nif (this.locked) throw new Error(\"Locked!\");\nreturn this._content;\n}\n};\nIt is a box with a lock. There is an array in the box, but you can get at it only\nwhen the box is unlocked. Directly accessing the private _content property is\nforbidden.\nWrite a function called withBoxUnlocked that takes a function value as ar-\ngument, unlocks the box, runs the function, and then ensures that the box\nis locked again before returning, regardless of whether the argument function\nreturned normally or threw an exception.\nFor extra points, make sure that if you call withBoxUnlocked when the box\nis already unlocked, the box stays unlocked.\n142 \u201cSome people, when confronted with a problem, think \u2018I know, I\u2019ll\nuse regular expressions.\u2019 Now they have two problems.\u201d\n\u2014Jamie Zawinski\nChapter9\nRegular Expressions\nProgrammingtoolsandtechniquessurviveandspreadinachaotic, evolutionary\nway. It\u2019s not always the pretty or brilliant ones that win but rather the ones\nthat function well enough within the right niche or that happen to be integrated\nwith another successful piece of technology.\nIn this chapter, I will discuss one such tool, regular expressions. Regular\nexpressions are a way to describe patterns in string data. They form a small,\nseparate language that is part of JavaScript and many other languages and\nsystems.\nRegular expressions are both terribly awkward and extremely useful. Their\nsyntax is cryptic, and the programming interface JavaScript provides for them\nis clumsy. But they are a powerful tool for inspecting and processing strings.\nProperly understanding regular expressions will make you a more effective pro-\ngrammer.\nCreating a regular expression\nA regular expression is a type of object. It can be either constructed with\nthe RegExp constructor or written as a literal value by enclosing a pattern in\nforward slash (\/) characters.\nlet re1 = new RegExp(\"abc\");\nlet re2 = \/abc\/;\nBoth of those regular expression objects represent the same pattern: an a\ncharacter followed by a b followed by a c.\nWhen using the RegExp constructor, the pattern is written as a normal string,\nso the usual rules apply for backslashes.\nThe second notation, where the pattern appears between slash characters,\ntreats backslashes somewhat differently. First, since a forward slash ends the\npattern, we need to put a backslash before any forward slash that we want\n143 to be part of the pattern. In addition, backslashes that aren\u2019t part of special\ncharacter codes (like \\n) will be preserved, rather than ignored as they are\nin strings, and change the meaning of the pattern. Some characters, such as\nquestion marks and plus signs, have special meanings in regular expressions and\nmust be preceded by a backslash if they are meant to represent the character\nitself.\nlet eighteenPlus = \/eighteen\\+\/;\nTesting for matches\nRegular expression objects have a number of methods. The simplest one is\ntest. If you pass it a string, it will return a Boolean telling you whether the\nstring contains a match of the pattern in the expression.\nconsole.log(\/abc\/.test(\"abcde\"));\n\/\/ \u2192 true\nconsole.log(\/abc\/.test(\"abxde\"));\n\/\/ \u2192 false\nA regular expression consisting of only nonspecial characters simply repre-\nsents that sequence of characters. If abc occurs anywhere in the string we are\ntesting against (not just at the start), test will return true.\nSets of characters\nFinding out whether a string contains abc could just as well be done with a call\nto indexOf. Regular expressions allow us to express more complicated patterns.\nSay we want to match any number. In a regular expression, putting a set\nof characters between square brackets makes that part of the expression match\nany of the characters between the brackets.\nBoth of the following expressions match all strings that contain a digit:\nconsole.log(\/[0123456789]\/.test(\"in 1992\"));\n\/\/ \u2192 true\nconsole.log(\/[0-9]\/.test(\"in 1992\"));\n\/\/ \u2192 true\n144 Within square brackets, a hyphen (-) between two characters can be used\nto indicate a range of characters, where the ordering is determined by the\ncharacter\u2019s Unicode number. Characters 0 to 9 sit right next to each other in\nthis ordering (codes 48 to 57), so [0-9] covers all of them and matches any\ndigit.\nA number of common character groups have their own built-in shortcuts.\nDigits are one of them: \\d means the same thing as [0-9].\n\\d Any digit character\n\\w An alphanumeric character (\u201cword character\u201d)\n\\s Any whitespace character (space, tab, newline, and similar)\n\\D A character that is not a digit\n\\W A nonalphanumeric character\n\\S A nonwhitespace character\n. Any character except for newline\nSo you could match a date and time format like 01-30-2003 15:20 with the\nfollowing expression:\nlet dateTime = \/\\d\\d-\\d\\d-\\d\\d\\d\\d \\d\\d:\\d\\d\/;\nconsole.log(dateTime.test(\"01-30-2003 15:20\"));\n\/\/ \u2192 true\nconsole.log(dateTime.test(\"30-jan-2003 15:20\"));\n\/\/ \u2192 false\nThat looks completely awful, doesn\u2019t it? Half of it is backslashes, producing\na background noise that makes it hard to spot the actual pattern expressed.\nWe\u2019ll see a slightly improved version of this expression later.\nThese backslash codes can also be used inside square brackets. For example,\n[\\d.] means any digit or a period character. But the period itself, between\nsquare brackets, loses its special meaning. The same goes for other special\ncharacters, such as +.\nTo invert a set of characters\u2014that is, to express that you want to match any\ncharacter except the ones in the set\u2014you can write a caret (^) character after\nthe opening bracket.\nlet notBinary = \/[^01]\/;\nconsole.log(notBinary.test(\"1100100010100110\"));\n\/\/ \u2192 false\nconsole.log(notBinary.test(\"1100100010200110\"));\n\/\/ \u2192 true\n145 Repeating parts of a pattern\nWe now know how to match a single digit. What if we want to match a whole\nnumber\u2014a sequence of one or more digits?\nWhen you put a plus sign (+) after something in a regular expression, it\nindicates that the element may be repeated more than once. Thus, \/\\d+\/\nmatches one or more digit characters.\nconsole.log(\/'\\d+'\/.test(\"'123'\"));\n\/\/ \u2192 true\nconsole.log(\/'\\d+'\/.test(\"''\"));\n\/\/ \u2192 false\nconsole.log(\/'\\d*'\/.test(\"'123'\"));\n\/\/ \u2192 true\nconsole.log(\/'\\d*'\/.test(\"''\"));\n\/\/ \u2192 true\nThe star (*) has a similar meaning but also allows the pattern to match zero\ntimes. Something with a star after it never prevents a pattern from matching\u2014\nit\u2019ll just match zero instances if it can\u2019t find any suitable text to match.\nA question mark makes a part of a pattern optional, meaning it may occur\nzero times or one time. In the following example, the u character is allowed to\noccur, but the pattern also matches when it is missing.\nlet neighbor = \/neighbou?r\/;\nconsole.log(neighbor.test(\"neighbour\"));\n\/\/ \u2192 true\nconsole.log(neighbor.test(\"neighbor\"));\n\/\/ \u2192 true\nTo indicate that a pattern should occur a precise number of times, use braces.\nPutting {4} after an element, for example, requires it to occur exactly four\ntimes. It is also possible to specify a range this way: {2,4} means the element\nmust occur at least twice and at most four times.\nHere is another version of the date and time pattern that allows both single-\nand double-digit days, months, and hours. It is also slightly easier to decipher.\nlet dateTime = \/\\d{1,2}-\\d{1,2}-\\d{4} \\d{1,2}:\\d{2}\/;\nconsole.log(dateTime.test(\"1-30-2003 8:45\"));\n\/\/ \u2192 true\n146 You can also specify open-ended ranges when using braces by omitting the\nnumber after the comma. So, {5,} means five or more times.\nGrouping subexpressions\nTo use an operator like * or + on more than one element at a time, you have to\nuse parentheses. A part of a regular expression that is enclosed in parentheses\ncounts as a single element as far as the operators following it are concerned.\nlet cartoonCrying = \/boo+(hoo+)+\/i;\nconsole.log(cartoonCrying.test(\"Boohoooohoohooo\"));\n\/\/ \u2192 true\nThe first and second + characters apply only to the second o in boo and hoo,\nrespectively. The third + applies to the whole group (hoo+), matching one or\nmore sequences like that.\nThe i at the end of the expression in the example makes this regular expres-\nsion case insensitive, allowing it to match the uppercase B in the input string,\neven though the pattern is itself all lowercase.\nMatches and groups\nThe test method is the absolute simplest way to match a regular expression.\nIt tells you only whether it matched and nothing else. Regular expressions also\nhave an exec (execute) method that will return null if no match was found\nand return an object with information about the match otherwise.\nlet match = \/\\d+\/.exec(\"one two 100\");\nconsole.log(match);\n\/\/ \u2192 [\"100\"]\nconsole.log(match.index);\n\/\/ \u2192 8\nAn object returned from exec has an index property that tells us where in\nthe string the successful match begins. Other than that, the object looks like\n(and in fact is) an array of strings, whose first element is the string that was\nmatched. In the previous example, this is the sequence of digits that we were\nlooking for.\nString values have a match method that behaves similarly.\n147 console.log(\"one two 100\".match(\/\\d+\/));\n\/\/ \u2192 [\"100\"]\nWhen the regular expression contains subexpressions grouped with paren-\ntheses, the text that matched those groups will also show up in the array.\nThe whole match is always the first element. The next element is the part\nmatched by the first group (the one whose opening parenthesis comes first in\nthe expression), then the second group, and so on.\nlet quotedText = \/'([^']*)'\/;\nconsole.log(quotedText.exec(\"she said 'hello'\"));\n\/\/ \u2192 [\"'hello'\", \"hello\"]\nWhen a group does not end up being matched at all (for example, when fol-\nlowed by a question mark), its position in the output array will hold undefined.\nSimilarly, when a group is matched multiple times, only the last match ends\nup in the array.\nconsole.log(\/bad(ly)?\/.exec(\"bad\"));\n\/\/ \u2192 [\"bad\", undefined]\nconsole.log(\/(\\d)+\/.exec(\"123\"));\n\/\/ \u2192 [\"123\", \"3\"]\nGroups can be useful for extracting parts of a string. If we don\u2019t just want\nto verify whether a string contains a date but also extract it and construct an\nobject that represents it, we can wrap parentheses around the digit patterns\nand directly pick the date out of the result of exec.\nBut first we\u2019ll take a brief detour, in which we discuss the built-in way to\nrepresent date and time values in JavaScript.\nThe Date class\nJavaScript has a standard class for representing dates\u2014or, rather, points in\ntime. It is called Date. If you simply create a date object using new, you get\nthe current date and time.\nconsole.log(new Date());\n\/\/ \u2192 Mon Nov 13 2017 16:19:11 GMT+0100 (CET)\nYou can also create an object for a specific time.\n148 console.log(new Date(2009, 11, 9));\n\/\/ \u2192 Wed Dec 09 2009 00:00:00 GMT+0100 (CET)\nconsole.log(new Date(2009, 11, 9, 12, 59, 59, 999));\n\/\/ \u2192 Wed Dec 09 2009 12:59:59 GMT+0100 (CET)\nJavaScript uses a convention where month numbers start at zero (so De-\ncember is 11), yet day numbers start at one. This is confusing and silly. Be\ncareful.\nThe last four arguments (hours, minutes, seconds, and milliseconds) are op-\ntional and taken to be zero when not given.\nTimestamps are stored as the number of milliseconds since the start of 1970,\nin the UTC time zone. This follows a convention set by \u201cUnix time\u201d, which\nwas invented around that time. You can use negative numbers for times before\n1970. The getTime method on a date object returns this number. It is big, as\nyou can imagine.\nconsole.log(new Date(2013, 11, 19).getTime());\n\/\/ \u2192 1387407600000\nconsole.log(new Date(1387407600000));\n\/\/ \u2192 Thu Dec 19 2013 00:00:00 GMT+0100 (CET)\nIf you give the Date constructor a single argument, that argument is treated\nas such a millisecond count. You can get the current millisecond count by\ncreating a new Date object and calling getTime on it or by calling the Date.now\nfunction.\nDateobjectsprovidemethodssuchasgetFullYear, getMonth, getDate, getHours\n, getMinutes, andgetSecondstoextracttheircomponents. BesidesgetFullYear\nthere\u2019s also getYear, which gives you the year minus 1900 (98 or 119) and is\nmostly useless.\nPutting parentheses around the parts of the expression that we are interested\nin, we can now create a date object from a string.\nfunction getDate(string) {\nlet [_, month, day, year] =\n\/(\\d{1,2})-(\\d{1,2})-(\\d{4})\/.exec(string);\nreturn new Date(year, month - 1, day);\n}\nconsole.log(getDate(\"1-30-2003\"));\n\/\/ \u2192 Thu Jan 30 2003 00:00:00 GMT+0100 (CET)\n149 The _ (underscore) binding is ignored and used only to skip the full match\nelement in the array returned by exec.\nWord and string boundaries\nUnfortunately, getDate will also happily extract the nonsensical date 00-1-3000\nfrom the string \"100-1-30000\". A match may happen anywhere in the string, so\nin this case, it\u2019ll just start at the second character and end at the second-to-last\ncharacter.\nIf we want to enforce that the match must span the whole string, we can add\nthe markers ^ and $. The caret matches the start of the input string, whereas\nthedollarsignmatchestheend. So, \/^\\d+$\/matchesastringconsistingentirely\nof one or more digits, \/^!\/ matches any string that starts with an exclamation\nmark, and \/x^\/ does not match any string (there cannot be an x before the\nstart of the string).\nIf, on the other hand, we just want to make sure the date starts and ends\non a word boundary, we can use the marker \\b. A word boundary can be the\nstart or end of the string or any point in the string that has a word character\n(as in \\w) on one side and a nonword character on the other.\nconsole.log(\/cat\/.test(\"concatenate\"));\n\/\/ \u2192 true\nconsole.log(\/\\bcat\\b\/.test(\"concatenate\"));\n\/\/ \u2192 false\nNote that a boundary marker doesn\u2019t match an actual character. It just\nenforces that the regular expression matches only when a certain condition\nholds at the place where it appears in the pattern.\nChoice patterns\nSay we want to know whether a piece of text contains not only a number but a\nnumber followed by one of the words pig, cow, or chicken, or any of their plural\nforms.\nWe could write three regular expressions and test them in turn, but there is\na nicer way. The pipe character (|) denotes a choice between the pattern to its\nleft and the pattern to its right. So I can say this:\nlet animalCount = \/\\b\\d+ (pig|cow|chicken)s?\\b\/;\nconsole.log(animalCount.test(\"15 pigs\"));\n150 \/\/ \u2192 true\nconsole.log(animalCount.test(\"15 pigchickens\"));\n\/\/ \u2192 false\nParenthesescanbeusedtolimitthepartofthepatternthatthepipeoperator\nappliesto, andyoucanputmultiplesuchoperatorsnexttoeachothertoexpress\na choice between more than two alternatives.\nThe mechanics of matching\nConceptually, when you use exec or test, the regular expression engine looks\nfor a match in your string by trying to match the expression first from the start\nof the string, then from the second character, and so on, until it finds a match\nor reaches the end of the string. It\u2019ll either return the first match that can be\nfound or fail to find any match at all.\nTo do the actual matching, the engine treats a regular expression something\nlike a flow diagram. This is the diagram for the livestock expression in the\nprevious example:\nGroup #1\n\"pig\"\nboundary digit \" \" \"cow\" \"s\" boundary\n\"chicken\"\nOur expression matches if we can find a path from the left side of the diagram\nto the right side. We keep a current position in the string, and every time we\nmove through a box, we verify that the part of the string after our current\nposition matches that box.\nSo if we try to match \"the 3 pigs\" from position 4, our progress through\nthe flow chart would look like this:\n\u2022 At position 4, there is a word boundary, so we can move past the first\nbox.\n\u2022 Still at position 4, we find a digit, so we can also move past the second\nbox.\n\u2022 At position 5, one path loops back to before the second (digit) box,\nwhile the other moves forward through the box that holds a single space\n151 character. There is a space here, not a digit, so we must take the second\npath.\n\u2022 We are now at position 6 (the start of pigs) and at the three-way branch\nin the diagram. We don\u2019t see cow or chicken here, but we do see pig, so\nwe take that branch.\n\u2022 At position 9, after the three-way branch, one path skips the s box and\ngoes straight to the final word boundary, while the other path matches an\ns. There is an s character here, not a word boundary, so we go through\nthe s box.\n\u2022 We\u2019re at position 10 (the end of the string) and can match only a word\nboundary. The end of a string counts as a word boundary, so we go\nthrough the last box and have successfully matched this string.\nBacktracking\nThe regular expression \/\\b([01]+b|[\\da-f]+h|\\d+)\\b\/ matches either a binary\nnumber followed by a b, a hexadecimal number (that is, base 16, with the letters\na to f standing for the digits 10 to 15) followed by an h, or a regular decimal\nnumber with no su\ufb00ix character. This is the corresponding diagram:\ngroup #1\nOne of:\n\u201c0\u201d\n\u201cb\u201d\n\u201c1\u201d\nOne of:\nword boundary word boundary\ndigit\n\u201ch\u201d\n\u201ca\u201d - \u201cf\u201d\ndigit\nWhen matching this expression, it will often happen that the top (binary)\nbranch is entered even though the input does not actually contain a binary\nnumber. When matching the string \"103\", for example, it becomes clear only\nat the 3 that we are in the wrong branch. The string does match the expression,\njust not the branch we are currently in.\n152 So the matcher backtracks. When entering a branch, it remembers its current\nposition (in this case, at the start of the string, just past the first boundary box\nin the diagram) so that it can go back and try another branch if the current one\ndoes not work out. For the string \"103\", after encountering the 3 character, it\nwill start trying the branch for hexadecimal numbers, which fails again because\nthere is no h after the number. So it tries the decimal number branch. This\none fits, and a match is reported after all.\nThe matcher stops as soon as it finds a full match. This means that if\nmultiple branches could potentially match a string, only the first one (ordered\nby where the branches appear in the regular expression) is used.\nBacktracking also happens for repetition operators like + and *. If you\nmatch \/^.*x\/ against \"abcxe\", the .* part will first try to consume the whole\nstring. The engine will then realize that it needs an x to match the pattern.\nSince there is no x past the end of the string, the star operator tries to match\none character less. But the matcher doesn\u2019t find an x after abcx either, so it\nbacktracks again, matching the star operator to just abc. Now it finds an x\nwhere it needs it and reports a successful match from positions 0 to 4.\nIt is possible to write regular expressions that will do a lot of backtracking.\nThis problem occurs when a pattern can match a piece of input in many dif-\nferent ways. For example, if we get confused while writing a binary-number\nregular expression, we might accidentally write something like \/([01]+)+b\/.\nGroup #1\nOne of:\n\"0\"\n\"b\"\n\"1\"\nIf that tries to match some long series of zeros and ones with no trailing b\ncharacter, the matcher first goes through the inner loop until it runs out of\ndigits. Then it notices there is no b, so it backtracks one position, goes through\nthe outer loop once, and gives up again, trying to backtrack out of the inner\nloop once more. It will continue to try every possible route through these two\nloops. This means the amount of work doubles with each additional character.\nFor even just a few dozen characters, the resulting match will take practically\nforever.\n153 The replace method\nString values have a replace method that can be used to replace part of the\nstring with another string.\nconsole.log(\"papa\".replace(\"p\", \"m\"));\n\/\/ \u2192 mapa\nThe first argument can also be a regular expression, in which case the first\nmatch of the regular expression is replaced. When a g option (for global) is\nadded to the regular expression, all matches in the string will be replaced, not\njust the first.\nconsole.log(\"Borobudur\".replace(\/[ou]\/, \"a\"));\n\/\/ \u2192 Barobudur\nconsole.log(\"Borobudur\".replace(\/[ou]\/g, \"a\"));\n\/\/ \u2192 Barabadar\nIt would have been sensible if the choice between replacing one match or all\nmatches was made through an additional argument to replace or by providing\na different method, replaceAll. But for some unfortunate reason, the choice\nrelies on a property of the regular expression instead.\nThe real power of using regular expressions with replace comes from the fact\nthat we can refer to matched groups in the replacement string. For example,\nsay we have a big string containing the names of people, one name per line, in\nthe format Lastname, Firstname. If we want to swap these names and remove\nthe comma to get a Firstname Lastname format, we can use the following code:\nconsole.log(\n\"Liskov, Barbara\\nMcCarthy, John\\nWadler, Philip\"\n.replace(\/(\\w+), (\\w+)\/g, \"$2 $1\"));\n\/\/ \u2192 Barbara Liskov\n\/\/ John McCarthy\n\/\/ Philip Wadler\nThe $1 and $2 in the replacement string refer to the parenthesized groups in\nthe pattern. $1 is replaced by the text that matched against the first group, $2\nby the second, and so on, up to $9. The whole match can be referred to with\n$&.\nIt is possible to pass a function\u2014rather than a string\u2014as the second argu-\nment to replace. For each replacement, the function will be called with the\n154 matched groups (as well as the whole match) as arguments, and its return value\nwill be inserted into the new string.\nHere\u2019s a small example:\nlet s = \"the cia and fbi\";\nconsole.log(s.replace(\/\\b(fbi|cia)\\b\/g,\nstr => str.toUpperCase()));\n\/\/ \u2192 the CIA and FBI\nHere\u2019s a more interesting one:\nlet stock = \"1 lemon, 2 cabbages, and 101 eggs\";\nfunction minusOne(match, amount, unit) {\namount = Number(amount) - 1;\nif (amount == 1) { \/\/ only one left, remove the 's'\nunit = unit.slice(0, unit.length - 1);\n} else if (amount == 0) {\namount = \"no\";\n}\nreturn amount + \" \" + unit;\n}\nconsole.log(stock.replace(\/(\\d+) (\\w+)\/g, minusOne));\n\/\/ \u2192 no lemon, 1 cabbage, and 100 eggs\nThis takes a string, finds all occurrences of a number followed by an alphanu-\nmeric word, and returns a string wherein every such occurrence is decremented\nby one.\nThe (\\d+) group ends up as the amount argument to the function, and the\n(\\w+) group gets bound to unit. The function converts amount to a number\u2014\nwhich always works since it matched \\d+\u2014and makes some adjustments in case\nthere is only one or zero left.\nGreed\nIt is possible to use replace to write a function that removes all comments\nfrom a piece of JavaScript code. Here is a first attempt:\nfunction stripComments(code) {\nreturn code.replace(\/\\\/\\\/.*|\\\/\\*[^]*\\*\\\/\/g, \"\");\n}\nconsole.log(stripComments(\"1 + \/* 2 *\/3\"));\n\/\/ \u2192 1 + 3\n155 console.log(stripComments(\"x = 10;\/\/ ten!\"));\n\/\/ \u2192 x = 10;\nconsole.log(stripComments(\"1 \/* a *\/+\/* b *\/ 1\"));\n\/\/ \u2192 1 1\nThe part before the or operator matches two slash characters followed by any\nnumber of non-newline characters. The part for multiline comments is more\ninvolved. We use [^] (any character that is not in the empty set of characters)\nas a way to match any character. We cannot just use a period here because\nblock comments can continue on a new line, and the period character does not\nmatch newline characters.\nBut the output for the last line appears to have gone wrong. Why?\nThe [^]* part of the expression, as I described in the section on backtracking,\nwill first match as much as it can. If that causes the next part of the pattern to\nfail, the matcher moves back one character and tries again from there. In the\nexample, the matcher first tries to match the whole rest of the string and then\nmoves back from there. It will find an occurrence of *\/ after going back four\ncharacters and match that. This is not what we wanted\u2014the intention was to\nmatch a single comment, not to go all the way to the end of the code and find\nthe end of the last block comment.\nBecause of this behavior, we say the repetition operators (+, *, ?, and {}\n) are greedy, meaning they match as much as they can and backtrack from\nthere. If you put a question mark after them (+?, *?, ??, {}?), they become\nnongreedy and start by matching as little as possible, matching more only when\nthe remaining pattern does not fit the smaller match.\nAnd that is exactly what we want in this case. By having the star match\nthe smallest stretch of characters that brings us to a *\/, we consume one block\ncomment and nothing more.\nfunction stripComments(code) {\nreturn code.replace(\/\\\/\\\/.*|\\\/\\*[^]*?\\*\\\/\/g, \"\");\n}\nconsole.log(stripComments(\"1 \/* a *\/+\/* b *\/ 1\"));\n\/\/ \u2192 1 + 1\nA lot of bugs in regular expression programs can be traced to unintentionally\nusing a greedy operator where a nongreedy one would work better. When using\na repetition operator, consider the nongreedy variant first.\n156 Dynamically creating RegExp objects\nThere are cases where you might not know the exact pattern you need to match\nagainst when you are writing your code. Say you want to look for the user\u2019s\nname in a piece of text and enclose it in underscore characters to make it stand\nout. Since you will know the name only once the program is actually running,\nyou can\u2019t use the slash-based notation.\nBut you can build up a string and use the RegExp constructor on that. Here\u2019s\nan example:\nlet name = \"harry\";\nlet text = \"Harry is a suspicious character.\";\nlet regexp = new RegExp(\"\\\\b(\" + name + \")\\\\b\", \"gi\");\nconsole.log(text.replace(regexp, \"_$1_\"));\n\/\/ \u2192 _Harry_ is a suspicious character.\nWhen creating the \\b boundary markers, we have to use two backslashes\nbecause we are writing them in a normal string, not a slash-enclosed regu-\nlar expression. The second argument to the RegExp constructor contains the\noptions for the regular expression\u2014in this case, \"gi\" for global and case insen-\nsitive.\nBut what if the name is \"dea+hl[]rd\" because our user is a nerdy teenager?\nThat would result in a nonsensical regular expression that won\u2019t actually match\nthe user\u2019s name.\nTo work around this, we can add backslashes before any character that has\na special meaning.\nlet name = \"dea+hl[]rd\";\nlet text = \"This dea+hl[]rd guy is super annoying.\";\nlet escaped = name.replace(\/[\\\\[.+*?(){|^$]\/g, \"\\\\$&\");\nlet regexp = new RegExp(\"\\\\b\" + escaped + \"\\\\b\", \"gi\");\nconsole.log(text.replace(regexp, \"_$&_\"));\n\/\/ \u2192 This _dea+hl[]rd_ guy is super annoying.\nThe search method\nThe indexOf method on strings cannot be called with a regular expression. But\nthere is another method, search, that does expect a regular expression. Like\nindexOf, it returns the first index on which the expression was found, or -1\nwhen it wasn\u2019t found.\n157 console.log(\" word\".search(\/\\S\/));\n\/\/ \u2192 2\nconsole.log(\" \".search(\/\\S\/));\n\/\/ \u2192 -1\nUnfortunately, there is no way to indicate that the match should start at a\ngiven offset (like we can with the second argument to indexOf), which would\noften be useful.\nThe lastIndex property\nThe exec method similarly does not provide a convenient way to start searching\nfrom a given position in the string. But it does provide an inconvenient way.\nRegular expression objects have properties. One such property is source,\nwhich contains the string that expression was created from. Another property\nis lastIndex, which controls, in some limited circumstances, where the next\nmatch will start.\nThose circumstances are that the regular expression must have the global\n(g) or sticky (y) option enabled, and the match must happen through the exec\nmethod. Again, a less confusing solution would have been to just allow an\nextra argument to be passed to exec, but confusion is an essential feature of\nJavaScript\u2019s regular expression interface.\nlet pattern = \/y\/g;\npattern.lastIndex = 3;\nlet match = pattern.exec(\"xyzzy\");\nconsole.log(match.index);\n\/\/ \u2192 4\nconsole.log(pattern.lastIndex);\n\/\/ \u2192 5\nIf the match was successful, the call to exec automatically updates the\nlastIndex property to point after the match. If no match was found, lastIndex\nis set back to zero, which is also the value it has in a newly constructed regular\nexpression object.\nThe difference between the global and the sticky options is that, when sticky\nisenabled, thematchwillsucceedonlyifitstartsdirectlyatlastIndex, whereas\nwith global, it will search ahead for a position where a match can start.\nlet global = \/abc\/g;\nconsole.log(global.exec(\"xyz abc\"));\n158 \/\/ \u2192 [\"abc\"]\nlet sticky = \/abc\/y;\nconsole.log(sticky.exec(\"xyz abc\"));\n\/\/ \u2192 null\nWhen using a shared regular expression value for multiple exec calls, these\nautomatic updates to the lastIndex property can cause problems. Your regular\nexpression might be accidentally starting at an index that was left over from a\nprevious call.\nlet digit = \/\\d\/g;\nconsole.log(digit.exec(\"here it is: 1\"));\n\/\/ \u2192 [\"1\"]\nconsole.log(digit.exec(\"and now: 1\"));\n\/\/ \u2192 null\nAnother interesting effect of the global option is that it changes the way\nthe match method on strings works. When called with a global expression,\ninstead of returning an array similar to that returned by exec, match will find\nall matches of the pattern in the string and return an array containing the\nmatched strings.\nconsole.log(\"Banana\".match(\/an\/g));\n\/\/ \u2192 [\"an\", \"an\"]\nSo be cautious with global regular expressions. The cases where they are\nnecessary\u2014callstoreplaceandplaceswhereyouwanttoexplicitlyuselastIndex\n\u2014are typically the only places where you want to use them.\nLooping over matches\nA common thing to do is to scan through all occurrences of a pattern in a\nstring, in a way that gives us access to the match object in the loop body. We\ncan do this by using lastIndex and exec.\nlet input = \"A string with 3 numbers in it... 42 and 88.\";\nlet number = \/\\b\\d+\\b\/g;\nlet match;\nwhile (match = number.exec(input)) {\nconsole.log(\"Found\", match[0], \"at\", match.index);\n}\n\/\/ \u2192 Found 3 at 14\n159 \/\/ Found 42 at 33\n\/\/ Found 88 at 40\nThis makes use of the fact that the value of an assignment expression (=) is\nthe assigned value. So by using match = number.exec(input) as the condition\nin the while statement, we perform the match at the start of each iteration,\nsave its result in a binding, and stop looping when no more matches are found.\nParsing an INI file\nTo conclude the chapter, we\u2019ll look at a problem that calls for regular expres-\nsions. Imagine we are writing a program to automatically collect information\nabout our enemies from the Internet. (We will not actually write that program\nhere, just the part that reads the configuration file. Sorry.) The configuration\nfile looks like this:\nsearchengine=https:\/\/duckduckgo.com\/?q=$1\nspitefulness=9.7\n; comments are preceded by a semicolon...\n; each section concerns an individual enemy\n[larry]\nfullname=Larry Doe\ntype=kindergarten bully\nwebsite=http:\/\/www.geocities.com\/CapeCanaveral\/11451\n[davaeorn]\nfullname=Davaeorn\ntype=evil wizard\noutputdir=\/home\/marijn\/enemies\/davaeorn\nThe exact rules for this format (which is a widely used format, usually called\nan INI file) are as follows:\n\u2022 Blank lines and lines starting with semicolons are ignored.\n\u2022 Lines wrapped in [ and ] start a new section.\n\u2022 Lines containing an alphanumeric identifier followed by an = character\nadd a setting to the current section.\n\u2022 Anything else is invalid.\n160 Our task is to convert a string like this into an object whose properties hold\nstrings for settings written before the first section header and subobjects for\nsections, with those subobjects holding the section\u2019s settings.\nSince the format has to be processed line by line, splitting up the file into\nseparate lines is a good start. We saw the split method in Chapter 4. Some\noperating systems, however, use not just a newline character to separate lines\nbut a carriage return character followed by a newline (\"\\r\\n\"). Given that\nthe split method also allows a regular expression as its argument, we can use\na regular expression like \/\\r?\\n\/ to split in a way that allows both \"\\n\" and\n\"\\r\\n\" between lines.\nfunction parseINI(string) {\n\/\/ Start with an object to hold the top-level fields\nlet result = {};\nlet section = result;\nstring.split(\/\\r?\\n\/).forEach(line => {\nlet match;\nif (match = line.match(\/^(\\w+)=(.*)$\/)) {\nsection[match[1]] = match[2];\n} else if (match = line.match(\/^\\[(.*)\\]$\/)) {\nsection = result[match[1]] = {};\n} else if (!\/^\\s*(;.*)?$\/.test(line)) {\nthrow new Error(\"Line '\" + line + \"' is not valid.\");\n}\n});\nreturn result;\n}\nconsole.log(parseINI(`\nname=Vasilis\n[address]\ncity=Tessaloniki`));\n\/\/ \u2192 {name: \"Vasilis\", address: {city: \"Tessaloniki\"}}\nThe code goes over the file\u2019s lines and builds up an object. Properties at the\ntop are stored directly into that object, whereas properties found in sections are\nstored in a separate section object. The section binding points at the object\nfor the current section.\nThere are two kinds of significant lines\u2014section headers or property lines.\nWhen a line is a regular property, it is stored in the current section. When it\nis a section header, a new section object is created, and section is set to point\nat it.\n161 Note the recurring use of ^ and $ to make sure the expression matches the\nwhole line, not just part of it. Leaving these out results in code that mostly\nworks but behaves strangely for some input, which can be a di\ufb00icult bug to\ntrack down.\nThe pattern if (match = string.match(...)) is similar to the trick of using\nan assignment as the condition for while. You often aren\u2019t sure that your call\nto match will succeed, so you can access the resulting object only inside an\nif statement that tests for this. To not break the pleasant chain of else if\nforms, we assign the result of the match to a binding and immediately use that\nassignment as the test for the if statement.\nIf a line is not a section header or a property, the function checks whether it\nis a comment or an empty line using the expression \/^\\s*(;.*)?$\/. Do you see\nhow it works? The part between the parentheses will match comments, and\nthe ? makes sure it also matches lines containing only whitespace. When a line\ndoesn\u2019t match any of the expected forms, the function throws an exception.\nInternational characters\nBecause of JavaScript\u2019s initial simplistic implementation and the fact that this\nsimplistic approach was later set in stone as standard behavior, JavaScript\u2019s\nregular expressions are rather dumb about characters that do not appear in\nthe English language. For example, as far as JavaScript\u2019s regular expressions\nare concerned, a \u201cword character\u201d is only one of the 26 characters in the Latin\nalphabet (uppercase or lowercase), decimal digits, and, for some reason, the\nunderscore character. Things like \u00e9 or \u00df, which most definitely are word char-\nacters, will not match \\w (and will match uppercase \\W, the nonword category).\nBy a strange historical accident, \\s (whitespace) does not have this problem\nand matches all characters that the Unicode standard considers whitespace,\nincluding things like the nonbreaking space and the Mongolian vowel separator.\nAnother problem is that, by default, regular expressions work on code units,\nas discussed in Chapter 5, not actual characters. This means characters that\nare composed of two code units behave strangely.\n\ud83c\udf4e \ud83c\udf4e\ud83c\udf4e\ud83c\udf4e\nconsole.log(\/ {3}\/.test(\" \"));\n\/\/ \u2192 false\n\ud83c\udf39\nconsole.log(\/<.>\/.test(\"< >\"));\n\/\/ \u2192 false\n\ud83c\udf39\nconsole.log(\/<.>\/u.test(\"< >\"));\n\/\/ \u2192 true\n162 The problem is that the \ud83c\udf4e in the first line is treated as two code units, and\nthe {3} part is applied only to the second one. Similarly, the dot matches a\nsingle code unit, not the two that make up the rose emoji.\nYou must add a u option (for Unicode) to your regular expression to make\nit treat such characters properly. The wrong behavior remains the default,\nunfortunately, because changing that might cause problems for existing code\nthat depends on it.\nThough this was only just standardized and is, at the time of writing, not\nwidely supported yet, it is possible to use \\p in a regular expression (that must\nhave the Unicode option enabled) to match all characters to which the Unicode\nstandard assigns a given property.\nconsole.log(\/\\p{Script=Greek}\/u.test(\"\u03b1\"));\n\/\/ \u2192 true\nconsole.log(\/\\p{Script=Arabic}\/u.test(\"\u03b1\"));\n\/\/ \u2192 false\nconsole.log(\/\\p{Alphabetic}\/u.test(\"\u03b1\"));\n\/\/ \u2192 true\nconsole.log(\/\\p{Alphabetic}\/u.test(\"!\"));\n\/\/ \u2192 false\nUnicode defines a number of useful properties, though finding the one that\nyou need may not always be trivial. You can use the \\p{Property=Value}\nnotation to match any character that has the given value for that property. If\nthe property name is left off, as in \\p{Name}, the name is assumed to be either\na binary property such as Alphabetic or a category such as Number.\nSummary\nRegular expressions are objects that represent patterns in strings. They use\ntheir own language to express these patterns.\n163 \/abc\/ A sequence of characters\n\/[abc]\/ Any character from a set of characters\n\/[^abc]\/ Any character not in a set of characters\n\/[0-9]\/ Any character in a range of characters\n\/x+\/ One or more occurrences of the pattern x\n\/x+?\/ One or more occurrences, nongreedy\n\/x*\/ Zero or more occurrences\n\/x?\/ Zero or one occurrence\n\/x{2,4}\/ Two to four occurrences\n\/(abc)\/ A group\n\/a|b|c\/ Any one of several patterns\n\/\\d\/ Any digit character\n\/\\w\/ An alphanumeric character (\u201cword character\u201d)\n\/\\s\/ Any whitespace character\n\/.\/ Any character except newlines\n\/\\b\/ A word boundary\n\/^\/ Start of input\n\/$\/ End of input\nA regular expression has a method test to test whether a given string\nmatches it. It also has a method exec that, when a match is found, returns\nan array containing all matched groups. Such an array has an index property\nthat indicates where the match started.\nStrings have a match method to match them against a regular expression\nand a search method to search for one, returning only the starting position\nof the match. Their replace method can replace matches of a pattern with a\nreplacement string or function.\nRegular expressions can have options, which are written after the closing\nslash. The i option makes the match case insensitive. The g option makes\nthe expression global, which, among other things, causes the replace method\nto replace all instances instead of just the first. The y option makes it sticky,\nwhich means that it will not search ahead and skip part of the string when\nlooking for a match. The u option turns on Unicode mode, which fixes a\nnumber of problems around the handling of characters that take up two code\nunits.\nRegular expressions are a sharp tool with an awkward handle. They simplify\nsome tasks tremendously but can quickly become unmanageable when applied\nto complex problems. Part of knowing how to use them is resisting the urge to\ntry to shoehorn things that they cannot cleanly express into them.\n164 Exercises\nIt is almost unavoidable that, in the course of working on these exercises,\nyou will get confused and frustrated by some regular expression\u2019s inexplicable\nbehavior. Sometimes it helps to enter your expression into an online tool like\nhttps:\/\/debuggex.com to see whether its visualization corresponds to what you\nintended and to experiment with the way it responds to various input strings.\nRegexp golf\nCode golf is a term used for the game of trying to express a particular program\nin as few characters as possible. Similarly, regexp golf is the practice of writing\nas tiny a regular expression as possible to match a given pattern, and only that\npattern.\nForeachofthefollowingitems, writearegularexpressiontotestwhetherany\nof the given substrings occur in a string. The regular expression should match\nonly strings containing one of the substrings described. Do not worry about\nword boundaries unless explicitly mentioned. When your expression works, see\nwhether you can make it any smaller.\n1. car and cat\n2. pop and prop\n3. ferret, ferry, and ferrari\n4. Any word ending in ious\n5. A whitespace character followed by a period, comma, colon, or semicolon\n6. A word longer than six letters\n7. A word without the letter e (or E)\nRefer to the table in the chapter summary for help. Test each solution with\na few test strings.\nQuoting style\nImagine you have written a story and used single quotation marks throughout\nto mark pieces of dialogue. Now you want to replace all the dialogue quotes\nwith double quotes, while keeping the single quotes used in contractions like\naren\u2019t.\nThink of a pattern that distinguishes these two kinds of quote usage and\ncraft a call to the replace method that does the proper replacement.\n165 Numbers again\nWrite an expression that matches only JavaScript-style numbers. It must sup-\nport an optional minus or plus sign in front of the number, the decimal dot,\nand exponent notation\u20145e-3 or 1E10\u2014again with an optional sign in front of\nthe exponent. Also note that it is not necessary for there to be digits in front\nof or after the dot, but the number cannot be a dot alone. That is, .5 and 5.\nare valid JavaScript numbers, but a lone dot isn\u2019t.\n166 \u201cWrite code that is easy to delete, not easy to extend.\u201d\n\u2014Tef, Programming is Terrible\nChapter10\nModules\nThe ideal program has a crystal-clear structure. The way it works is easy to\nexplain, and each part plays a well-defined role.\nA typical real program grows organically. New pieces of functionality are\nadded as new needs come up. Structuring\u2014and preserving structure\u2014is ad-\nditional work. It\u2019s work that will pay off only in the future, the next time\nsomeone works on the program. So it is tempting to neglect it and allow the\nparts of the program to become deeply entangled.\nThis causes two practical issues. First, understanding such a system is hard.\nIf everything can touch everything else, it is di\ufb00icult to look at any given piece\nin isolation. You are forced to build up a holistic understanding of the entire\nthing. Second, if you want to use any of the functionality from such a program\nin another situation, rewriting it may be easier than trying to disentangle it\nfrom its context.\nThe phrase \u201cbig ball of mud\u201d is often used for such large, structureless\nprograms. Everything sticks together, and when you try to pick out a piece,\nthe whole thing comes apart, and your hands get dirty.\nModules\nModulesareanattempttoavoidtheseproblems. Amoduleisapieceofprogram\nthat specifies which other pieces it relies on and which functionality it provides\nfor other modules to use (its interface).\nModule interfaces have a lot in common with object interfaces, as we saw\nthem in Chapter 6. They make part of the module available to the outside\nworld and keep the rest private. By restricting the ways in which modules\ninteract with each other, the system becomes more like LEGO, where pieces\ninteract through well-defined connectors, and less like mud, where everything\nmixes with everything.\nThe relations between modules are called dependencies. When a module\nneeds a piece from another module, it is said to depend on that module. When\n167 this fact is clearly specified in the module itself, it can be used to figure out\nwhich other modules need to be present to be able to use a given module and\nto automatically load dependencies.\nTo separate modules in that way, each needs its own private scope.\nJust putting your JavaScript code into different files does not satisfy these\nrequirements. The files still share the same global namespace. They can,\nintentionally or accidentally, interfere with each other\u2019s bindings. And the\ndependency structure remains unclear. We can do better, as we\u2019ll see later in\nthe chapter.\nDesigning a fitting module structure for a program can be di\ufb00icult. In the\nphase where you are still exploring the problem, trying different things to see\nwhat works, you might want to not worry about it too much since it can be a\nbig distraction. Once you have something that feels solid, that\u2019s a good time\nto take a step back and organize it.\nPackages\nOne of the advantages of building a program out of separate pieces, and being\nactually able to run those pieces on their own, is that you might be able to\napply the same piece in different programs.\nBut how do you set this up? Say I want to use the parseINI function from\nChapter 9 in another program. If it is clear what the function depends on (in\nthis case, nothing), I can just copy all the necessary code into my new project\nand use it. But then, if I find a mistake in that code, I\u2019ll probably fix it in\nwhichever program I\u2019m working with at the time and forget to also fix it in the\nother program.\nOnce you start duplicating code, you\u2019ll quickly find yourself wasting time\nand energy moving copies around and keeping them up-to-date.\nThat\u2019s where packages come in. A package is a chunk of code that can be\ndistributed (copied and installed). It may contain one or more modules and\nhas information about which other packages it depends on. A package also\nusually comes with documentation explaining what it does so that people who\ndidn\u2019t write it might still be able to use it.\nWhen a problem is found in a package or a new feature is added, the package\nis updated. Now the programs that depend on it (which may also be packages)\ncan upgrade to the new version.\nWorking in this way requires infrastructure. We need a place to store and\nfind packages and a convenient way to install and upgrade them. In the\nJavaScript world, this infrastructure is provided by NPM (https:\/\/npmjs.org).\n168 NPM is two things: an online service where one can download (and upload)\npackages and a program (bundled with Node.js) that helps you install and\nmanage them.\nAt the time of writing, there are more than half a million different packages\navailable on NPM. A large portion of those are rubbish, I should mention,\nbut almost every useful, publicly available package can be found on there. For\nexample, an INI file parser, similar to the one we built in Chapter 9, is available\nunder the package name ini.\nChapter 20 will show how to install such packages locally using the npm\ncommand line program.\nHaving quality packages available for download is extremely valuable. It\nmeans that we can often avoid reinventing a program that 100 people have\nwritten before and get a solid, well-tested implementation at the press of a few\nkeys.\nSoftware is cheap to copy, so once someone has written it, distributing it to\nother people is an e\ufb00icient process. But writing it in the first place is work,\nand responding to people who have found problems in the code, or who want\nto propose new features, is even more work.\nBy default, you own the copyright to the code you write, and other peo-\nple may use it only with your permission. But because some people are just\nnice and because publishing good software can help make you a little bit fa-\nmous among programmers, many packages are published under a license that\nexplicitly allows other people to use it.\nMost code on NPM is licensed this way. Some licenses require you to also\npublish code that you build on top of the package under the same license.\nOthers are less demanding, just requiring that you keep the license with the\ncode as you distribute it. The JavaScript community mostly uses the latter\ntype of license. When using other people\u2019s packages, make sure you are aware\nof their license.\nImprovised modules\nUntil 2015, the JavaScript language had no built-in module system. Yet people\nhad been building large systems in JavaScript for more than a decade, and they\nneeded modules.\nSo they designed their own module systems on top of the language. You can\nuse JavaScript functions to create local scopes and objects to represent module\ninterfaces.\nThis is a module for going between day names and numbers (as returned\n169 by Date\u2019s getDay method). Its interface consists of weekDay.name and weekDay\n.number, and it hides its local binding names inside the scope of a function\nexpression that is immediately invoked.\nconst weekDay = function() {\nconst names = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\"];\nreturn {\nname(number) { return names[number]; },\nnumber(name) { return names.indexOf(name); }\n};\n}();\nconsole.log(weekDay.name(weekDay.number(\"Sunday\")));\n\/\/ \u2192 Sunday\nThis style of modules provides isolation, to a certain degree, but it does not\ndeclare dependencies. Instead, it just puts its interface into the global scope\nand expects its dependencies, if any, to do the same. For a long time this was\nthe main approach used in web programming, but it is mostly obsolete now.\nIf we want to make dependency relations part of the code, we\u2019ll have to take\ncontrol of loading dependencies. Doing that requires being able to execute\nstrings as code. JavaScript can do this.\nEvaluating data as code\nThere are several ways to take data (a string of code) and run it as part of the\ncurrent program.\nThe most obvious way is the special operator eval, which will execute a\nstring in the current scope. This is usually a bad idea because it breaks some\nof the properties that scopes normally have, such as it being easily predictable\nwhich binding a given name refers to.\nconst x = 1;\nfunction evalAndReturnX(code) {\neval(code);\nreturn x;\n}\nconsole.log(evalAndReturnX(\"var x = 2\"));\n\/\/ \u2192 2\nconsole.log(x);\n170 \/\/ \u2192 1\nA less scary way of interpreting data as code is to use the Function con-\nstructor. It takes two arguments: a string containing a comma-separated list\nof argument names and a string containing the function body. It wraps the\ncode in a function value so that it gets its own scope and won\u2019t do odd things\nwith other scopes.\nlet plusOne = Function(\"n\", \"return n + 1;\");\nconsole.log(plusOne(4));\n\/\/ \u2192 5\nThis is precisely what we need for a module system. We can wrap the\nmodule\u2019s code in a function and use that function\u2019s scope as module scope.\nCommonJS\nThe most widely used approach to bolted-on JavaScript modules is called Com-\nmonJS modules. Node.js uses it and is the system used by most packages on\nNPM.\nThemainconceptinCommonJSmodulesisafunctioncalledrequire. When\nyou call this with the module name of a dependency, it makes sure the module\nis loaded and returns its interface.\nBecause the loader wraps the module code in a function, modules automat-\nically get their own local scope. All they have to do is call require to access\ntheir dependencies and put their interface in the object bound to exports.\nThis example module provides a date-formatting function. It uses two pack-\nages from NPM\u2014ordinal to convert numbers to strings like \"1st\" and \"2nd\",\nand date-names to get the English names for weekdays and months. It exports\na single function, formatDate, which takes a Date object and a template string.\nThe template string may contain codes that direct the format, such as YYYY\nfor the full year and Do for the ordinal day of the month. You could give it a\nstring like \"MMMM Do YYYY\" to get output like \u201cNovember 22nd 2017\u201d.\nconst ordinal = require(\"ordinal\");\nconst {days, months} = require(\"date-names\");\nexports.formatDate = function(date, format) {\nreturn format.replace(\/YYYY|M(MMM)?|Do?|dddd\/g, tag => {\nif (tag == \"YYYY\") return date.getFullYear();\n171 if (tag == \"M\") return date.getMonth();\nif (tag == \"MMMM\") return months[date.getMonth()];\nif (tag == \"D\") return date.getDate();\nif (tag == \"Do\") return ordinal(date.getDate());\nif (tag == \"dddd\") return days[date.getDay()];\n});\n};\nThe interface of ordinal is a single function, whereas date-names exports an\nobject containing multiple things\u2014days and months are arrays of names. De-\nstructuring is very convenient when creating bindings for imported interfaces.\nThe module adds its interface function to exports so that modules that\ndepend on it get access to it. We could use the module like this:\nconst {formatDate} = require(\".\/format-date\");\nconsole.log(formatDate(new Date(2017, 9, 13),\n\"dddd the Do\"));\n\/\/ \u2192 Friday the 13th\nWe can define require, in its most minimal form, like this:\nrequire.cache = Object.create(null);\nfunction require(name) {\nif (!(name in require.cache)) {\nlet code = readFile(name);\nlet module = {exports: {}};\nrequire.cache[name] = module;\nlet wrapper = Function(\"require, exports, module\", code);\nwrapper(require, module.exports, module);\n}\nreturn require.cache[name].exports;\n}\nIn this code, readFile is a made-up function that reads a file and returns its\ncontents as a string. Standard JavaScript provides no such functionality\u2014but\ndifferent JavaScript environments, such as the browser and Node.js, provide\ntheir own ways of accessing files. The example just pretends that readFile\nexists.\nTo avoid loading the same module multiple times, require keeps a store\n(cache) of already loaded modules. When called, it first checks if the requested\n172 module has been loaded and, if not, loads it. This involves reading the module\u2019s\ncode, wrapping it in a function, and calling it.\nThe interface of the ordinal package we saw before is not an object but\na function. A quirk of the CommonJS modules is that, though the module\nsystem will create an empty interface object for you (bound to exports), you\ncan replace that with any value by overwriting module.exports. This is done\nby many modules to export a single value instead of an interface object.\nBy defining require, exports, and module as parameters for the generated\nwrapper function (and passing the appropriate values when calling it), the\nloader makes sure that these bindings are available in the module\u2019s scope.\nThe way the string given to require is translated to an actual filename or\nweb address differs in different systems. When it starts with \".\/\" or \"..\/\",\nit is generally interpreted as relative to the current module\u2019s filename. So \".\/\nformat-date\" would be the file named format-date.js in the same directory.\nWhen the name isn\u2019t relative, Node.js will look for an installed package by\nthat name. In the example code in this chapter, we\u2019ll interpret such names as\nreferring to NPM packages. We\u2019ll go into more detail on how to install and use\nNPM modules in Chapter 20.\nNow, instead of writing our own INI file parser, we can use one from NPM.\nconst {parse} = require(\"ini\");\nconsole.log(parse(\"x = 10\\ny = 20\"));\n\/\/ \u2192 {x: \"10\", y: \"20\"}\nECMAScript modules\nCommonJS modules work quite well and, in combination with NPM, have\nallowed the JavaScript community to start sharing code on a large scale.\nButtheyremainabitofaduct-tapehack. Thenotationisslightlyawkward\u2014\nthe things you add to exports are not available in the local scope, for example.\nAnd because require is a normal function call taking any kind of argument, not\njust a string literal, it can be hard to determine the dependencies of a module\nwithout running its code.\nThis is why the JavaScript standard from 2015 introduces its own, differ-\nent module system. It is usually called ES modules, where ES stands for\nECMAScript. The main concepts of dependencies and interfaces remain the\nsame, but the details differ. For one thing, the notation is now integrated into\n173 the language. Instead of calling a function to access a dependency, you use a\nspecial import keyword.\nimport ordinal from \"ordinal\";\nimport {days, months} from \"date-names\";\nexport function formatDate(date, format) { \/* ... *\/ }\nSimilarly, the export keyword is used to export things. It may appear in\nfront of a function, class, or binding definition (let, const, or var).\nAn ES module\u2019s interface is not a single value but a set of named bindings.\nThe preceding module binds formatDate to a function. When you import from\nanother module, you import the binding, not the value, which means an export-\ning module may change the value of the binding at any time, and the modules\nthat import it will see its new value.\nWhen there is a binding named default, it is treated as the module\u2019s main\nexported value. If you import a module like ordinal in the example, without\nbraces around the binding name, you get its default binding. Such modules\ncan still export other bindings under different names alongside their default\nexport.\nTo create a default export, you write export default before an expression,\na function declaration, or a class declaration.\nexport default [\"Winter\", \"Spring\", \"Summer\", \"Autumn\"];\nIt is possible to rename imported bindings using the word as.\nimport {days as dayNames} from \"date-names\";\nconsole.log(dayNames.length);\n\/\/ \u2192 7\nAnother important difference is that ES module imports happen before a\nmodule\u2019s script starts running. That means import declarations may not ap-\npear inside functions or blocks, and the names of dependencies must be quoted\nstrings, not arbitrary expressions.\nAt the time of writing, the JavaScript community is in the process of adopt-\ning this module style. But it has been a slow process. It took a few years,\nafter the format was specified, for browsers and Node.js to start supporting it.\nAnd though they mostly support it now, this support still has issues, and the\n174 discussion on how such modules should be distributed through NPM is still\nongoing.\nMany projects are written using ES modules and then automatically con-\nverted to some other format when published. We are in a transitional period\nin which two different module systems are used side by side, and it is useful to\nbe able to read and write code in either of them.\nBuilding and bundling\nInfact, manyJavaScriptprojectsaren\u2019teven, technically, writteninJavaScript.\nThere are extensions, such as the type checking dialect mentioned in Chapter\n8, that are widely used. People also often start using planned extensions to the\nlanguage long before they have been added to the platforms that actually run\nJavaScript.\nTo make this possible, they compile their code, translating it from their\nchosen JavaScript dialect to plain old JavaScript\u2014or even to a past version of\nJavaScript\u2014so that old browsers can run it.\nIncluding a modular program that consists of 200 different files in a web\npage produces its own problems. If fetching a single file over the network takes\n50 milliseconds, loading the whole program takes 10 seconds, or maybe half\nthat if you can load several files simultaneously. That\u2019s a lot of wasted time.\nBecause fetching a single big file tends to be faster than fetching a lot of tiny\nones, web programmers have started using tools that roll their programs (which\nthey painstakingly split into modules) back into a single big file before they\npublish it to the Web. Such tools are called bundlers.\nAnd we can go further. Apart from the number of files, the size of the\nfiles also determines how fast they can be transferred over the network. Thus,\nthe JavaScript community has invented minifiers. These are tools that take\na JavaScript program and make it smaller by automatically removing com-\nments and whitespace, renaming bindings, and replacing pieces of code with\nequivalent code that take up less space.\nSo it is not uncommon for the code that you find in an NPM package or that\nruns on a web page to have gone through multiple stages of transformation\u2014\nconverted from modern JavaScript to historic JavaScript, from ES module for-\nmat to CommonJS, bundled, and minified. We won\u2019t go into the details of\nthese tools in this book since they tend to be boring and change rapidly. Just\nbe aware that the JavaScript code you run is often not the code as it was\nwritten.\n175 Module design\nStructuring programs is one of the subtler aspects of programming. Any non-\ntrivial piece of functionality can be modeled in various ways.\nGood program design is subjective\u2014there are trade-offs involved and mat-\nters of taste. The best way to learn the value of well-structured design is to\nread or work on a lot of programs and notice what works and what doesn\u2019t.\nDon\u2019t assume that a painful mess is \u201cjust the way it is\u201d. You can improve the\nstructure of almost everything by putting more thought into it.\nOne aspect of module design is ease of use. If you are designing something\nthat is intended to be used by multiple people\u2014or even by yourself, in three\nmonths when you no longer remember the specifics of what you did\u2014it is\nhelpful if your interface is simple and predictable.\nThat may mean following existing conventions. A good example is the ini\npackage. This module imitates the standard JSON object by providing parse\nand stringify (to write an INI file) functions, and, like JSON, converts between\nstrings and plain objects. So the interface is small and familiar, and after you\u2019ve\nworked with it once, you\u2019re likely to remember how to use it.\nEven if there\u2019s no standard function or widely used package to imitate, you\ncan keep your modules predictable by using simple data structures and doing\na single, focused thing. Many of the INI-file parsing modules on NPM provide\na function that directly reads such a file from the hard disk and parses it,\nfor example. This makes it impossible to use such modules in the browser,\nwhere we don\u2019t have direct file system access, and adds complexity that would\nhave been better addressed by composing the module with some file-reading\nfunction.\nThis points to another helpful aspect of module design\u2014the ease with which\nsomething can be composed with other code. Focused modules that compute\nvalues are applicable in a wider range of programs than bigger modules that\nperform complicated actions with side effects. An INI file reader that insists on\nreading the file from disk is useless in a scenario where the file\u2019s content comes\nfrom some other source.\nRelatedly, stateful objects are sometimes useful or even necessary, but if\nsomething can be done with a function, use a function. Several of the INI file\nreaders on NPM provide an interface style that requires you to first create an\nobject, then load the file into your object, and finally use specialized methods\nto get at the results. This type of thing is common in the object-oriented\ntradition, and it\u2019s terrible. Instead of making a single function call and moving\non, you have to perform the ritual of moving your object through various\nstates. And because the data is now wrapped in a specialized object type, all\n176 code that interacts with it has to know about that type, creating unnecessary\ninterdependencies.\nOften defining new data structures can\u2019t be avoided\u2014only a few basic ones\nare provided by the language standard, and many types of data have to be\nmore complex than an array or a map. But when an array su\ufb00ices, use an\narray.\nAn example of a slightly more complex data structure is the graph from\nChapter 7. There is no single obvious way to represent a graph in JavaScript.\nIn that chapter, we used an object whose properties hold arrays of strings\u2014the\nother nodes reachable from that node.\nThere are several different pathfinding packages on NPM, but none of them\nuses this graph format. They usually allow the graph\u2019s edges to have a weight,\nwhich is the cost or distance associated with it. That isn\u2019t possible in our\nrepresentation.\nFor example, there\u2019s the dijkstrajs package. A well-known approach to\npathfinding, quite similar to our findRoute function, is called Dijkstra\u2019s algo-\nrithm, after Edsger Dijkstra, who first wrote it down. The js su\ufb00ix is often\nadded to package names to indicate the fact that they are written in JavaScript.\nThis dijkstrajs package uses a graph format similar to ours, but instead of\narrays, it uses objects whose property values are numbers\u2014the weights of the\nedges.\nSo if we wanted to use that package, we\u2019d have to make sure that our graph\nwas stored in the format it expects. All edges get the same weight since our\nsimplified model treats each road as having the same cost (one turn).\nconst {find_path} = require(\"dijkstrajs\");\nlet graph = {};\nfor (let node of Object.keys(roadGraph)) {\nlet edges = graph[node] = {};\nfor (let dest of roadGraph[node]) {\nedges[dest] = 1;\n}\n}\nconsole.log(find_path(graph, \"Post Office\", \"Cabin\"));\n\/\/ \u2192 [\"Post Office\", \"Alice's House\", \"Cabin\"]\nThis can be a barrier to composition\u2014when various packages are using dif-\nferent data structures to describe similar things, combining them is di\ufb00icult.\nTherefore, if you want to design for composability, find out what data struc-\n177 tures other people are using and, when possible, follow their example.\nSummary\nModulesprovidestructuretobiggerprogramsbyseparatingthecodeintopieces\nwith clear interfaces and dependencies. The interface is the part of the module\nthat\u2019s visible from other modules, and the dependencies are the other modules\nthat it makes use of.\nBecause JavaScript historically did not provide a module system, the Com-\nmonJS system was built on top of it. Then at some point it did get a built-in\nsystem, which now coexists uneasily with the CommonJS system.\nA package is a chunk of code that can be distributed on its own. NPM is a\nrepository of JavaScript packages. You can download all kinds of useful (and\nuseless) packages from it.\nExercises\nA modular robot\nThese are the bindings that the project from Chapter 7 creates:\nroads\nbuildGraph\nroadGraph\nVillageState\nrunRobot\nrandomPick\nrandomRobot\nmailRoute\nrouteRobot\nfindRoute\ngoalOrientedRobot\nIf you were to write that project as a modular program, what modules would\nyou create? Which module would depend on which other module, and what\nwould their interfaces look like?\nWhich pieces are likely to be available prewritten on NPM? Would you prefer\nto use an NPM package or write them yourself?\n178 Roads module\nWrite a CommonJS module, based on the example from Chapter 7, that con-\ntains the array of roads and exports the graph data structure representing them\nas roadGraph. It should depend on a module .\/graph, which exports a function\nbuildGraph that is used to build the graph. This function expects an array of\ntwo-element arrays (the start and end points of the roads).\nCircular dependencies\nA circular dependency is a situation where module A depends on B, and B\nalso, directly or indirectly, depends on A. Many module systems simply forbid\nthis because whichever order you choose for loading such modules, you cannot\nmake sure that each module\u2019s dependencies have been loaded before it runs.\nCommonJS modules allow a limited form of cyclic dependencies. As long as\nthe modules do not replace their default exports object and don\u2019t access each\nother\u2019s interface until after they finish loading, cyclic dependencies are okay.\nThe require function given earlier in this chapter supports this type of\ndependency cycle. Can you see how it handles cycles? What would go wrong\nwhen a module in a cycle does replace its default exports object?\n179 \u201cWho can wait quietly while the mud settles?\nWho can remain still until the moment of action?\u201d\n\u2014Laozi, Tao Te Ching\nChapter11\nAsynchronous Programming\nThe central part of a computer, the part that carries out the individual steps\nthat make up our programs, is called the processor. The programs we have seen\nso far are things that will keep the processor busy until they have finished their\nwork. The speed at which something like a loop that manipulates numbers can\nbe executed depends pretty much entirely on the speed of the processor.\nBut many programs interact with things outside of the processor. For ex-\nample, they may communicate over a computer network or request data from\nthe hard disk\u2014which is a lot slower than getting it from memory.\nWhen such a thing is happening, it would be a shame to let the processor\nsit idle\u2014there might be some other work it could do in the meantime. In\npart, this is handled by your operating system, which will switch the processor\nbetween multiple running programs. But that doesn\u2019t help when we want a\nsingle program to be able to make progress while it is waiting for a network\nrequest.\nAsynchronicity\nIn a synchronous programming model, things happen one at a time. When you\ncall a function that performs a long-running action, it returns only when the\naction has finished and it can return the result. This stops your program for\nthe time the action takes.\nAn asynchronous model allows multiple things to happen at the same time.\nWhen you start an action, your program continues to run. When the action\nfinishes, the program is informed and gets access to the result (for example,\nthe data read from disk).\nWe can compare synchronous and asynchronous programming using a small\nexample: a program that fetches two resources from the network and then\ncombines results.\nIn a synchronous environment, where the request function returns only after\nit has done its work, the easiest way to perform this task is to make the requests\n180 one after the other. This has the drawback that the second request will be\nstarted only when the first has finished. The total time taken will be at least\nthe sum of the two response times.\nThe solution to this problem, in a synchronous system, is to start additional\nthreads of control. A thread is another running program whose execution may\nbe interleaved with other programs by the operating system\u2014since most mod-\nern computers contain multiple processors, multiple threads may even run at\nthe same time, on different processors. A second thread could start the second\nrequest, and then both threads wait for their results to come back, after which\nthey resynchronize to combine their results.\nIn the following diagram, the thick lines represent time the program spends\nrunning normally, and the thin lines represent time spent waiting for the net-\nwork. In the synchronous model, the time taken by the network is part of the\ntimeline for a given thread of control. In the asynchronous model, starting a\nnetwork action conceptually causes a split in the timeline. The program that\ninitiated the action continues running, and the action happens alongside it,\nnotifying the program when it is finished.\nsynchronous,singlethreadofcontrol\nsynchronous, two threads of control\nasynchronous\nAnother way to describe the difference is that waiting for actions to finish\nis implicit in the synchronous model, while it is explicit, under our control, in\nthe asynchronous one.\nAsynchronicity cuts both ways. It makes expressing programs that do not\nfit the straight-line model of control easier, but it can also make expressing\nprograms that do follow a straight line more awkward. We\u2019ll see some ways to\naddress this awkwardness later in the chapter.\nBoth of the important JavaScript programming platforms\u2014browsers and\nNode.js\u2014make operations that might take a while asynchronous, rather than\nrelying on threads. Since programming with threads is notoriously hard (under-\nstanding what a program does is much more di\ufb00icult when it\u2019s doing multiple\nthings at once), this is generally considered a good thing.\n181 Crow tech\nMost people are aware of the fact that crows are very smart birds. They can\nuse tools, plan ahead, remember things, and even communicate these things\namong themselves.\nWhat most people don\u2019t know is that they are capable of many things that\nthey keep well hidden from us. I\u2019ve been told by a reputable (if somewhat\neccentric) expert on corvids that crow technology is not far behind human\ntechnology, and they are catching up.\nFor example, many crow cultures have the ability to construct computing\ndevices. These are not electronic, as human computing devices are, but operate\nthroughtheactionsoftinyinsects, aspeciescloselyrelatedtothetermite, which\nhas developed a symbiotic relationship with the crows. The birds provide them\nwith food, and in return the insects build and operate their complex colonies\nthat, with the help of the living creatures inside them, perform computations.\nSuch colonies are usually located in big, long-lived nests. The birds and\ninsects work together to build a network of bulbous clay structures, hidden\nbetween the twigs of the nest, in which the insects live and work.\nTo communicate with other devices, these machines use light signals. The\ncrows embed pieces of reflective material in special communication stalks, and\ntheinsectsaimthesetoreflectlightatanothernest, encodingdataasasequence\nof quick flashes. This means that only nests that have an unbroken visual\nconnection can communicate.\nOur friend the corvid expert has mapped the network of crow nests in the\nvillage of Hi\u00e8res-sur-Amby, on the banks of the river Rh\u00f4ne. This map shows\nthe nests and their connections:\nIn an astounding example of convergent evolution, crow computers run\nJavaScript. In this chapter we\u2019ll write some basic networking functions for\nthem.\n182 Callbacks\nOne approach to asynchronous programming is to make functions that perform\na slow action take an extra argument, a callback function. The action is started,\nand when it finishes, the callback function is called with the result.\nAs an example, the setTimeout function, available both in Node.js and in\nbrowsers, waits a given number of milliseconds (a second is a thousand mil-\nliseconds) and then calls a function.\nsetTimeout(() => console.log(\"Tick\"), 500);\nWaiting is not generally a very important type of work, but it can be useful\nwhen doing something like updating an animation or checking whether some-\nthing is taking longer than a given amount of time.\nPerforming multiple asynchronous actions in a row using callbacks means\nthat you have to keep passing new functions to handle the continuation of the\ncomputation after the actions.\nMost crow nest computers have a long-term data storage bulb, where pieces\nofinformationareetchedintotwigssothattheycanberetrievedlater. Etching,\nor finding a piece of data, takes a moment, so the interface to long-term storage\nis asynchronous and uses callback functions.\nStorage bulbs store pieces of JSON-encodable data under names. A crow\nmight store information about the places where it\u2019s hidden food under the name\n\"food caches\", which could hold an array of names that point at other pieces\nof data, describing the actual cache. To look up a food cache in the storage\nbulbs of the Big Oak nest, a crow could run code like this:\nimport {bigOak} from \".\/crow-tech\";\nbigOak.readStorage(\"food caches\", caches => {\nlet firstCache = caches[0];\nbigOak.readStorage(firstCache, info => {\nconsole.log(info);\n});\n});\n(All binding names and strings have been translated from crow language to\nEnglish.)\nThis style of programming is workable, but the indentation level increases\nwith each asynchronous action because you end up in another function. Doing\nmore complicated things, such as running multiple actions at the same time,\n183 can get a little awkward.\nCrow nest computers are built to communicate using request-response pairs.\nThat means one nest sends a message to another nest, which then immediately\nsends a message back, confirming receipt and possibly including a reply to a\nquestion asked in the message.\nEach message is tagged with a type, which determines how it is handled. Our\ncode can define handlers for specific request types, and when such a request\ncomes in, the handler is called to produce a response.\nThe interface exported by the \".\/crow-tech\" module provides callback-\nbased functions for communication. Nests have a send method that sends\noff a request. It expects the name of the target nest, the type of the request,\nand the content of the request as its first three arguments, and it expects a\nfunction to call when a response comes in as its fourth and last argument.\nbigOak.send(\"Cow Pasture\", \"note\", \"Let's caw loudly at 7PM\",\n() => console.log(\"Note delivered.\"));\nBut to make nests capable of receiving that request, we first have to define a\nrequest type named \"note\". The code that handles the requests has to run not\njust on this nest-computer but on all nests that can receive messages of this\ntype. We\u2019ll just assume that a crow flies over and installs our handler code on\nall the nests.\nimport {defineRequestType} from \".\/crow-tech\";\ndefineRequestType(\"note\", (nest, content, source, done) => {\nconsole.log(`${nest.name} received note: ${content}`);\ndone();\n});\nThe defineRequestType function defines a new type of request. The example\nadds support for \"note\" requests, which just sends a note to a given nest. Our\nimplementationcallsconsole.logsothatwecanverifythattherequestarrived.\nNests have a name property that holds their name.\nThe fourth argument given to the handler, done, is a callback function that it\nmust call when it is done with the request. If we had used the handler\u2019s return\nvalue as the response value, that would mean that a request handler can\u2019t itself\nperform asynchronous actions. A function doing asynchronous work typically\nreturns before the work is done, having arranged for a callback to be called\nwhen it completes. So we need some asynchronous mechanism\u2014in this case,\n184 another callback function\u2014to signal when a response is available.\nIn a way, asynchronicity is contagious. Any function that calls a function\nthat works asynchronously must itself be asynchronous, using a callback or\nsimilar mechanism to deliver its result. Calling a callback is somewhat more\ninvolved and error-prone than simply returning a value, so needing to structure\nlarge parts of your program that way is not great.\nPromises\nWorking with abstract concepts is often easier when those concepts can be\nrepresented by values. In the case of asynchronous actions, you could, instead\nof arranging for a function to be called at some point in the future, return an\nobject that represents this future event.\nThis is what the standard class Promise is for. A promise is an asynchronous\naction that may complete at some point and produce a value. It is able to notify\nanyone who is interested when its value is available.\nThe easiest way to create a promise is by calling Promise.resolve. This\nfunction ensures that the value you give it is wrapped in a promise. If it\u2019s\nalready a promise, it is simply returned\u2014otherwise, you get a new promise\nthat immediately finishes with your value as its result.\nlet fifteen = Promise.resolve(15);\nfifteen.then(value => console.log(`Got ${value}`));\n\/\/ \u2192 Got 15\nTo get the result of a promise, you can use its then method. This registers a\ncallback function to be called when the promise resolves and produces a value.\nYou can add multiple callbacks to a single promise, and they will be called,\neven if you add them after the promise has already resolved (finished).\nBut that\u2019s not all the then method does. It returns another promise, which\nresolves to the value that the handler function returns or, if that returns a\npromise, waits for that promise and then resolves to its result.\nIt is useful to think of promises as a device to move values into an asyn-\nchronous reality. A normal value is simply there. A promised value is a value\nthat might already be there or might appear at some point in the future. Com-\nputations defined in terms of promises act on such wrapped values and are\nexecuted asynchronously as the values become available.\nTo create a promise, you can use Promise as a constructor. It has a some-\nwhat odd interface\u2014the constructor expects a function as argument, which it\n185 immediately calls, passing it a function that it can use to resolve the promise.\nIt works this way, instead of for example with a resolve method, so that only\nthe code that created the promise can resolve it.\nThis is how you\u2019d create a promise-based interface for the readStorage func-\ntion:\nfunction storage(nest, name) {\nreturn new Promise(resolve => {\nnest.readStorage(name, result => resolve(result));\n});\n}\nstorage(bigOak, \"enemies\")\n.then(value => console.log(\"Got\", value));\nThis asynchronous function returns a meaningful value. This is the main\nadvantage of promises\u2014they simplify the use of asynchronous functions. In-\nstead of having to pass around callbacks, promise-based functions look similar\nto regular ones: they take input as arguments and return their output. The\nonly difference is that the output may not be available yet.\nFailure\nRegular JavaScript computations can fail by throwing an exception. Asyn-\nchronous computations often need something like that. A network request may\nfail, or some code that is part of the asynchronous computation may throw an\nexception.\nOne of the most pressing problems with the callback style of asynchronous\nprogramming is that it makes it extremely di\ufb00icult to make sure failures are\nproperly reported to the callbacks.\nA widely used convention is that the first argument to the callback is used\nto indicate that the action failed, and the second contains the value produced\nby the action when it was successful. Such callback functions must always\ncheck whether they received an exception and make sure that any problems\nthey cause, including exceptions thrown by functions they call, are caught and\ngiven to the right function.\nPromises make this easier. They can be either resolved (the action finished\nsuccessfully) or rejected (it failed). Resolve handlers (as registered with then)\nare called only when the action is successful, and rejections are automatically\npropagated to the new promise that is returned by then. And when a handler\n186 throws an exception, this automatically causes the promise produced by its\nthen call to be rejected. So if any element in a chain of asynchronous actions\nfails, the outcome of the whole chain is marked as rejected, and no success\nhandlers are called beyond the point where it failed.\nMuch like resolving a promise provides a value, rejecting one also provides\none, usually called the reason of the rejection. When an exception in a handler\nfunction causes the rejection, the exception value is used as the reason. Sim-\nilarly, when a handler returns a promise that is rejected, that rejection flows\ninto the next promise. There\u2019s a Promise.reject function that creates a new,\nimmediately rejected promise.\nTo explicitly handle such rejections, promises have a catch method that\nregisters a handler to be called when the promise is rejected, similar to how\nthen handlers handle normal resolution. It\u2019s also very much like then in that\nit returns a new promise, which resolves to the original promise\u2019s value if it\nresolves normally and to the result of the catch handler otherwise. If a catch\nhandler throws an error, the new promise is also rejected.\nAs a shorthand, then also accepts a rejection handler as a second argument,\nso you can install both types of handlers in a single method call.\nA function passed to the Promise constructor receives a second argument,\nalongside the resolve function, which it can use to reject the new promise.\nThe chains of promise values created by calls to then and catch can be seen\nas a pipeline through which asynchronous values or failures move. Since such\nchains are created by registering handlers, each link has a success handler or a\nrejection handler (or both) associated with it. Handlers that don\u2019t match the\ntype of outcome (success or failure) are ignored. But those that do match are\ncalled, and their outcome determines what kind of value comes next\u2014success\nwhen it returns a non-promise value, rejection when it throws an exception,\nand the outcome of a promise when it returns one of those.\nnew Promise((_, reject) => reject(new Error(\"Fail\")))\n.then(value => console.log(\"Handler 1\"))\n.catch(reason => {\nconsole.log(\"Caught failure \" + reason);\nreturn \"nothing\";\n})\n.then(value => console.log(\"Handler 2\", value));\n\/\/ \u2192 Caught failure Error: Fail\n\/\/ \u2192 Handler 2 nothing\nMuch like an uncaught exception is handled by the environment, JavaScript\nenvironments can detect when a promise rejection isn\u2019t handled and will report\n187 this as an error.\nNetworks are hard\nOccasionally, there isn\u2019t enough light for the crows\u2019 mirror systems to transmit\na signal or something is blocking the path of the signal. It is possible for a\nsignal to be sent but never received.\nAs it is, that will just cause the callback given to send to never be called,\nwhich will probably cause the program to stop without even noticing there is\na problem. It would be nice if, after a given period of not getting a response,\na request would time out and report failure.\nOften, transmission failures are random accidents, like a car\u2019s headlight in-\nterfering with the light signals, and simply retrying the request may cause it\nto succeed. So while we\u2019re at it, let\u2019s make our request function automatically\nretry the sending of the request a few times before it gives up.\nAnd, since we\u2019ve established that promises are a good thing, we\u2019ll also make\nour request function return a promise. In terms of what they can express, call-\nbacks and promises are equivalent. Callback-based functions can be wrapped\nto expose a promise-based interface, and vice versa.\nEven when a request and its response are successfully delivered, the response\nmay indicate failure\u2014for example, if the request tries to use a request type\nthat hasn\u2019t been defined or the handler throws an error. To support this, send\nand defineRequestType follow the convention mentioned before, where the first\nargument passed to callbacks is the failure reason, if any, and the second is the\nactual result.\nThese can be translated to promise resolution and rejection by our wrapper.\nclass Timeout extends Error {}\nfunction request(nest, target, type, content) {\nreturn new Promise((resolve, reject) => {\nlet done = false;\nfunction attempt(n) {\nnest.send(target, type, content, (failed, value) => {\ndone = true;\nif (failed) reject(failed);\nelse resolve(value);\n});\nsetTimeout(() => {\nif (done) return;\nelse if (n < 3) attempt(n + 1);\nelse reject(new Timeout(\"Timed out\"));\n188 }, 250);\n}\nattempt(1);\n});\n}\nBecause promises can be resolved (or rejected) only once, this will work. The\nfirst time resolve or reject is called determines the outcome of the promise,\nand further calls caused by a request coming back after another request finished\nare ignored.\nTo build an asynchronous loop, for the retries, we need to use a recursive\nfunction\u2014a regular loop doesn\u2019t allow us to stop and wait for an asynchronous\naction. The attempt function makes a single attempt to send a request. It also\nsets a timeout that, if no response has come back after 250 milliseconds, either\nstarts the next attempt or, if this was the third attempt, rejects the promise\nwith an instance of Timeout as the reason.\nRetrying every quarter-second and giving up when no response has come in\nafter three-quarter second is definitely somewhat arbitrary. It is even possible,\nif the request did come through but the handler is just taking a bit longer,\nfor requests to be delivered multiple times. We\u2019ll write our handlers with that\nproblem in mind\u2014duplicate messages should be harmless.\nIn general, we will not be building a world-class, robust network today. But\nthat\u2019s okay\u2014crows don\u2019t have very high expectations yet when it comes to\ncomputing.\nTo isolate ourselves from callbacks altogether, we\u2019ll go ahead and also define\na wrapper for defineRequestType that allows the handler function to return a\npromise or plain value and wires that up to the callback for us.\nfunction requestType(name, handler) {\ndefineRequestType(name, (nest, content, source,\ncallback) => {\ntry {\nPromise.resolve(handler(nest, content, source))\n.then(response => callback(null, response),\nfailure => callback(failure));\n} catch (exception) {\ncallback(exception);\n}\n});\n}\n189 Promise.resolve is used to convert the value returned by handler to a\npromise if it isn\u2019t already.\nNote that the call to handler had to be wrapped in a try block to make sure\nany exception it raises directly is given to the callback. This nicely illustrates\nthe di\ufb00iculty of properly handling errors with raw callbacks\u2014it is easy to forget\nto properly route exceptions like that, and if you don\u2019t do it, failures won\u2019t get\nreported to the right callback. Promises make this mostly automatic and thus\nless error-prone.\nCollections of promises\nEach nest computer keeps an array of other nests within transmission distance\nin its neighbors property. To check which of those are currently reachable,\nyou could write a function that tries to send a \"ping\" request (a request that\nsimply asks for a response) to each of them and see which ones come back.\nWhen working with collections of promises running at the same time, the\nPromise.all function can be useful. It returns a promise that waits for all of\nthe promises in the array to resolve and then resolves to an array of the values\nthat these promises produced (in the same order as the original array). If any\npromise is rejected, the result of Promise.all is itself rejected.\nrequestType(\"ping\", () => \"pong\");\nfunction availableNeighbors(nest) {\nlet requests = nest.neighbors.map(neighbor => {\nreturn request(nest, neighbor, \"ping\")\n.then(() => true, () => false);\n});\nreturn Promise.all(requests).then(result => {\nreturn nest.neighbors.filter((_, i) => result[i]);\n});\n}\nWhen a neighbor isn\u2019t available, we don\u2019t want the entire combined promise\nto fail since then we still wouldn\u2019t know anything. So the function that is\nmapped over the set of neighbors to turn them into request promises attaches\nhandlers that make successful requests produce true and rejected ones produce\nfalse.\nIn the handler for the combined promise, filter is used to remove those\nelements from the neighbors array whose corresponding value is false. This\nmakes use of the fact that filter passes the array index of the current element\n190 as a second argument to its filtering function (map, some, and similar higher-\norder array methods do the same).\nNetwork flooding\nThe fact that nests can talk only to their neighbors greatly inhibits the useful-\nness of this network.\nFor broadcasting information to the whole network, one solution is to set up\na type of request that is automatically forwarded to neighbors. These neighbors\nthen in turn forward it to their neighbors, until the whole network has received\nthe message.\nimport {everywhere} from \".\/crow-tech\";\neverywhere(nest => {\nnest.state.gossip = [];\n});\nfunction sendGossip(nest, message, exceptFor = null) {\nnest.state.gossip.push(message);\nfor (let neighbor of nest.neighbors) {\nif (neighbor == exceptFor) continue;\nrequest(nest, neighbor, \"gossip\", message);\n}\n}\nrequestType(\"gossip\", (nest, message, source) => {\nif (nest.state.gossip.includes(message)) return;\nconsole.log(`${nest.name} received gossip '${\nmessage}' from ${source}`);\nsendGossip(nest, message, source);\n});\nTo avoid sending the same message around the network forever, each nest\nkeeps an array of gossip strings that it has already seen. To define this array,\nwe use the everywhere function\u2014which runs code on every nest\u2014to add a\nproperty to the nest\u2019s state object, which is where we\u2019ll keep nest-local state.\nWhen a nest receives a duplicate gossip message, which is very likely to\nhappen with everybody blindly resending them, it ignores it. But when it\nreceives a new message, it excitedly tells all its neighbors except for the one\nwho sent it the message.\nThis will cause a new piece of gossip to spread through the network like an\n191 ink stain in water. Even when some connections aren\u2019t currently working, if\nthere is an alternative route to a given nest, the gossip will reach it through\nthere.\nThis style of network communication is called flooding\u2014it floods the network\nwith a piece of information until all nodes have it.\nMessage routing\nIf a given node wants to talk to a single other node, flooding is not a very\ne\ufb00icient approach. Especially when the network is big, that would lead to a lot\nof useless data transfers.\nAn alternative approach is to set up a way for messages to hop from node to\nnode until they reach their destination. The di\ufb00iculty with that is it requires\nknowledge about the layout of the network. To send a request in the direction\nof a faraway nest, it is necessary to know which neighboring nest gets it closer\nto its destination. Sending it in the wrong direction will not do much good.\nSince each nest knows only about its direct neighbors, it doesn\u2019t have the\ninformation it needs to compute a route. We must somehow spread the infor-\nmation about these connections to all nests, preferably in a way that allows it\nto change over time, when nests are abandoned or new nests are built.\nWe can use flooding again, but instead of checking whether a given message\nhas already been received, we now check whether the new set of neighbors for\na given nest matches the current set we have for it.\nrequestType(\"connections\", (nest, {name, neighbors},\nsource) => {\nlet connections = nest.state.connections;\nif (JSON.stringify(connections.get(name)) ==\nJSON.stringify(neighbors)) return;\nconnections.set(name, neighbors);\nbroadcastConnections(nest, name, source);\n});\nfunction broadcastConnections(nest, name, exceptFor = null) {\nfor (let neighbor of nest.neighbors) {\nif (neighbor == exceptFor) continue;\nrequest(nest, neighbor, \"connections\", {\nname,\nneighbors: nest.state.connections.get(name)\n});\n}\n}\n192 everywhere(nest => {\nnest.state.connections = new Map();\nnest.state.connections.set(nest.name, nest.neighbors);\nbroadcastConnections(nest, nest.name);\n});\nThe comparison uses JSON.stringify because ==, on objects or arrays, will\nreturn true only when the two are the exact same value, which is not what\nwe need here. Comparing the JSON strings is a crude but effective way to\ncompare their content.\nThe nodes immediately start broadcasting their connections, which should,\nunless some nests are completely unreachable, quickly give every nest a map of\nthe current network graph.\nA thing you can do with graphs is find routes in them, as we saw in Chapter\n7. If we have a route toward a message\u2019s destination, we know which direction\nto send it in.\nThis findRoute function, which greatly resembles the findRoute from Chap-\nter 7, searches for a way to reach a given node in the network. But instead of\nreturning the whole route, it just returns the next step. That next nest will\nitself, using its current information about the network, decide where it sends\nthe message.\nfunction findRoute(from, to, connections) {\nlet work = [{at: from, via: null}];\nfor (let i = 0; i < work.length; i++) {\nlet {at, via} = work[i];\nfor (let next of connections.get(at) || []) {\nif (next == to) return via;\nif (!work.some(w => w.at == next)) {\nwork.push({at: next, via: via || next});\n}\n}\n}\nreturn null;\n}\nNow we can build a function that can send long-distance messages. If the\nmessage is addressed to a direct neighbor, it is delivered as usual. If not, it is\npackaged in an object and sent to a neighbor that is closer to the target, using\nthe \"route\" request type, which will cause that neighbor to repeat the same\n193 behavior.\nfunction routeRequest(nest, target, type, content) {\nif (nest.neighbors.includes(target)) {\nreturn request(nest, target, type, content);\n} else {\nlet via = findRoute(nest.name, target,\nnest.state.connections);\nif (!via) throw new Error(`No route to ${target}`);\nreturn request(nest, via, \"route\",\n{target, type, content});\n}\n}\nrequestType(\"route\", (nest, {target, type, content}) => {\nreturn routeRequest(nest, target, type, content);\n});\nWe\u2019ve constructed several layers of functionality on top of a primitive com-\nmunication system to make it convenient to use. This is a nice (though sim-\nplified) model of how real computer networks work.\nA distinguishing property of computer networks is that they aren\u2019t reliable\u2014\nabstractions built on top of them can help, but you can\u2019t abstract away network\nfailure. So network programming is typically very much about anticipating and\ndealing with failures.\nAsync functions\nTo store important information, crows are known to duplicate it across nests.\nThat way, when a hawk destroys a nest, the information isn\u2019t lost.\nToretrieve a given piece of information that it doesn\u2019t have in its own storage\nbulb, a nest computer might consult random other nests in the network until\nit finds one that has it.\nrequestType(\"storage\", (nest, name) => storage(nest, name));\nfunction findInStorage(nest, name) {\nreturn storage(nest, name).then(found => {\nif (found != null) return found;\nelse return findInRemoteStorage(nest, name);\n});\n}\n194 function network(nest) {\nreturn Array.from(nest.state.connections.keys());\n}\nfunction findInRemoteStorage(nest, name) {\nlet sources = network(nest).filter(n => n != nest.name);\nfunction next() {\nif (sources.length == 0) {\nreturn Promise.reject(new Error(\"Not found\"));\n} else {\nlet source = sources[Math.floor(Math.random() *\nsources.length)];\nsources = sources.filter(n => n != source);\nreturn routeRequest(nest, source, \"storage\", name)\n.then(value => value != null ? value : next(),\nnext);\n}\n}\nreturn next();\n}\nBecause connections is a Map, Object.keys doesn\u2019t work on it. It has a\nkeys method, but that returns an iterator rather than an array. An iterator (or\niterable value) can be converted to an array with the Array.from function.\nEven with promises this is some rather awkward code. Multiple asyn-\nchronous actions are chained together in non-obvious ways. We again need\na recursive function (next) to model looping through the nests.\nAnd the thing the code actually does is completely linear\u2014it always waits for\nthe previous action to complete before starting the next one. In a synchronous\nprogramming model, it\u2019d be simpler to express.\nThe good news is that JavaScript allows you to write pseudo-synchronous\ncode to describe asynchronous computation. An async function is a function\nthat implicitly returns a promise and that can, in its body, awaitother promises\nin a way that looks synchronous.\nWe can rewrite findInStorage like this:\nasync function findInStorage(nest, name) {\nlet local = await storage(nest, name);\nif (local != null) return local;\nlet sources = network(nest).filter(n => n != nest.name);\nwhile (sources.length > 0) {\nlet source = sources[Math.floor(Math.random() *\n195 sources.length)];\nsources = sources.filter(n => n != source);\ntry {\nlet found = await routeRequest(nest, source, \"storage\",\nname);\nif (found != null) return found;\n} catch (_) {}\n}\nthrow new Error(\"Not found\");\n}\nAn asyncfunction is markedbythe wordasyncbefore the functionkeyword.\nMethods can also be made async by writing async before their name. When\nsuch a function or method is called, it returns a promise. As soon as the body\nreturns something, that promise is resolved. If it throws an exception, the\npromise is rejected.\nInside an async function, the word await can be put in front of an expression\nto wait for a promise to resolve and only then continue the execution of the\nfunction.\nSuch a function no longer, like a regular JavaScript function, runs from start\nto completion in one go. Instead, it can be frozen at any point that has an\nawait, and can be resumed at a later time.\nFor non-trivial asynchronous code, this notation is usually more convenient\nthan directly using promises. Even if you need to do something that doesn\u2019t\nfit the synchronous model, such as perform multiple actions at the same time,\nit is easy to combine await with the direct use of promises.\nGenerators\nThis ability of functions to be paused and then resumed again is not exclusive\nto async functions. JavaScript also has a feature called generator functions.\nThese are similar, but without the promises.\nWhen you define a function with function* (placing an asterisk after the\nword function), it becomes a generator. When you call a generator, it returns\nan iterator, which we already saw in Chapter 6.\nfunction* powers(n) {\nfor (let current = n;; current *= n) {\nyield current;\n}\n}\n196 for (let power of powers(3)) {\nif (power > 50) break;\nconsole.log(power);\n}\n\/\/ \u2192 3\n\/\/ \u2192 9\n\/\/ \u2192 27\nInitially, when you call powers, the function is frozen at its start. Every time\nyou call next on the iterator, the function runs until it hits a yield expression,\nwhich pauses it and causes the yielded value to become the next value produced\nby the iterator. When the function returns (the one in the example never does),\nthe iterator is done.\nWriting iterators is often much easier when you use generator functions. The\niterator for the Group class (from the exercise in Chapter 6) can be written with\nthis generator:\nGroup.prototype[Symbol.iterator] = function*() {\nfor (let i = 0; i < this.members.length; i++) {\nyield this.members[i];\n}\n};\nThere\u2019s no longer a need to create an object to hold the iteration state\u2014\ngenerators automatically save their local state every time they yield.\nSuch yield expressions may occur only directly in the generator function\nitself and not in an inner function you define inside of it. The state a generator\nsaves, when yielding, is only its local environment and the position where it\nyielded.\nAn async function is a special type of generator. It produces a promise when\ncalled, which is resolved when it returns (finishes) and rejected when it throws\nan exception. Whenever it yields (awaits) a promise, the result of that promise\n(value or thrown exception) is the result of the await expression.\nThe event loop\nAsynchronous programs are executed piece bypiece. Each piece may start some\nactions and schedule code to be executed when the action finishes or fails. In\nbetween these pieces, the program sits idle, waiting for the next action.\n197 So callbacks are not directly called by the code that scheduled them. If I\ncall setTimeout from within a function, that function will have returned by the\ntime the callback function is called. And when the callback returns, control\ndoes not go back to the function that scheduled it.\nAsynchronous behavior happens on its own empty function call stack. This\nis one of the reasons that, without promises, managing exceptions across asyn-\nchronous code is hard. Since each callback starts with a mostly empty stack,\nyour catch handlers won\u2019t be on the stack when they throw an exception.\ntry {\nsetTimeout(() => {\nthrow new Error(\"Woosh\");\n}, 20);\n} catch (_) {\n\/\/ This will not run\nconsole.log(\"Caught!\");\n}\nNomatterhowcloselytogetherevents\u2014suchastimeoutsorincomingrequests\u2014\nhappen, a JavaScript environment will run only one program at a time. You\ncan think of this as it running a big loop around your program, called the event\nloop. When there\u2019s nothing to be done, that loop is stopped. But as events\ncome in, they are added to a queue, and their code is executed one after the\nother. Because no two things run at the same time, slow-running code might\ndelay the handling of other events.\nThis example sets a timeout but then dallies until after the timeout\u2019s in-\ntended point of time, causing the timeout to be late.\nlet start = Date.now();\nsetTimeout(() => {\nconsole.log(\"Timeout ran at\", Date.now() - start);\n}, 20);\nwhile (Date.now() < start + 50) {}\nconsole.log(\"Wasted time until\", Date.now() - start);\n\/\/ \u2192 Wasted time until 50\n\/\/ \u2192 Timeout ran at 55\nPromises always resolve or reject as a new event. Even if a promise is already\nresolved, waiting for it will cause your callback to run after the current script\nfinishes, rather than right away.\nPromise.resolve(\"Done\").then(console.log);\n198 console.log(\"Me first!\");\n\/\/ \u2192 Me first!\n\/\/ \u2192 Done\nIn later chapters we\u2019ll see various other types of events that run on the event\nloop.\nAsynchronous bugs\nWhen your program runs synchronously, in a single go, there are no state\nchanges happening except those that the program itself makes. For asyn-\nchronous programs this is different\u2014they may have gaps in their execution\nduring which other code can run.\nLet\u2019s look at an example. One of the hobbies of our crows is to count the\nnumber of chicks that hatch throughout the village every year. Nests store this\ncount in their storage bulbs. The following code tries to enumerate the counts\nfrom all the nests for a given year:\nfunction anyStorage(nest, source, name) {\nif (source == nest.name) return storage(nest, name);\nelse return routeRequest(nest, source, \"storage\", name);\n}\nasync function chicks(nest, year) {\nlet list = \"\";\nawait Promise.all(network(nest).map(async name => {\nlist += `${name}: ${\nawait anyStorage(nest, name, `chicks in ${year}`)\n}\\n`;\n}));\nreturn list;\n}\nThe async name => part shows that arrow functions can also be made async\nby putting the word async in front of them.\nThe code doesn\u2019t immediately look suspicious...it maps the async arrow\nfunction over the set of nests, creating an array of promises, and then uses\nPromise.all to wait for all of these before returning the list they build up.\nBut it is seriously broken. It\u2019ll always return only a single line of output,\nlisting the nest that was slowest to respond.\nCan you work out why?\n199 The problem lies in the += operator, which takes the current value of list\nat the time where the statement starts executing and then, when the await\nfinishes, sets the list binding to be that value plus the added string.\nBut between the time where the statement starts executing and the time\nwhere it finishes there\u2019s an asynchronous gap. The map expression runs before\nanything has been added to the list, so each of the += operators starts from an\nempty string and ends up, when its storage retrieval finishes, setting list to a\nsingle-line list\u2014the result of adding its line to the empty string.\nThis could have easily been avoided by returning the lines from the mapped\npromises and calling join on the result of Promise.all, instead of building\nup the list by changing a binding. As usual, computing new values is less\nerror-prone than changing existing values.\nasync function chicks(nest, year) {\nlet lines = network(nest).map(async name => {\nreturn name + \": \" +\nawait anyStorage(nest, name, `chicks in ${year}`);\n});\nreturn (await Promise.all(lines)).join(\"\\n\");\n}\nMistakes like this are easy to make, especially when using await, and you\nshould be aware of where the gaps in your code occur. An advantage of\nJavaScript\u2019s explicit asynchronicity (whether through callbacks, promises, or\nawait) is that spotting these gaps is relatively easy.\nSummary\nAsynchronous programming makes it possible to express waiting for long-\nrunning actions without freezing the program during these actions. JavaScript\nenvironments typically implement this style of programming using callbacks,\nfunctions that are called when the actions complete. An event loop schedules\nsuch callbacks to be called when appropriate, one after the other, so that their\nexecution does not overlap.\nProgramming asynchronously is made easier by promises, objects that rep-\nresent actions that might complete in the future, and async functions, which\nallow you to write an asynchronous program as if it were synchronous.\n200 Exercises\nTracking the scalpel\nThe village crows own an old scalpel that they occasionally use on special\nmissions\u2014say, to cut through screen doors or packaging. To be able to quickly\ntrack it down, every time the scalpel is moved to another nest, an entry is\nadded to the storage of both the nest that had it and the nest that took it,\nunder the name \"scalpel\", with its new location as the value.\nThis means that finding the scalpel is a matter of following the breadcrumb\ntrail of storage entries, until you find a nest where that points at the nest itself.\nWrite an async function locateScalpel that does this, starting at the nest\non which it runs. You can use the anyStorage function defined earlier to access\nstorage in arbitrary nests. The scalpel has been going around long enough that\nyou may assume that every nest has a \"scalpel\" entry in its data storage.\nNext, write the same function again without using async and await.\nDo request failures properly show up as rejections of the returned promise\nin both versions? How?\nBuilding Promise.all\nGiven an array of promises, Promise.all returns a promise that waits for all of\nthe promises in the array to finish. It then succeeds, yielding an array of result\nvalues. If a promise in the array fails, the promise returned by all fails too,\nwith the failure reason from the failing promise.\nImplementsomethinglikethisyourselfasaregularfunctioncalledPromise_all\n.\nRemember that after a promise has succeeded or failed, it can\u2019t succeed or\nfail again, and further calls to the functions that resolve it are ignored. This\ncan simplify the way you handle failure of your promise.\n201 \u201cThe evaluator, which determines the meaning of expressions in a\nprogramming language, is just another program.\u201d\n\u2014Hal Abelson and Gerald Sussman, Structure and Interpretation of\nComputer Programs\nChapter12\nProject: A Programming Language\nBuilding your own programming language is surprisingly easy (as long as you\ndo not aim too high) and very enlightening.\nThe main thing I want to show in this chapter is that there is no magic\ninvolved in building your own language. I\u2019ve often felt that some human in-\nventions were so immensely clever and complicated that I\u2019d never be able to\nunderstand them. But with a little reading and experimenting, they often turn\nout to be quite mundane.\nWe will build a programming language called Egg. It will be a tiny, simple\nlanguage\u2014but one that is powerful enough to express any computation you\ncan think of. It will allow simple abstraction based on functions.\nParsing\nThe most immediately visible part of a programming language is its syntax, or\nnotation. A parser is a program that reads a piece of text and produces a data\nstructure that reflects the structure of the program contained in that text. If\nthe text does not form a valid program, the parser should point out the error.\nOur language will have a simple and uniform syntax. Everything in Egg\nis an expression. An expression can be the name of a binding, a number, a\nstring, or an application. Applications are used for function calls but also for\nconstructs such as if or while.\nTo keep the parser simple, strings in Egg do not support anything like back-\nslash escapes. A string is simply a sequence of characters that are not double\nquotes, wrapped in double quotes. A number is a sequence of digits. Binding\nnames can consist of any character that is not whitespace and that does not\nhave a special meaning in the syntax.\nApplications are written the way they are in JavaScript, by putting paren-\ntheses after an expression and having any number of arguments between those\nparentheses, separated by commas.\ndo(define(x, 10),\n202 if(>(x, 5),\nprint(\"large\"),\nprint(\"small\")))\nThe uniformity of the Egg language means that things that are operators in\nJavaScript (such as >) are normal bindings in this language, applied just like\nother functions. And since the syntax has no concept of a block, we need a do\nconstruct to represent doing multiple things in sequence.\nThe data structure that the parser will use to describe a program consists\nof expression objects, each of which has a type property indicating the kind of\nexpression it is and other properties to describe its content.\nExpressions of type \"value\"represent literal strings or numbers. Their value\nproperty contains the string or number value that they represent. Expressions\nof type \"word\" are used for identifiers (names). Such objects have a name prop-\nerty that holds the identifier\u2019s name as a string. Finally, \"apply\" expressions\nrepresent applications. They have an operator property that refers to the ex-\npression that is being applied, as well as an args property that holds an array\nof argument expressions.\nThe >(x, 5) part of the previous program would be represented like this:\n{\ntype: \"apply\",\noperator: {type: \"word\", name: \">\"},\nargs: [\n{type: \"word\", name: \"x\"},\n{type: \"value\", value: 5}\n]\n}\nSuch a data structure is called a syntax tree. If you imagine the objects as\ndots and the links between them as lines between those dots, it has a treelike\nshape. The fact that expressions contain other expressions, which in turn\nmight contain more expressions, is similar to the way tree branches split and\nsplit again.\n203 do\ndefine\nx\n10\nif\n>\nx\n5\nprint\n\"large\"\nprint\n\"small\"\nContrast this to the parser we wrote for the configuration file format in\nChapter 9, which had a simple structure: it split the input into lines and\nhandled those lines one at a time. There were only a few simple forms that a\nline was allowed to have.\nHere we must find a different approach. Expressions are not separated into\nlines, and they have a recursive structure. Application expressions contain\nother expressions.\nFortunately, thisproblemcanbesolvedverywellbywritingaparserfunction\nthat is recursive in a way that reflects the recursive nature of the language.\nWe define a function parseExpression, which takes a string as input and\nreturns an object containing the data structure for the expression at the start\nof the string, along with the part of the string left after parsing this expression.\nWhen parsing subexpressions (the argument to an application, for example),\nthis function can be called again, yielding the argument expression as well as\nthe text that remains. This text may in turn contain more arguments or may\nbe the closing parenthesis that ends the list of arguments.\nThis is the first part of the parser:\nfunction parseExpression(program) {\nprogram = skipSpace(program);\nlet match, expr;\nif (match = \/^\"([^\"]*)\"\/.exec(program)) {\nexpr = {type: \"value\", value: match[1]};\n} else if (match = \/^\\d+\\b\/.exec(program)) {\nexpr = {type: \"value\", value: Number(match[0])};\n} else if (match = \/^[^\\s(),#\"]+\/.exec(program)) {\nexpr = {type: \"word\", name: match[0]};\n} else {\n204 throw new SyntaxError(\"Unexpected syntax: \" + program);\n}\nreturn parseApply(expr, program.slice(match[0].length));\n}\nfunction skipSpace(string) {\nlet first = string.search(\/\\S\/);\nif (first == -1) return \"\";\nreturn string.slice(first);\n}\nBecause Egg, like JavaScript, allows any amount of whitespace between its\nelements, we have to repeatedly cut the whitespace off the start of the program\nstring. That is what the skipSpace function helps with.\nAfter skipping any leading space, parseExpression uses three regular expres-\nsions to spot the three atomic elements that Egg supports: strings, numbers,\nand words. The parser constructs a different kind of data structure depending\non which one matches. If the input does not match one of these three forms, it\nis not a valid expression, and the parser throws an error. We use SyntaxError\ninstead of Error as the exception constructor, which is another standard error\ntype, because it is a little more specific\u2014it is also the error type thrown when\nan attempt is made to run an invalid JavaScript program.\nWe then cut off the part that was matched from the program string and\npass that, along with the object for the expression, to parseApply, which checks\nwhether the expression is an application. If so, it parses a parenthesized list of\narguments.\nfunction parseApply(expr, program) {\nprogram = skipSpace(program);\nif (program[0] != \"(\") {\nreturn {expr: expr, rest: program};\n}\nprogram = skipSpace(program.slice(1));\nexpr = {type: \"apply\", operator: expr, args: []};\nwhile (program[0] != \")\") {\nlet arg = parseExpression(program);\nexpr.args.push(arg.expr);\nprogram = skipSpace(arg.rest);\nif (program[0] == \",\") {\nprogram = skipSpace(program.slice(1));\n} else if (program[0] != \")\") {\n205 throw new SyntaxError(\"Expected ',' or ')'\");\n}\n}\nreturn parseApply(expr, program.slice(1));\n}\nIf the next character in the program is not an opening parenthesis, this is\nnot an application, and parseApply returns the expression it was given.\nOtherwise, itskipstheopeningparenthesisandcreatesthesyntaxtreeobject\nfor this application expression. It then recursively calls parseExpression to\nparse each argument until a closing parenthesis is found. The recursion is\nindirect, through parseApply and parseExpression calling each other.\nBecauseanapplicationexpressioncanitselfbeapplied(suchasinmultiplier\n(2)(1)), parseApply must, after it has parsed an application, call itself again\nto check whether another pair of parentheses follows.\nThis is all we need to parse Egg. We wrap it in a convenient parse func-\ntion that verifies that it has reached the end of the input string after parsing\nthe expression (an Egg program is a single expression), and that gives us the\nprogram\u2019s data structure.\nfunction parse(program) {\nlet {expr, rest} = parseExpression(program);\nif (skipSpace(rest).length > 0) {\nthrow new SyntaxError(\"Unexpected text after program\");\n}\nreturn expr;\n}\nconsole.log(parse(\"+(a, 10)\"));\n\/\/ \u2192 {type: \"apply\",\n\/\/ operator: {type: \"word\", name: \"+\"},\n\/\/ args: [{type: \"word\", name: \"a\"},\n\/\/ {type: \"value\", value: 10}]}\nIt works! It doesn\u2019t give us very helpful information when it fails and doesn\u2019t\nstore the line and column on which each expression starts, which might be\nhelpful when reporting errors later, but it\u2019s good enough for our purposes.\n206 The evaluator\nWhat can we do with the syntax tree for a program? Run it, of course! And\nthat is what the evaluator does. You give it a syntax tree and a scope object\nthat associates names with values, and it will evaluate the expression that the\ntree represents and return the value that this produces.\nconst specialForms = Object.create(null);\nfunction evaluate(expr, scope) {\nif (expr.type == \"value\") {\nreturn expr.value;\n} else if (expr.type == \"word\") {\nif (expr.name in scope) {\nreturn scope[expr.name];\n} else {\nthrow new ReferenceError(\n`Undefined binding: ${expr.name}`);\n}\n} else if (expr.type == \"apply\") {\nlet {operator, args} = expr;\nif (operator.type == \"word\" &&\noperator.name in specialForms) {\nreturn specialForms[operator.name](expr.args, scope);\n} else {\nlet op = evaluate(operator, scope);\nif (typeof op == \"function\") {\nreturn op(...args.map(arg => evaluate(arg, scope)));\n} else {\nthrow new TypeError(\"Applying a non-function.\");\n}\n}\n}\n}\nThe evaluator has code for each of the expression types. A literal value\nexpression produces its value. (For example, the expression 100 just evaluates\nto the number 100.) For a binding, we must check whether it is actually defined\nin the scope and, if it is, fetch the binding\u2019s value.\nApplications are more involved. If they are a special form, like if, we do not\nevaluate anything and pass the argument expressions, along with the scope,\nto the function that handles this form. If it is a normal call, we evaluate the\noperator, verify that it is a function, and call it with the evaluated arguments.\n207 We use plain JavaScript function values to represent Egg\u2019s function values.\nWe will come back to this later, when the special form called fun is defined.\nThe recursive structure of evaluate resembles the similar structure of the\nparser, and both mirror the structure of the language itself. It would also be\npossible to integrate the parser with the evaluator and evaluate during parsing,\nbut splitting them up this way makes the program clearer.\nThis is really all that is needed to interpret Egg. It is that simple. But\nwithout defining a few special forms and adding some useful values to the\nenvironment, you can\u2019t do much with this language yet.\nSpecial forms\nThe specialForms object is used to define special syntax in Egg. It associates\nwords with functions that evaluate such forms. It is currently empty. Let\u2019s add\nif.\nspecialForms.if = (args, scope) => {\nif (args.length != 3) {\nthrow new SyntaxError(\"Wrong number of args to if\");\n} else if (evaluate(args[0], scope) !== false) {\nreturn evaluate(args[1], scope);\n} else {\nreturn evaluate(args[2], scope);\n}\n};\nEgg\u2019s if construct expects exactly three arguments. It will evaluate the first,\nand if the result isn\u2019t the value false, it will evaluate the second. Otherwise,\nthe third gets evaluated. This if form is more similar to JavaScript\u2019s ternary\n?: operator than to JavaScript\u2019s if. It is an expression, not a statement, and\nit produces a value, namely, the result of the second or third argument.\nEgg also differs from JavaScript in how it handles the condition value to if.\nIt will not treat things like zero or the empty string as false, only the precise\nvalue false.\nThe reason we need to represent if as a special form, rather than a regular\nfunction, is that all arguments to functions are evaluated before the function is\ncalled, whereas if should evaluate only either its second or its third argument,\ndepending on the value of the first.\nThe while form is similar.\nspecialForms.while = (args, scope) => {\n208 if (args.length != 2) {\nthrow new SyntaxError(\"Wrong number of args to while\");\n}\nwhile (evaluate(args[0], scope) !== false) {\nevaluate(args[1], scope);\n}\n\/\/ Since undefined does not exist in Egg, we return false,\n\/\/ for lack of a meaningful result.\nreturn false;\n};\nAnother basic building block is do, which executes all its arguments from\ntop to bottom. Its value is the value produced by the last argument.\nspecialForms.do = (args, scope) => {\nlet value = false;\nfor (let arg of args) {\nvalue = evaluate(arg, scope);\n}\nreturn value;\n};\nTo be able to create bindings and give them new values, we also create a\nform called define. It expects a word as its first argument and an expression\nproducing the value to assign to that word as its second argument. Since\ndefine, like everything, is an expression, it must return a value. We\u2019ll make it\nreturn the value that was assigned (just like JavaScript\u2019s = operator).\nspecialForms.define = (args, scope) => {\nif (args.length != 2 || args[0].type != \"word\") {\nthrow new SyntaxError(\"Incorrect use of define\");\n}\nlet value = evaluate(args[1], scope);\nscope[args[0].name] = value;\nreturn value;\n};\n209 The environment\nThe scope accepted by evaluate is an object with properties whose names\ncorrespond to binding names and whose values correspond to the values those\nbindings are bound to. Let\u2019s define an object to represent the global scope.\nTo be able to use the if construct we just defined, we must have access\nto Boolean values. Since there are only two Boolean values, we do not need\nspecial syntax for them. We simply bind two names to the values true and\nfalse and use them.\nconst topScope = Object.create(null);\ntopScope.true = true;\ntopScope.false = false;\nWe can now evaluate a simple expression that negates a Boolean value.\nlet prog = parse(`if(true, false, true)`);\nconsole.log(evaluate(prog, topScope));\n\/\/ \u2192 false\nTo supply basic arithmetic and comparison operators, we will also add some\nfunction values to the scope. In the interest of keeping the code short, we\u2019ll\nuse Function to synthesize a bunch of operator functions in a loop, instead of\ndefining them individually.\nfor (let op of [\"+\", \"-\", \"*\", \"\/\", \"==\", \"<\", \">\"]) {\ntopScope[op] = Function(\"a, b\", `return a ${op} b;`);\n}\nA way to output values is also useful, so we\u2019ll wrap console.log in a function\nand call it print.\ntopScope.print = value => {\nconsole.log(value);\nreturn value;\n};\nThat gives us enough elementary tools to write simple programs. The fol-\nlowing function provides a convenient way to parse a program and run it in a\nfresh scope:\n210 function run(program) {\nreturn evaluate(parse(program), Object.create(topScope));\n}\nWe\u2019ll use object prototype chains to represent nested scopes so that the\nprogram can add bindings to its local scope without changing the top-level\nscope.\nrun(`\ndo(define(total, 0),\ndefine(count, 1),\nwhile(<(count, 11),\ndo(define(total, +(total, count)),\ndefine(count, +(count, 1)))),\nprint(total))\n`);\n\/\/ \u2192 55\nThis is the program we\u2019ve seen several times before, which computes the\nsum of the numbers 1 to 10, expressed in Egg. It is clearly uglier than the\nequivalent JavaScript program\u2014but not bad for a language implemented in\nless than 150 lines of code.\nFunctions\nA programming language without functions is a poor programming language\nindeed.\nFortunately, it isn\u2019t hard to add a fun construct, which treats its last argu-\nment as the function\u2019s body and uses all arguments before that as the names\nof the function\u2019s parameters.\nspecialForms.fun = (args, scope) => {\nif (!args.length) {\nthrow new SyntaxError(\"Functions need a body\");\n}\nlet body = args[args.length - 1];\nlet params = args.slice(0, args.length - 1).map(expr => {\nif (expr.type != \"word\") {\nthrow new SyntaxError(\"Parameter names must be words\");\n}\nreturn expr.name;\n});\n211 return function() {\nif (arguments.length != params.length) {\nthrow new TypeError(\"Wrong number of arguments\");\n}\nlet localScope = Object.create(scope);\nfor (let i = 0; i < arguments.length; i++) {\nlocalScope[params[i]] = arguments[i];\n}\nreturn evaluate(body, localScope);\n};\n};\nFunctions in Egg get their own local scope. The function produced by the\nfun form creates this local scope and adds the argument bindings to it. It then\nevaluates the function body in this scope and returns the result.\nrun(`\ndo(define(plusOne, fun(a, +(a, 1))),\nprint(plusOne(10)))\n`);\n\/\/ \u2192 11\nrun(`\ndo(define(pow, fun(base, exp,\nif(==(exp, 0),\n1,\n*(base, pow(base, -(exp, 1)))))),\nprint(pow(2, 10)))\n`);\n\/\/ \u2192 1024\nCompilation\nWhat we have built is an interpreter. During evaluation, it acts directly on the\nrepresentation of the program produced by the parser.\nCompilation is the process of adding another step between the parsing and\nthe running of a program, which transforms the program into something that\ncan be evaluated more e\ufb00iciently by doing as much work as possible in advance.\nFor example, in well-designed languages it is obvious, for each use of a binding,\nwhich binding is being referred to, without actually running the program. This\n212 can be used to avoid looking up the binding by name every time it is accessed,\ninstead directly fetching it from some predetermined memory location.\nTraditionally, compilation involves converting the program to machine code,\nthe raw format that a computer\u2019s processor can execute. But any process\nthat converts a program to a different representation can be thought of as\ncompilation.\nIt would be possible to write an alternative evaluation strategy for Egg,\none that first converts the program to a JavaScript program, uses Function\nto invoke the JavaScript compiler on it, and then runs the result. When\ndone right, this would make Egg run very fast while still being quite simple to\nimplement.\nIf you are interested in this topic and willing to spend some time on it, I\nencourage you to try to implement such a compiler as an exercise.\nCheating\nWhen we defined if and while, you probably noticed that they were more\nor less trivial wrappers around JavaScript\u2019s own if and while. Similarly, the\nvalues in Egg are just regular old JavaScript values.\nIf you compare the implementation of Egg, built on top of JavaScript, with\nthe amount of work and complexity required to build a programming language\ndirectly on the raw functionality provided by a machine, the difference is huge.\nRegardless, this example ideally gave you an impression of the way program-\nming languages work.\nAndwhenitcomestogettingsomethingdone, cheatingismoreeffectivethan\ndoing everything yourself. Though the toy language in this chapter doesn\u2019t do\nanything that couldn\u2019t be done better in JavaScript, there are situations where\nwriting small languages helps get real work done.\nSuch a language does not have to resemble a typical programming language.\nIf JavaScript didn\u2019t come equipped with regular expressions, for example, you\ncould write your own parser and evaluator for regular expressions.\nOr imagine you are building a giant robotic dinosaur and need to program\nits behavior. JavaScript might not be the most effective way to do this. You\nmight instead opt for a language that looks like this:\nbehavior walk\nperform when\ndestination ahead\nactions\nmove left-foot\n213 move right-foot\nbehavior attack\nperform when\nGodzilla in-view\nactions\nfire laser-eyes\nlaunch arm-rockets\nThis is what is usually called a domain-specific language, a language tai-\nlored to express a narrow domain of knowledge. Such a language can be more\nexpressive than a general-purpose language because it is designed to describe\nexactly the things that need to be described in its domain, and nothing else.\nExercises\nArrays\nAdd support for arrays to Egg by adding the following three functions to the\ntop scope: array(...values) to construct an array containing the argument\nvalues, length(array) to get an array\u2019s length, and element(array, n) to fetch\nthe nth element from an array.\nClosure\nThe way we have defined fun allows functions in Egg to reference the surround-\ning scope, allowing the function\u2019s body to use local values that were visible at\nthe time the function was defined, just like JavaScript functions do.\nThe following program illustrates this: function f returns a function that\nadds its argument to f\u2019s argument, meaning that it needs access to the local\nscope inside f to be able to use binding a.\nrun(`\ndo(define(f, fun(a, fun(b, +(a, b)))),\nprint(f(4)(5)))\n`);\n\/\/ \u2192 9\nGo back to the definition of the fun form and explain which mechanism\ncauses this to work.\n214 Comments\nIt would be nice if we could write comments in Egg. For example, whenever\nwe find a hash sign (#), we could treat the rest of the line as a comment and\nignore it, similar to \/\/ in JavaScript.\nWe do not have to make any big changes to the parser to support this. We\ncan simply change skipSpace to skip comments as if they are whitespace so that\nall the points where skipSpace is called will now also skip comments. Make\nthis change.\nFixing scope\nCurrently, the only way to assign a binding a value is define. This construct\nacts as a way both to define new bindings and to give existing ones a new value.\nThis ambiguity causes a problem. When you try to give a nonlocal binding\na new value, you will end up defining a local one with the same name instead.\nSome languages work like this by design, but I\u2019ve always found it an awkward\nway to handle scope.\nAdd a special form set, similar to define, which gives a binding a new value,\nupdating the binding in an outer scope if it doesn\u2019t already exist in the inner\nscope. If the binding is not defined at all, throw a ReferenceError (another\nstandard error type).\nThe technique of representing scopes as simple objects, which has made\nthings convenient so far, will get in your way a little at this point. You might\nwant to use the Object.getPrototypeOf function, which returns the prototype\nof an object. Also remember that scopes do not derive from Object.prototype,\nso if you want to call hasOwnProperty on them, you have to use this clumsy\nexpression:\nObject.prototype.hasOwnProperty.call(scope, name);\n215 \u201cThe dream behind the Web is of a common information space in\nwhich we communicate by sharing information. Its universality is\nessential: the fact that a hypertext link can point to anything, be it\npersonal, local or global, be it draft or highly polished.\u201d\n\u2014Tim Berners-Lee, The World Wide Web: A very short personal\nhistory\nChapter13\nJavaScript and the Browser\nThe next chapters of this book will talk about web browsers. Without web\nbrowsers, there would be no JavaScript. Or even if there were, no one would\never have paid any attention to it.\nWeb technology has been decentralized from the start, not just technically\nbut also in the way it evolved. Various browser vendors have added new func-\ntionality in ad hoc and sometimes poorly thought-out ways, which then, some-\ntimes, ended up being adopted by others\u2014and finally set down as in standards.\nThis is both a blessing and a curse. On the one hand, it is empowering to\nnot have a central party control a system but have it be improved by various\nparties working in loose collaboration (or occasionally open hostility). On the\nother hand, the haphazard way in which the Web was developed means that\nthe resulting system is not exactly a shining example of internal consistency.\nSome parts of it are downright confusing and poorly conceived.\nNetworks and the Internet\nComputer networks have been around since the 1950s. If you put cables be-\ntween two or more computers and allow them to send data back and forth\nthrough these cables, you can do all kinds of wonderful things.\nAnd if connecting two machines in the same building allows us to do won-\nderful things, connecting machines all over the planet should be even better.\nThe technology to start implementing this vision was developed in the 1980s,\nand the resulting network is called the Internet. It has lived up to its promise.\nA computer can use this network to shoot bits at another computer. For\nany effective communication to arise out of this bit-shooting, the computers on\nboth ends must know what the bits are supposed to represent. The meaning\nof any given sequence of bits depends entirely on the kind of thing that it is\ntrying to express and on the encoding mechanism used.\nA network protocol describes a style of communication over a network. There\nare protocols for sending email, for fetching email, for sharing files, and even\n216 for controlling computers that happen to be infected by malicious software.\nFor example, the Hypertext Transfer Protocol (HTTP) is a protocol for re-\ntrievingnamedresources(chunksofinformation, suchaswebpagesorpictures).\nIt specifies that the side making the request should start with a line like this,\nnaming the resource and the version of the protocol that it is trying to use:\nGET \/index.html HTTP\/1.1\nThere are a lot more rules about the way the requester can include more\ninformation in the request and the way the other side, which returns the re-\nsource, packages up its content. We\u2019ll look at HTTP in a little more detail in\nChapter 18.\nMost protocols are built on top of other protocols. HTTP treats the network\nas a streamlike device into which you can put bits and have them arrive at the\ncorrect destination in the correct order. As we saw in Chapter 11, ensuring\nthose things is already a rather di\ufb00icult problem.\nThe Transmission Control Protocol (TCP) is a protocol that addresses this\nproblem. All Internet-connected devices \u201cspeak\u201d it, and most communication\non the Internet is built on top of it.\nA TCP connection works as follows: one computer must be waiting, or\nlistening, for other computers to start talking to it. To be able to listen for\ndifferent kinds of communication at the same time on a single machine, each\nlistener has a number (called a port) associated with it. Most protocols specify\nwhich port should be used by default. For example, when we want to send\nan email using the SMTP protocol, the machine through which we send it is\nexpected to be listening on port 25.\nAnother computer can then establish a connection by connecting to the\ntarget machine using the correct port number. If the target machine can be\nreached and is listening on that port, the connection is successfully created.\nThe listening computer is called the server, and the connecting computer is\ncalled the client.\nSuch a connection acts as a two-way pipe through which bits can flow\u2014the\nmachines on both ends can put data into it. Once the bits are successfully\ntransmitted, they can be read out again by the machine on the other side.\nThis is a convenient model. You could say that TCP provides an abstraction\nof the network.\n217 The Web\nThe World Wide Web (not to be confused with the Internet as a whole) is a\nset of protocols and formats that allow us to visit web pages in a browser. The\n\u201cWeb\u201d part in the name refers to the fact that such pages can easily link to\neach other, thus connecting into a huge mesh that users can move through.\nTo become part of the Web, all you need to do is connect a machine to the\nInternet and have it listen on port 80 with the HTTP protocol so that other\ncomputers can ask it for documents.\nEach document on the Web is named by a Uniform Resource Locator (URL),\nwhich looks something like this:\nhttp:\/\/eloquentjavascript.net\/13_browser.html\n| | | |\nprotocol server path\nThe first part tells us that this URL uses the HTTP protocol (as opposed to,\nfor example, encrypted HTTP, which would be https:\/\/). Then comes the part\nthat identifies which server we are requesting the document from. Last is a\npath string that identifies the specific document (or resource) we are interested\nin.\nMachines connected to the Internet get an IP address, which is a number\nthat can be used to send messages to that machine, and looks something like\n149.210.142.219 or 2001:4860:4860::8888. But lists of more or less random\nnumbers are hard to remember and awkward to type, so you can instead reg-\nister a domain name for a specific address or set of addresses. I registered\neloquentjavascript.net to point at the IP address of a machine I control and\ncan thus use that domain name to serve web pages.\nIf you type this URL into your browser\u2019s address bar, the browser will try\nto retrieve and display the document at that URL. First, your browser has to\nfind out what address eloquentjavascript.net refers to. Then, using the HTTP\nprotocol, it will make a connection to the server at that address and ask for the\nresource \/13_browser.html. If all goes well, the server sends back a document,\nwhich your browser then displays on your screen.\nHTML\nHTML, which stands for Hypertext Markup Language, is the document format\nused for web pages. An HTML document contains text, as well as tags that\n218 give structure to the text, describing things such as links, paragraphs, and\nheadings.\nA short HTML document might look like this:\n<!doctype html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>My home page<\/title>\n<\/head>\n<body>\n<h1>My home page<\/h1>\n<p>Hello, I am Marijn and this is my home page.<\/p>\n<p>I also wrote a book! Read it\n<a href=\"http:\/\/eloquentjavascript.net\">here<\/a>.<\/p>\n<\/body>\n<\/html>\nThis is what such a document would look like in the browser:\nThe tags, wrapped in angle brackets (< and >, the symbols for less than and\ngreater than), provide information about the structure of the document. The\nother text is just plain text.\nThe document starts with <!doctype html>, which tells the browser to in-\nterpret the page as modern HTML, as opposed to various dialects that were in\nuse in the past.\nHTML documents have a head and a body. The head contains information\nabout the document, and the body contains the document itself. In this case,\nthe head declares that the title of this document is \u201cMy home page\u201d and that it\nuses the UTF-8 encoding, which is a way to encode Unicode text as binary data.\nThe document\u2019s body contains a heading (<h1>, meaning \u201cheading 1\u201d\u2014<h2> to\n<h6> produce subheadings) and two paragraphs (<p>).\nTags come in several forms. An element, such as the body, a paragraph, or a\nlink, is started by an opening tag like <p> and ended by a closing tag like <\/p>.\nSome opening tags, such as the one for the link (<a>), contain extra information\nin the form of name=\"value\" pairs. These are called attributes. In this case,\n219 the destination of the link is indicated with href=\"http:\/\/eloquentjavascript\n.net\", where href stands for \u201chypertext reference\u201d.\nSome kinds of tags do not enclose anything and thus do not need to be\nclosed. The metadata tag <meta charset=\"utf-8\"> is an example of this.\nTo be able to include angle brackets in the text of a document, even though\nthey have a special meaning in HTML, yet another form of special notation\nhas to be introduced. A plain opening angle bracket is written as &lt; (\u201cless\nthan\u201d), and a closing bracket is written as &gt; (\u201cgreater than\u201d). In HTML, an\nampersand (&) character followed by a name or character code and a semicolon\n(;) is called an entity and will be replaced by the character it encodes.\nThis is analogous to the way backslashes are used in JavaScript strings.\nSince this mechanism gives ampersand characters a special meaning, too, they\nneed to be escaped as &amp;. Inside attribute values, which are wrapped in\ndouble quotes, &quot; can be used to insert an actual quote character.\nHTML is parsed in a remarkably error-tolerant way. When tags that should\nbe there are missing, the browser reconstructs them. The way in which this is\ndone has been standardized, and you can rely on all modern browsers to do it\nin the same way.\nThe following document will be treated just like the one shown previously:\n<!doctype html>\n<meta charset=utf-8>\n<title>My home page<\/title>\n<h1>My home page<\/h1>\n<p>Hello, I am Marijn and this is my home page.\n<p>I also wrote a book! Read it\n<a href=http:\/\/eloquentjavascript.net>here<\/a>.\nThe <html>, <head>, and <body> tags are gone completely. The browser\nknows that <meta> and <title> belong in the head and that <h1> means the\nbody has started. Furthermore, I am no longer explicitly closing the para-\ngraphs since opening a new paragraph or ending the document will close them\nimplicitly. The quotes around the attribute values are also gone.\nThis book will usually omit the <html>, <head>, and <body> tags from ex-\namples to keep them short and free of clutter. But I will close tags and include\nquotes around attributes.\nI will also usually omit the doctype and charset declaration. This is not to\nbe taken as an encouragement to drop these from HTML documents. Browsers\nwill often do ridiculous things when you forget them. You should consider the\n220 doctype and the charset metadata to be implicitly present in examples, even\nwhen they are not actually shown in the text.\nHTML and JavaScript\nIn the context of this book, the most important HTML tag is <script>. This\ntag allows us to include a piece of JavaScript in a document.\n<h1>Testing alert<\/h1>\n<script>alert(\"hello!\");<\/script>\nSuch a script will run as soon as its <script> tag is encountered while the\nbrowser reads the HTML. This page will pop up a dialog when opened\u2014the\nalert function resembles prompt, in that it pops up a little window, but only\nshows a message without asking for input.\nIncluding large programs directly in HTML documents is often impractical.\nThe <script> tag can be given an src attribute to fetch a script file (a text file\ncontaining a JavaScript program) from a URL.\n<h1>Testing alert<\/h1>\n<script src=\"code\/hello.js\"><\/script>\nThe code\/hello.js file included here contains the same program\u2014alert(\"\nhello!\"). When an HTML page references other URLs as part of itself\u2014for\nexample, an image file or a script\u2014web browsers will retrieve them immediately\nand include them in the page.\nA script tag must always be closed with <\/script>, even if it refers to a\nscript file and doesn\u2019t contain any code. If you forget this, the rest of the page\nwill be interpreted as part of the script.\nYou can load ES modules (see Chapter 10) in the browser by giving your\nscript tag a type=\"module\" attribute. Such modules can depend on other mod-\nules by using URLs relative to themselves as module names in import declara-\ntions.\nSome attributes can also contain a JavaScript program. The <button> tag\nshown next (which shows up as a button) has an onclick attribute. The\nattribute\u2019s value will be run whenever the button is clicked.\n<button onclick=\"alert('Boom!');\">DO NOT PRESS<\/button>\n221 Note that I had to use single quotes for the string in the onclick attribute\nbecause double quotes are already used to quote the whole attribute. I could\nalso have used &quot;.\nIn the sandbox\nRunning programs downloaded from the Internet is potentially dangerous. You\ndo not know much about the people behind most sites you visit, and they do\nnot necessarily mean well. Running programs by people who do not mean well\nis how you get your computer infected by viruses, your data stolen, and your\naccounts hacked.\nYet the attraction of the Web is that you can browse it without necessarily\ntrusting all the pages you visit. This is why browsers severely limit the things\na JavaScript program may do: it can\u2019t look at the files on your computer or\nmodify anything not related to the web page it was embedded in.\nIsolating a programming environment in this way is called sandboxing, the\nidea being that the program is harmlessly playing in a sandbox. But you should\nimagine this particular kind of sandbox as having a cage of thick steel bars over\nit so that the programs playing in it can\u2019t actually get out.\nThe hard part of sandboxing is allowing the programs enough room to be\nuseful yet at the same time restricting them from doing anything dangerous.\nLots of useful functionality, such as communicating with other servers or read-\ning the content of the copy-paste clipboard, can also be used to do problematic,\nprivacy-invading things.\nEvery now and then, someone comes up with a new way to circumvent the\nlimitations of a browser and do something harmful, ranging from leaking minor\nprivate information to taking over the whole machine that the browser runs on.\nThe browser developers respond by fixing the hole, and all is well again\u2014until\nthe next problem is discovered, and hopefully publicized, rather than secretly\nexploited by some government agency or mafia.\nCompatibility and the browser wars\nIn the early stages of the Web, a browser called Mosaic dominated the mar-\nket. After a few years, the balance shifted to Netscape, which was then, in\nturn, largely supplanted by Microsoft\u2019s Internet Explorer. At any point where\na single browser was dominant, that browser\u2019s vendor would feel entitled to\nunilaterally invent new features for the Web. Since most users used the most\n222 popular browser, websites would simply start using those features\u2014never mind\nthe other browsers.\nThis was the dark age of compatibility, often called the browser wars. Web\ndevelopers were left with not one unified Web but two or three incompatible\nplatforms. To make things worse, the browsers in use around 2003 were all full\nof bugs, and of course the bugs were different for each browser. Life was hard\nfor people writing web pages.\nMozilla Firefox, a not-for-profit offshoot of Netscape, challenged Internet\nExplorer\u2019s position in the late 2000s. Because Microsoft was not particularly\ninterested in staying competitive at the time, Firefox took a lot of market share\naway from it. Around the same time, Google introduced its Chrome browser,\nand Apple\u2019s Safari browser gained popularity, leading to a situation where there\nwere four major players, rather than one.\nThe new players had a more serious attitude toward standards and better\nengineering practices, giving us less incompatibility and fewer bugs. Microsoft,\nseeing its market share crumble, came around and adopted these attitudes in\nits Edge browser, which replaces Internet Explorer. If you are starting to learn\nweb development today, consider yourself lucky. The latest versions of the\nmajor browsers behave quite uniformly and have relatively few bugs.\n223 \u201cToo bad! Same old story! Once you\u2019ve finished building your house\nyou notice you\u2019ve accidentally learned something that you really\nshould have known\u2014before you started.\u201d\n\u2014Friedrich Nietzsche, Beyond Good and Evil\nChapter14\nThe Document Object Model\nWhen you open a web page in your browser, the browser retrieves the page\u2019s\nHTML text and parses it, much like the way our parser from Chapter 12 parsed\nprograms. The browser builds up a model of the document\u2019s structure and uses\nthis model to draw the page on the screen.\nThis representation of the document is one of the toys that a JavaScript\nprogram has available in its sandbox. It is a data structure that you can read\nor modify. It acts as a live data structure: when it\u2019s modified, the page on the\nscreen is updated to reflect the changes.\nDocument structure\nYou can imagine an HTML document as a nested set of boxes. Tags such as\n<body> and <\/body> enclose other tags, which in turn contain other tags or\ntext. Here\u2019s the example document from the previous chapter:\n<!doctype html>\n<html>\n<head>\n<title>My home page<\/title>\n<\/head>\n<body>\n<h1>My home page<\/h1>\n<p>Hello, I am Marijn and this is my home page.<\/p>\n<p>I also wrote a book! Read it\n<a href=\"http:\/\/eloquentjavascript.net\">here<\/a>.<\/p>\n<\/body>\n<\/html>\nThis page has the following structure:\n224 html\nhead\ntitle\nMy home page\nbody\nh1\nMy home page\np\nHello, I am Marijn and this is...\np\na\nI also wrote a book! Read it here .\nThe data structure the browser uses to represent the document follows this\nshape. For each box, there is an object, which we can interact with to find\nout things such as what HTML tag it represents and which boxes and text it\ncontains. This representation is called the Document Object Model, or DOM\nfor short.\nTheglobalbindingdocumentgivesusaccesstotheseobjects. ItsdocumentElement\nproperty refers to the object representing the <html> tag. Since every HTML\ndocument has a head and a body, it also has head and body properties, pointing\nat those elements.\nTrees\nThink back to the syntax trees from Chapter 12 for a moment. Their structures\nare strikingly similar to the structure of a browser\u2019s document. Each node may\nrefer to other nodes, children, which in turn may have their own children. This\nshape is typical of nested structures where elements can contain subelements\nthat are similar to themselves.\nWe call a data structure a tree when it has a branching structure, has no\ncycles (a node may not contain itself, directly or indirectly), and has a single,\nwell-defined root. In the case of the DOM, document.documentElement serves\nas the root.\nTrees come up a lot in computer science. In addition to representing recur-\nsive structures such as HTML documents or programs, they are often used to\nmaintain sorted sets of data because elements can usually be found or inserted\n225 more e\ufb00iciently in a tree than in a flat array.\nA typical tree has different kinds of nodes. The syntax tree for the Egg\nlanguage had identifiers, values, and application nodes. Application nodes\nmay have children, whereas identifiers and values are leaves, or nodes without\nchildren.\nThe same goes for the DOM. Nodes for elements, which represent HTML\ntags, determine the structure of the document. These can have child nodes.\nAn example of such a node is document.body. Some of these children can be\nleaf nodes, such as pieces of text or comment nodes.\nEach DOM node object has a nodeType property, which contains a code\n(number) that identifies the type of node. Elements have code 1, which is also\ndefined as the constant property Node.ELEMENT_NODE. Text nodes, representing\na section of text in the document, get code 3 (Node.TEXT_NODE). Comments\nhave code 8 (Node.COMMENT_NODE).\nAnother way to visualize our document tree is as follows:\nhtml head title My home page\nbody h1 My home page\np Hello! I am...\np I also wrote...\na here\n.\nThe leaves are text nodes, and the arrows indicate parent-child relationships\nbetween nodes.\nThe standard\nUsing cryptic numeric codes to represent node types is not a very JavaScript-\nlike thing to do. Later in this chapter, we\u2019ll see that other parts of the DOM\ninterface also feel cumbersome and alien. The reason for this is that the DOM\nwasn\u2019t designed for just JavaScript. Rather, it tries to be a language-neutral\ninterface that can be used in other systems as well\u2014not just for HTML but\nalso for XML, which is a generic data format with an HTML-like syntax.\nThis is unfortunate. Standards are often useful. But in this case, the advan-\ntage (cross-language consistency) isn\u2019t all that compelling. Having an interface\nthat is properly integrated with the language you are using will save you more\n226 time than having a familiar interface across languages.\nAs an example of this poor integration, consider the childNodes property\nthat element nodes in the DOM have. This property holds an array-like object,\nwith a length property and properties labeled by numbers to access the child\nnodes. But it is an instance of the NodeList type, not a real array, so it does\nnot have methods such as slice and map.\nThen there are issues that are simply poor design. For example, there is\nno way to create a new node and immediately add children or attributes to it.\nInstead, you have to first create it and then add the children and attributes\none by one, using side effects. Code that interacts heavily with the DOM tends\nto get long, repetitive, and ugly.\nBut these flaws aren\u2019t fatal. Since JavaScript allows us to create our own\nabstractions, it is possible to design improved ways to express the operations\nyou are performing. Many libraries intended for browser programming come\nwith such tools.\nMoving through the tree\nDOM nodes contain a wealth of links to other nearby nodes. The following\ndiagram illustrates these:\nchildNodes firstChild\nbody\n0 h1\nMy home page\npreviousSibling\n1 p\nHello, I am Marijn... parentNode\nnextSibling\n2 p\nI also wrote a book! ...\nlastChild\nAlthough the diagram shows only one link of each type, every node has a\nparentNode property that points to the node it is part of, if any. Likewise,\nevery element node (node type 1) has a childNodes property that points to an\narray-like object holding its children.\nIn theory, you could move anywhere in the tree using just these parent and\nchild links. But JavaScript also gives you access to a number of additional\nconvenience links. The firstChild and lastChild properties point to the first\nand last child elements or have the value null for nodes without children.\n227 Similarly, previousSibling and nextSibling point to adjacent nodes, which\nare nodes with the same parent that appear immediately before or after the\nnode itself. For a first child, previousSibling will be null, and for a last child,\nnextSibling will be null.\nThere\u2019s also the children property, which is like childNodes but contains\nonly element (type 1) children, not other types of child nodes. This can be\nuseful when you aren\u2019t interested in text nodes.\nWhen dealing with a nested data structure like this one, recursive func-\ntions are often useful. The following function scans a document for text nodes\ncontaining a given string and returns true when it has found one:\nfunction talksAbout(node, string) {\nif (node.nodeType == Node.ELEMENT_NODE) {\nfor (let child of node.childNodes) {\nif (talksAbout(child, string)) {\nreturn true;\n}\n}\nreturn false;\n} else if (node.nodeType == Node.TEXT_NODE) {\nreturn node.nodeValue.indexOf(string) > -1;\n}\n}\nconsole.log(talksAbout(document.body, \"book\"));\n\/\/ \u2192 true\nThe nodeValue property of a text node holds the string of text that it rep-\nresents.\nFinding elements\nNavigating these links among parents, children, and siblings is often useful.\nBut if we want to find a specific node in the document, reaching it by starting\nat document.body and following a fixed path of properties is a bad idea. Do-\ning so bakes assumptions into our program about the precise structure of the\ndocument\u2014a structure you might want to change later. Another complicating\nfactor is that text nodes are created even for the whitespace between nodes.\nThe example document\u2019s <body> tag does not have just three children (<h1>\nand two <p> elements) but actually has seven: those three, plus the spaces\nbefore, after, and between them.\n228 So if we want to get the href attribute of the link in that document, we\ndon\u2019t want to say something like \u201cGet the second child of the sixth child of\nthe document body\u201d. It\u2019d be better if we could say \u201cGet the first link in the\ndocument\u201d. And we can.\nlet link = document.body.getElementsByTagName(\"a\")[0];\nconsole.log(link.href);\nAll element nodes have a getElementsByTagName method, which collects all\nelements with the given tag name that are descendants (direct or indirect chil-\ndren) of that node and returns them as an array-like object.\nTofindaspecificsinglenode, youcangiveitanidattributeandusedocument\n.getElementById instead.\n<p>My ostrich Gertrude:<\/p>\n<p><img id=\"gertrude\" src=\"img\/ostrich.png\"><\/p>\n<script>\nlet ostrich = document.getElementById(\"gertrude\");\nconsole.log(ostrich.src);\n<\/script>\nAthird, similarmethodisgetElementsByClassName, which, likegetElementsByTagName\n, searches through the contents of an element node and retrieves all elements\nthat have the given string in their class attribute.\nChanging the document\nAlmost everything about the DOM data structure can be changed. The shape\nof the document tree can be modified by changing parent-child relationships.\nNodes have a remove method to remove them from their current parent node.\nTo add a child node to an element node, we can use appendChild, which puts\nit at the end of the list of children, or insertBefore, which inserts the node\ngiven as the first argument before the node given as the second argument.\n<p>One<\/p>\n<p>Two<\/p>\n<p>Three<\/p>\n<script>\nlet paragraphs = document.body.getElementsByTagName(\"p\");\n229 document.body.insertBefore(paragraphs[2], paragraphs[0]);\n<\/script>\nA node can exist in the document in only one place. Thus, inserting para-\ngraph Three in front of paragraph One will first remove it from the end of the\ndocument and then insert it at the front, resulting in Three\/One\/Two. All\noperations that insert a node somewhere will, as a side effect, cause it to be\nremoved from its current position (if it has one).\nThe replaceChild method is used to replace a child node with another one.\nIt takes as arguments two nodes: a new node and the node to be replaced. The\nreplaced node must be a child of the element the method is called on. Note\nthat both replaceChild and insertBefore expect the new node as their first\nargument.\nCreating nodes\nSay we want to write a script that replaces all images (<img> tags) in the doc-\nument with the text held in their alt attributes, which specifies an alternative\ntextual representation of the image.\nThis involves not only removing the images but adding a new text node\nto replace them. Text nodes are created with the document.createTextNode\nmethod.\n<p>The <img src=\"img\/cat.png\" alt=\"Cat\"> in the\n<img src=\"img\/hat.png\" alt=\"Hat\">.<\/p>\n<p><button onclick=\"replaceImages()\">Replace<\/button><\/p>\n<script>\nfunction replaceImages() {\nlet images = document.body.getElementsByTagName(\"img\");\nfor (let i = images.length - 1; i >= 0; i--) {\nlet image = images[i];\nif (image.alt) {\nlet text = document.createTextNode(image.alt);\nimage.parentNode.replaceChild(text, image);\n}\n}\n}\n<\/script>\n230 Given a string, createTextNode gives us a text node that we can insert into\nthe document to make it show up on the screen.\nThe loop that goes over the images starts at the end of the list. This is nec-\nessary because the node list returned by a method like getElementsByTagName\n(or a property like childNodes) is live. That is, it is updated as the document\nchanges. If we started from the front, removing the first image would cause the\nlist to lose its first element so that the second time the loop repeats, where i\nis 1, it would stop because the length of the collection is now also 1.\nIf you want a solid collection of nodes, as opposed to a live one, you can\nconvert the collection to a real array by calling Array.from.\nlet arrayish = {0: \"one\", 1: \"two\", length: 2};\nlet array = Array.from(arrayish);\nconsole.log(array.map(s => s.toUpperCase()));\n\/\/ \u2192 [\"ONE\", \"TWO\"]\nTo create element nodes, you can use the document.createElement method.\nThis method takes a tag name and returns a new empty node of the given type.\nThe following example defines a utility elt, which creates an element node\nand treats the rest of its arguments as children to that node. This function is\nthen used to add an attribution to a quote.\n<blockquote id=\"quote\">\nNo book can ever be finished. While working on it we learn\njust enough to find it immature the moment we turn away\nfrom it.\n<\/blockquote>\n<script>\nfunction elt(type, ...children) {\nlet node = document.createElement(type);\nfor (let child of children) {\nif (typeof child != \"string\") node.appendChild(child);\nelse node.appendChild(document.createTextNode(child));\n}\nreturn node;\n}\ndocument.getElementById(\"quote\").appendChild(\nelt(\"footer\", \"\u2014\",\nelt(\"strong\", \"Karl Popper\"),\n\", preface to the second edition of \",\nelt(\"em\", \"The Open Society and Its Enemies\"),\n231 \", 1950\"));\n<\/script>\nThis is what the resulting document looks like:\nAttributes\nSome element attributes, such as href for links, can be accessed through a\nproperty of the same name on the element\u2019s DOM object. This is the case for\nmost commonly used standard attributes.\nBut HTML allows you to set any attribute you want on nodes. This can be\nuseful because it allows you to store extra information in a document. If you\nmake up your own attribute names, though, such attributes will not be present\nas properties on the element\u2019s node. Instead, you have to use the getAttribute\nand setAttribute methods to work with them.\n<p data-classified=\"secret\">The launch code is 00000000.<\/p>\n<p data-classified=\"unclassified\">I have two feet.<\/p>\n<script>\nlet paras = document.body.getElementsByTagName(\"p\");\nfor (let para of Array.from(paras)) {\nif (para.getAttribute(\"data-classified\") == \"secret\") {\npara.remove();\n}\n}\n<\/script>\nIt is recommended to prefix the names of such made-up attributes with data-\nto ensure they do not conflict with any other attributes.\nThere is a commonly used attribute, class, which is a keyword in the\nJavaScript language. For historical reasons\u2014some old JavaScript implementa-\ntions could not handle property names that matched keywords\u2014the property\nused to access this attribute is called className. You can also access it under\nits real name, \"class\", by using the getAttribute and setAttribute methods.\n232 Layout\nYou may have noticed that different types of elements are laid out differently.\nSome, such as paragraphs (<p>) or headings (<h1>), take up the whole width\nof the document and are rendered on separate lines. These are called block\nelements. Others, such as links (<a>) or the <strong> element, are rendered\non the same line with their surrounding text. Such elements are called inline\nelements.\nFor any given document, browsers are able to compute a layout, which gives\neach element a size and position based on its type and content. This layout is\nthen used to actually draw the document.\nThe size and position of an element can be accessed from JavaScript. The\noffsetWidth and offsetHeight properties give you the space the element takes\nup in pixels. A pixel is the basic unit of measurement in the browser. It\ntraditionally corresponds to the smallest dot that the screen can draw, but on\nmodern displays, which can draw very small dots, that may no longer be the\ncase, and a browser pixel may span multiple display dots.\nSimilarly, clientWidth and clientHeight give you the size of the space inside\nthe element, ignoring border width.\n<p style=\"border: 3px solid red\">\nI'm boxed in\n<\/p>\n<script>\nlet para = document.body.getElementsByTagName(\"p\")[0];\nconsole.log(\"clientHeight:\", para.clientHeight);\nconsole.log(\"offsetHeight:\", para.offsetHeight);\n<\/script>\nGiving a paragraph a border causes a rectangle to be drawn around it.\nThe most effective way to find the precise position of an element on the\nscreen is the getBoundingClientRect method. It returns an object with top,\nbottom, left, and right properties, indicating the pixel positions of the sides\nof the element relative to the top left of the screen. If you want them relative\nto the whole document, you must add the current scroll position, which you\ncan find in the pageXOffset and pageYOffset bindings.\nLaying out a document can be quite a lot of work. In the interest of\n233 speed, browser engines do not immediately re-layout a document every time\nyou change it but wait as long as they can. When a JavaScript program that\nchanged the document finishes running, the browser will have to compute a new\nlayout to draw the changed document to the screen. When a program asks for\nthe position or size of something by reading properties such as offsetHeight\nor calling getBoundingClientRect, providing correct information also requires\ncomputing a layout.\nA program that repeatedly alternates between reading DOM layout infor-\nmation and changing the DOM forces a lot of layout computations to happen\nand will consequently run very slowly. The following code is an example of\nthis. It contains two different programs that build up a line of X characters\n2,000 pixels wide and measures the time each one takes.\n<p><span id=\"one\"><\/span><\/p>\n<p><span id=\"two\"><\/span><\/p>\n<script>\nfunction time(name, action) {\nlet start = Date.now(); \/\/ Current time in milliseconds\naction();\nconsole.log(name, \"took\", Date.now() - start, \"ms\");\n}\ntime(\"naive\", () => {\nlet target = document.getElementById(\"one\");\nwhile (target.offsetWidth < 2000) {\ntarget.appendChild(document.createTextNode(\"X\"));\n}\n});\n\/\/ \u2192 naive took 32 ms\ntime(\"clever\", function() {\nlet target = document.getElementById(\"two\");\ntarget.appendChild(document.createTextNode(\"XXXXX\"));\nlet total = Math.ceil(2000 \/ (target.offsetWidth \/ 5));\ntarget.firstChild.nodeValue = \"X\".repeat(total);\n});\n\/\/ \u2192 clever took 1 ms\n<\/script>\n234 Styling\nWe have seen that different HTML elements are drawn differently. Some are\ndisplayed as blocks, others inline. Some add styling\u2014<strong> makes its con-\ntent bold, and <a> makes it blue and underlines it.\nThe way an <img> tag shows an image or an <a> tag causes a link to be fol-\nlowed when it is clicked is strongly tied to the element type. But we can change\nthe styling associated with an element, such as the text color or underline. Here\nis an example that uses the style property:\n<p><a href=\".\">Normal link<\/a><\/p>\n<p><a href=\".\" style=\"color: green\">Green link<\/a><\/p>\nThe second link will be green instead of the default link color.\nA style attribute may contain one or more declarations, which are a property\n(such as color) followed by a colon and a value (such as green). When there\nis more than one declaration, they must be separated by semicolons, as in\n\"color: red; border: none\".\nA lot of aspects of the document can be influenced by styling. For example,\nthe display property controls whether an element is displayed as a block or an\ninline element.\nThis text is displayed <strong>inline<\/strong>,\n<strong style=\"display: block\">as a block<\/strong>, and\n<strong style=\"display: none\">not at all<\/strong>.\nThe block tag will end up on its own line since block elements are not\ndisplayed inline with the text around them. The last tag is not displayed at\nall\u2014display: none prevents an element from showing up on the screen. This\nis a way to hide elements. It is often preferable to removing them from the\ndocument entirely because it makes it easy to reveal them again later.\nJavaScript code can directly manipulate the style of an element through the\n235 element\u2019s style property. This property holds an object that has properties for\nall possible style properties. The values of these properties are strings, which\nwe can write to in order to change a particular aspect of the element\u2019s style.\n<p id=\"para\" style=\"color: purple\">\nNice text\n<\/p>\n<script>\nlet para = document.getElementById(\"para\");\nconsole.log(para.style.color);\npara.style.color = \"magenta\";\n<\/script>\nSome style property names contain hyphens, such as font-family. Because\nsuch property names are awkward to work with in JavaScript (you\u2019d have to\nsay style[\"font-family\"]), the property names in the style object for such\nproperties have their hyphens removed and the letters after them capitalized\n(style.fontFamily).\nCascading styles\nThe styling system for HTML is called CSS, for Cascading Style Sheets. A style\nsheet is a set of rules for how to style elements in a document. It can be given\ninside a <style> tag.\n<style>\nstrong {\nfont-style: italic;\ncolor: gray;\n}\n<\/style>\n<p>Now <strong>strong text<\/strong> is italic and gray.<\/p>\nThe cascading in the name refers to the fact that multiple such rules are\ncombined to produce the final style for an element. In the example, the default\nstyling for <strong> tags, which gives them font-weight: bold, is overlaid by\nthe rule in the <style> tag, which adds font-style and color.\nWhen multiple rules define a value for the same property, the most recently\nread rule gets a higher precedence and wins. So if the rule in the <style> tag\nincluded font-weight: normal, contradicting the default font-weight rule, the\n236 text would be normal, not bold. Styles in a style attribute applied directly to\nthe node have the highest precedence and always win.\nIt is possible to target things other than tag names in CSS rules. A rule for\n.abc applies to all elements with \"abc\" in their class attribute. A rule for #xyz\napplies to the element with an id attribute of \"xyz\" (which should be unique\nwithin the document).\n.subtle {\ncolor: gray;\nfont-size: 80%;\n}\n#header {\nbackground: blue;\ncolor: white;\n}\n\/* p elements with id main and with classes a and b *\/\np#main.a.b {\nmargin-bottom: 20px;\n}\nThe precedence rule favoring the most recently defined rule applies only\nwhen the rules have the same specificity. A rule\u2019s specificity is a measure of\nhow precisely it describes matching elements, determined by the number and\nkind (tag, class, or ID) of element aspects it requires. For example, a rule that\ntargets p.a is more specific than rules that target p or just .a and would thus\ntake precedence over them.\nThe notation p > a \u2026{} applies the given styles to all <a> tags that are direct\nchildren of <p> tags. Similarly, p a \u2026{} applies to all <a> tags inside <p> tags,\nwhether they are direct or indirect children.\nQuery selectors\nWe won\u2019t be using style sheets all that much in this book. Understanding them\nis helpful when programming in the browser, but they are complicated enough\nto warrant a separate book.\nThe main reason I introduced selector syntax\u2014the notation used in style\nsheets to determine which elements a set of styles apply to\u2014is that we can use\nthis same mini-language as an effective way to find DOM elements.\nThe querySelectorAll method, which is defined both on the document object\nand on element nodes, takes a selector string and returns a NodeList containing\nall the elements that it matches.\n237 <p>And if you go chasing\n<span class=\"animal\">rabbits<\/span><\/p>\n<p>And you know you're going to fall<\/p>\n<p>Tell 'em a <span class=\"character\">hookah smoking\n<span class=\"animal\">caterpillar<\/span><\/span><\/p>\n<p>Has given you the call<\/p>\n<script>\nfunction count(selector) {\nreturn document.querySelectorAll(selector).length;\n}\nconsole.log(count(\"p\")); \/\/ All <p> elements\n\/\/ \u2192 4\nconsole.log(count(\".animal\")); \/\/ Class animal\n\/\/ \u2192 2\nconsole.log(count(\"p .animal\")); \/\/ Animal inside of <p>\n\/\/ \u2192 2\nconsole.log(count(\"p > .animal\")); \/\/ Direct child of <p>\n\/\/ \u2192 1\n<\/script>\nUnlikemethodssuchasgetElementsByTagName, theobjectreturnedbyquerySelectorAll\nis not live. It won\u2019t change when you change the document. It is still not a\nreal array, though, so you still need to call Array.from if you want to treat it\nlike one.\nThe querySelector method (without the All part) works in a similar way.\nThis one is useful if you want a specific, single element. It will return only the\nfirst matching element or null when no element matches.\nPositioning and animating\nThe position style property influences layout in a powerful way. By default\nit has a value of static, meaning the element sits in its normal place in the\ndocument. When it is set to relative, the element still takes up space in the\ndocument, but now the top and left style properties can be used to move it\nrelative to that normal place. When position is set to absolute, the element is\nremoved from the normal document flow\u2014that is, it no longer takes up space\nand may overlap with other elements. Also, its top and left properties can\nbe used to absolutely position it relative to the top-left corner of the near-\nest enclosing element whose position property isn\u2019t static, or relative to the\ndocument if no such enclosing element exists.\n238 We can use this to create an animation. The following document displays a\npicture of a cat that moves around in an ellipse:\n<p style=\"text-align: center\">\n<img src=\"img\/cat.png\" style=\"position: relative\">\n<\/p>\n<script>\nlet cat = document.querySelector(\"img\");\nlet angle = Math.PI \/ 2;\nfunction animate(time, lastTime) {\nif (lastTime != null) {\nangle += (time - lastTime) * 0.001;\n}\ncat.style.top = (Math.sin(angle) * 20) + \"px\";\ncat.style.left = (Math.cos(angle) * 200) + \"px\";\nrequestAnimationFrame(newTime => animate(newTime, time));\n}\nrequestAnimationFrame(animate);\n<\/script>\nThe gray arrow shows the path along which the image moves.\nOur picture is centered on the page and given a position of relative. We\u2019ll\nrepeatedly update that picture\u2019s top and left styles to move it.\nThe script uses requestAnimationFrame to schedule the animate function to\nrun whenever the browser is ready to repaint the screen. The animate function\nitself again calls requestAnimationFrame to schedule the next update. When\nthe browser window (or tab) is active, this will cause updates to happen at a\nrate of about 60 per second, which tends to produce a good-looking animation.\nIf we just updated the DOM in a loop, the page would freeze, and nothing\nwould show up on the screen. Browsers do not update their display while a\nJavaScript program is running, nor do they allow any interaction with the page.\nThis is why we need requestAnimationFrame\u2014it lets the browser know that we\nare done for now, and it can go ahead and do the things that browsers do, such\nas updating the screen and responding to user actions.\nTheanimationfunctionispassedthecurrenttimeasanargument. Toensure\nthat the motion of the cat per millisecond is stable, it bases the speed at which\n239 the angle changes on the difference between the current time and the last time\nthe function ran. If it just moved the angle by a fixed amount per step, the\nmotion would stutter if, for example, another heavy task running on the same\ncomputer were to prevent the function from running for a fraction of a second.\nMoving in circles is done using the trigonometry functions Math.cos and\nMath.sin. For those who aren\u2019t familiar with these, I\u2019ll briefly introduce them\nsince we will occasionally use them in this book.\nMath.cosandMath.sinareusefulforfindingpointsthatlieonacirclearound\npoint (0,0) with a radius of one. Both functions interpret their argument as\nthe position on this circle, with zero denoting the point on the far right of the\ncircle, going clockwise until 2\u03c0 (about 6.28) has taken us around the whole\ncircle. Math.cos tells you the x-coordinate of the point that corresponds to\nthe given position, and Math.sin yields the y-coordinate. Positions (or angles)\ngreater than 2\u03c0 or less than 0 are valid\u2014the rotation repeats so that a+2\u03c0\nrefers to the same angle as a.\nThis unit for measuring angles is called radians\u2014a full circle is 2\u03c0 radians,\nsimilar to how it is 360 degrees when measuring in degrees. The constant \u03c0 is\navailable as Math.PI in JavaScript.\ncos(-\u2154\u03c0)\nsin(-\u2154\u03c0)\nsin(\u00bc\u03c0)\ncos(\u00bc\u03c0)\nThe cat animation code keeps a counter, angle, for the current angle of the\nanimation and increments it every time the animate function is called. It can\nthen use this angle to compute the current position of the image element. The\ntop style is computed with Math.sin and multiplied by 20, which is the vertical\nradius of our ellipse. The left style is based on Math.cos and multiplied by\n200 so that the ellipse is much wider than it is high.\nNote that styles usually need units. In this case, we have to append \"px\"\nto the number to tell the browser that we are counting in pixels (as opposed\nto centimeters, \u201cems\u201d, or other units). This is easy to forget. Using numbers\nwithout units will result in your style being ignored\u2014unless the number is 0,\nwhich always means the same thing, regardless of its unit.\n240 Summary\nJavaScript programs may inspect and interfere with the document that the\nbrowser is displaying through a data structure called the DOM. This data\nstructure represents the browser\u2019s model of the document, and a JavaScript\nprogram can modify it to change the visible document.\nThe DOM is organized like a tree, in which elements are arranged hierar-\nchically according to the structure of the document. The objects representing\nelements have properties such as parentNode and childNodes, which can be\nused to navigate through this tree.\nThe way a document is displayed can be influenced by styling, both by\nattaching styles to nodes directly and by defining rules that match certain\nnodes. There are many different style properties, such as color or display.\nJavaScript code can manipulate an element\u2019s style directly through its style\nproperty.\nExercises\nBuild a table\nAn HTML table is built with the following tag structure:\n<table>\n<tr>\n<th>name<\/th>\n<th>height<\/th>\n<th>place<\/th>\n<\/tr>\n<tr>\n<td>Kilimanjaro<\/td>\n<td>5895<\/td>\n<td>Tanzania<\/td>\n<\/tr>\n<\/table>\nFor each row, the <table> tag contains a <tr> tag. Inside of these <tr> tags,\nwe can put cell elements: either heading cells (<th>) or regular cells (<td>).\nGiven a data set of mountains, an array of objects with name, height, and\nplace properties, generate the DOM structure for a table that enumerates the\nobjects. It should have one column per key and one row per object, plus a\nheader row with <th> elements at the top, listing the column names.\n241 Write this so that the columns are automatically derived from the objects,\nby taking the property names of the first object in the data.\nAdd the resulting table to the element with an id attribute of \"mountains\"\nso that it becomes visible in the document.\nOnce you have this working, right-align cells that contain number values by\nsetting their style.textAlign property to \"right\".\nElements by tag name\nThe document.getElementsByTagName method returns all child elements with a\ngiven tag name. Implement your own version of this as a function that takes a\nnode and a string (the tag name) as arguments and returns an array containing\nall descendant element nodes with the given tag name.\nTo find the tag name of an element, use its nodeName property. But note\nthat this will return the tag name in all uppercase. Use the toLowerCase or\ntoUpperCase string methods to compensate for this.\nThe cat's hat\nExtend the cat animation defined earlier so that both the cat and his hat\n(<img src=\"img\/hat.png\">) orbit at opposite sides of the ellipse.\nOr make the hat circle around the cat. Or alter the animation in some other\ninteresting way.\nTo make positioning multiple objects easier, it is probably a good idea to\nswitch to absolute positioning. This means that top and left are counted\nrelative to the top left of the document. To avoid using negative coordinates,\nwhich would cause the image to move outside of the visible page, you can add\na fixed number of pixels to the position values.\n242 \u201cYou have power over your mind\u2014not outside events. Realize this,\nand you will find strength.\u201d\n\u2014Marcus Aurelius, Meditations\nChapter15\nHandling Events\nSome programs work with direct user input, such as mouse and keyboard ac-\ntions. That kind of input isn\u2019t available as a well-organized data structure\u2014it\ncomes in piece by piece, in real time, and the program is expected to respond\nto it as it happens.\nEvent handlers\nImagine an interface where the only way to find out whether a key on the\nkeyboard is being pressed is to read the current state of that key. To be able\nto react to keypresses, you would have to constantly read the key\u2019s state so\nthat you\u2019d catch it before it\u2019s released again. It would be dangerous to perform\nother time-intensive computations since you might miss a keypress.\nSome primitive machines do handle input like that. A step up from this\nwould be for the hardware or operating system to notice the keypress and put\nit in a queue. A program can then periodically check the queue for new events\nand react to what it finds there.\nOf course, it has to remember to look at the queue, and to do it often,\nbecause any time between the key being pressed and the program noticing\nthe event will cause the software to feel unresponsive. This approach is called\npolling. Most programmers prefer to avoid it.\nA better mechanism is for the system to actively notify our code when an\nevent occurs. Browsers do this by allowing us to register functions as handlers\nfor specific events.\n<p>Click this document to activate the handler.<\/p>\n<script>\nwindow.addEventListener(\"click\", () => {\nconsole.log(\"You knocked?\");\n});\n<\/script>\n243 The window binding refers to a built-in object provided by the browser.\nIt represents the browser window that contains the document. Calling its\naddEventListener method registers the second argument to be called when-\never the event described by its first argument occurs.\nEvents and DOM nodes\nEach browser event handler is registered in a context. In the previous example\nwe called addEventListener on the window object to register a handler for the\nwhole window. Such a method can also be found on DOM elements and some\nother types of objects. Event listeners are called only when the event happens\nin the context of the object they are registered on.\n<button>Click me<\/button>\n<p>No handler here.<\/p>\n<script>\nlet button = document.querySelector(\"button\");\nbutton.addEventListener(\"click\", () => {\nconsole.log(\"Button clicked.\");\n});\n<\/script>\nThat example attaches a handler to the button node. Clicks on the button\ncause that handler to run, but clicks on the rest of the document do not.\nGiving a node an onclick attribute has a similar effect. This works for most\ntypes of events\u2014you can attach a handler through the attribute whose name\nis the event name with on in front of it.\nBut a node can have only one onclick attribute, so you can register only\none handler per node that way. The addEventListener method allows you to\nadd any number of handlers so that it is safe to add handlers even if there is\nalready another handler on the element.\nTheremoveEventListenermethod, calledwithargumentssimilartoaddEventListener\n, removes a handler.\n<button>Act-once button<\/button>\n<script>\nlet button = document.querySelector(\"button\");\nfunction once() {\nconsole.log(\"Done.\");\nbutton.removeEventListener(\"click\", once);\n}\nbutton.addEventListener(\"click\", once);\n244 <\/script>\nThe function given to removeEventListener has to be the same function\nvalue that was given to addEventListener. So, to unregister a handler, you\u2019ll\nwant to give the function a name (once, in the example) to be able to pass the\nsame function value to both methods.\nEvent objects\nThough we have ignored it so far, event handler functions are passed an ar-\ngument: the event object. This object holds additional information about the\nevent. For example, if we want to know which mouse button was pressed, we\ncan look at the event object\u2019s button property.\n<button>Click me any way you want<\/button>\n<script>\nlet button = document.querySelector(\"button\");\nbutton.addEventListener(\"mousedown\", event => {\nif (event.button == 0) {\nconsole.log(\"Left button\");\n} else if (event.button == 1) {\nconsole.log(\"Middle button\");\n} else if (event.button == 2) {\nconsole.log(\"Right button\");\n}\n});\n<\/script>\nThe information stored in an event object differs per type of event. We\u2019ll\ndiscuss different types later in the chapter. The object\u2019s type property always\nholds a string identifying the event (such as \"click\" or \"mousedown\").\nPropagation\nFor most event types, handlers registered on nodes with children will also re-\nceive events that happen in the children. If a button inside a paragraph is\nclicked, event handlers on the paragraph will also see the click event.\nBut if both the paragraph and the button have a handler, the more specific\nhandler\u2014the one on the button\u2014gets to go first. The event is said to propagate\noutward, from the node where it happened to that node\u2019s parent node and on\n245 to the root of the document. Finally, after all handlers registered on a specific\nnode have had their turn, handlers registered on the whole window get a chance\nto respond to the event.\nAt any point, an event handler can call the stopPropagation method on the\nevent object to prevent handlers further up from receiving the event. This can\nbe useful when, for example, you have a button inside another clickable element\nand you don\u2019t want clicks on the button to activate the outer element\u2019s click\nbehavior.\nThe following example registers \"mousedown\" handlers on both a button and\nthe paragraph around it. When clicked with the right mouse button, the han-\ndler for the button calls stopPropagation, which will prevent the handler on\nthe paragraph from running. When the button is clicked with another mouse\nbutton, both handlers will run.\n<p>A paragraph with a <button>button<\/button>.<\/p>\n<script>\nlet para = document.querySelector(\"p\");\nlet button = document.querySelector(\"button\");\npara.addEventListener(\"mousedown\", () => {\nconsole.log(\"Handler for paragraph.\");\n});\nbutton.addEventListener(\"mousedown\", event => {\nconsole.log(\"Handler for button.\");\nif (event.button == 2) event.stopPropagation();\n});\n<\/script>\nMost event objects have a target property that refers to the node where they\noriginated. You can use this property to ensure that you\u2019re not accidentally\nhandling something that propagated up from a node you do not want to handle.\nIt is also possible to use the target property to cast a wide net for a specific\ntype of event. For example, if you have a node containing a long list of buttons,\nit may be more convenient to register a single click handler on the outer node\nand have it use the target property to figure out whether a button was clicked,\nrather than register individual handlers on all of the buttons.\n<button>A<\/button>\n<button>B<\/button>\n<button>C<\/button>\n<script>\ndocument.body.addEventListener(\"click\", event => {\nif (event.target.nodeName == \"BUTTON\") {\n246 console.log(\"Clicked\", event.target.textContent);\n}\n});\n<\/script>\nDefault actions\nMany events have a default action associated with them. If you click a link,\nyou will be taken to the link\u2019s target. If you press the down arrow, the browser\nwill scroll the page down. If you right-click, you\u2019ll get a context menu. And so\non.\nFor most types of events, the JavaScript event handlers are called before the\ndefault behavior takes place. If the handler doesn\u2019t want this normal behavior\nto happen, typically because it has already taken care of handling the event, it\ncan call the preventDefault method on the event object.\nThis can be used to implement your own keyboard shortcuts or context\nmenu. It can also be used to obnoxiously interfere with the behavior that users\nexpect. For example, here is a link that cannot be followed:\n<a href=\"https:\/\/developer.mozilla.org\/\">MDN<\/a>\n<script>\nlet link = document.querySelector(\"a\");\nlink.addEventListener(\"click\", event => {\nconsole.log(\"Nope.\");\nevent.preventDefault();\n});\n<\/script>\nTry not to do such things unless you have a really good reason to. It\u2019ll be\nunpleasant for people who use your page when expected behavior is broken.\nDepending on the browser, some events can\u2019t be intercepted at all. On\nChrome, forexample, thekeyboardshortcuttoclosethecurrenttab(control-\nW or command-W) cannot be handled by JavaScript.\nKey events\nWhen a key on the keyboard is pressed, your browser fires a \"keydown\" event.\nWhen it is released, you get a \"keyup\" event.\n247 <p>This page turns violet when you hold the V key.<\/p>\n<script>\nwindow.addEventListener(\"keydown\", event => {\nif (event.key == \"v\") {\ndocument.body.style.background = \"violet\";\n}\n});\nwindow.addEventListener(\"keyup\", event => {\nif (event.key == \"v\") {\ndocument.body.style.background = \"\";\n}\n});\n<\/script>\nDespite its name, \"keydown\" fires not only when the key is physically pushed\ndown. When a key is pressed and held, the event fires again every time the\nkey repeats. Sometimes you have to be careful about this. For example, if you\nadd a button to the DOM when a key is pressed and remove it again when the\nkey is released, you might accidentally add hundreds of buttons when the key\nis held down longer.\nThe example looked at the key property of the event object to see which\nkey the event is about. This property holds a string that, for most keys,\ncorresponds to the thing that pressing that key would type. For special keys\nsuch as enter, it holds a string that names the key (\"Enter\", in this case).\nIf you hold shift while pressing a key, that might also influence the name of\nthe key\u2014\"v\" becomes \"V\", and \"1\" may become \"!\", if that is what pressing\nshift-1 produces on your keyboard.\nModifier keys such as shift, control, alt, and meta (command on\nMac) generate key events just like normal keys. But when looking for key\ncombinations, youcanalsofindoutwhetherthesekeysarehelddownbylooking\nat the shiftKey, ctrlKey, altKey, and metaKey properties of keyboard and\nmouse events.\n<p>Press Control-Space to continue.<\/p>\n<script>\nwindow.addEventListener(\"keydown\", event => {\nif (event.key == \" \" && event.ctrlKey) {\nconsole.log(\"Continuing!\");\n}\n});\n<\/script>\n248 The DOM node where a key event originates depends on the element that\nhas focus when the key is pressed. Most nodes cannot have focus unless you\ngive them a tabindex attribute, but things like links, buttons, and form fields\ncan. We\u2019ll come back to form fields in Chapter 18. When nothing in particular\nhas focus, document.body acts as the target node of key events.\nWhen the user is typing text, using key events to figure out what is being\ntyped is problematic. Some platforms, most notably the virtual keyboard on\nAndroidphones, don\u2019tfirekeyevents. Butevenwhenyouhaveanold-fashioned\nkeyboard, some types of text input don\u2019t match key presses in a straightforward\nway, such as input method editor (IME) software used by people whose scripts\ndon\u2019t fit on a keyboard, where multiple key strokes are combined to create\ncharacters.\nTo notice when something was typed, elements that you can type into, such\nas the <input> and <textarea> tags, fire \"input\" events whenever the user\nchanges their content. To get the actual content that was typed, it is best to\ndirectly read it from the focused field. Chapter 18 will show how.\nPointer events\nThere are currently two widely used ways to point at things on a screen: mice\n(including devices that act like mice, such as touchpads and trackballs) and\ntouchscreens. These produce different kinds of events.\nMouse clicks\nPressing a mouse button causes a number of events to fire. The \"mousedown\"\nand \"mouseup\" events are similar to \"keydown\" and \"keyup\" and fire when the\nbutton is pressed and released. These happen on the DOM nodes that are\nimmediately below the mouse pointer when the event occurs.\nAfter the \"mouseup\" event, a \"click\" event fires on the most specific node\nthat contained both the press and the release of the button. For example, if I\npress down the mouse button on one paragraph and then move the pointer to\nanother paragraph and release the button, the \"click\" event will happen on\nthe element that contains both those paragraphs.\nIf two clicks happen close together, a \"dblclick\" (double-click) event also\nfires, after the second click event.\nTo get precise information about the place where a mouse event happened,\nyou can look at its clientX and clientY properties, which contain the event\u2019s\ncoordinates (in pixels) relative to the top-left corner of the window, or pageX\n249 and pageY, which are relative to the top-left corner of the whole document\n(which may be different when the window has been scrolled).\nThe following implements a primitive drawing program. Every time you\nclick the document, it adds a dot under your mouse pointer. See Chapter 19\nfor a less primitive drawing program.\n<style>\nbody {\nheight: 200px;\nbackground: beige;\n}\n.dot {\nheight: 8px; width: 8px;\nborder-radius: 4px; \/* rounds corners *\/\nbackground: blue;\nposition: absolute;\n}\n<\/style>\n<script>\nwindow.addEventListener(\"click\", event => {\nlet dot = document.createElement(\"div\");\ndot.className = \"dot\";\ndot.style.left = (event.pageX - 4) + \"px\";\ndot.style.top = (event.pageY - 4) + \"px\";\ndocument.body.appendChild(dot);\n});\n<\/script>\nMouse motion\nEvery time the mouse pointer moves, a \"mousemove\" event is fired. This event\ncan be used to track the position of the mouse. A common situation in which\nthis is useful is when implementing some form of mouse-dragging functionality.\nAs an example, the following program displays a bar and sets up event\nhandlers so that dragging to the left or right on this bar makes it narrower or\nwider:\n<p>Drag the bar to change its width:<\/p>\n<div style=\"background: orange; width: 60px; height: 20px\">\n<\/div>\n<script>\nlet lastX; \/\/ Tracks the last observed mouse X position\nlet bar = document.querySelector(\"div\");\n250 bar.addEventListener(\"mousedown\", event => {\nif (event.button == 0) {\nlastX = event.clientX;\nwindow.addEventListener(\"mousemove\", moved);\nevent.preventDefault(); \/\/ Prevent selection\n}\n});\nfunction moved(event) {\nif (event.buttons == 0) {\nwindow.removeEventListener(\"mousemove\", moved);\n} else {\nlet dist = event.clientX - lastX;\nlet newWidth = Math.max(10, bar.offsetWidth + dist);\nbar.style.width = newWidth + \"px\";\nlastX = event.clientX;\n}\n}\n<\/script>\nThe resulting page looks like this:\nNote that the \"mousemove\" handler is registered on the whole window. Even\nif the mouse goes outside of the bar during resizing, as long as the button is\nheld we still want to update its size.\nWe must stop resizing the bar when the mouse button is released. For that,\nwe can use the buttons property (note the plural), which tells us about the\nbuttons that are currently held down. When this is zero, no buttons are down.\nWhen buttons are held, its value is the sum of the codes for those buttons\u2014the\nleft button has code 1, the right button 2, and the middle one 4. With the left\nand right buttons held, for example, the value of buttons will be 3.\nNote that the order of these codes is different from the one used by button,\nwhere the middle button came before the right one. As mentioned, consistency\nisn\u2019t really a strong point of the browser\u2019s programming interface.\nTouch events\nThe style of graphical browser that we use was designed with mouse interfaces\nin mind, at a time where touchscreens were rare. To make the Web \u201cwork\u201d\n251 on early touchscreen phones, browsers for those devices pretended, to a certain\nextent, that touch events were mouse events. If you tap your screen, you\u2019ll get\n\"mousedown\", \"mouseup\", and \"click\" events.\nBut this illusion isn\u2019t very robust. A touchscreen works differently from a\nmouse: it doesn\u2019t have multiple buttons, you can\u2019t track the finger when it\nisn\u2019t on the screen (to simulate \"mousemove\"), and it allows multiple fingers to\nbe on the screen at the same time.\nMouse events cover touch interaction only in straightforward cases\u2014if you\nadd a \"click\" handler to a button, touch users will still be able to use it. But\nsomething like the resizeable bar in the previous example does not work on a\ntouchscreen.\nThere are specific event types fired by touch interaction. When a finger\nstarts touching the screen, you get a \"touchstart\" event. When it is moved\nwhile touching, \"touchmove\" events fire. Finally, when it stops touching the\nscreen, you\u2019ll see a \"touchend\" event.\nBecause many touchscreens can detect multiple fingers at the same time,\ntheseeventsdon\u2019thaveasinglesetofcoordinatesassociatedwiththem. Rather,\ntheir event objects have a touches property, which holds an array-like object of\npoints, eachofwhichhasitsownclientX, clientY, pageX, andpageYproperties.\nYou could do something like this to show red circles around every touching\nfinger:\n<style>\ndot { position: absolute; display: block;\nborder: 2px solid red; border-radius: 50px;\nheight: 100px; width: 100px; }\n<\/style>\n<p>Touch this page<\/p>\n<script>\nfunction update(event) {\nfor (let dot; dot = document.querySelector(\"dot\");) {\ndot.remove();\n}\nfor (let i = 0; i < event.touches.length; i++) {\nlet {pageX, pageY} = event.touches[i];\nlet dot = document.createElement(\"dot\");\ndot.style.left = (pageX - 50) + \"px\";\ndot.style.top = (pageY - 50) + \"px\";\ndocument.body.appendChild(dot);\n}\n}\nwindow.addEventListener(\"touchstart\", update);\nwindow.addEventListener(\"touchmove\", update);\n252 window.addEventListener(\"touchend\", update);\n<\/script>\nYou\u2019ll often want to call preventDefault in touch event handlers to override\nthe browser\u2019s default behavior (which may include scrolling the page on swip-\ning) and to prevent the mouse events from being fired, for which you may also\nhave a handler.\nScroll events\nWhenever an element is scrolled, a \"scroll\" event is fired on it. This has var-\nious uses, such as knowing what the user is currently looking at (for disabling\noff-screen animations or sending spy reports to your evil headquarters) or show-\ning some indication of progress (by highlighting part of a table of contents or\nshowing a page number).\nThefollowingexampledrawsaprogressbarabovethedocumentandupdates\nit to fill up as you scroll down:\n<style>\n#progress {\nborder-bottom: 2px solid blue;\nwidth: 0;\nposition: fixed;\ntop: 0; left: 0;\n}\n<\/style>\n<div id=\"progress\"><\/div>\n<script>\n\/\/ Create some content\ndocument.body.appendChild(document.createTextNode(\n\"supercalifragilisticexpialidocious \".repeat(1000)));\nlet bar = document.querySelector(\"#progress\");\nwindow.addEventListener(\"scroll\", () => {\nlet max = document.body.scrollHeight - innerHeight;\nbar.style.width = `${(pageYOffset \/ max) * 100}%`;\n});\n<\/script>\nGiving an element a position of fixed acts much like an absolute position\nbut also prevents it from scrolling along with the rest of the document. The\n253 effect is to make our progress bar stay at the top. Its width is changed to\nindicate the current progress. We use %, rather than px, as a unit when setting\nthe width so that the element is sized relative to the page width.\nThe global innerHeight binding gives us the height of the window, which\nwe have to subtract from the total scrollable height\u2014you can\u2019t keep scrolling\nwhen you hit the bottom of the document. There\u2019s also an innerWidth for the\nwindow width. By dividing pageYOffset, the current scroll position, by the\nmaximum scroll position and multiplying by 100, we get the percentage for the\nprogress bar.\nCalling preventDefault on a scroll event does not prevent the scrolling from\nhappening. In fact, the event handler is called only after the scrolling takes\nplace.\nFocus events\nWhen an element gains focus, the browser fires a \"focus\" event on it. When\nit loses focus, the element gets a \"blur\" event.\nSome events, like these two and \"scroll\", do not propagate. A handler on\na parent element is not notified when a child element gains or loses focus.\nThe following example displays help text for the text field that currently has\nfocus:\n<p>Name: <input type=\"text\" data-help=\"Your full name\"><\/p>\n<p>Age: <input type=\"text\" data-help=\"Your age in years\"><\/p>\n<p id=\"help\"><\/p>\n<script>\nlet help = document.querySelector(\"#help\");\nlet fields = document.querySelectorAll(\"input\");\nfor (let field of Array.from(fields)) {\nfield.addEventListener(\"focus\", event => {\nlet text = event.target.getAttribute(\"data-help\");\nhelp.textContent = text;\n});\nfield.addEventListener(\"blur\", event => {\nhelp.textContent = \"\";\n});\n}\n<\/script>\nThis screenshot shows the help text for the age field.\n254 The window object will receive \"focus\" and \"blur\" events when the user\nmoves from or to the browser tab or window in which the document is shown.\nLoad event\nWhen a page finishes loading, the \"load\" event fires on the window and the\ndocumentbodyobjects. Thisisoftenusedtoscheduleinitializationactionsthat\nrequire the whole document to have been built. Remember that the content of\n<script> tags is run immediately when the tag is encountered. This may be\ntoo soon, for example when the script needs to do something with parts of the\ndocument that appear after the <script> tag.\nElements such as images and script tags that load an external file also have\na \"load\" event that indicates the files they reference were loaded. Like the\nfocus-related events, loading events do not propagate.\nWhen a page is closed or navigated away from (for example, by following a\nlink), a \"beforeunload\" event fires. The main use of this event is to prevent the\nuser from accidentally losing work by closing a document. If you prevent the\ndefault behavior on this event and set the returnValue property on the event\nobject to a string, the browser will show the user a dialog asking if they really\nwant to leave the page. That dialog might include your string, but because\nsome malicious sites try to use these dialogs to confuse people into staying on\ntheir page to look at dodgy weight loss ads, most browsers no longer display\nthem.\nEvents and the event loop\nIn the context of the event loop, as discussed in Chapter 11, browser event\nhandlers behave like other asynchronous notifications. They are scheduled\nwhen the event occurs but must wait for other scripts that are running to\nfinish before they get a chance to run.\nThe fact that events can be processed only when nothing else is running\nmeans that, if the event loop is tied up with other work, any interaction with\nthe page (which happens through events) will be delayed until there\u2019s time to\nprocess it. So if you schedule too much work, either with long-running event\n255 handlers or with lots of short-running ones, the page will become slow and\ncumbersome to use.\nFor cases where you really do want to do some time-consuming thing in the\nbackground without freezing the page, browsers provide something called web\nworkers. A worker is a JavaScript process that runs alongside the main script,\non its own timeline.\nImagine that squaring a number is a heavy, long-running computation that\nwe want to perform in a separate thread. We could write a file called code\/\nsquareworker.js that responds to messages by computing a square and sending\na message back.\naddEventListener(\"message\", event => {\npostMessage(event.data * event.data);\n});\nTo avoid the problems of having multiple threads touching the same data,\nworkers do not share their global scope or any other data with the main script\u2019s\nenvironment. Instead, you have to communicate with them by sending mes-\nsages back and forth.\nThis code spawns a worker running that script, sends it a few messages, and\noutputs the responses.\nlet squareWorker = new Worker(\"code\/squareworker.js\");\nsquareWorker.addEventListener(\"message\", event => {\nconsole.log(\"The worker responded:\", event.data);\n});\nsquareWorker.postMessage(10);\nsquareWorker.postMessage(24);\nThe postMessage function sends a message, which will cause a \"message\"\nevent to fire in the receiver. The script that created the worker sends and\nreceives messages through the Worker object, whereas the worker talks to the\nscript that created it by sending and listening directly on its global scope. Only\nvalues that can be represented as JSON can be sent as messages\u2014the other\nside will receive a copy of them, rather than the value itself.\nTimers\nWe saw the setTimeout function in Chapter 11. It schedules another function\nto be called later, after a given number of milliseconds.\n256 Sometimes you need to cancel a function you have scheduled. This is done\nby storing the value returned by setTimeout and calling clearTimeout on it.\nlet bombTimer = setTimeout(() => {\nconsole.log(\"BOOM!\");\n}, 500);\nif (Math.random() < 0.5) { \/\/ 50% chance\nconsole.log(\"Defused.\");\nclearTimeout(bombTimer);\n}\nThe cancelAnimationFrame function works in the same way as clearTimeout\n\u2014calling it on a value returned by requestAnimationFrame will cancel that\nframe (assuming it hasn\u2019t already been called).\nA similar set of functions, setInterval and clearInterval, are used to set\ntimers that should repeat every X milliseconds.\nlet ticks = 0;\nlet clock = setInterval(() => {\nconsole.log(\"tick\", ticks++);\nif (ticks == 10) {\nclearInterval(clock);\nconsole.log(\"stop.\");\n}\n}, 200);\nDebouncing\nSome types of events have the potential to fire rapidly, many times in a row (the\n\"mousemove\" and \"scroll\" events, for example). When handling such events,\nyou must be careful not to do anything too time-consuming or your handler\nwill take up so much time that interaction with the document starts to feel\nslow.\nIf you do need to do something nontrivial in such a handler, you can use\nsetTimeout to make sure you are not doing it too often. This is usually called\ndebouncing the event. There are several slightly different approaches to this.\nInthefirstexample, wewanttoreactwhentheuserhastypedsomething, but\nwe don\u2019t want to do it immediately for every input event. When they are typing\nquickly, we just want to wait until a pause occurs. Instead of immediately\n257 performing an action in the event handler, we set a timeout. We also clear the\nprevious timeout (if any) so that when events occur close together (closer than\nour timeout delay), the timeout from the previous event will be canceled.\n<textarea>Type something here...<\/textarea>\n<script>\nlet textarea = document.querySelector(\"textarea\");\nlet timeout;\ntextarea.addEventListener(\"input\", () => {\nclearTimeout(timeout);\ntimeout = setTimeout(() => console.log(\"Typed!\"), 500);\n});\n<\/script>\nGiving an undefined value to clearTimeout or calling it on a timeout that\nhas already fired has no effect. Thus, we don\u2019t have to be careful about when\nto call it, and we simply do so for every event.\nWe can use a slightly different pattern if we want to space responses so that\nthey\u2019re separated by at least a certain length of time but want to fire them\nduring a series of events, not just afterward. For example, we might want to\nrespond to \"mousemove\" events by showing the current coordinates of the mouse\nbut only every 250 milliseconds.\n<script>\nlet scheduled = null;\nwindow.addEventListener(\"mousemove\", event => {\nif (!scheduled) {\nsetTimeout(() => {\ndocument.body.textContent =\n`Mouse at ${scheduled.pageX}, ${scheduled.pageY}`;\nscheduled = null;\n}, 250);\n}\nscheduled = event;\n});\n<\/script>\nSummary\nEvent handlers make it possible to detect and react to events happening in our\nweb page. The addEventListener method is used to register such a handler.\n258 Each event has a type (\"keydown\", \"focus\", and so on) that identifies it.\nMost events are called on a specific DOM element and then propagate to that\nelement\u2019s ancestors, allowing handlers associated with those elements to handle\nthem.\nWhen an event handler is called, it is passed an event object with additional\ninformation about the event. This object also has methods that allow us to\nstop further propagation (stopPropagation) and prevent the browser\u2019s default\nhandling of the event (preventDefault).\nPressing a key fires \"keydown\" and \"keyup\" events. Pressing a mouse button\nfires \"mousedown\", \"mouseup\", and \"click\" events. Moving the mouse fires\n\"mousemove\" events. Touchscreen interaction will result in \"touchstart\", \"\ntouchmove\", and \"touchend\" events.\nScrolling can be detected with the \"scroll\" event, and focus changes can\nbe detected with the \"focus\" and \"blur\" events. When the document finishes\nloading, a \"load\" event fires on the window.\nExercises\nBalloon\nWrite a page that displays a balloon (using the balloon emoji, \ud83c\udf88). When you\npress the up arrow, it should inflate (grow) 10 percent, and when you press the\ndown arrow, it should deflate (shrink) 10 percent.\nYou can control the size of text (emoji are text) by setting the font-size\nCSS property (style.fontSize) on its parent element. Remember to include a\nunit in the value\u2014for example, pixels (10px).\nThe key names of the arrow keys are \"ArrowUp\" and \"ArrowDown\". Make\nsure the keys change only the balloon, without scrolling the page.\nWhen that works, add a feature where, if you blow up the balloon past a\ncertain size, it explodes. In this case, exploding means that it is replaced with\nan \ud83d\udca5 emoji, and the event handler is removed (so that you can\u2019t inflate or\ndeflate the explosion).\nMouse trail\nIn JavaScript\u2019s early days, which was the high time of gaudy home pages with\nlots of animated images, people came up with some truly inspiring ways to use\nthe language.\nOne of these was the mouse trail\u2014a series of elements that would follow the\nmouse pointer as you moved it across the page.\n259 In this exercise, I want you to implement a mouse trail. Use absolutely\npositioned <div> elements with a fixed size and background color (refer to the\ncode in the \u201cMouse Clicks\u201d section for an example). Create a bunch of such\nelements and, when the mouse moves, display them in the wake of the mouse\npointer.\nThere are various possible approaches here. You can make your solution as\nsimple or as complex as you want. A simple solution to start with is to keep\na fixed number of trail elements and cycle through them, moving the next one\nto the mouse\u2019s current position every time a \"mousemove\" event occurs.\nTabs\nTabbed panels are widely used in user interfaces. They allow you to select\nan interface panel by choosing from a number of tabs \u201csticking out\u201d above an\nelement.\nIn this exercise you must implement a simple tabbed interface. Write a func-\ntion, asTabs, that takes a DOM node and creates a tabbed interface showing\nthe child elements of that node. It should insert a list of <button> elements at\nthe top of the node, one for each child element, containing text retrieved from\nthe data-tabname attribute of the child. All but one of the original children\nshould be hidden (given a display style of none). The currently visible node\ncan be selected by clicking the buttons.\nWhen that works, extend it to style the button for the currently selected\ntab differently so that it is obvious which tab is selected.\n260 \u201cAll reality is a game.\u201d\n\u2014Iain Banks, The Player of Games\nChapter16\nProject: A Platform Game\nMuch of my initial fascination with computers, like that of many nerdy kids,\nhad to do with computer games. I was drawn into the tiny simulated worlds\nthat I could manipulate and in which stories (sort of) unfolded\u2014more, I sup-\npose, because of the way I projected my imagination into them than because\nof the possibilities they actually offered.\nI don\u2019t wish a career in game programming on anyone. Much like the music\nindustry, the discrepancy between the number of eager young people wanting\nto work in it and the actual demand for such people creates a rather unhealthy\nenvironment. But writing games for fun is amusing.\nThis chapter will walk through the implementation of a small platform game.\nPlatform games (or \u201cjump and run\u201d games) are games that expect the player\nto move a figure through a world, which is usually two-dimensional and viewed\nfrom the side, while jumping over and onto things.\nThe game\nOurgamewillberoughlybasedonDarkBlue(www.lessmilk.com\/games\/10)by\nThomas Palef. I chose that game because it is both entertaining and minimalist\nand because it can be built without too much code. It looks like this:\nThe dark box represents the player, whose task is to collect the yellow boxes\n261 (coins) while avoiding the red stuff (lava). A level is completed when all coins\nhave been collected.\nThe player can walk around with the left and right arrow keys and can jump\nwith the up arrow. Jumping is a specialty of this game character. It can reach\nseveral times its own height and can change direction in midair. This may not\nbe entirely realistic, but it helps give the player the feeling of being in direct\ncontrol of the on-screen avatar.\nThe game consists of a static background, laid out like a grid, with the\nmoving elements overlaid on that background. Each field on the grid is either\nempty, solid, or lava. The moving elements are the player, coins, and certain\npieces of lava. The positions of these elements are not constrained to the grid\u2014\ntheir coordinates may be fractional, allowing smooth motion.\nThe technology\nWe will use the browser DOM to display the game, and we\u2019ll read user input\nby handling key events.\nThe screen- and keyboard-related code is only a small part of the work\nwe need to do to build this game. Since everything looks like colored boxes,\ndrawing is uncomplicated: we create DOM elements and use styling to give\nthem a background color, size, and position.\nWe can represent the background as a table since it is an unchanging grid of\nsquares. The free-moving elements can be overlaid using absolutely positioned\nelements.\nIn games and other programs that should animate graphics and respond\nto user input without noticeable delay, e\ufb00iciency is important. Although the\nDOM was not originally designed for high-performance graphics, it is actually\nbetter at this than you would expect. You saw some animations in Chapter\n14. On a modern machine, a simple game like this performs well, even if we\ndon\u2019t worry about optimization very much.\nIn the next chapter, we will explore another browser technology, the <canvas\n> tag, which provides a more traditional way to draw graphics, working in terms\nof shapes and pixels rather than DOM elements.\nLevels\nWe\u2019ll want a human-readable, human-editable way to specify levels. Since it\nis okay for everything to start out on a grid, we could use big strings in which\n262 each character represents an element\u2014either a part of the background grid or\na moving element.\nThe plan for a small level might look like this:\nlet simpleLevelPlan = `\n......................\n..#................#..\n..#..............=.#..\n..#.........o.o....#..\n..#.@......#####...#..\n..#####............#..\n......#++++++++++++#..\n......##############..\n......................`;\nPeriods are empty space, hash (#) characters are walls, and plus signs are\nlava. The player\u2019s starting position is the at sign (@). Every O character is a\ncoin, and the equal sign (=) at the top is a block of lava that moves back and\nforth horizontally.\nWe\u2019ll support two additional kinds of moving lava: the pipe character (|)\ncreates vertically moving blobs, and v indicates dripping lava\u2014vertically mov-\ning lava that doesn\u2019t bounce back and forth but only moves down, jumping\nback to its start position when it hits the floor.\nA whole game consists of multiple levels that the player must complete. A\nlevel is completed when all coins have been collected. If the player touches\nlava, the current level is restored to its starting position, and the player may\ntry again.\nReading a level\nThe following class stores a level object. Its argument should be the string that\ndefines the level.\nclass Level {\nconstructor(plan) {\nlet rows = plan.trim().split(\"\\n\").map(l => [...l]);\nthis.height = rows.length;\nthis.width = rows[0].length;\nthis.startActors = [];\nthis.rows = rows.map((row, y) => {\nreturn row.map((ch, x) => {\n263 let type = levelChars[ch];\nif (typeof type == \"string\") return type;\nthis.startActors.push(\ntype.create(new Vec(x, y), ch));\nreturn \"empty\";\n});\n});\n}\n}\nThe trim method is used to remove whitespace at the start and end of the\nplan string. This allows our example plan to start with a newline so that all\nthe lines are directly below each other. The remaining string is split on newline\ncharacters, and each line is spread into an array, producing arrays of characters.\nSo rows holds an array of arrays of characters, the rows of the plan. We can\nderive the level\u2019s width and height from these. But we must still separate the\nmoving elements from the background grid. We\u2019ll call moving elements actors.\nThey\u2019ll be stored in an array of objects. The background will be an array of\narrays of strings, holding field types such as \"empty\", \"wall\", or \"lava\".\nTo create these arrays, we map over the rows and then over their content.\nRememberthatmappassesthearrayindexasasecondargumenttothemapping\nfunction, which tells us the x- and y-coordinates of a given character. Positions\nin the game will be stored as pairs of coordinates, with the top left being 0,0\nand each background square being 1 unit high and wide.\nTo interpret the characters in the plan, the Level constructor uses the\nlevelChars object, which maps background elements to strings and actor char-\nacters to classes. When type is an actor class, its static create method is used\nto create an object, which is added to startActors, and the mapping function\nreturns \"empty\" for this background square.\nThe position of the actor is stored as a Vec object. This is a two-dimensional\nvector, an object with x and y properties, as seen in the exercises of Chapter 6.\nAs the game runs, actors will end up in different places or even disappear\nentirely (as coins do when collected). We\u2019ll use a State class to track the state\nof a running game.\nclass State {\nconstructor(level, actors, status) {\nthis.level = level;\nthis.actors = actors;\nthis.status = status;\n}\n264 static start(level) {\nreturn new State(level, level.startActors, \"playing\");\n}\nget player() {\nreturn this.actors.find(a => a.type == \"player\");\n}\n}\nThe status property will switch to \"lost\" or \"won\" when the game has\nended.\nThis is again a persistent data structure\u2014updating the game state creates\na new state and leaves the old one intact.\nActors\nActorobjectsrepresentthecurrentpositionandstateofagivenmovingelement\nin our game. All actor objects conform to the same interface. Their pos\nproperty holds the coordinates of the element\u2019s top-left corner, and their size\nproperty holds its size.\nThen they have an update method, which is used to compute their new state\nand position after a given time step. It simulates the thing the actor does\u2014\nmoving in response to the arrow keys for the player and bouncing back and\nforth for the lava\u2014and returns a new, updated actor object.\nA type property contains a string that identifies the type of the actor\u2014\"\nplayer\", \"coin\", or \"lava\". This is useful when drawing the game\u2014the look\nof the rectangle drawn for an actor is based on its type.\nActor classes have a static create method that is used by the Level con-\nstructor to create an actor from a character in the level plan. It is given the\ncoordinates of the character and the character itself, which is needed because\nthe Lava class handles several different characters.\nThis is the Vec class that we\u2019ll use for our two-dimensional values, such as\nthe position and size of actors.\nclass Vec {\nconstructor(x, y) {\nthis.x = x; this.y = y;\n}\nplus(other) {\nreturn new Vec(this.x + other.x, this.y + other.y);\n265 }\ntimes(factor) {\nreturn new Vec(this.x * factor, this.y * factor);\n}\n}\nThe times method scales a vector by a given number. It will be useful\nwhen we need to multiply a speed vector by a time interval to get the distance\ntraveled during that time.\nThe different types of actors get their own classes since their behavior is very\ndifferent. Let\u2019s define these classes. We\u2019ll get to their update methods later.\nTheplayerclasshasapropertyspeedthatstoresitscurrentspeedtosimulate\nmomentum and gravity.\nclass Player {\nconstructor(pos, speed) {\nthis.pos = pos;\nthis.speed = speed;\n}\nget type() { return \"player\"; }\nstatic create(pos) {\nreturn new Player(pos.plus(new Vec(0, -0.5)),\nnew Vec(0, 0));\n}\n}\nPlayer.prototype.size = new Vec(0.8, 1.5);\nBecause a player is one-and-a-half squares high, its initial position is set to\nbe half a square above the position where the @ character appeared. This way,\nits bottom aligns with the bottom of the square it appeared in.\nThe size property is the same for all instances of Player, so we store it on\nthe prototype rather than on the instances themselves. We could have used\na getter like type, but that would create and return a new Vec object every\ntime the property is read, which would be wasteful. (Strings, being immutable,\ndon\u2019t have to be re-created every time they are evaluated.)\nWhen constructing a Lava actor, we need to initialize the object differently\ndepending on the character it is based on. Dynamic lava moves along at its\ncurrent speed until it hits an obstacle. At that point, if it has a reset property,\n266 it will jump back to its start position (dripping). If it does not, it will invert\nits speed and continue in the other direction (bouncing).\nThe create method looks at the character that the Level constructor passes\nand creates the appropriate lava actor.\nclass Lava {\nconstructor(pos, speed, reset) {\nthis.pos = pos;\nthis.speed = speed;\nthis.reset = reset;\n}\nget type() { return \"lava\"; }\nstatic create(pos, ch) {\nif (ch == \"=\") {\nreturn new Lava(pos, new Vec(2, 0));\n} else if (ch == \"|\") {\nreturn new Lava(pos, new Vec(0, 2));\n} else if (ch == \"v\") {\nreturn new Lava(pos, new Vec(0, 3), pos);\n}\n}\n}\nLava.prototype.size = new Vec(1, 1);\nCoin actors are relatively simple. They mostly just sit in their place. But\nto liven up the game a little, they are given a \u201cwobble\u201d, a slight vertical back-\nand-forth motion. To track this, a coin object stores a base position as well\nas a wobble property that tracks the phase of the bouncing motion. Together,\nthese determine the coin\u2019s actual position (stored in the pos property).\nclass Coin {\nconstructor(pos, basePos, wobble) {\nthis.pos = pos;\nthis.basePos = basePos;\nthis.wobble = wobble;\n}\nget type() { return \"coin\"; }\nstatic create(pos) {\nlet basePos = pos.plus(new Vec(0.2, 0.1));\n267 return new Coin(basePos, basePos,\nMath.random() * Math.PI * 2);\n}\n}\nCoin.prototype.size = new Vec(0.6, 0.6);\nIn Chapter 14, we saw that Math.sin gives us the y-coordinate of a point\non a circle. That coordinate goes back and forth in a smooth waveform as\nwe move along the circle, which makes the sine function useful for modeling a\nwavy motion.\nTo avoid a situation where all coins move up and down synchronously, the\nstarting phase of each coin is randomized. The period of Math.sin\u2019s wave, the\nwidth of a wave it produces, is 2\u03c0. We multiply the value returned by Math\n.random by that number to give the coin a random starting position on the\nwave.\nWe can now define the levelChars object that maps plan characters to either\nbackground grid types or actor classes.\nconst levelChars = {\n\".\": \"empty\", \"#\": \"wall\", \"+\": \"lava\",\n\"@\": Player, \"o\": Coin,\n\"=\": Lava, \"|\": Lava, \"v\": Lava\n};\nThat gives us all the parts needed to create a Level instance.\nlet simpleLevel = new Level(simpleLevelPlan);\nconsole.log(`${simpleLevel.width} by ${simpleLevel.height}`);\n\/\/ \u2192 22 by 9\nThe task ahead is to display such levels on the screen and to model time\nand motion inside them.\nEncapsulation as a burden\nMost of the code in this chapter does not worry about encapsulation very much\nfor two reasons. First, encapsulation takes extra effort. It makes programs\nbigger and requires additional concepts and interfaces to be introduced. Since\nthere is only so much code you can throw at a reader before their eyes glaze\n268 over, I\u2019ve made an effort to keep the program small.\nSecond, the various elements in this game are so closely tied together that\nif the behavior of one of them changed, it is unlikely that any of the others\nwould be able to stay the same. Interfaces between the elements would end\nup encoding a lot of assumptions about the way the game works. This makes\nthem a lot less effective\u2014whenever you change one part of the system, you still\nhave to worry about the way it impacts the other parts because their interfaces\nwouldn\u2019t cover the new situation.\nSome cutting points in a system lend themselves well to separation through\nrigorous interfaces, but others don\u2019t. Trying to encapsulate something that\nisn\u2019t a suitable boundary is a sure way to waste a lot of energy. When you\nare making this mistake, you\u2019ll usually notice that your interfaces are getting\nawkwardly large and detailed and that they need to be changed often, as the\nprogram evolves.\nThere is one thing that we will encapsulate, and that is the drawing subsys-\ntem. The reason for this is that we\u2019ll display the same game in a different way\nin the next chapter. By putting the drawing behind an interface, we can load\nthe same game program there and plug in a new display module.\nDrawing\nThe encapsulation of the drawing code is done by defining a display object,\nwhich displays a given level and state. The display type we define in this\nchapter is called DOMDisplay because it uses DOM elements to show the level.\nWe\u2019ll be using a style sheet to set the actual colors and other fixed properties\nof the elements that make up the game. It would also be possible to directly\nassign to the elements\u2019 style property when we create them, but that would\nproduce more verbose programs.\nThe following helper function provides a succinct way to create an element\nand give it some attributes and child nodes:\nfunction elt(name, attrs, ...children) {\nlet dom = document.createElement(name);\nfor (let attr of Object.keys(attrs)) {\ndom.setAttribute(attr, attrs[attr]);\n}\nfor (let child of children) {\ndom.appendChild(child);\n}\nreturn dom;\n}\n269 A display is created by giving it a parent element to which it should append\nitself and a level object.\nclass DOMDisplay {\nconstructor(parent, level) {\nthis.dom = elt(\"div\", {class: \"game\"}, drawGrid(level));\nthis.actorLayer = null;\nparent.appendChild(this.dom);\n}\nclear() { this.dom.remove(); }\n}\nThe level\u2019s background grid, which never changes, is drawn once. Actors are\nredrawn every time the display is updated with a given state. The actorLayer\nproperty will be used to track the element that holds the actors so that they\ncan be easily removed and replaced.\nOur coordinates and sizes are tracked in grid units, where a size or distance\nof 1 means one grid block. When setting pixel sizes, we will have to scale these\ncoordinates up\u2014everything in the game would be ridiculously small at a single\npixel per square. The scale constant gives the number of pixels that a single\nunit takes up on the screen.\nconst scale = 20;\nfunction drawGrid(level) {\nreturn elt(\"table\", {\nclass: \"background\",\nstyle: `width: ${level.width * scale}px`\n}, ...level.rows.map(row =>\nelt(\"tr\", {style: `height: ${scale}px`},\n...row.map(type => elt(\"td\", {class: type})))\n));\n}\nAs mentioned, the background is drawn as a <table> element. This nicely\ncorresponds to the structure of the rows property of the level\u2014each row of the\ngrid is turned into a table row (<tr> element). The strings in the grid are\nused as class names for the table cell (<td>) elements. The spread (triple dot)\noperator is used to pass arrays of child nodes to elt as separate arguments.\nThe following CSS makes the table look like the background we want:\n270 .background { background: rgb(52, 166, 251);\ntable-layout: fixed;\nborder-spacing: 0; }\n.background td { padding: 0; }\n.lava { background: rgb(255, 100, 100); }\n.wall { background: white; }\nSome of these (table-layout, border-spacing, and padding) are used to\nsuppress unwanted default behavior. We don\u2019t want the layout of the table to\ndepend upon the contents of its cells, and we don\u2019t want space between the\ntable cells or padding inside them.\nThe background rule sets the background color. CSS allows colors to be\nspecified both as words (white) or with a format such as rgb(R, G, B), where\nthe red, green, and blue components of the color are separated into three num-\nbers from 0 to 255. So, in rgb(52, 166, 251), the red component is 52, green\nis 166, and blue is 251. Since the blue component is the largest, the resulting\ncolor will be bluish. You can see that in the .lava rule, the first number (red)\nis the largest.\nWe draw each actor by creating a DOM element for it and setting that\nelement\u2019s position and size based on the actor\u2019s properties. The values have to\nbe multiplied by scale to go from game units to pixels.\nfunction drawActors(actors) {\nreturn elt(\"div\", {}, ...actors.map(actor => {\nlet rect = elt(\"div\", {class: `actor ${actor.type}`});\nrect.style.width = `${actor.size.x * scale}px`;\nrect.style.height = `${actor.size.y * scale}px`;\nrect.style.left = `${actor.pos.x * scale}px`;\nrect.style.top = `${actor.pos.y * scale}px`;\nreturn rect;\n}));\n}\nTo give an element more than one class, we separate the class names by\nspaces. In the CSS code shown next, the actor class gives the actors their\nabsolute position. Their type name is used as an extra class to give them a\ncolor. We don\u2019t have to define the lava class again because we\u2019re reusing the\nclass for the lava grid squares we defined earlier.\n.actor { position: absolute; }\n.coin { background: rgb(241, 229, 89); }\n.player { background: rgb(64, 64, 64); }\n271 The syncState method is used to make the display show a given state. It\nfirst removes the old actor graphics, if any, and then redraws the actors in\ntheir new positions. It may be tempting to try to reuse the DOM elements for\nactors, but to make that work, we would need a lot of additional bookkeeping\nto associate actors with DOM elements and to make sure we remove elements\nwhen their actors vanish. Since there will typically be only a handful of actors\nin the game, redrawing all of them is not expensive.\nDOMDisplay.prototype.syncState = function(state) {\nif (this.actorLayer) this.actorLayer.remove();\nthis.actorLayer = drawActors(state.actors);\nthis.dom.appendChild(this.actorLayer);\nthis.dom.className = `game ${state.status}`;\nthis.scrollPlayerIntoView(state);\n};\nBy adding the level\u2019s current status as a class name to the wrapper, we can\nstyle the player actor slightly differently when the game is won or lost by adding\na CSS rule that takes effect only when the player has an ancestor element with\na given class.\n.lost .player {\nbackground: rgb(160, 64, 64);\n}\n.won .player {\nbox-shadow: -4px -7px 8px white, 4px -7px 8px white;\n}\nAfter touching lava, the player\u2019s color turns dark red, suggesting scorching.\nWhen the last coin has been collected, we add two blurred white shadows\u2014one\nto the top left and one to the top right\u2014to create a white halo effect.\nWe can\u2019t assume that the level always fits in the viewport\u2014the element into\nwhich we draw the game. That is why the scrollPlayerIntoView call is needed.\nIt ensures that if the level is protruding outside the viewport, we scroll that\nviewport to make sure the player is near its center. The following CSS gives\nthe game\u2019s wrapping DOM element a maximum size and ensures that anything\nthat sticks out of the element\u2019s box is not visible. We also give it a relative\nposition so that the actors inside it are positioned relative to the level\u2019s top-left\ncorner.\n272 .game {\noverflow: hidden;\nmax-width: 600px;\nmax-height: 450px;\nposition: relative;\n}\nIn the scrollPlayerIntoView method, we find the player\u2019s position and up-\ndate the wrapping element\u2019s scroll position. We change the scroll position by\nmanipulating that element\u2019s scrollLeft and scrollTop properties when the\nplayer is too close to the edge.\nDOMDisplay.prototype.scrollPlayerIntoView = function(state) {\nlet width = this.dom.clientWidth;\nlet height = this.dom.clientHeight;\nlet margin = width \/ 3;\n\/\/ The viewport\nlet left = this.dom.scrollLeft, right = left + width;\nlet top = this.dom.scrollTop, bottom = top + height;\nlet player = state.player;\nlet center = player.pos.plus(player.size.times(0.5))\n.times(scale);\nif (center.x < left + margin) {\nthis.dom.scrollLeft = center.x - margin;\n} else if (center.x > right - margin) {\nthis.dom.scrollLeft = center.x + margin - width;\n}\nif (center.y < top + margin) {\nthis.dom.scrollTop = center.y - margin;\n} else if (center.y > bottom - margin) {\nthis.dom.scrollTop = center.y + margin - height;\n}\n};\nThe way the player\u2019s center is found shows how the methods on our Vec type\nallow computations with objects to be written in a relatively readable way. To\nfind the actor\u2019s center, we add its position (its top-left corner) and half its size.\nThat is the center in level coordinates, but we need it in pixel coordinates, so\nwe then multiply the resulting vector by our display scale.\nNext, a series of checks verifies that the player position isn\u2019t outside of the\n273 allowed range. Note that sometimes this will set nonsense scroll coordinates\nthat are below zero or beyond the element\u2019s scrollable area. This is okay\u2014the\nDOM will constrain them to acceptable values. Setting scrollLeft to -10 will\ncause it to become 0.\nIt would have been slightly simpler to always try to scroll the player to the\ncenter of the viewport. But this creates a rather jarring effect. As you are\njumping, the view will constantly shift up and down. It is more pleasant to\nhave a \u201cneutral\u201d area in the middle of the screen where you can move around\nwithout causing any scrolling.\nWe are now able to display our tiny level.\n<link rel=\"stylesheet\" href=\"css\/game.css\">\n<script>\nlet simpleLevel = new Level(simpleLevelPlan);\nlet display = new DOMDisplay(document.body, simpleLevel);\ndisplay.syncState(State.start(simpleLevel));\n<\/script>\nThe <link> tag, when used with rel=\"stylesheet\", is a way to load a CSS\nfile into a page. The file game.css contains the styles necessary for our game.\nMotion and collision\nNow we\u2019re at the point where we can start adding motion\u2014the most interesting\naspect of the game. The basic approach, taken by most games like this, is to\nsplit time into small steps and, for each step, move the actors by a distance\ncorresponding to their speed multiplied by the size of the time step. We\u2019ll\nmeasure time in seconds, so speeds are expressed in units per second.\nMoving things is easy. The di\ufb00icult part is dealing with the interactions\nbetween the elements. When the player hits a wall or floor, they should not\nsimply move through it. The game must notice when a given motion causes\nan object to hit another object and respond accordingly. For walls, the motion\nmust be stopped. When hitting a coin, it must be collected. When touching\n274 lava, the game should be lost.\nSolving this for the general case is a big task. You can find libraries, usually\ncalled physics engines, that simulate interaction between physical objects in\ntwo or three dimensions. We\u2019ll take a more modest approach in this chapter,\nhandling only collisions between rectangular objects and handling them in a\nrather simplistic way.\nBeforemovingtheplayerorablockoflava, wetestwhetherthemotionwould\ntake it inside of a wall. If it does, we simply cancel the motion altogether. The\nresponse to such a collision depends on the type of actor\u2014the player will stop,\nwhereas a lava block will bounce back.\nThis approach requires our time steps to be rather small since it will cause\nmotion to stop before the objects actually touch. If the time steps (and thus\nthe motion steps) are too big, the player would end up hovering a noticeable\ndistance above the ground. Another approach, arguably better but more com-\nplicated, would be to find the exact collision spot and move there. We will take\nthe simple approach and hide its problems by ensuring the animation proceeds\nin small steps.\nThis method tells us whether a rectangle (specified by a position and a size)\ntouches a grid element of the given type.\nLevel.prototype.touches = function(pos, size, type) {\nlet xStart = Math.floor(pos.x);\nlet xEnd = Math.ceil(pos.x + size.x);\nlet yStart = Math.floor(pos.y);\nlet yEnd = Math.ceil(pos.y + size.y);\nfor (let y = yStart; y < yEnd; y++) {\nfor (let x = xStart; x < xEnd; x++) {\nlet isOutside = x < 0 || x >= this.width ||\ny < 0 || y >= this.height;\nlet here = isOutside ? \"wall\" : this.rows[y][x];\nif (here == type) return true;\n}\n}\nreturn false;\n};\nThe method computes the set of grid squares that the body overlaps with\nby using Math.floor and Math.ceil on its coordinates. Remember that grid\nsquares are 1 by 1 units in size. By rounding the sides of a box up and down,\nwe get the range of background squares that the box touches.\n275 We loop over the block of grid squares found by rounding the coordinates\nand return true when a matching square is found. Squares outside of the level\nare always treated as \"wall\" to ensure that the player can\u2019t leave the world\nand that we won\u2019t accidentally try to read outside of the bounds of our rows\narray.\nThe state update method uses touches to figure out whether the player is\ntouching lava.\nState.prototype.update = function(time, keys) {\nlet actors = this.actors\n.map(actor => actor.update(time, this, keys));\nlet newState = new State(this.level, actors, this.status);\nif (newState.status != \"playing\") return newState;\nlet player = newState.player;\nif (this.level.touches(player.pos, player.size, \"lava\")) {\nreturn new State(this.level, actors, \"lost\");\n}\nfor (let actor of actors) {\nif (actor != player && overlap(actor, player)) {\nnewState = actor.collide(newState);\n}\n}\nreturn newState;\n};\nThe method is passed a time step and a data structure that tells it which\nkeys are being held down. The first thing it does is call the update method on\nall actors, producing an array of updated actors. The actors also get the time\nstep, the keys, and the state, so that they can base their update on those. Only\nthe player will actually read keys, since that\u2019s the only actor that\u2019s controlled\nby the keyboard.\nIf the game is already over, no further processing has to be done (the game\ncan\u2019t be won after being lost, or vice versa). Otherwise, the method tests\nwhether the player is touching background lava. If so, the game is lost, and\n276 we\u2019re done. Finally, if the game really is still going on, it sees whether any\nother actors overlap the player.\nOverlap between actors is detected with the overlap function. It takes two\nactor objects and returns true when they touch\u2014which is the case when they\noverlap both along the x-axis and along the y-axis.\nfunction overlap(actor1, actor2) {\nreturn actor1.pos.x + actor1.size.x > actor2.pos.x &&\nactor1.pos.x < actor2.pos.x + actor2.size.x &&\nactor1.pos.y + actor1.size.y > actor2.pos.y &&\nactor1.pos.y < actor2.pos.y + actor2.size.y;\n}\nIf any actor does overlap, its collide method gets a chance to update the\nstate. Touching a lava actor sets the game status to \"lost\". Coins vanish when\nyou touch them and set the status to \"won\" when they are the last coin of the\nlevel.\nLava.prototype.collide = function(state) {\nreturn new State(state.level, state.actors, \"lost\");\n};\nCoin.prototype.collide = function(state) {\nlet filtered = state.actors.filter(a => a != this);\nlet status = state.status;\nif (!filtered.some(a => a.type == \"coin\")) status = \"won\";\nreturn new State(state.level, filtered, status);\n};\nActor updates\nActor objects\u2019 update methods take as arguments the time step, the state ob-\nject, and a keys object. The one for the Lava actor type ignores the keys\nobject.\nLava.prototype.update = function(time, state) {\nlet newPos = this.pos.plus(this.speed.times(time));\nif (!state.level.touches(newPos, this.size, \"wall\")) {\nreturn new Lava(newPos, this.speed, this.reset);\n} else if (this.reset) {\nreturn new Lava(this.reset, this.speed, this.reset);\n277 } else {\nreturn new Lava(this.pos, this.speed.times(-1));\n}\n};\nThis update method computes a new position by adding the product of the\ntime step and the current speed to its old position. If no obstacle blocks that\nnew position, it moves there. If there is an obstacle, the behavior depends on\nthetype of the lavablock\u2014drippinglavahas a resetposition, to whichit jumps\nback when it hits something. Bouncing lava inverts its speed by multiplying it\nby -1 so that it starts moving in the opposite direction.\nCoins use their update method to wobble. They ignore collisions with the\ngrid since they are simply wobbling around inside of their own square.\nconst wobbleSpeed = 8, wobbleDist = 0.07;\nCoin.prototype.update = function(time) {\nlet wobble = this.wobble + time * wobbleSpeed;\nlet wobblePos = Math.sin(wobble) * wobbleDist;\nreturn new Coin(this.basePos.plus(new Vec(0, wobblePos)),\nthis.basePos, wobble);\n};\nThe wobble property is incremented to track time and then used as an ar-\ngument to Math.sin to find the new position on the wave. The coin\u2019s current\nposition is then computed from its base position and an offset based on this\nwave.\nThat leaves the player itself. Player motion is handled separately per axis\nbecause hitting the floor should not prevent horizontal motion, and hitting a\nwall should not stop falling or jumping motion.\nconst playerXSpeed = 7;\nconst gravity = 30;\nconst jumpSpeed = 17;\nPlayer.prototype.update = function(time, state, keys) {\nlet xSpeed = 0;\nif (keys.ArrowLeft) xSpeed -= playerXSpeed;\nif (keys.ArrowRight) xSpeed += playerXSpeed;\nlet pos = this.pos;\nlet movedX = pos.plus(new Vec(xSpeed * time, 0));\nif (!state.level.touches(movedX, this.size, \"wall\")) {\n278 pos = movedX;\n}\nlet ySpeed = this.speed.y + time * gravity;\nlet movedY = pos.plus(new Vec(0, ySpeed * time));\nif (!state.level.touches(movedY, this.size, \"wall\")) {\npos = movedY;\n} else if (keys.ArrowUp && ySpeed > 0) {\nySpeed = -jumpSpeed;\n} else {\nySpeed = 0;\n}\nreturn new Player(pos, new Vec(xSpeed, ySpeed));\n};\nThe horizontal motion is computed based on the state of the left and right\narrow keys. When there\u2019s no wall blocking the new position created by this\nmotion, it is used. Otherwise, the old position is kept.\nVertical motion works in a similar way but has to simulate jumping and\ngravity. The player\u2019s vertical speed (ySpeed) is first accelerated to account for\ngravity.\nWe check for walls again. If we don\u2019t hit any, the new position is used. If\nthere is a wall, there are two possible outcomes. When the up arrow is pressed\nand we are moving down (meaning the thing we hit is below us), the speed is\nset to a relatively large, negative value. This causes the player to jump. If that\nis not the case, the player simply bumped into something, and the speed is set\nto zero.\nThe gravity strength, jumping speed, and pretty much all other constants\nin this game have been set by trial and error. I tested values until I found a\ncombination I liked.\nTracking keys\nFor a game like this, we do not want keys to take effect once per keypress.\nRather, we want their effect (moving the player figure) to stay active as long\nas they are held.\nWe need to set up a key handler that stores the current state of the left,\nright, and up arrow keys. We will also want to call preventDefault for those\nkeys so that they don\u2019t end up scrolling the page.\nThe following function, when given an array of key names, will return an\nobject that tracks the current position of those keys. It registers event handlers\n279 for \"keydown\" and \"keyup\" events and, when the key code in the event is present\nin the set of codes that it is tracking, updates the object.\nfunction trackKeys(keys) {\nlet down = Object.create(null);\nfunction track(event) {\nif (keys.includes(event.key)) {\ndown[event.key] = event.type == \"keydown\";\nevent.preventDefault();\n}\n}\nwindow.addEventListener(\"keydown\", track);\nwindow.addEventListener(\"keyup\", track);\nreturn down;\n}\nconst arrowKeys =\ntrackKeys([\"ArrowLeft\", \"ArrowRight\", \"ArrowUp\"]);\nThe same handler function is used for both event types. It looks at the event\nobject\u2019s type property to determine whether the key state should be updated\nto true (\"keydown\") or false (\"keyup\").\nRunning the game\nThe requestAnimationFrame function, which we saw in Chapter 14, provides\na good way to animate a game. But its interface is quite primitive\u2014using it\nrequires us to track the time at which our function was called the last time\naround and call requestAnimationFrame again after every frame.\nLet\u2019s define a helper function that wraps those boring parts in a convenient\ninterface and allows us to simply call runAnimation, giving it a function that\nexpects a time difference as an argument and draws a single frame. When the\nframe function returns the value false, the animation stops.\nfunction runAnimation(frameFunc) {\nlet lastTime = null;\nfunction frame(time) {\nif (lastTime != null) {\nlet timeStep = Math.min(time - lastTime, 100) \/ 1000;\nif (frameFunc(timeStep) === false) return;\n}\nlastTime = time;\nrequestAnimationFrame(frame);\n280 }\nrequestAnimationFrame(frame);\n}\nI have set a maximum frame step of 100 milliseconds (one-tenth of a second).\nWhenthebrowsertaborwindowwithourpageishidden, requestAnimationFrame\ncalls will be suspended until the tab or window is shown again. In this case,\nthe difference between lastTime and time will be the entire time in which the\npage was hidden. Advancing the game by that much in a single step would\nlook silly and might cause weird side effects, such as the player falling through\nthe floor.\nThe function also converts the time steps to seconds, which are an easier\nquantity to think about than milliseconds.\nThe runLevel function takes a Level object and a display constructor and\nreturns a promise. It displays the level (in document.body) and lets the user\nplay through it. When the level is finished (lost or won), runLevel waits one\nmore second (to let the user see what happens) and then clears the display,\nstops the animation, and resolves the promise to the game\u2019s end status.\nfunction runLevel(level, Display) {\nlet display = new Display(document.body, level);\nlet state = State.start(level);\nlet ending = 1;\nreturn new Promise(resolve => {\nrunAnimation(time => {\nstate = state.update(time, arrowKeys);\ndisplay.syncState(state);\nif (state.status == \"playing\") {\nreturn true;\n} else if (ending > 0) {\nending -= time;\nreturn true;\n} else {\ndisplay.clear();\nresolve(state.status);\nreturn false;\n}\n});\n});\n}\nA game is a sequence of levels. Whenever the player dies, the current level\n281 is restarted. When a level is completed, we move on to the next level. This\ncan be expressed by the following function, which takes an array of level plans\n(strings) and a display constructor:\nasync function runGame(plans, Display) {\nfor (let level = 0; level < plans.length;) {\nlet status = await runLevel(new Level(plans[level]),\nDisplay);\nif (status == \"won\") level++;\n}\nconsole.log(\"You've won!\");\n}\nBecause we made runLevel return a promise, runGame can be written using\nan async function, as shown in Chapter 11. It returns another promise, which\nresolves when the player finishes the game.\nThere is a set of level plans available in the GAME_LEVELS binding in this\nchapter\u2019s sandbox (https:\/\/eloquentjavascript.net\/code#16). This page feeds\nthem to runGame, starting an actual game.\n<link rel=\"stylesheet\" href=\"css\/game.css\">\n<body>\n<script>\nrunGame(GAME_LEVELS, DOMDisplay);\n<\/script>\n<\/body>\nExercises\nGame over\nIt\u2019s traditional for platform games to have the player start with a limited num-\nber of lives and subtract one life each time they die. When the player is out of\nlives, the game restarts from the beginning.\nAdjust runGame to implement lives. Have the player start with three. Output\nthe current number of lives (using console.log) every time a level starts.\n282 Pausing the game\nMake it possible to pause (suspend) and unpause the game by pressing the Esc\nkey.\nThis can be done by changing the runLevel function to use another keyboard\nevent handler and interrupting or resuming the animation whenever the Esc\nkey is hit.\nThe runAnimation interface may not look like it is suitable for this at first\nglance, but it is if you rearrange the way runLevel calls it.\nWhen you have that working, there is something else you could try. The\nwaywehavebeenregisteringkeyboardeventhandlersissomewhatproblematic.\nThe arrowKeys object is currently a global binding, and its event handlers are\nkept around even when no game is running. You could say they leak out of our\nsystem. Extend trackKeys to provide a way to unregister its handlers and then\nchange runLevel to register its handlers when it starts and unregister them\nagain when it is finished.\nA monster\nIt is traditional for platform games to have enemies that you can jump on top\nof to defeat. This exercise asks you to add such an actor type to the game.\nWe\u2019ll call it a monster. Monsters move only horizontally. You can make\nthem move in the direction of the player, bounce back and forth like horizontal\nlava, or have any movement pattern you want. The class doesn\u2019t have to handle\nfalling, but it should make sure the monster doesn\u2019t walk through walls.\nWhen a monster touches the player, the effect depends on whether the player\nis jumping on top of them or not. You can approximate this by checking\nwhether the player\u2019s bottom is near the monster\u2019s top. If this is the case, the\nmonster disappears. If not, the game is lost.\n283 \u201cDrawing is deception.\u201d\n\u2014M.C. Escher, cited by Bruno Ernst in The Magic Mirror of M.C.\nEscher\nChapter17\nDrawing on Canvas\nBrowsers give us several ways to display graphics. The simplest way is to use\nstyles to position and color regular DOM elements. This can get you quite far,\nas the game in the previous chapter showed. By adding partially transparent\nbackground images to the nodes, we can make them look exactly the way we\nwant. It is even possible to rotate or skew nodes with the transform style.\nBut we\u2019d be using the DOM for something that it wasn\u2019t originally designed\nfor. Some tasks, such as drawing a line between arbitrary points, are extremely\nawkward to do with regular HTML elements.\nThere are two alternatives. The first is DOM-based but utilizes Scalable\nVector Graphics (SVG), rather than HTML. Think of SVG as a document-\nmarkup dialect that focuses on shapes rather than text. You can embed an\nSVG document directly in an HTML document or include it with an <img> tag.\nThe second alternative is called a canvas. A canvas is a single DOM element\nthat encapsulates a picture. It provides a programming interface for drawing\nshapes onto the space taken up by the node. The main difference between a\ncanvas and an SVG picture is that in SVG the original description of the shapes\nis preserved so that they can be moved or resized at any time. A canvas, on\nthe other hand, converts the shapes to pixels (colored dots on a raster) as soon\nas they are drawn and does not remember what these pixels represent. The\nonly way to move a shape on a canvas is to clear the canvas (or the part of the\ncanvas around the shape) and redraw it with the shape in a new position.\nSVG\nThis book will not go into SVG in detail, but I will briefly explain how it\nworks. At the end of the chapter, I\u2019ll come back to the trade-offs that you\nmust consider when deciding which drawing mechanism is appropriate for a\ngiven application.\nThis is an HTML document with a simple SVG picture in it:\n<p>Normal HTML here.<\/p>\n284 <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n<circle r=\"50\" cx=\"50\" cy=\"50\" fill=\"red\"\/>\n<rect x=\"120\" y=\"5\" width=\"90\" height=\"90\"\nstroke=\"blue\" fill=\"none\"\/>\n<\/svg>\nThe xmlns attribute changes an element (and its children) to a different\nXML namespace. This namespace, identified by a URL, specifies the dialect\nthat we are currently speaking. The <circle> and <rect> tags, which do not\nexist in HTML, do have a meaning in SVG\u2014they draw shapes using the style\nand position specified by their attributes.\nThe document is displayed like this:\nThese tags create DOM elements, just like HTML tags, that scripts can\ninteract with. For example, this changes the <circle> element to be colored\ncyan instead:\nlet circle = document.querySelector(\"circle\");\ncircle.setAttribute(\"fill\", \"cyan\");\nThe canvas element\nCanvas graphics can be drawn onto a <canvas> element. You can give such an\nelement width and height attributes to determine its size in pixels.\nA new canvas is empty, meaning it is entirely transparent and thus shows\nup as empty space in the document.\nThe <canvas> tag is intended to allow different styles of drawing. To get\naccess to an actual drawing interface, we first need to create a context, an object\nwhose methods provide the drawing interface. There are currently two widely\nsupported drawing styles: \"2d\" for two-dimensional graphics and \"webgl\" for\nthree-dimensional graphics through the OpenGL interface.\nThis book won\u2019t discuss WebGL\u2014we\u2019ll stick to two dimensions. But if you\nare interested in three-dimensional graphics, I do encourage you to look into\n285 WebGL. It provides a direct interface to graphics hardware and allows you to\nrender even complicated scenes e\ufb00iciently, using JavaScript.\nYou create a context with the getContext method on the <canvas> DOM\nelement.\n<p>Before canvas.<\/p>\n<canvas width=\"120\" height=\"60\"><\/canvas>\n<p>After canvas.<\/p>\n<script>\nlet canvas = document.querySelector(\"canvas\");\nlet context = canvas.getContext(\"2d\");\ncontext.fillStyle = \"red\";\ncontext.fillRect(10, 10, 100, 50);\n<\/script>\nAfter creating the context object, the example draws a red rectangle 100\npixels wide and 50 pixels high, with its top-left corner at coordinates (10,10).\nJust like in HTML (and SVG), the coordinate system that the canvas uses\nputs (0,0) at the top-left corner, and the positive y-axis goes down from there.\nSo (10,10) is 10 pixels below and to the right of the top-left corner.\nLines and surfaces\nIn the canvas interface, a shape can be filled, meaning its area is given a certain\ncolor or pattern, or it can be stroked, which means a line is drawn along its\nedge. The same terminology is used by SVG.\nThe fillRect method fills a rectangle. It takes first the x- and y-coordinates\nof the rectangle\u2019s top-left corner, then its width, and then its height. A similar\nmethod, strokeRect, draws the outline of a rectangle.\nNeither method takes any further parameters. The color of the fill, thickness\nof the stroke, and so on, are not determined by an argument to the method (as\nyou might reasonably expect) but rather by properties of the context object.\nThe fillStyle property controls the way shapes are filled. It can be set to\na string that specifies a color, using the color notation used by CSS.\n286 The strokeStyle property works similarly but determines the color used for\na stroked line. The width of that line is determined by the lineWidth property,\nwhich may contain any positive number.\n<canvas><\/canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\ncx.strokeStyle = \"blue\";\ncx.strokeRect(5, 5, 50, 50);\ncx.lineWidth = 5;\ncx.strokeRect(135, 5, 50, 50);\n<\/script>\nThis code draws two blue squares, using a thicker line for the second one.\nWhen no width or height attribute is specified, as in the example, a canvas\nelement gets a default width of 300 pixels and height of 150 pixels.\nPaths\nA path is a sequence of lines. The 2D canvas interface takes a peculiar approach\nto describing such a path. It is done entirely through side effects. Paths are\nnot values that can be stored and passed around. Instead, if you want to do\nsomething with a path, you make a sequence of method calls to describe its\nshape.\n<canvas><\/canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\ncx.beginPath();\nfor (let y = 10; y < 100; y += 10) {\ncx.moveTo(10, y);\ncx.lineTo(90, y);\n}\ncx.stroke();\n<\/script>\nThis example creates a path with a number of horizontal line segments and\n287 then strokes it using the stroke method. Each segment created with lineTo\nstarts at the path\u2019s current position. That position is usually the end of the\nlast segment, unless moveTo was called. In that case, the next segment would\nstart at the position passed to moveTo.\nThe path described by the previous program looks like this:\nWhen filling a path (using the fill method), each shape is filled separately.\nA path can contain multiple shapes\u2014each moveTo motion starts a new one.\nBut the path needs to be closed (meaning its start and end are in the same\nposition) before it can be filled. If the path is not already closed, a line is added\nfrom its end to its start, and the shape enclosed by the completed path is filled.\n<canvas><\/canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\ncx.beginPath();\ncx.moveTo(50, 10);\ncx.lineTo(10, 70);\ncx.lineTo(90, 70);\ncx.fill();\n<\/script>\nThis example draws a filled triangle. Note that only two of the triangle\u2019s\nsides are explicitly drawn. The third, from the bottom-right corner back to the\ntop, is implied and wouldn\u2019t be there when you stroke the path.\nYou could also use the closePath method to explicitly close a path by adding\nan actual line segment back to the path\u2019s start. This segment is drawn when\nstroking the path.\n288 Curves\nA path may also contain curved lines. These are unfortunately a bit more\ninvolved to draw.\nThe quadraticCurveTo method draws a curve to a given point. To determine\nthe curvature of the line, the method is given a control point as well as a\ndestination point. Imagine this control point as attracting the line, giving it\nits curve. The line won\u2019t go through the control point, but its direction at the\nstart and end points will be such that a straight line in that direction would\npoint toward the control point. The following example illustrates this:\n<canvas><\/canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\ncx.beginPath();\ncx.moveTo(10, 90);\n\/\/ control=(60,10) goal=(90,90)\ncx.quadraticCurveTo(60, 10, 90, 90);\ncx.lineTo(60, 10);\ncx.closePath();\ncx.stroke();\n<\/script>\nIt produces a path that looks like this:\nWe draw a quadratic curve from the left to the right, with (60,10) as control\npoint, and then draw two line segments going through that control point and\nback to the start of the line. The result somewhat resembles a Star Trek\ninsignia. You can see the effect of the control point: the lines leaving the lower\ncorners start off in the direction of the control point and then curve toward\ntheir target.\nThe bezierCurveTo method draws a similar kind of curve. Instead of a single\ncontrol point, this one has two\u2014one for each of the line\u2019s endpoints. Here is a\nsimilar sketch to illustrate the behavior of such a curve:\n<canvas><\/canvas>\n<script>\n289 let cx = document.querySelector(\"canvas\").getContext(\"2d\");\ncx.beginPath();\ncx.moveTo(10, 90);\n\/\/ control1=(10,10) control2=(90,10) goal=(50,90)\ncx.bezierCurveTo(10, 10, 90, 10, 50, 90);\ncx.lineTo(90, 10);\ncx.lineTo(10, 10);\ncx.closePath();\ncx.stroke();\n<\/script>\nThe two control points specify the direction at both ends of the curve. The\nfarther they are away from their corresponding point, the more the curve will\n\u201cbulge\u201d in that direction.\nSuch curves can be hard to work with\u2014it\u2019s not always clear how to find the\ncontrol points that provide the shape you are looking for. Sometimes you can\ncompute them, and sometimes you\u2019ll just have to find a suitable value by trial\nand error.\nThe arc method is a way to draw a line that curves along the edge of a\ncircle. It takes a pair of coordinates for the arc\u2019s center, a radius, and then a\nstart angle and end angle.\nThose last two parameters make it possible to draw only part of the circle.\nThe angles are measured in radians, not degrees. This means a full circle has\nan angle of 2\u03c0, or 2 * Math.PI, which is about 6.28. The angle starts counting\nat the point to the right of the circle\u2019s center and goes clockwise from there.\nYou can use a start of 0 and an end bigger than 2\u03c0 (say, 7) to draw a full circle.\n<canvas><\/canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\ncx.beginPath();\n\/\/ center=(50,50) radius=40 angle=0 to 7\ncx.arc(50, 50, 40, 0, 7);\n\/\/ center=(150,50) radius=40 angle=0 to \u03c0\u00bd\ncx.arc(150, 50, 40, 0, 0.5 * Math.PI);\ncx.stroke();\n290 <\/script>\nThe resulting picture contains a line from the right of the full circle (first call\nto arc) to the right of the quarter-circle (second call). Like other path-drawing\nmethods, a line drawn with arc is connected to the previous path segment.\nYou can call moveTo or start a new path to avoid this.\nDrawing a pie chart\nImagineyou\u2019vejusttakenajobatEconomiCorp, Inc., andyourfirstassignment\nis to draw a pie chart of its customer satisfaction survey results.\nThe results binding contains an array of objects that represent the survey\nresponses.\nconst results = [\n{name: \"Satisfied\", count: 1043, color: \"lightblue\"},\n{name: \"Neutral\", count: 563, color: \"lightgreen\"},\n{name: \"Unsatisfied\", count: 510, color: \"pink\"},\n{name: \"No comment\", count: 175, color: \"silver\"}\n];\nTo draw a pie chart, we draw a number of pie slices, each made up of an arc\nand a pair of lines to the center of that arc. We can compute the angle taken\nup by each arc by dividing a full circle (2\u03c0) by the total number of responses\nand then multiplying that number (the angle per response) by the number of\npeople who picked a given choice.\n<canvas width=\"200\" height=\"200\"><\/canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\nlet total = results\n.reduce((sum, {count}) => sum + count, 0);\n\/\/ Start at the top\nlet currentAngle = -0.5 * Math.PI;\nfor (let result of results) {\n291 let sliceAngle = (result.count \/ total) * 2 * Math.PI;\ncx.beginPath();\n\/\/ center=100,100, radius=100\n\/\/ from current angle, clockwise by slice's angle\ncx.arc(100, 100, 100,\ncurrentAngle, currentAngle + sliceAngle);\ncurrentAngle += sliceAngle;\ncx.lineTo(100, 100);\ncx.fillStyle = result.color;\ncx.fill();\n}\n<\/script>\nThis draws the following chart:\nBut a chart that doesn\u2019t tell us what the slices mean isn\u2019t very helpful. We\nneed a way to draw text to the canvas.\nText\nA 2D canvas drawing context provides the methods fillText and strokeText.\nThe latter can be useful for outlining letters, but usually fillText is what you\nneed. It will fill the outline of the given text with the current fillStyle.\n<canvas><\/canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\ncx.font = \"28px Georgia\";\ncx.fillStyle = \"fuchsia\";\ncx.fillText(\"I can draw text, too!\", 10, 50);\n<\/script>\n292 You can specify the size, style, and font of the text with the font property.\nThis example just gives a font size and family name. It is also possible to add\nitalic or bold to the start of the string to select a style.\nThe last two arguments to fillText and strokeText provide the position\nat which the font is drawn. By default, they indicate the position of the start\nof the text\u2019s alphabetic baseline, which is the line that letters \u201cstand\u201d on, not\ncounting hanging parts in letters such as j or p. You can change the horizontal\npositionbysettingthetextAlignpropertyto\"end\"or\"center\"andthevertical\nposition by setting textBaseline to \"top\", \"middle\", or \"bottom\".\nWe\u2019ll come back to our pie chart, and the problem of labeling the slices, in\nthe exercises at the end of the chapter.\nImages\nIn computer graphics, a distinction is often made between vector graphics and\nbitmap graphics. The first is what we have been doing so far in this chapter\u2014\nspecifying a picture by giving a logical description of shapes. Bitmap graphics,\non the other hand, don\u2019t specify actual shapes but rather work with pixel data\n(rasters of colored dots).\nThe drawImage method allows us to draw pixel data onto a canvas. This\npixel data can originate from an <img> element or from another canvas. The\nfollowing example creates a detached <img> element and loads an image file\ninto it. But it cannot immediately start drawing from this picture because the\nbrowser may not have loaded it yet. To deal with this, we register a \"load\"\nevent handler and do the drawing after the image has loaded.\n<canvas><\/canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\nlet img = document.createElement(\"img\");\nimg.src = \"img\/hat.png\";\nimg.addEventListener(\"load\", () => {\nfor (let x = 10; x < 200; x += 30) {\ncx.drawImage(img, x, 10);\n}\n});\n<\/script>\nBy default, drawImage will draw the image at its original size. You can also\ngive it two additional arguments to set a different width and height.\nWhen drawImage is given nine arguments, it can be used to draw only a\n293 fragment of an image. The second through fifth arguments indicate the rect-\nangle (x, y, width, and height) in the source image that should be copied, and\nthe sixth to ninth arguments give the rectangle (on the canvas) into which it\nshould be copied.\nThis can be used to pack multiple sprites (image elements) into a single\nimage file and then draw only the part you need. For example, we have this\npicture containing a game character in multiple poses:\nBy alternating which pose we draw, we can show an animation that looks\nlike a walking character.\nTo animate a picture on a canvas, the clearRect method is useful. It resem-\nbles fillRect, but instead of coloring the rectangle, it makes it transparent,\nremoving the previously drawn pixels.\nWe know that each sprite, each subpicture, is 24 pixels wide and 30 pixels\nhigh. The following code loads the image and then sets up an interval (repeated\ntimer) to draw the next frame:\n<canvas><\/canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\nlet img = document.createElement(\"img\");\nimg.src = \"img\/player.png\";\nlet spriteW = 24, spriteH = 30;\nimg.addEventListener(\"load\", () => {\nlet cycle = 0;\nsetInterval(() => {\ncx.clearRect(0, 0, spriteW, spriteH);\ncx.drawImage(img,\n\/\/ source rectangle\ncycle * spriteW, 0, spriteW, spriteH,\n\/\/ destination rectangle\n0, 0, spriteW, spriteH);\ncycle = (cycle + 1) % 8;\n}, 120);\n});\n<\/script>\nThe cycle binding tracks our position in the animation. For each frame, it is\nincremented and then clipped back to the 0 to 7 range by using the remainder\noperator. This binding is then used to compute the x-coordinate that the sprite\n294 for the current pose has in the picture.\nTransformation\nBut what if we want our character to walk to the left instead of to the right?\nWe could draw another set of sprites, of course. But we can also instruct the\ncanvas to draw the picture the other way round.\nCalling the scale method will cause anything drawn after it to be scaled.\nThis method takes two parameters, one to set a horizontal scale and one to set\na vertical scale.\n<canvas><\/canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\ncx.scale(3, .5);\ncx.beginPath();\ncx.arc(50, 50, 40, 0, 7);\ncx.lineWidth = 3;\ncx.stroke();\n<\/script>\nBecause of the call to scale, the circle is drawn three times as wide and half\nas high.\nScaling will cause everything about the drawn image, including the line\nwidth, to be stretched out or squeezed together as specified. Scaling by a\nnegative amount will flip the picture around. The flipping happens around\npoint (0,0), which means it will also flip the direction of the coordinate system.\nWhen a horizontal scaling of -1 is applied, a shape drawn at x position 100 will\nend up at what used to be position -100.\nSo to turn a picture around, we can\u2019t simply add cx.scale(-1, 1) before the\ncall to drawImage because that would move our picture outside of the canvas,\nwhere it won\u2019t be visible. You could adjust the coordinates given to drawImage\nto compensate for this by drawing the image at x position -50 instead of 0.\nAnother solution, which doesn\u2019t require the code that does the drawing to know\nabout the scale change, is to adjust the axis around which the scaling happens.\nThere are several other methods besides scale that influence the coordinate\nsystem for a canvas. You can rotate subsequently drawn shapes with the rotate\n295 method and move them with the translate method. The interesting\u2014and\nconfusing\u2014thing is that these transformations stack, meaning that each one\nhappens relative to the previous transformations.\nSo if we translate by 10 horizontal pixels twice, everything will be drawn\n20 pixels to the right. If we first move the center of the coordinate system to\n(50,50) and then rotate by 20 degrees (about 0.1\u03c0 radians), that rotation will\nhappen around point (50,50).\nrotate(0.1*Math.PI)\ntranslate(50, 50)\ntranslate(50, 50)\nrotate(0.1*Math.PI)\nBut if we first rotate by 20 degrees and then translate by (50,50), the transla-\ntion will happen in the rotated coordinate system and thus produce a different\norientation. The order in which transformations are applied matters.\nTo flip a picture around the vertical line at a given x position, we can do the\nfollowing:\nfunction flipHorizontally(context, around) {\ncontext.translate(around, 0);\ncontext.scale(-1, 1);\ncontext.translate(-around, 0);\n}\nWe move the y-axis to where we want our mirror to be, apply the mirroring,\nand finally move the y-axis back to its proper place in the mirrored universe.\nThe following picture explains why this works:\nmirror\n3 1 4 2\nThis shows the coordinate systems before and after mirroring across the\ncentral line. The triangles are numbered to illustrate each step. If we draw a\ntriangle at a positive x position, it would, by default, be in the place where\n296 triangle 1 is. A call to flipHorizontally first does a translation to the right,\nwhich gets us to triangle 2. It then scales, flipping the triangle over to position\n3. This is not where it should be, if it were mirrored in the given line. The\nsecond translate call fixes this\u2014it \u201ccancels\u201d the initial translation and makes\ntriangle 4 appear exactly where it should.\nWe can now draw a mirrored character at position (100,0) by flipping the\nworld around the character\u2019s vertical center.\n<canvas><\/canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\nlet img = document.createElement(\"img\");\nimg.src = \"img\/player.png\";\nlet spriteW = 24, spriteH = 30;\nimg.addEventListener(\"load\", () => {\nflipHorizontally(cx, 100 + spriteW \/ 2);\ncx.drawImage(img, 0, 0, spriteW, spriteH,\n100, 0, spriteW, spriteH);\n});\n<\/script>\nStoring and clearing transformations\nTransformations stick around. Everything else we draw after drawing that\nmirrored character would also be mirrored. That might be inconvenient.\nIt is possible to save the current transformation, do some drawing and trans-\nforming, and then restore the old transformation. This is usually the proper\nthing to do for a function that needs to temporarily transform the coordinate\nsystem. First, we save whatever transformation the code that called the func-\ntion was using. Then the function does its thing, adding more transformations\non top of the current transformation. Finally, we revert to the transformation\nwe started with.\nThe save and restore methods on the 2D canvas context do this transfor-\nmation management. They conceptually keep a stack of transformation states.\nWhen you call save, the current state is pushed onto the stack, and when you\ncall restore, the state on top of the stack is taken off and used as the context\u2019s\ncurrent transformation. You can also call resetTransform to fully reset the\ntransformation.\nThe branch function in the following example illustrates what you can do\nwith a function that changes the transformation and then calls a function (in\n297 this case itself), which continues drawing with the given transformation.\nThis function draws a treelike shape by drawing a line, moving the center\nof the coordinate system to the end of the line, and calling itself twice\u2014first\nrotated to the left and then rotated to the right. Every call reduces the length\nof the branch drawn, and the recursion stops when the length drops below 8.\n<canvas width=\"600\" height=\"300\"><\/canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\nfunction branch(length, angle, scale) {\ncx.fillRect(0, 0, 1, length);\nif (length < 8) return;\ncx.save();\ncx.translate(0, length);\ncx.rotate(-angle);\nbranch(length * scale, angle, scale);\ncx.rotate(2 * angle);\nbranch(length * scale, angle, scale);\ncx.restore();\n}\ncx.translate(300, 0);\nbranch(60, 0.5, 0.8);\n<\/script>\nThe result is a simple fractal.\nIf the calls to save and restore were not there, the second recursive call to\nbranch would end up with the position and rotation created by the first call.\nIt wouldn\u2019t be connected to the current branch but rather to the innermost,\nrightmost branch drawn by the first call. The resulting shape might also be\ninteresting, but it is definitely not a tree.\n298 Back to the game\nWe now know enough about canvas drawing to start working on a canvas-based\ndisplay system for the game from the previous chapter. The new display will\nno longer be showing just colored boxes. Instead, we\u2019ll use drawImage to draw\npictures that represent the game\u2019s elements.\nWe define another display object type called CanvasDisplay, supporting the\nsame interface as DOMDisplay from Chapter 16, namely, the methods syncState\nand clear.\nThis object keeps a little more information than DOMDisplay. Rather than\nusing the scroll position of its DOM element, it tracks its own viewport, which\ntells us what part of the level we are currently looking at. Finally, it keeps\na flipPlayer property so that even when the player is standing still, it keeps\nfacing the direction it last moved in.\nclass CanvasDisplay {\nconstructor(parent, level) {\nthis.canvas = document.createElement(\"canvas\");\nthis.canvas.width = Math.min(600, level.width * scale);\nthis.canvas.height = Math.min(450, level.height * scale);\nparent.appendChild(this.canvas);\nthis.cx = this.canvas.getContext(\"2d\");\nthis.flipPlayer = false;\nthis.viewport = {\nleft: 0,\ntop: 0,\nwidth: this.canvas.width \/ scale,\nheight: this.canvas.height \/ scale\n};\n}\nclear() {\nthis.canvas.remove();\n}\n}\nThe syncState method first computes a new viewport and then draws the\ngame scene at the appropriate position.\nCanvasDisplay.prototype.syncState = function(state) {\nthis.updateViewport(state);\n299 this.clearDisplay(state.status);\nthis.drawBackground(state.level);\nthis.drawActors(state.actors);\n};\nContrary to DOMDisplay, this display style does have to redraw the back-\nground on every update. Because shapes on a canvas are just pixels, after we\ndraw them there is no good way to move them (or remove them). The only\nway to update the canvas display is to clear it and redraw the scene. We may\nalso have scrolled, which requires the background to be in a different position.\nTheupdateViewportmethodissimilartoDOMDisplay\u2019sscrollPlayerIntoView\nmethod. It checks whether the player is too close to the edge of the screen\nand moves the viewport when this is the case.\nCanvasDisplay.prototype.updateViewport = function(state) {\nlet view = this.viewport, margin = view.width \/ 3;\nlet player = state.player;\nlet center = player.pos.plus(player.size.times(0.5));\nif (center.x < view.left + margin) {\nview.left = Math.max(center.x - margin, 0);\n} else if (center.x > view.left + view.width - margin) {\nview.left = Math.min(center.x + margin - view.width,\nstate.level.width - view.width);\n}\nif (center.y < view.top + margin) {\nview.top = Math.max(center.y - margin, 0);\n} else if (center.y > view.top + view.height - margin) {\nview.top = Math.min(center.y + margin - view.height,\nstate.level.height - view.height);\n}\n};\nThe calls to Math.max and Math.min ensure that the viewport does not end\nup showing space outside of the level. Math.max(x, 0) makes sure the resulting\nnumber is not less than zero. Math.min similarly guarantees that a value stays\nbelow a given bound.\nWhen clearing the display, we\u2019ll use a slightly different color depending on\nwhether the game is won (brighter) or lost (darker).\nCanvasDisplay.prototype.clearDisplay = function(status) {\nif (status == \"won\") {\n300 this.cx.fillStyle = \"rgb(68, 191, 255)\";\n} else if (status == \"lost\") {\nthis.cx.fillStyle = \"rgb(44, 136, 214)\";\n} else {\nthis.cx.fillStyle = \"rgb(52, 166, 251)\";\n}\nthis.cx.fillRect(0, 0,\nthis.canvas.width, this.canvas.height);\n};\nTo draw the background, we run through the tiles that are visible in the\ncurrent viewport, using the same trick used in the touches method from the\nprevious chapter.\nlet otherSprites = document.createElement(\"img\");\notherSprites.src = \"img\/sprites.png\";\nCanvasDisplay.prototype.drawBackground = function(level) {\nlet {left, top, width, height} = this.viewport;\nlet xStart = Math.floor(left);\nlet xEnd = Math.ceil(left + width);\nlet yStart = Math.floor(top);\nlet yEnd = Math.ceil(top + height);\nfor (let y = yStart; y < yEnd; y++) {\nfor (let x = xStart; x < xEnd; x++) {\nlet tile = level.rows[y][x];\nif (tile == \"empty\") continue;\nlet screenX = (x - left) * scale;\nlet screenY = (y - top) * scale;\nlet tileX = tile == \"lava\" ? scale : 0;\nthis.cx.drawImage(otherSprites,\ntileX, 0, scale, scale,\nscreenX, screenY, scale, scale);\n}\n}\n};\nTilesthatarenotemptyaredrawnwithdrawImage. TheotherSpritesimage\ncontains the pictures used for elements other than the player. It contains, from\nleft to right, the wall tile, the lava tile, and the sprite for a coin.\n301 Background tiles are 20 by 20 pixels since we will use the same scale that we\nused in DOMDisplay. Thus, the offset for lava tiles is 20 (the value of the scale\nbinding), and the offset for walls is 0.\nWe don\u2019t bother waiting for the sprite image to load. Calling drawImage\nwith an image that hasn\u2019t been loaded yet will simply do nothing. Thus, we\nmight fail to draw the game properly for the first few frames, while the image\nis still loading, but that is not a serious problem. Since we keep updating the\nscreen, the correct scene will appear as soon as the loading finishes.\nThe walking character shown earlier will be used to represent the player.\nThe code that draws it needs to pick the right sprite and direction based on\nthe player\u2019s current motion. The first eight sprites contain a walking animation.\nWhen the player is moving along a floor, we cycle through them based on the\ncurrent time. We want to switch frames every 60 milliseconds, so the time is\ndivided by 60 first. When the player is standing still, we draw the ninth sprite.\nDuring jumps, which are recognized by the fact that the vertical speed is not\nzero, we use the tenth, rightmost sprite.\nBecause the sprites are slightly wider than the player object\u201424 instead of\n16 pixels to allow some space for feet and arms\u2014the method has to adjust the\nx-coordinate and width by a given amount (playerXOverlap).\nlet playerSprites = document.createElement(\"img\");\nplayerSprites.src = \"img\/player.png\";\nconst playerXOverlap = 4;\nCanvasDisplay.prototype.drawPlayer = function(player, x, y,\nwidth, height){\nwidth += playerXOverlap * 2;\nx -= playerXOverlap;\nif (player.speed.x != 0) {\nthis.flipPlayer = player.speed.x < 0;\n}\nlet tile = 8;\nif (player.speed.y != 0) {\ntile = 9;\n} else if (player.speed.x != 0) {\ntile = Math.floor(Date.now() \/ 60) % 8;\n}\nthis.cx.save();\nif (this.flipPlayer) {\nflipHorizontally(this.cx, x + width \/ 2);\n}\n302 let tileX = tile * width;\nthis.cx.drawImage(playerSprites, tileX, 0, width, height,\nx, y, width, height);\nthis.cx.restore();\n};\nThe drawPlayer method is called by drawActors, which is responsible for\ndrawing all the actors in the game.\nCanvasDisplay.prototype.drawActors = function(actors) {\nfor (let actor of actors) {\nlet width = actor.size.x * scale;\nlet height = actor.size.y * scale;\nlet x = (actor.pos.x - this.viewport.left) * scale;\nlet y = (actor.pos.y - this.viewport.top) * scale;\nif (actor.type == \"player\") {\nthis.drawPlayer(actor, x, y, width, height);\n} else {\nlet tileX = (actor.type == \"coin\" ? 2 : 1) * scale;\nthis.cx.drawImage(otherSprites,\ntileX, 0, width, height,\nx, y, width, height);\n}\n}\n};\nWhen drawing something that is not the player, we look at its type to find\nthe offset of the correct sprite. The lava tile is found at offset 20, and the coin\nsprite is found at 40 (two times scale).\nWe have to subtract the viewport\u2019s position when computing the actor\u2019s\nposition since (0,0) on our canvas corresponds to the top left of the viewport,\nnot the top left of the level. We could also have used translate for this. Either\nway works.\nThat concludes the new display system. The resulting game looks something\nlike this:\n303 Choosing a graphics interface\nSo when you need to generate graphics in the browser, you can choose between\nplain HTML, SVG, and canvas. There is no single best approach that works in\nall situations. Each option has strengths and weaknesses.\nPlain HTML has the advantage of being simple. It also integrates well with\ntext. Both SVG and canvas allow you to draw text, but they won\u2019t help you\nposition that text or wrap it when it takes up more than one line. In an\nHTML-based picture, it is much easier to include blocks of text.\nSVG can be used to produce crisp graphics that look good at any zoom\nlevel. Unlike HTML, it is designed for drawing and is thus more suitable for\nthat purpose.\nBoth SVG and HTML build up a data structure (the DOM) that represents\nyour picture. This makes it possible to modify elements after they are drawn.\nIf you need to repeatedly change a small part of a big picture in response to\nwhat the user is doing or as part of an animation, doing it in a canvas can be\nneedlessly expensive. The DOM also allows us to register mouse event handlers\non every element in the picture (even on shapes drawn with SVG). You can\u2019t\ndo that with canvas.\nBut canvas\u2019s pixel-oriented approach can be an advantage when drawing\na huge number of tiny elements. The fact that it does not build up a data\nstructure but only repeatedly draws onto the same pixel surface gives canvas a\nlower cost per shape.\nThere are also effects, such as rendering a scene one pixel at a time (for\nexample, using a ray tracer) or postprocessing an image with JavaScript (blur-\nring or distorting it), that can be realistically handled only by a pixel-based\napproach.\nIn some cases, you may want to combine several of these techniques. For\n304 example, you might draw a graph with SVG or canvas but show textual infor-\nmation by positioning an HTML element on top of the picture.\nFor nondemanding applications, it really doesn\u2019t matter much which inter-\nface you choose. The display we built for our game in this chapter could have\nbeen implemented using any of these three graphics technologies since it does\nnot need to draw text, handle mouse interaction, or work with an extraordi-\nnarily large number of elements.\nSummary\nIn this chapter we discussed techniques for drawing graphics in the browser,\nfocusing on the <canvas> element.\nA canvas node represents an area in a document that our program may draw\non. This drawing is done through a drawing context object, created with the\ngetContext method.\nThe2Ddrawinginterfaceallowsustofillandstrokevariousshapes. Thecon-\ntext\u2019s fillStyle property determines how shapes are filled. The strokeStyle\nand lineWidth properties control the way lines are drawn.\nRectangles and pieces of text can be drawn with a single method call. The\nfillRect and strokeRect methods draw rectangles, and the fillText and\nstrokeText methods draw text. To create custom shapes, we must first build\nup a path.\nCalling beginPath starts a new path. A number of other methods add lines\nand curves to the current path. For example, lineTo can add a straight line.\nWhen a path is finished, it can be filled with the fill method or stroked with\nthe stroke method.\nMoving pixels from an image or another canvas onto our canvas is done with\nthe drawImage method. By default, this method draws the whole source image,\nbut by giving it more parameters, you can copy a specific area of the image.\nWe used this for our game by copying individual poses of the game character\nout of an image that contained many such poses.\nTransformations allow you to draw a shape in multiple orientations. A\n2D drawing context has a current transformation that can be changed with\nthe translate, scale, and rotate methods. These will affect all subsequent\ndrawing operations. A transformation state can be saved with the save method\nand restored with the restore method.\nWhen showing an animation on a canvas, the clearRect method can be used\nto clear part of the canvas before redrawing it.\n305 Exercises\nShapes\nWrite a program that draws the following shapes on a canvas:\n1. A trapezoid (a rectangle that is wider on one side)\n2. A red diamond (a rectangle rotated 45 degrees or \u00bc\u03c0 radians)\n3. A zigzagging line\n4. A spiral made up of 100 straight line segments\n5. A yellow star\nWhen drawing the last two, you may want to refer to the explanation of\nMath.cos and Math.sin in Chapter 14, which describes how to get coordinates\non a circle using these functions.\nI recommend creating a function for each shape. Pass the position, and\noptionally other properties such as the size or the number of points, as param-\neters. The alternative, which is to hard-code numbers all over your code, tends\nto make the code needlessly hard to read and modify.\nThe pie chart\nEarlier in the chapter, we saw an example program that drew a pie chart.\nModify this program so that the name of each category is shown next to the\nslice that represents it. Try to find a pleasing-looking way to automatically\nposition this text that would work for other data sets as well. You may assume\nthat categories are big enough to leave ample room for their labels.\nYou might need Math.sin and Math.cos again, which are described in Chap-\nter 14.\nA bouncing ball\nUsetherequestAnimationFrametechniquethatwesawinChapter14andChap-\nter 16 to draw a box with a bouncing ball in it. The ball moves at a constant\nspeed and bounces off the box\u2019s sides when it hits them.\n306 Precomputed mirroring\nOne unfortunate thing about transformations is that they slow down the draw-\ning of bitmaps. The position and size of each pixel has to be transformed, and\nthough it is possible that browsers will get cleverer about transformation in\nthe future, they currently cause a measurable increase in the time it takes to\ndraw a bitmap.\nIn a game like ours, where we are drawing only a single transformed sprite,\nthis is a nonissue. But imagine that we need to draw hundreds of characters\nor thousands of rotating particles from an explosion.\nThink of a way to allow us to draw an inverted character without loading\nadditional image files and without having to make transformed drawImage calls\nevery frame.\n307 \u201cCommunication must be stateless in nature [...] such that each\nrequest from client to server must contain all of the information\nnecessary to understand the request, and cannot take advantage of\nany stored context on the server.\u201d\n\u2014Roy Fielding, Architectural Styles and the Design of\nNetwork-based Software Architectures\nChapter18\nHTTP and Forms\nThe Hypertext Transfer Protocol, already mentioned in Chapter 13, is the mech-\nanism through which data is requested and provided on the World Wide Web.\nThis chapter describes the protocol in more detail and explains the way browser\nJavaScript has access to it.\nThe protocol\nIf you type eloquentjavascript.net\/18_http.html into your browser\u2019s address\nbar, the browser first looks up the address of the server associated with elo-\nquentjavascript.net and tries to open a TCP connection to it on port 80, the\ndefault port for HTTP tra\ufb00ic. If the server exists and accepts the connection,\nthe browser might send something like this:\nGET \/18_http.html HTTP\/1.1\nHost: eloquentjavascript.net\nUser-Agent: Your browser's name\nThen the server responds, through that same connection.\nHTTP\/1.1 200 OK\nContent-Length: 65585\nContent-Type: text\/html\nLast-Modified: Mon, 08 Jan 2018 10:29:45 GMT\n<!doctype html>\n... the rest of the document\nThe browser takes the part of the response after the blank line, its body\n(not to be confused with the HTML <body> tag), and displays it as an HTML\ndocument.\nThe information sent by the client is called the request. It starts with this\n308 line:\nGET \/18_http.html HTTP\/1.1\nThe first word is the method of the request. GET means that we want to get\nthe specified resource. Other common methods are DELETE to delete a resource,\nPUT to create or replace it, and POST to send information to it. Note that the\nserver is not obliged to carry out every request it gets. If you walk up to a\nrandom website and tell it to DELETE its main page, it\u2019ll probably refuse.\nThe part after the method name is the path of the resource the request\napplies to. In the simplest case, a resource is simply a file on the server, but\nthe protocol doesn\u2019t require it to be. A resource may be anything that can be\ntransferred as if it is a file. Many servers generate the responses they produce\non the fly. For example, if you open https:\/\/github.com\/marijnh, the server\nlooks in its database for a user named \u201cmarijnh\u201d, and if it finds one, it will\ngenerate a profile page for that user.\nAfter the resource path, the first line of the request mentions HTTP\/1.1 to\nindicate the version of the HTTP protocol it is using.\nIn practice, many sites use HTTP version 2, which supports the same con-\ncepts as version 1.1 but is a lot more complicated so that it can be faster.\nBrowsers will automatically switch to the appropriate protocol version when\ntalking to a given server, and the outcome of a request is the same regardless of\nwhich version is used. Because version 1.1 is more straightforward and easier\nto play around with, we\u2019ll focus on that.\nThe server\u2019s response will start with a version as well, followed by the status\nof the response, first as a three-digit status code and then as a human-readable\nstring.\nHTTP\/1.1 200 OK\nStatus codes starting with a 2 indicate that the request succeeded. Codes\nstarting with 4 mean there was something wrong with the request. 404 is\nprobably the most famous HTTP status code\u2014it means that the resource could\nnot be found. Codes that start with 5 mean an error happened on the server\nand the request is not to blame.\nThe first line of a request or response may be followed by any number of\nheaders. These are lines in the form name: value that specify extra informa-\ntion about the request or response. These headers were part of the example\nresponse:\n309 Content-Length: 65585\nContent-Type: text\/html\nLast-Modified: Thu, 04 Jan 2018 14:05:30 GMT\nThis tells us the size and type of the response document. In this case, it is\nan HTML document of 65,585 bytes. It also tells us when that document was\nlast modified.\nFor most headers, the client and server are free to decide whether to include\nthem in a request or response. But a few are required. For example, the Host\nheader, which specifies the hostname, should be included in a request because a\nserver might be serving multiple hostnames on a single IP address, and without\nthat header, the server won\u2019t know which hostname the client is trying to talk\nto.\nAfter the headers, both requests and responses may include a blank line\nfollowedbyabody, whichcontainsthe databeingsent. GETandDELETErequests\ndon\u2019t send along any data, but PUT and POST requests do. Similarly, some\nresponse types, such as error responses, do not require a body.\nBrowsers and HTTP\nAs we saw in the example, a browser will make a request when we enter a URL\nin its address bar. When the resulting HTML page references other files, such\nas images and JavaScript files, those are also retrieved.\nA moderately complicated website can easily include anywhere from 10 to\n200 resources. To be able to fetch those quickly, browsers will make several GET\nrequests simultaneously, rather than waiting for the responses one at a time.\nHTML pages may include forms, which allow the user to fill out information\nand send it to the server. This is an example of a form:\n<form method=\"GET\" action=\"example\/message.html\">\n<p>Name: <input type=\"text\" name=\"name\"><\/p>\n<p>Message:<br><textarea name=\"message\"><\/textarea><\/p>\n<p><button type=\"submit\">Send<\/button><\/p>\n<\/form>\nThis code describes a form with two fields: a small one asking for a name\nand a larger one to write a message in. When you click the Send button, the\nform is submitted, meaning that the content of its field is packed into an HTTP\nrequest and the browser navigates to the result of that request.\n310 When the <form> element\u2019s method attribute is GET (or is omitted), the in-\nformation in the form is added to the end of the action URL as a query string.\nThe browser might make a request to this URL:\nGET \/example\/message.html?name=Jean&message=Yes%3F HTTP\/1.1\nThe question mark indicates the end of the path part of the URL and the\nstart of the query. It is followed by pairs of names and values, corresponding to\nthe name attribute on the form field elements and the content of those elements,\nrespectively. An ampersand character (&) is used to separate the pairs.\nThe actual message encoded in the URL is \u201cYes?\u201d, but the question mark is\nreplaced by a strange code. Some characters in query strings must be escaped.\nThe question mark, represented as %3F, is one of those. There seems to be\nan unwritten rule that every format needs its own way of escaping characters.\nThis one, called URL encoding, uses a percent sign followed by two hexadecimal\n(base 16) digits that encode the character code. In this case, 3F, which is 63\nin decimal notation, is the code of a question mark character. JavaScript\nprovides the encodeURIComponent and decodeURIComponent functions to encode\nand decode this format.\nconsole.log(encodeURIComponent(\"Yes?\"));\n\/\/ \u2192 Yes%3F\nconsole.log(decodeURIComponent(\"Yes%3F\"));\n\/\/ \u2192 Yes?\nIf we change the method attribute of the HTML form in the example we saw\nearlier to POST, the HTTP request made to submit the form will use the POST\nmethod and put the query string in the body of the request, rather than adding\nit to the URL.\nPOST \/example\/message.html HTTP\/1.1\nContent-length: 24\nContent-type: application\/x-www-form-urlencoded\nname=Jean&message=Yes%3F\nGET requests should be used for requests that do not have side effects but\nsimply ask for information. Requests that change something on the server,\nfor example creating a new account or posting a message, should be expressed\nwith other methods, such as POST. Client-side software such as a browser knows\n311 that it shouldn\u2019t blindly make POST requests but will often implicitly make GET\nrequests\u2014for example to prefetch a resource it believes the user will soon need.\nWe\u2019ll come back to forms and how to interact with them from JavaScript\nlater in the chapter.\nFetch\nThe interface through which browser JavaScript can make HTTP requests is\ncalled fetch. Since it is relatively new, it conveniently uses promises (which is\nrare for browser interfaces).\nfetch(\"example\/data.txt\").then(response => {\nconsole.log(response.status);\n\/\/ \u2192 200\nconsole.log(response.headers.get(\"Content-Type\"));\n\/\/ \u2192 text\/plain\n});\nCalling fetch returns a promise that resolves to a Response object holding\ninformation about the server\u2019s response, such as its status code and its head-\ners. The headers are wrapped in a Map-like object that treats its keys (the\nheader names) as case insensitive because header names are not supposed to\nbe case sensitive. This means headers.get(\"Content-Type\") and headers.get\n(\"content-TYPE\") will return the same value.\nNote that the promise returned by fetch resolves successfully even if the\nserver responded with an error code. It might also be rejected if there is a\nnetwork error or if the server that the request is addressed to can\u2019t be found.\nThe first argument to fetch is the URL that should be requested. When\nthat URL doesn\u2019t start with a protocol name (such as http:), it is treated as\nrelative, which means it is interpreted relative to the current document. When\nit starts with a slash (\/), it replaces the current path, which is the part after\nthe server name. When it does not, the part of the current path up to and\nincluding its last slash character is put in front of the relative URL.\nTo get at the actual content of a response, you can use its text method.\nBecause the initial promise is resolved as soon as the response\u2019s headers have\nbeen received and because reading the response body might take a while longer,\nthis again returns a promise.\nfetch(\"example\/data.txt\")\n.then(resp => resp.text())\n.then(text => console.log(text));\n312 \/\/ \u2192 This is the content of data.txt\nA similar method, called json, returns a promise that resolves to the value\nyou get when parsing the body as JSON or rejects if it\u2019s not valid JSON.\nBy default, fetch uses the GET method to make its request and does not\ninclude a request body. You can configure it differently by passing an object\nwith extra options as a second argument. For example, this request tries to\ndelete example\/data.txt:\nfetch(\"example\/data.txt\", {method: \"DELETE\"}).then(resp => {\nconsole.log(resp.status);\n\/\/ \u2192 405\n});\nThe 405 status code means \u201cmethod not allowed\u201d, an HTTP server\u2019s way of\nsaying \u201cI can\u2019t do that\u201d.\nTo add a request body, you can include a body option. To set headers, there\u2019s\nthe headers option. For example, this request includes a Range header, which\ninstructs the server to return only part of a response.\nfetch(\"example\/data.txt\", {headers: {Range: \"bytes=8-19\"}})\n.then(resp => resp.text())\n.then(console.log);\n\/\/ \u2192 the content\nThe browser will automatically add some request headers, such as \u201cHost\u201d\nand those needed for the server to figure out the size of the body. But adding\nyour own headers is often useful to include things such as authentication infor-\nmation or to tell the server which file format you\u2019d like to receive.\nHTTP sandboxing\nMaking HTTP requests in web page scripts once again raises concerns about\nsecurity. The person who controls the script might not have the same interests\nas the person on whose computer it is running. More specifically, if I visit the-\nmafia.org, I do not want its scripts to be able to make a request to mybank.com,\nusing identifying information from my browser, with instructions to transfer all\nmy money to some random account.\nFor this reason, browsers protect us by disallowing scripts to make HTTP\n313 requests to other domains (names such as themafia.org and mybank.com).\nThis can be an annoying problem when building systems that want to ac-\ncess several domains for legitimate reasons. Fortunately, servers can include a\nheader like this in their response to explicitly indicate to the browser that it is\nokay for the request to come from another domain:\nAccess-Control-Allow-Origin: *\nAppreciating HTTP\nWhen building a system that requires communication between a JavaScript\nprogram running in the browser (client-side) and a program on a server (server-\nside), there are several different ways to model this communication.\nA commonly used model is that of remote procedure calls. In this model,\ncommunication follows the patterns of normal function calls, except that the\nfunction is actually running on another machine. Calling it involves making a\nrequest to the server that includes the function\u2019s name and arguments. The\nresponse to that request contains the returned value.\nWhen thinking in terms of remote procedure calls, HTTP is just a vehicle\nfor communication, and you will most likely write an abstraction layer that\nhides it entirely.\nAnother approach is to build your communication around the concept of\nresources and HTTP methods. Instead of a remote procedure called addUser,\nyou use a PUT request to \/users\/larry. Instead of encoding that user\u2019s prop-\nerties in function arguments, you define a JSON document format (or use an\nexisting format) that represents a user. The body of the PUT request to create\na new resource is then such a document. A resource is fetched by making a GET\nrequest to the resource\u2019s URL (for example, \/user\/larry), which again returns\nthe document representing the resource.\nThis second approach makes it easier to use some of the features that HTTP\nprovides, such as support for caching resources (keeping a copy on the client for\nfast access). The concepts used in HTTP, which are well designed, can provide\na helpful set of principles to design your server interface around.\nSecurity and HTTPS\nData traveling over the Internet tends to follow a long, dangerous road. To\nget to its destination, it must hop through anything from coffee shop Wi-Fi\n314 hotspots to networks controlled by various companies and states. At any point\nalong its route it may be inspected or even modified.\nIf it is important that something remain secret, such as the password to\nyour email account, or that it arrive at its destination unmodified, such as the\naccount number you transfer money to via your bank\u2019s website, plain HTTP\nis not good enough.\nThe secure HTTP protocol, used for URLs starting with https:\/\/, wraps\nHTTP tra\ufb00ic in a way that makes it harder to read and tamper with. Before\nexchanging data, the client verifies that the server is who it claims to be by\nasking it to prove that it has a cryptographic certificate issued by a certificate\nauthority that the browser recognizes. Next, all data going over the connection\nis encrypted in a way that should prevent eavesdropping and tampering.\nThus, whenitworksright, HTTPSpreventsotherpeoplefromimpersonating\nthe website you are trying to talk to and from snooping on your communication.\nIt is not perfect, and there have been various incidents where HTTPS failed\nbecause of forged or stolen certificates and broken software, but it is a lot safer\nthan plain HTTP.\nForm fields\nForms were originally designed for the pre-JavaScript Web to allow web sites\nto send user-submitted information in an HTTP request. This design assumes\nthat interaction with the server always happens by navigating to a new page.\nBut their elements are part of the DOM like the rest of the page, and the\nDOM elements that represent form fields support a number of properties and\nevents that are not present on other elements. These make it possible to inspect\nand control such input fields with JavaScript programs and do things such as\nadding new functionality to a form or using forms and fields as building blocks\nin a JavaScript application.\nA web form consists of any number of input fields grouped in a <form>\ntag. HTML allows several different styles of fields, ranging from simple on\/off\ncheckboxes to drop-down menus and fields for text input. This book won\u2019t try\nto comprehensively discuss all field types, but we\u2019ll start with a rough overview.\nA lot of field types use the <input> tag. This tag\u2019s type attribute is used to\nselect the field\u2019s style. These are some commonly used <input> types:\n315 text A single-line text field\npassword Same as text but hides the text that is typed\ncheckbox An on\/off switch\nradio (Part of) a multiple-choice field\nfile Allows the user to choose a file from their computer\nForm fields do not necessarily have to appear in a <form> tag. You can put\nthem anywhere in a page. Such form-less fields cannot be submitted (only a\nform as a whole can), but when responding to input with JavaScript, we often\ndon\u2019t want to submit our fields normally anyway.\n<p><input type=\"text\" value=\"abc\"> (text)<\/p>\n<p><input type=\"password\" value=\"abc\"> (password)<\/p>\n<p><input type=\"checkbox\" checked> (checkbox)<\/p>\n<p><input type=\"radio\" value=\"A\" name=\"choice\">\n<input type=\"radio\" value=\"B\" name=\"choice\" checked>\n<input type=\"radio\" value=\"C\" name=\"choice\"> (radio)<\/p>\n<p><input type=\"file\"> (file)<\/p>\nThe fields created with this HTML code look like this:\nThe JavaScript interface for such elements differs with the type of the ele-\nment.\nMultiline text fields have their own tag, <textarea>, mostly because using\nan attribute to specify a multiline starting value would be awkward. The <\ntextarea> tag requires a matching <\/textarea> closing tag and uses the text\nbetween those two, instead of the value attribute, as starting text.\n<textarea>\none\ntwo\nthree\n<\/textarea>\nFinally, the <select> tag is used to create a field that allows the user to\nselect from a number of predefined options.\n316 <select>\n<option>Pancakes<\/option>\n<option>Pudding<\/option>\n<option>Ice cream<\/option>\n<\/select>\nSuch a field looks like this:\nWhenever the value of a form field changes, it will fire a \"change\" event.\nFocus\nUnlike most elements in HTML documents, form fields can get keyboard focus.\nWhen clicked or activated in some other way, they become the currently active\nelement and the recipient of keyboard input.\nThus, you can type into a text field only when it is focused. Other fields\nrespond differently to keyboard events. For example, a <select> menu tries to\nmove to the option that contains the text the user typed and responds to the\narrow keys by moving its selection up and down.\nWe can control focus from JavaScript with the focus and blur methods. The\nfirst moves focus to the DOM element it is called on, and the second removes\nfocus. The value in document.activeElement corresponds to the currently fo-\ncused element.\n<input type=\"text\">\n<script>\ndocument.querySelector(\"input\").focus();\nconsole.log(document.activeElement.tagName);\n\/\/ \u2192 INPUT\ndocument.querySelector(\"input\").blur();\nconsole.log(document.activeElement.tagName);\n\/\/ \u2192 BODY\n<\/script>\nFor some pages, the user is expected to want to interact with a form field\nimmediately. JavaScript can be used to focus this field when the document is\nloaded, but HTML also provides the autofocus attribute, which produces the\nsame effect while letting the browser know what we are trying to achieve. This\n317 gives the browser the option to disable the behavior when it is not appropriate,\nsuch as when the user has put the focus on something else.\nBrowsers traditionally also allow the user to move the focus through the doc-\nument by pressing the tab key. We can influence the order in which elements\nreceive focus with the tabindex attribute. The following example document\nwill let the focus jump from the text input to the OK button, rather than\ngoing through the help link first:\n<input type=\"text\" tabindex=1> <a href=\".\">(help)<\/a>\n<button onclick=\"console.log('ok')\" tabindex=2>OK<\/button>\nBy default, most types of HTML elements cannot be focused. But you can\naddatabindexattributetoanyelementthatwillmakeitfocusable. Atabindex\nof -1 makes tabbing skip over an element, even if it is normally focusable.\nDisabled fields\nAll form fields can be disabled through their disabled attribute. It is an at-\ntribute that can be specified without value\u2014the fact that it is present at all\ndisables the element.\n<button>I'm all right<\/button>\n<button disabled>I'm out<\/button>\nDisabled fields cannot be focused or changed, and browsers make them look\ngray and faded.\nWhen a program is in the process of handling an action caused by some\nbutton or other control that might require communication with the server and\nthus take a while, it can be a good idea to disable the control until the action\nfinishes. That way, when the user gets impatient and clicks it again, they don\u2019t\naccidentally repeat their action.\nThe form as a whole\nWhen a field is contained in a <form> element, its DOM element will have a\nform property linking back to the form\u2019s DOM element. The <form> element,\n318 in turn, has a property called elements that contains an array-like collection\nof the fields inside it.\nThe name attribute of a form field determines the way its value will be iden-\ntified when the form is submitted. It can also be used as a property name when\naccessing the form\u2019s elements property, which acts both as an array-like object\n(accessible by number) and a map (accessible by name).\n<form action=\"example\/submit.html\">\nName: <input type=\"text\" name=\"name\"><br>\nPassword: <input type=\"password\" name=\"password\"><br>\n<button type=\"submit\">Log in<\/button>\n<\/form>\n<script>\nlet form = document.querySelector(\"form\");\nconsole.log(form.elements[1].type);\n\/\/ \u2192 password\nconsole.log(form.elements.password.type);\n\/\/ \u2192 password\nconsole.log(form.elements.name.form == form);\n\/\/ \u2192 true\n<\/script>\nA button with a type attribute of submit will, when pressed, cause the form\nto be submitted. Pressing enter when a form field is focused has the same\neffect.\nSubmitting a form normally means that the browser navigates to the page\nindicated by the form\u2019s action attribute, using either a GET or a POST request.\nBut before that happens, a \"submit\" event is fired. You can handle this event\nwith JavaScript and prevent this default behavior by calling preventDefault\non the event object.\n<form action=\"example\/submit.html\">\nValue: <input type=\"text\" name=\"value\">\n<button type=\"submit\">Save<\/button>\n<\/form>\n<script>\nlet form = document.querySelector(\"form\");\nform.addEventListener(\"submit\", event => {\nconsole.log(\"Saving value\", form.elements.value.value);\nevent.preventDefault();\n});\n<\/script>\n319 Intercepting \"submit\" events in JavaScript has various uses. We can write\ncode to verify that the values the user entered make sense and immediately\nshow an error message instead of submitting the form. Or we can disable the\nregular way of submitting the form entirely, as in the example, and have our\nprogram handle the input, possibly using fetch to send it to a server without\nreloading the page.\nText fields\nFields created by <textarea> tags, or <input> tags with a type of text or\npassword, share a common interface. Their DOM elements have a value prop-\nerty that holds their current content as a string value. Setting this property to\nanother string changes the field\u2019s content.\nThe selectionStart and selectionEnd properties of text fields give us infor-\nmation about the cursor and selection in the text. When nothing is selected,\nthese two properties hold the same number, indicating the position of the cur-\nsor. For example, 0 indicates the start of the text, and 10 indicates the cursor\nis after the 10th character. When part of the field is selected, the two properties\nwill differ, giving us the start and end of the selected text. Like value, these\nproperties may also be written to.\nImagine you are writing an article about Khasekhemwy but have some trou-\nble spelling his name. The following code wires up a <textarea> tag with an\nevent handler that, when you press F2, inserts the string \u201cKhasekhemwy\u201d for\nyou.\n<textarea><\/textarea>\n<script>\nlet textarea = document.querySelector(\"textarea\");\ntextarea.addEventListener(\"keydown\", event => {\n\/\/ The key code for F2 happens to be 113\nif (event.keyCode == 113) {\nreplaceSelection(textarea, \"Khasekhemwy\");\nevent.preventDefault();\n}\n});\nfunction replaceSelection(field, word) {\nlet from = field.selectionStart, to = field.selectionEnd;\nfield.value = field.value.slice(0, from) + word +\nfield.value.slice(to);\n\/\/ Put the cursor after the word\nfield.selectionStart = from + word.length;\nfield.selectionEnd = from + word.length;\n320 }\n<\/script>\nThe replaceSelection function replaces the currently selected part of a text\nfield\u2019s content with the given word and then moves the cursor after that word\nso that the user can continue typing.\nThe \"change\" event for a text field does not fire every time something is\ntyped. Rather, it fires when the field loses focus after its content was changed.\nTo respond immediately to changes in a text field, you should register a han-\ndler for the \"input\" event instead, which fires for every time the user types a\ncharacter, deletes text, or otherwise manipulates the field\u2019s content.\nThe following example shows a text field and a counter displaying the current\nlength of the text in the field:\n<input type=\"text\"> length: <span id=\"length\">0<\/span>\n<script>\nlet text = document.querySelector(\"input\");\nlet output = document.querySelector(\"#length\");\ntext.addEventListener(\"input\", () => {\noutput.textContent = text.value.length;\n});\n<\/script>\nCheckboxes and radio buttons\nA checkbox field is a binary toggle. Its value can be extracted or changed\nthrough its checked property, which holds a Boolean value.\n<label>\n<input type=\"checkbox\" id=\"purple\"> Make this page purple\n<\/label>\n<script>\nlet checkbox = document.querySelector(\"#purple\");\ncheckbox.addEventListener(\"change\", () => {\ndocument.body.style.background =\ncheckbox.checked ? \"mediumpurple\" : \"\";\n});\n<\/script>\nThe <label> tag associates a piece of document with an input field. Clicking\n321 anywhere on the label will activate the field, which focuses it and toggles its\nvalue when it is a checkbox or radio button.\nA radio button is similar to a checkbox, but it\u2019s implicitly linked to other\nradio buttons with the same name attribute so that only one of them can be\nactive at any time.\nColor:\n<label>\n<input type=\"radio\" name=\"color\" value=\"orange\"> Orange\n<\/label>\n<label>\n<input type=\"radio\" name=\"color\" value=\"lightgreen\"> Green\n<\/label>\n<label>\n<input type=\"radio\" name=\"color\" value=\"lightblue\"> Blue\n<\/label>\n<script>\nlet buttons = document.querySelectorAll(\"[name=color]\");\nfor (let button of Array.from(buttons)) {\nbutton.addEventListener(\"change\", () => {\ndocument.body.style.background = button.value;\n});\n}\n<\/script>\nThe square brackets in the CSS query given to querySelectorAll are used\nto match attributes. It selects elements whose name attribute is \"color\".\nSelect fields\nSelect fields are conceptually similar to radio buttons\u2014they also allow the user\nto choose from a set of options. But where a radio button puts the layout of\nthe options under our control, the appearance of a <select> tag is determined\nby the browser.\nSelect fields also have a variant that is more akin to a list of checkboxes,\nrather than radio boxes. When given the multiple attribute, a <select> tag\nwill allow the user to select any number of options, rather than just a single\noption. This will, in most browsers, show up differently than a normal select\nfield, which is typically drawn as a drop-down control that shows the options\nonly when you open it.\nEach <option> tag has a value. This value can be defined with a value\nattribute. When that is not given, the text inside the option will count as its\n322 value. The value property of a <select> element reflects the currently selected\noption. For a multiple field, though, this property doesn\u2019t mean much since it\nwill give the value of only one of the currently selected options.\nThe <option> tags for a <select> field can be accessed as an array-like ob-\nject through the field\u2019s options property. Each option has a property called\nselected, which indicates whether that option is currently selected. The prop-\nerty can also be written to select or deselect an option.\nThis example extracts the selected values from a multiple select field and\nuses them to compose a binary number from individual bits. Hold control\n(or command on a Mac) to select multiple options.\n<select multiple>\n<option value=\"1\">0001<\/option>\n<option value=\"2\">0010<\/option>\n<option value=\"4\">0100<\/option>\n<option value=\"8\">1000<\/option>\n<\/select> = <span id=\"output\">0<\/span>\n<script>\nlet select = document.querySelector(\"select\");\nlet output = document.querySelector(\"#output\");\nselect.addEventListener(\"change\", () => {\nlet number = 0;\nfor (let option of Array.from(select.options)) {\nif (option.selected) {\nnumber += Number(option.value);\n}\n}\noutput.textContent = number;\n});\n<\/script>\nFile fields\nFile fields were originally designed as a way to upload files from the user\u2019s\nmachine through a form. In modern browsers, they also provide a way to read\nsuch files from JavaScript programs. The field acts as a kind of gatekeeper.\nThe script cannot simply start reading private files from the user\u2019s computer,\nbut if the user selects a file in such a field, the browser interprets that action\nto mean that the script may read the file.\nA file field usually looks like a button labeled with something like \u201cchoose\nfile\u201d or \u201cbrowse\u201d, with information about the chosen file next to it.\n323 <input type=\"file\">\n<script>\nlet input = document.querySelector(\"input\");\ninput.addEventListener(\"change\", () => {\nif (input.files.length > 0) {\nlet file = input.files[0];\nconsole.log(\"You chose\", file.name);\nif (file.type) console.log(\"It has type\", file.type);\n}\n});\n<\/script>\nThe files property of a file field element is an array-like object (again,\nnot a real array) containing the files chosen in the field. It is initially empty.\nThe reason there isn\u2019t simply a file property is that file fields also support a\nmultiple attribute, which makes it possible to select multiple files at the same\ntime.\nObjects in the files object have properties such as name (the filename), size\n(the file\u2019s size in bytes, which are chunks of 8 bits), and type (the media type\nof the file, such as text\/plain or image\/jpeg).\nWhat it does not have is a property that contains the content of the file.\nGetting at that is a little more involved. Since reading a file from disk can take\ntime, the interface must be asynchronous to avoid freezing the document.\n<input type=\"file\" multiple>\n<script>\nlet input = document.querySelector(\"input\");\ninput.addEventListener(\"change\", () => {\nfor (let file of Array.from(input.files)) {\nlet reader = new FileReader();\nreader.addEventListener(\"load\", () => {\nconsole.log(\"File\", file.name, \"starts with\",\nreader.result.slice(0, 20));\n});\nreader.readAsText(file);\n}\n});\n<\/script>\nReading a file is done by creating a FileReader object, registering a \"load\"\nevent handler for it, and calling its readAsText method, giving it the file we\nwant to read. Once loading finishes, the reader\u2019s result property contains the\n324 file\u2019s content.\nFileReaders also fire an \"error\" event when reading the file fails for any\nreason. The error object itself will end up in the reader\u2019s error property. This\ninterface was designed before promises became part of the language. You could\nwrap it in a promise like this:\nfunction readFileText(file) {\nreturn new Promise((resolve, reject) => {\nlet reader = new FileReader();\nreader.addEventListener(\n\"load\", () => resolve(reader.result));\nreader.addEventListener(\n\"error\", () => reject(reader.error));\nreader.readAsText(file);\n});\n}\nStoring data client-side\nSimple HTML pages with a bit of JavaScript can be a great format for \u201cmini\napplications\u201d\u2014small helper programs that automate basic tasks. By connect-\ning a few form fields with event handlers, you can do anything from converting\nbetween centimeters and inches to computing passwords from a master pass-\nword and a website name.\nWhen such an application needs to remember something between sessions,\nyou cannot use JavaScript bindings\u2014those are thrown away every time the\npage is closed. You could set up a server, connect it to the Internet, and have\nyour application store something there. We will see how to do that in Chapter\n20. But that\u2019s a lot of extra work and complexity. Sometimes it is enough to\njust keep the data in the browser.\nThe localStorage object can be used to store data in a way that survives\npage reloads. This object allows you to file string values under names.\nlocalStorage.setItem(\"username\", \"marijn\");\nconsole.log(localStorage.getItem(\"username\"));\n\/\/ \u2192 marijn\nlocalStorage.removeItem(\"username\");\nA value in localStorage sticks around until it is overwritten, it is removed\nwith removeItem, or the user clears their local data.\n325 Sitesfromdifferentdomainsgetdifferentstoragecompartments. Thatmeans\ndata stored in localStorage by a given website can, in principle, be read (and\noverwritten) only by scripts on that same site.\nBrowsers do enforce a limit on the size of the data a site can store in\nlocalStorage. That restriction, along with the fact that filling up people\u2019s\nhard drives with junk is not really profitable, prevents the feature from eating\nup too much space.\nThe following code implements a crude note-taking application. It keeps a\nset of named notes and allows the user to edit notes and create new ones.\nNotes: <select><\/select> <button>Add<\/button><br>\n<textarea style=\"width: 100%\"><\/textarea>\n<script>\nlet list = document.querySelector(\"select\");\nlet note = document.querySelector(\"textarea\");\nlet state;\nfunction setState(newState) {\nlist.textContent = \"\";\nfor (let name of Object.keys(newState.notes)) {\nlet option = document.createElement(\"option\");\noption.textContent = name;\nif (newState.selected == name) option.selected = true;\nlist.appendChild(option);\n}\nnote.value = newState.notes[newState.selected];\nlocalStorage.setItem(\"Notes\", JSON.stringify(newState));\nstate = newState;\n}\nsetState(JSON.parse(localStorage.getItem(\"Notes\")) || {\nnotes: {\"shopping list\": \"Carrots\\nRaisins\"},\nselected: \"shopping list\"\n});\nlist.addEventListener(\"change\", () => {\nsetState({notes: state.notes, selected: list.value});\n});\nnote.addEventListener(\"change\", () => {\nsetState({\nnotes: Object.assign({}, state.notes,\n{[state.selected]: note.value}),\nselected: state.selected\n});\n326 });\ndocument.querySelector(\"button\")\n.addEventListener(\"click\", () => {\nlet name = prompt(\"Note name\");\nif (name) setState({\nnotes: Object.assign({}, state.notes, {[name]: \"\"}),\nselected: name\n});\n});\n<\/script>\nThescriptgetsitsstartingstatefromthe\"Notes\"valuestoredinlocalStorage\nor, if that is missing, creates an example state that has only a shopping list in\nit. Reading a field that does not exist from localStorage will yield null. Pass-\ning null to JSON.parse will make it parse the string \"null\" and return null.\nThus, the || operator can be used to provide a default value in a situation like\nthis.\nThe setState method makes sure the DOM is showing a given state and\nstores the new state to localStorage. Event handlers call this function to\nmove to a new state.\nThe use of Object.assign in the example is intended to create a new object\nthat is a clone of the old state.notes, but with one property added or over-\nwritten. Object.assign takes its first argument and adds all properties from\nany further arguments to it. Thus, giving it an empty object will cause it to\nfill a fresh object. The square brackets notation in the third argument is used\nto create a property whose name is based on some dynamic value.\nThere is another object, similar to localStorage, called sessionStorage.\nThe difference between the two is that the content of sessionStorage is forgot-\nten at the end of each session, which for most browsers means whenever the\nbrowser is closed.\nSummary\nIn this chapter, we discussed how the HTTP protocol works. A client sends\na request, which contains a method (usually GET) and a path that identifies a\nresource. The server then decides what to do with the request and responds\nwith a status code and a response body. Both requests and responses may\ncontain headers that provide additional information.\nThe interface through which browser JavaScript can make HTTP requests\nis called fetch. Making a request looks like this:\n327 fetch(\"\/18_http.html\").then(r => r.text()).then(text => {\nconsole.log(`The page starts with ${text.slice(0, 15)}`);\n});\nBrowsers make GET requests to fetch the resources needed to display a web\npage. A page may also contain forms, which allow information entered by the\nuser to be sent as a request for a new page when the form is submitted.\nHTML can represent various types of form fields, such as text fields, check-\nboxes, multiple-choice fields, and file pickers.\nSuch fields can be inspected and manipulated with JavaScript. They fire the\n\"change\" event when changed, fire the \"input\" event when text is typed, and\nreceive keyboard events when they have keyboard focus. Properties like value\n(for text and select fields) or checked (for checkboxes and radio buttons) are\nused to read or set the field\u2019s content.\nWhen a form is submitted, a \"submit\" event is fired on it. A JavaScript\nhandler can call preventDefault on that event to disable the browser\u2019s default\nbehavior. Form field elements may also occur outside of a form tag.\nWhen the user has selected a file from their local file system in a file picker\nfield, the FileReader interface can be used to access the content of this file from\na JavaScript program.\nThe localStorage and sessionStorage objects can be used to save informa-\ntion in a way that survives page reloads. The first object saves the data forever\n(or until the user decides to clear it), and the second saves it until the browser\nis closed.\nExercises\nContent negotiation\nOne of the things HTTP can do is called content negotiation. The Accept\nrequest header is used to tell the server what type of document the client\nwould like to get. Many servers ignore this header, but when a server knows of\nvarious ways to encode a resource, it can look at this header and send the one\nthat the client prefers.\nTheURLhttps:\/\/eloquentjavascript.net\/author isconfiguredtorespondwith\neither plaintext, HTML, or JSON, depending on what the client asks for. These\nformats are identified by the standardized media types text\/plain, text\/html,\nand application\/json.\nSend requests to fetch all three formats of this resource. Use the headers\n328 property in the options object passed to fetch to set the header named Accept\nto the desired media type.\nFinally, try asking for the media type application\/rainbows+unicorns and\nsee which status code that produces.\nA JavaScript workbench\nBuild an interface that allows people to type and run pieces of JavaScript code.\nPutabuttonnexttoa<textarea>fieldthat, whenpressed, usestheFunction\nconstructor we saw in Chapter 10 to wrap the text in a function and call it.\nConvert the return value of the function, or any error it raises, to a string and\ndisplay it below the text field.\nConway's Game of Life\nConway\u2019s Game of Life is a simple simulation that creates artificial \u201clife\u201d on\na grid, each cell of which is either alive or not. Each generation (turn), the\nfollowing rules are applied:\n\u2022 Any live cell with fewer than two or more than three live neighbors dies.\n\u2022 Any live cell with two or three live neighbors lives on to the next gener-\nation.\n\u2022 Any dead cell with exactly three live neighbors becomes a live cell.\nA neighbor is defined as any adjacent cell, including diagonally adjacent\nones.\nNote that these rules are applied to the whole grid at once, not one square\nat a time. That means the counting of neighbors is based on the situation at\nthe start of the generation, and changes happening to neighbor cells during this\ngeneration should not influence the new state of a given cell.\nImplement this game using whichever data structure you find appropriate.\nUse Math.random to populate the grid with a random pattern initially. Display\nit as a grid of checkbox fields, with a button next to it to advance to the next\ngeneration. When the user checks or unchecks the checkboxes, their changes\nshould be included when computing the next generation.\n329 \u201cI look at the many colors before me. I look at my blank canvas.\nThen, I try to apply colors like words that shape poems, like notes\nthat shape music.\u201d\n\u2014Joan Miro\nChapter19\nProject: A Pixel Art Editor\nThe material from the previous chapters gives you all the elements you need\nto build a basic web application. In this chapter, we will do just that.\nOur application will be a pixel drawing program, where you can modify a\npicture pixel by pixel by manipulating a zoomed-in view of it, shown as a grid\nof colored squares. You can use the program to open image files, scribble on\nthem with your mouse or other pointer device, and save them. This is what it\nwill look like:\nPainting on a computer is great. You don\u2019t need to worry about materials,\nskill, or talent. You just start smearing.\nComponents\nThe interface for the application shows a big <canvas> element on top, with a\nnumber of form fields below it. The user draws on the picture by selecting a\ntool from a <select> field and then clicking, touching, or dragging across the\ncanvas. There are tools for drawing single pixels or rectangles, for filling an\narea, and for picking a color from the picture.\nWewillstructuretheeditorinterfaceasanumberofcomponents, objectsthat\nare responsible for a piece of the DOM and that may contain other components\ninside them.\nThe state of the application consists of the current picture, the selected tool,\nand the selected color. We\u2019ll set things up so that the state lives in a single\n330 value, and the interface components always base the way they look on the\ncurrent state.\nTo see why this is important, let\u2019s consider the alternative\u2014distributing\npieces of state throughout the interface. Up to a certain point, this is easier to\nprogram. We can just put in a color field and read its value when we need to\nknow the current color.\nBut then we add the color picker\u2014a tool that lets you click the picture to\nselectthecolorofagivenpixel. Tokeepthecolorfieldshowingthecorrectcolor,\nthat tool would have to know that it exists and update it whenever it picks a\nnew color. If you ever add another place that makes the color visible (maybe\nthe mouse cursor could show it), you have to update your color-changing code\nto keep that synchronized.\nIn effect, this creates a problem where each part of the interface needs to\nknow about all other parts, which is not very modular. For small applications\nlike the one in this chapter, that may not be a problem. For bigger projects, it\ncan turn into a real nightmare.\nTo avoid this nightmare on principle, we\u2019re going to be strict about data\nflow. There is a state, and the interface is drawn based on that state. An\ninterface component may respond to user actions by updating the state, at\nwhich point the components get a chance to synchronize themselves with this\nnew state.\nIn practice, each component is set up so that when it is given a new state, it\nalso notifies its child components, insofar as those need to be updated. Setting\nthis up is a bit of a hassle. Making this more convenient is the main selling\npoint of many browser programming libraries. But for a small application like\nthis, we can do it without such infrastructure.\nUpdates to the state are represented as objects, which we\u2019ll call actions.\nComponentsmaycreatesuchactionsanddispatch them\u2014givethemtoacentral\nstatemanagementfunction. Thatfunctioncomputesthenextstate, afterwhich\nthe interface components update themselves to this new state.\nWe\u2019re taking the messy task of running a user interface and applying some\nstructure to it. Though the DOM-related pieces are still full of side effects,\nthey are held up by a conceptually simple backbone: the state update cycle.\nThe state determines what the DOM looks like, and the only way DOM events\ncan change the state is by dispatching actions to the state.\nThere are many variants of this approach, each with its own benefits and\nproblems, but their central idea is the same: state changes should go through\na single well-defined channel, not happen all over the place.\nOurcomponentswillbeclassesconformingtoaninterface. Theirconstructor\nis given a state\u2014which may be the whole application state or some smaller\n331 value if it doesn\u2019t need access to everything\u2014and uses that to build up a dom\nproperty. This is the DOM element that represents the component. Most\nconstructors will also take some other values that won\u2019t change over time, such\nas the function they can use to dispatch an action.\nEach component has a syncState method that is used to synchronize it to\na new state value. The method takes one argument, the state, which is of the\nsame type as the first argument to its constructor.\nThe state\nThe application state will be an object with picture, tool, and color prop-\nerties. The picture is itself an object that stores the width, height, and pixel\ncontent of the picture. The pixels are stored in an array, in the same way as\nthe matrix class from Chapter 6\u2014row by row, from top to bottom.\nclass Picture {\nconstructor(width, height, pixels) {\nthis.width = width;\nthis.height = height;\nthis.pixels = pixels;\n}\nstatic empty(width, height, color) {\nlet pixels = new Array(width * height).fill(color);\nreturn new Picture(width, height, pixels);\n}\npixel(x, y) {\nreturn this.pixels[x + y * this.width];\n}\ndraw(pixels) {\nlet copy = this.pixels.slice();\nfor (let {x, y, color} of pixels) {\ncopy[x + y * this.width] = color;\n}\nreturn new Picture(this.width, this.height, copy);\n}\n}\nWe want to be able to treat a picture as an immutable value, for reasons\nthat we\u2019ll get back to later in the chapter. But we also sometimes need to\nupdate a whole bunch of pixels at a time. To be able to do that, the class\nhas a draw method that expects an array of updated pixels\u2014objects with x, y,\nand color properties\u2014and creates a new picture with those pixels overwritten.\n332 This method uses slice without arguments to copy the entire pixel array\u2014the\nstart of the slice defaults to 0, and the end defaults to the array\u2019s length.\nThe empty method uses two pieces of array functionality that we haven\u2019t\nseen before. The Array constructor can be called with a number to create an\nempty array of the given length. The fill method can then be used to fill this\narray with a given value. These are used to create an array in which all pixels\nhave the same color.\nColors are stored as strings containing traditional CSS color codes made up\nof a hash sign (#) followed by six hexadecimal (base-16) digits\u2014two for the\nred component, two for the green component, and two for the blue component.\nThis is a somewhat cryptic and inconvenient way to write colors, but it is the\nformat the HTML color input field uses, and it can be used in the fillStyle\nproperty of a canvas drawing context, so for the ways we\u2019ll use colors in this\nprogram, it is practical enough.\nBlack, where all components are zero, is written \"#000000\", and bright pink\nlooks like \"#ff00ff\", where the red and blue components have the maximum\nvalue of 255, written ff in hexadecimal digits (which use a to f to represent\ndigits 10 to 15).\nWe\u2019ll allow the interface to dispatch actions as objects whose properties\noverwrite the properties of the previous state. The color field, when the user\nchanges it, could dispatch an object like {color: field.value}, from which\nthis update function can compute a new state.\nfunction updateState(state, action) {\nreturn Object.assign({}, state, action);\n}\nThis rather cumbersome pattern, in which Object.assign is used to first\nadd the properties of state to an empty object and then overwrite some of\nthose with the properties from action, is common in JavaScript code that uses\nimmutable objects. A more convenient notation for this, in which the triple-\ndot operator is used to include all properties from another object in an object\nexpression, is in the final stages of being standardized. With that addition,\nyou could write {...state, ...action} instead. At the time of writing, this\ndoesn\u2019t yet work in all browsers.\n333 DOM building\nOneofthemainthingsthatinterfacecomponentsdoiscreatingDOMstructure.\nWe again don\u2019t want to directly use the verbose DOM methods for that, so\nhere\u2019s a slightly expanded version of the elt function:\nfunction elt(type, props, ...children) {\nlet dom = document.createElement(type);\nif (props) Object.assign(dom, props);\nfor (let child of children) {\nif (typeof child != \"string\") dom.appendChild(child);\nelse dom.appendChild(document.createTextNode(child));\n}\nreturn dom;\n}\nThe main difference between this version and the one we used in Chapter\n16 is that it assigns properties to DOM nodes, not attributes. This means we\ncan\u2019t use it to set arbitrary attributes, but we can use it to set properties whose\nvalue isn\u2019t a string, such as onclick, which can be set to a function to register\na click event handler.\nThis allows the following style of registering event handlers:\n<body>\n<script>\ndocument.body.appendChild(elt(\"button\", {\nonclick: () => console.log(\"click\")\n}, \"The button\"));\n<\/script>\n<\/body>\nThe canvas\nThe first component we\u2019ll define is the part of the interface that displays the\npicture as a grid of colored boxes. This component is responsible for two things:\nshowing a picture and communicating pointer events on that picture to the rest\nof the application.\nAs such, we can define it as a component that knows about only the current\npicture, not the whole application state. Because it doesn\u2019t know how the\napplication as a whole works, it cannot directly dispatch actions. Rather,\n334 when responding to pointer events, it calls a callback function provided by the\ncode that created it, which will handle the application-specific parts.\nconst scale = 10;\nclass PictureCanvas {\nconstructor(picture, pointerDown) {\nthis.dom = elt(\"canvas\", {\nonmousedown: event => this.mouse(event, pointerDown),\nontouchstart: event => this.touch(event, pointerDown)\n});\nthis.syncState(picture);\n}\nsyncState(picture) {\nif (this.picture == picture) return;\nthis.picture = picture;\ndrawPicture(this.picture, this.dom, scale);\n}\n}\nWe draw each pixel as a 10-by-10 square, as determined by the scale con-\nstant. To avoid unnecessary work, the component keeps track of its current\npicture and does a redraw only when syncState is given a new picture.\nThe actual drawing function sets the size of the canvas based on the scale\nand picture size and fills it with a series of squares, one for each pixel.\nfunction drawPicture(picture, canvas, scale) {\ncanvas.width = picture.width * scale;\ncanvas.height = picture.height * scale;\nlet cx = canvas.getContext(\"2d\");\nfor (let y = 0; y < picture.height; y++) {\nfor (let x = 0; x < picture.width; x++) {\ncx.fillStyle = picture.pixel(x, y);\ncx.fillRect(x * scale, y * scale, scale, scale);\n}\n}\n}\nWhen the left mouse button is pressed while the mouse is over the picture\ncanvas, the component calls the pointerDown callback, giving it the position\nof the pixel that was clicked\u2014in picture coordinates. This will be used to im-\nplement mouse interaction with the picture. The callback may return another\n335 callback function to be notified when the pointer is moved to a different pixel\nwhile the button is held down.\nPictureCanvas.prototype.mouse = function(downEvent, onDown) {\nif (downEvent.button != 0) return;\nlet pos = pointerPosition(downEvent, this.dom);\nlet onMove = onDown(pos);\nif (!onMove) return;\nlet move = moveEvent => {\nif (moveEvent.buttons == 0) {\nthis.dom.removeEventListener(\"mousemove\", move);\n} else {\nlet newPos = pointerPosition(moveEvent, this.dom);\nif (newPos.x == pos.x && newPos.y == pos.y) return;\npos = newPos;\nonMove(newPos);\n}\n};\nthis.dom.addEventListener(\"mousemove\", move);\n};\nfunction pointerPosition(pos, domNode) {\nlet rect = domNode.getBoundingClientRect();\nreturn {x: Math.floor((pos.clientX - rect.left) \/ scale),\ny: Math.floor((pos.clientY - rect.top) \/ scale)};\n}\nSince we know the size of the pixels and we can use getBoundingClientRect\nto find the position of the canvas on the screen, it is possible to go from mouse\nevent coordinates (clientX and clientY) to picture coordinates. These are\nalways rounded down so that they refer to a specific pixel.\nWith touch events, we have to do something similar, but using different\nevents and making sure we call preventDefault on the \"touchstart\" event to\nprevent panning.\nPictureCanvas.prototype.touch = function(startEvent,\nonDown) {\nlet pos = pointerPosition(startEvent.touches[0], this.dom);\nlet onMove = onDown(pos);\nstartEvent.preventDefault();\nif (!onMove) return;\nlet move = moveEvent => {\nlet newPos = pointerPosition(moveEvent.touches[0],\nthis.dom);\n336 if (newPos.x == pos.x && newPos.y == pos.y) return;\npos = newPos;\nonMove(newPos);\n};\nlet end = () => {\nthis.dom.removeEventListener(\"touchmove\", move);\nthis.dom.removeEventListener(\"touchend\", end);\n};\nthis.dom.addEventListener(\"touchmove\", move);\nthis.dom.addEventListener(\"touchend\", end);\n};\nFor touch events, clientX and clientY aren\u2019t available directly on the event\nobject, but we can use the coordinates of the first touch object in the touches\nproperty.\nThe application\nTo make it possible to build the application piece by piece, we\u2019ll implement the\nmain component as a shell around a picture canvas and a dynamic set of tools\nand controls that we pass to its constructor.\nThecontrolsaretheinterfaceelementsthatappearbelowthepicture. They\u2019ll\nbe provided as an array of component constructors.\nThe tools do things like drawing pixels or filling in an area. The application\nshows the set of available tools as a <select> field. The currently selected\ntool determines what happens when the user interacts with the picture with a\npointer device. The set of available tools is provided as an object that maps\nthe names that appear in the drop-down field to functions that implement the\ntools. Such functions get a picture position, a current application state, and\na dispatch function as arguments. They may return a move handler function\nthat gets called with a new position and a current state when the pointer moves\nto a different pixel.\nclass PixelEditor {\nconstructor(state, config) {\nlet {tools, controls, dispatch} = config;\nthis.state = state;\nthis.canvas = new PictureCanvas(state.picture, pos => {\nlet tool = tools[this.state.tool];\nlet onMove = tool(pos, this.state, dispatch);\nif (onMove) return pos => onMove(pos, this.state);\n337 });\nthis.controls = controls.map(\nControl => new Control(state, config));\nthis.dom = elt(\"div\", {}, this.canvas.dom, elt(\"br\"),\n...this.controls.reduce(\n(a, c) => a.concat(\" \", c.dom), []));\n}\nsyncState(state) {\nthis.state = state;\nthis.canvas.syncState(state.picture);\nfor (let ctrl of this.controls) ctrl.syncState(state);\n}\n}\nThe pointer handler given to PictureCanvas calls the currently selected tool\nwith the appropriate arguments and, if that returns a move handler, adapts it\nto also receive the state.\nAll controls are constructed and stored in this.controls so that they can\nbe updated when the application state changes. The call to reduce introduces\nspaces between the controls\u2019 DOM elements. That way they don\u2019t look so\npressed together.\nThe first control is the tool selection menu. It creates a <select> element\nwith an option for each tool and sets up a \"change\" event handler that updates\nthe application state when the user selects a different tool.\nclass ToolSelect {\nconstructor(state, {tools, dispatch}) {\nthis.select = elt(\"select\", {\nonchange: () => dispatch({tool: this.select.value})\n}, ...Object.keys(tools).map(name => elt(\"option\", {\nselected: name == state.tool\n}, name)));\n\ud83d\udd8c\nthis.dom = elt(\"label\", null, \" Tool: \", this.select);\n}\nsyncState(state) { this.select.value = state.tool; }\n}\nBy wrapping the label text and the field in a <label> element, we tell the\nbrowser that the label belongs to that field so that you can, for example, click\nthe label to focus the field.\nWe also need to be able to change the color, so let\u2019s add a control for that.\nAn HTML <input> element with a type attribute of color gives us a form\n338 field that is specialized for selecting colors. Such a field\u2019s value is always a\nCSS color code in \"#RRGGBB\" format (red, green, and blue components, two\ndigits per color). The browser will show a color picker interface when the user\ninteracts with it.\nDepending on the browser, the color picker might look like this:\nThis control creates such a field and wires it up to stay synchronized with\nthe application state\u2019s color property.\nclass ColorSelect {\nconstructor(state, {dispatch}) {\nthis.input = elt(\"input\", {\ntype: \"color\",\nvalue: state.color,\nonchange: () => dispatch({color: this.input.value})\n});\n\ud83c\udfa8\nthis.dom = elt(\"label\", null, \" Color: \", this.input);\n}\nsyncState(state) { this.input.value = state.color; }\n}\nDrawing tools\nBefore we can draw anything, we need to implement the tools that will control\nthe functionality of mouse or touch events on the canvas.\nThe most basic tool is the draw tool, which changes any pixel you click or\ntap to the currently selected color. It dispatches an action that updates the\npicture to a version in which the pointed-at pixel is given the currently selected\n339 color.\nfunction draw(pos, state, dispatch) {\nfunction drawPixel({x, y}, state) {\nlet drawn = {x, y, color: state.color};\ndispatch({picture: state.picture.draw([drawn])});\n}\ndrawPixel(pos, state);\nreturn drawPixel;\n}\nThe function immediately calls the drawPixel function but then also returns\nit so that it is called again for newly touched pixels when the user drags or\nswipes over the picture.\nTo draw larger shapes, it can be useful to quickly create rectangles. The\nrectangle tool draws a rectangle between the point where you start dragging\nand the point that you drag to.\nfunction rectangle(start, state, dispatch) {\nfunction drawRectangle(pos) {\nlet xStart = Math.min(start.x, pos.x);\nlet yStart = Math.min(start.y, pos.y);\nlet xEnd = Math.max(start.x, pos.x);\nlet yEnd = Math.max(start.y, pos.y);\nlet drawn = [];\nfor (let y = yStart; y <= yEnd; y++) {\nfor (let x = xStart; x <= xEnd; x++) {\ndrawn.push({x, y, color: state.color});\n}\n}\ndispatch({picture: state.picture.draw(drawn)});\n}\ndrawRectangle(start);\nreturn drawRectangle;\n}\nAn important detail in this implementation is that when dragging, the rect-\nangle is redrawn on the picture from the original state. That way, you can\nmake the rectangle larger and smaller again while creating it, without the in-\ntermediate rectangles sticking around in the final picture. This is one of the\nreasons why immutable picture objects are useful\u2014we\u2019ll see another reason\nlater.\nImplementing flood fill is somewhat more involved. This is a tool that fills\n340 the pixel under the pointer and all adjacent pixels that have the same color.\n\u201cAdjacent\u201d means directly horizontally or vertically adjacent, not diagonally.\nThis picture illustrates the set of pixels colored when the flood fill tool is used\nat the marked pixel:\nInterestingly, the way we\u2019ll do this looks a bit like the pathfinding code from\nChapter 7. Whereas that code searched through a graph to find a route, this\ncode searches through a grid to find all \u201cconnected\u201d pixels. The problem of\nkeeping track of a branching set of possible routes is similar.\nconst around = [{dx: -1, dy: 0}, {dx: 1, dy: 0},\n{dx: 0, dy: -1}, {dx: 0, dy: 1}];\nfunction fill({x, y}, state, dispatch) {\nlet targetColor = state.picture.pixel(x, y);\nlet drawn = [{x, y, color: state.color}];\nfor (let done = 0; done < drawn.length; done++) {\nfor (let {dx, dy} of around) {\nlet x = drawn[done].x + dx, y = drawn[done].y + dy;\nif (x >= 0 && x < state.picture.width &&\ny >= 0 && y < state.picture.height &&\nstate.picture.pixel(x, y) == targetColor &&\n!drawn.some(p => p.x == x && p.y == y)) {\ndrawn.push({x, y, color: state.color});\n}\n}\n}\ndispatch({picture: state.picture.draw(drawn)});\n}\nThe array of drawn pixels doubles as the function\u2019s work list. For each pixel\nreached, we have to see whether any adjacent pixels have the same color and\nhaven\u2019t already been painted over. The loop counter lags behind the length of\nthe drawn array as new pixels are added. Any pixels ahead of it still need to\nbe explored. When it catches up with the length, no unexplored pixels remain,\nand the function is done.\nThe final tool is a color picker, which allows you to point at a color in the\n341 picture to use it as the current drawing color.\nfunction pick(pos, state, dispatch) {\ndispatch({color: state.picture.pixel(pos.x, pos.y)});\n}\nSaving and loading\nWhen we\u2019ve drawn our masterpiece, we\u2019ll want to save it for later. We should\nadd a button for downloading the current picture as an image file. This control\nprovides that button:\nclass SaveButton {\nconstructor(state) {\nthis.picture = state.picture;\nthis.dom = elt(\"button\", {\nonclick: () => this.save()\n\ud83d\udcbe\n}, \" Save\");\n}\nsave() {\nlet canvas = elt(\"canvas\");\ndrawPicture(this.picture, canvas, 1);\nlet link = elt(\"a\", {\nhref: canvas.toDataURL(),\ndownload: \"pixelart.png\"\n});\ndocument.body.appendChild(link);\nlink.click();\nlink.remove();\n}\nsyncState(state) { this.picture = state.picture; }\n}\nThe component keeps track of the current picture so that it can access it\nwhen saving. To create the image file, it uses a <canvas> element that it draws\nthe picture on (at a scale of one pixel per pixel).\nThe toDataURL method on a canvas element creates a URL that starts with\ndata:. Unlike http: and https: URLs, data URLs contain the whole resource\nin the URL. They are usually very long, but they allow us to create working\nlinks to arbitrary pictures, right here in the browser.\nTo actually get the browser to download the picture, we then create a link\n342 element that points at this URL and has a download attribute. Such links,\nwhen clicked, make the browser show a file save dialog. We add that link to\nthe document, simulate a click on it, and remove it again.\nYou can do a lot with browser technology, but sometimes the way to do it\nis rather odd.\nAnd it gets worse. We\u2019ll also want to be able to load existing image files\ninto our application. To do that, we again define a button component.\nclass LoadButton {\nconstructor(_, {dispatch}) {\nthis.dom = elt(\"button\", {\nonclick: () => startLoad(dispatch)\n\ud83d\udcc1\n}, \" Load\");\n}\nsyncState() {}\n}\nfunction startLoad(dispatch) {\nlet input = elt(\"input\", {\ntype: \"file\",\nonchange: () => finishLoad(input.files[0], dispatch)\n});\ndocument.body.appendChild(input);\ninput.click();\ninput.remove();\n}\nTo get access to a file on the user\u2019s computer, we need the user to select the\nfile through a file input field. But I don\u2019t want the load button to look like a\nfile input field, so we create the file input when the button is clicked and then\npretend that this file input itself was clicked.\nWhen the user has selected a file, we can use FileReader to get access to\nits contents, again as a data URL. That URL can be used to create an <img>\nelement, but because we can\u2019t get direct access to the pixels in such an image,\nwe can\u2019t create a Picture object from that.\nfunction finishLoad(file, dispatch) {\nif (file == null) return;\nlet reader = new FileReader();\nreader.addEventListener(\"load\", () => {\nlet image = elt(\"img\", {\nonload: () => dispatch({\npicture: pictureFromImage(image)\n343 }),\nsrc: reader.result\n});\n});\nreader.readAsDataURL(file);\n}\nTo get access to the pixels, we must first draw the picture to a <canvas>\nelement. The canvas context has a getImageData method that allows a script\nto read its pixels. So, once the picture is on the canvas, we can access it and\nconstruct a Picture object.\nfunction pictureFromImage(image) {\nlet width = Math.min(100, image.width);\nlet height = Math.min(100, image.height);\nlet canvas = elt(\"canvas\", {width, height});\nlet cx = canvas.getContext(\"2d\");\ncx.drawImage(image, 0, 0);\nlet pixels = [];\nlet {data} = cx.getImageData(0, 0, width, height);\nfunction hex(n) {\nreturn n.toString(16).padStart(2, \"0\");\n}\nfor (let i = 0; i < data.length; i += 4) {\nlet [r, g, b] = data.slice(i, i + 3);\npixels.push(\"#\" + hex(r) + hex(g) + hex(b));\n}\nreturn new Picture(width, height, pixels);\n}\nWe\u2019ll limit the size of images to 100 by 100 pixels since anything bigger will\nlook huge on our display and might slow down the interface.\nThe data property of the object returned by getImageData is an array of\ncolor components. For each pixel in the rectangle specified by the arguments,\nit contains four values, which represent the red, green, blue, and alpha com-\nponents of the pixel\u2019s color, as numbers between 0 and 255. The alpha part\nrepresents opacity\u2014when it is zero, the pixel is fully transparent, and when it\nis 255, it is fully opaque. For our purpose, we can ignore it.\nThe two hexadecimal digits per component, as used in our color notation,\ncorrespond precisely to the 0 to 255 range\u2014two base-16 digits can express 162\n= 256 different numbers. The toString method of numbers can be given a\n344 base as argument, so n.toString(16) will produce a string representation in\nbase 16. We have to make sure that each number takes up two digits, so the\nhex helper function calls padStart to add a leading zero when necessary.\nWe can load and save now! That leaves one more feature before we\u2019re done.\nUndo history\nHalf of the process of editing is making little mistakes and correcting them. So\nan important feature in a drawing program is an undo history.\nTo be able to undo changes, we need to store previous versions of the picture.\nSince it\u2019s an immutable value, that is easy. But it does require an additional\nfield in the application state.\nWe\u2019ll add a done array to keep previous versions of the picture. Maintaining\nthis property requires a more complicated state update function that adds\npictures to the array.\nBut we don\u2019t want to store every change, only changes a certain amount\nof time apart. To be able to do that, we\u2019ll need a second property, doneAt,\ntracking the time at which we last stored a picture in the history.\nfunction historyUpdateState(state, action) {\nif (action.undo == true) {\nif (state.done.length == 0) return state;\nreturn Object.assign({}, state, {\npicture: state.done[0],\ndone: state.done.slice(1),\ndoneAt: 0\n});\n} else if (action.picture &&\nstate.doneAt < Date.now() - 1000) {\nreturn Object.assign({}, state, action, {\ndone: [state.picture, ...state.done],\ndoneAt: Date.now()\n});\n} else {\nreturn Object.assign({}, state, action);\n}\n}\nWhentheactionisanundoaction, thefunctiontakesthemostrecentpicture\nfrom the history and makes that the current picture. It sets doneAt to zero so\nthat the next change is guaranteed to store the picture back in the history,\nallowing you to revert to it another time if you want.\n345 Otherwise, if the action contains a new picture and the last time we stored\nsomething is more than a second (1000 milliseconds) ago, the done and doneAt\nproperties are updated to store the previous picture.\nThe undo button component doesn\u2019t do much. It dispatches undo actions\nwhen clicked and disables itself when there is nothing to undo.\nclass UndoButton {\nconstructor(state, {dispatch}) {\nthis.dom = elt(\"button\", {\nonclick: () => dispatch({undo: true}),\ndisabled: state.done.length == 0\n\u2baa\n}, \" Undo\");\n}\nsyncState(state) {\nthis.dom.disabled = state.done.length == 0;\n}\n}\nLet's draw\nTo set up the application, we need to create a state, a set of tools, a set\nof controls, and a dispatch function. We can pass them to the PixelEditor\nconstructor to create the main component. Since we\u2019ll need to create several\neditors in the exercises, we first define some bindings.\nconst startState = {\ntool: \"draw\",\ncolor: \"#000000\",\npicture: Picture.empty(60, 30, \"#f0f0f0\"),\ndone: [],\ndoneAt: 0\n};\nconst baseTools = {draw, fill, rectangle, pick};\nconst baseControls = [\nToolSelect, ColorSelect, SaveButton, LoadButton, UndoButton\n];\nfunction startPixelEditor({state = startState,\ntools = baseTools,\ncontrols = baseControls}) {\n346 let app = new PixelEditor(state, {\ntools,\ncontrols,\ndispatch(action) {\nstate = historyUpdateState(state, action);\napp.syncState(state);\n}\n});\nreturn app.dom;\n}\nWhen destructuring an object or array, you can use = after a binding name\nto give the binding a default value, which is used when the property is missing\nor holds undefined. The startPixelEditor function makes use of this to accept\nan object with a number of optional properties as an argument. If you don\u2019t\nprovide a tools property, for example, tools will be bound to baseTools.\nThis is how we get an actual editor on the screen:\n<div><\/div>\n<script>\ndocument.querySelector(\"div\")\n.appendChild(startPixelEditor({}));\n<\/script>\nWhy is this so hard?\nBrowser technology is amazing. It provides a powerful set of interface building\nblocks, ways to style and manipulate them, and tools to inspect and debug your\napplications. The software you write for the browser can be run on almost every\ncomputer and phone on the planet.\nAt the same time, browser technology is ridiculous. You have to learn a\nlarge number of silly tricks and obscure facts to master it, and the default\nprogramming model it provides is so problematic that most programmers prefer\nto cover it in several layers of abstraction rather than deal with it directly.\nAnd though the situation is definitely improving, it mostly does so in the\nform of more elements being added to address shortcomings\u2014creating even\nmore complexity. A feature used by a million websites can\u2019t really be replaced.\nEven if it could, it would be hard to decide what it should be replaced with.\nTechnology never exists in a vacuum\u2014we\u2019re constrained by our tools and\n347 the social, economic, and historical factors that produced them. This can be\nannoying, but it is generally more productive to try to build a good under-\nstanding of how the existing technical reality works\u2014and why it is the way it\nis\u2014than to rage against it or hold out for another reality.\nNew abstractions can be helpful. The component model and data flow con-\nvention I used in this chapter is a crude form of that. As mentioned, there are\nlibraries that try to make user interface programming more pleasant. At the\ntime of writing, React and Angular are popular choices, but there\u2019s a whole\ncottage industry of such frameworks. If you\u2019re interested in programming web\napplications, I recommend investigating a few of them to understand how they\nwork and what benefits they provide.\nExercises\nThere is still room for improvement in our program. Let\u2019s add a few more\nfeatures as exercises.\nKeyboard bindings\nAdd keyboard shortcuts to the application. The first letter of a tool\u2019s name\nselects the tool, and control-Z or command-Z activates undo.\nDo this by modifying the PixelEditor component. Add a tabIndex property\nof 0 to the wrapping <div> element so that it can receive keyboard focus. Note\nthat the property corresponding to the tabindex attribute is called tabIndex,\nwith a capital I, and our elt function expects property names. Register the key\nevent handlers directly on that element. This means you have to click, touch,\nor tab to the application before you can interact with it with the keyboard.\nRemember that keyboard events have ctrlKey and metaKey (for the com-\nmand key on Mac) properties that you can use to see whether those keys are\nheld down.\nEfficient drawing\nDuring drawing, the majority of work that our application does happens in\ndrawPicture. Creating a new state and updating the rest of the DOM isn\u2019t\nvery expensive, but repainting all the pixels on the canvas is quite a bit of\nwork.\nFind a way to make the syncState method of PictureCanvas faster by re-\ndrawing only the pixels that actually changed.\n348 Remember that drawPicture is also used by the save button, so if you change\nit, either make sure the changes don\u2019t break the old use or create a new version\nwith a different name.\nAlso note that changing the size of a <canvas> element, by setting its width\nor height properties, clears it, making it entirely transparent again.\nCircles\nDefine a tool called circle that draws a filled circle when you drag. The center\nof the circle lies at the point where the drag or touch gesture starts, and its\nradius is determined by the distance dragged.\nProper lines\nThis is a more advanced exercise than the preceding two, and it will require\nyou to design a solution to a nontrivial problem. Make sure you have plenty\nof time and patience before starting to work on this exercise, and do not get\ndiscouraged by initial failures.\nOn most browsers, when you select the draw tool and quickly drag across\nthe picture, you don\u2019t get a closed line. Rather, you get dots with gaps be-\ntween them because the \"mousemove\" or \"touchmove\" events did not fire quickly\nenough to hit every pixel.\nImprove the draw tool to make it draw a full line. This means you have to\nmake the motion handler function remember the previous position and connect\nthat to the current one.\nTo do this, since the pixels can be an arbitrary distance apart, you\u2019ll have\nto write a general line drawing function.\nA line between two pixels is a connected chain of pixels, as straight as pos-\nsible, going from the start to the end. Diagonally adjacent pixels count as a\nconnected. So a slanted line should look like the picture on the left, not the\npicture on the right.\nFinally, if we have code that draws a line between two arbitrary points, we\nmight as well use it to also define a line tool, which draws a straight line\nbetween the start and end of a drag.\n349 \u201cA student asked, \u2018The programmers of old used only simple\nmachines and no programming languages, yet they made beautiful\nprograms. Why do we use complicated machines and programming\nlanguages?\u2019. Fu-Tzu replied, \u2018The builders of old used only sticks and\nclay, yet they made beautiful huts.\u201d\u2019\n\u2014Master Yuan-Ma, The Book of Programming\nChapter20\nNode.js\nSo far, we have used the JavaScript language in a single environment: the\nbrowser. This chapter and the next one will briefly introduce Node.js, a pro-\ngram that allows you to apply your JavaScript skills outside of the browser.\nWith it, you can build anything from small command line tools to HTTP\nservers that power dynamic websites.\nThese chapters aim to teach you the main concepts that Node.js uses and\nto give you enough information to write useful programs for it. They do not\ntry to be a complete, or even a thorough, treatment of the platform.\nIf you want to follow along and run the code in this chapter, you\u2019ll need to\ninstall Node.js version 10.1 or higher. To do so, go to https:\/\/nodejs.org and\nfollow the installation instructions for your operating system. You can also find\nfurther documentation for Node.js there.\nBackground\nOne of the more di\ufb00icult problems with writing systems that communicate over\nthe network is managing input and output\u2014that is, the reading and writing of\ndata to and from the network and hard drive. Moving data around takes time,\nand scheduling it cleverly can make a big difference in how quickly a system\nresponds to the user or to network requests.\nIn such programs, asynchronous programming is often helpful. It allows the\nprogram to send and receive data from and to multiple devices at the same\ntime without complicated thread management and synchronization.\nNode was initially conceived for the purpose of making asynchronous pro-\ngramming easy and convenient. JavaScript lends itself well to a system like\nNode. It is one of the few programming languages that does not have a built-in\nway to do in- and output. Thus, JavaScript could be fit onto Node\u2019s rather\neccentric approach to in- and output without ending up with two inconsistent\ninterfaces. In 2009, when Node was being designed, people were already do-\ning callback-based programming in the browser, so the community around the\n350 language was used to an asynchronous programming style.\nThe node command\nWhen Node.js is installed on a system, it provides a program called node, which\nis used to run JavaScript files. Say you have a file hello.js, containing this\ncode:\nlet message = \"Hello world\";\nconsole.log(message);\nYou can then run node from the command line like this to execute the pro-\ngram:\n$ node hello.js\nHello world\nThe console.log method in Node does something similar to what it does\nin the browser. It prints out a piece of text. But in Node, the text will go\nto the process\u2019s standard output stream, rather than to a browser\u2019s JavaScript\nconsole. When running node from the command line, that means you see the\nlogged values in your terminal.\nIf you run node without giving it a file, it provides you with a prompt at\nwhich you can type JavaScript code and immediately see the result.\n$ node\n> 1 + 1\n2\n> [-1, -2, -3].map(Math.abs)\n[1, 2, 3]\n> process.exit(0)\n$\nThe process binding, just like the console binding, is available globally in\nNode. It provides various ways to inspect and manipulate the current program.\nThe exit method ends the process and can be given an exit status code, which\ntells the program that started node (in this case, the command line shell)\nwhether the program completed successfully (code zero) or encountered an\nerror (any other code).\nTo find the command line arguments given to your script, you can read\n351 process.argv, which is an array of strings. Note that it also includes the name\nof the node command and your script name, so the actual arguments start at\nindex 2. If showargv.js contains the statement console.log(process.argv),\nyou could run it like this:\n$ node showargv.js one --and two\n[\"node\", \"\/tmp\/showargv.js\", \"one\", \"--and\", \"two\"]\nAll the standard JavaScript global bindings, such as Array, Math, and JSON,\nare also present in Node\u2019s environment. Browser-related functionality, such as\ndocument or prompt, is not.\nModules\nBeyond the bindings I mentioned, such as console and process, Node puts\nfew additional bindings in the global scope. If you want to access built-in\nfunctionality, you have to ask the module system for it.\nThe CommonJS module system, based on the require function, was de-\nscribed in Chapter 10. This system is built into Node and is used to load\nanything from built-in modules to downloaded packages to files that are part\nof your own program.\nWhen require is called, Node has to resolve the given string to an actual\nfile that it can load. Pathnames that start with \/, .\/, or ..\/ are resolved\nrelative to the current module\u2019s path, where . stands for the current directory,\n..\/ for one directory up, and \/ for the root of the file system. So if you ask\nfor \".\/graph\" from the file \/tmp\/robot\/robot.js, Node will try to load the file\n\/tmp\/robot\/graph.js.\nThe .js extension may be omitted, and Node will add it if such a file exists.\nIf the required path refers to a directory, Node will try to load the file named\nindex.js in that directory.\nWhen a string that does not look like a relative or absolute path is given\nto require, it is assumed to refer to either a built-in module or a module\ninstalled in a node_modules directory. For example, require(\"fs\") will give\nyou Node\u2019s built-in file system module. And require(\"robot\") might try to\nload the library found in node_modules\/robot\/. A common way to install such\nlibraries is by using NPM, which we\u2019ll come back to in a moment.\nLet\u2019s set up a small project consisting of two files. The first one, called\nmain.js, defines a script that can be called from the command line to reverse\na string.\n352 const {reverse} = require(\".\/reverse\");\n\/\/ Index 2 holds the first actual command line argument\nlet argument = process.argv[2];\nconsole.log(reverse(argument));\nThe file reverse.js defines a library for reversing strings, which can be used\nboth by this command line tool and by other scripts that need direct access to\na string-reversing function.\nexports.reverse = function(string) {\nreturn Array.from(string).reverse().join(\"\");\n};\nRemember that adding properties to exports adds them to the interface of\nthe module. Since Node.js treats files as CommonJS modules, main.js can take\nthe exported reverse function from reverse.js.\nWe can now call our tool like this:\n$ node main.js JavaScript\ntpircSavaJ\nInstalling with NPM\nNPM, which was introduced in Chapter 10, is an online repository of JavaScript\nmodules, many of which are specifically written for Node. When you install\nNode on your computer, you also get the npm command, which you can use to\ninteract with this repository.\nNPM\u2019s main use is downloading packages. We saw the ini package in Chap-\nter 10. We can use NPM to fetch and install that package on our computer.\n$ npm install ini\nnpm WARN enoent ENOENT: no such file or directory,\nopen '\/tmp\/package.json'\n+ ini@1.3.5\nadded 1 package in 0.552s\n$ node\n> const {parse} = require(\"ini\");\n353 > parse(\"x = 1\\ny = 2\");\n{ x: '1', y: '2' }\nAfterrunningnpm install, NPMwillhavecreatedadirectorycallednode_modules\n. Inside that directory will be an ini directory that contains the library. You\ncan open it and look at the code. When we call require(\"ini\"), this library\nis loaded, and we can call its parse property to parse a configuration file.\nBy default NPM installs packages under the current directory, rather than\nin a central place. If you are used to other package managers, this may seem\nunusual, but it has advantages\u2014it puts each application in full control of the\npackages it installs and makes it easier to manage versions and clean up when\nremoving an application.\nPackage files\nIn the npm install example, you could see a warning about the fact that the\npackage.json file did not exist. It is recommended to create such a file for each\nproject, either manually or by running npm init. It contains some information\nabout the project, such as its name and version, and lists its dependencies.\nThe robot simulation from Chapter 7, as modularized in the exercise in\nChapter 10, might have a package.json file like this:\n{\n\"author\": \"Marijn Haverbeke\",\n\"name\": \"eloquent-javascript-robot\",\n\"description\": \"Simulation of a package-delivery robot\",\n\"version\": \"1.0.0\",\n\"main\": \"run.js\",\n\"dependencies\": {\n\"dijkstrajs\": \"^1.0.1\",\n\"random-item\": \"^1.0.0\"\n},\n\"license\": \"ISC\"\n}\nWhen you run npm install without naming a package to install, NPM will\ninstall the dependencies listed in package.json. When you install a specific\npackage that is not already listed as a dependency, NPM will add it to package\n.json.\n354 Versions\nA package.json file lists both the program\u2019s own version and versions for its\ndependencies. Versions are a way to deal with the fact that packages evolve\nseparately, and code written to work with a package as it existed at one point\nmay not work with a later, modified version of the package.\nNPM demands that its packages follow a schema called semantic version-\ning, whichencodessomeinformationaboutwhichversionsarecompatible (don\u2019t\nbreak the old interface) in the version number. A semantic version consists of\nthree numbers, separated by periods, such as 2.3.0. Every time new func-\ntionality is added, the middle number has to be incremented. Every time\ncompatibility is broken, so that existing code that uses the package might not\nwork with the new version, the first number has to be incremented.\nA caret character (^) in front of the version number for a dependency in\npackage.json indicates that any version compatible with the given number\nmay be installed. So, for example, \"^2.3.0\" would mean that any version\ngreater than or equal to 2.3.0 and less than 3.0.0 is allowed.\nThe npm command is also used to publish new packages or new versions of\npackages. If you run npm publish in a directory that has a package.json file, it\nwill publish a package with the name and version listed in the JSON file to the\nregistry. Anyone can publish packages to NPM\u2014though only under a package\nname that isn\u2019t in use yet since it would be somewhat scary if random people\ncould update existing packages.\nSince the npm program is a piece of software that talks to an open system\u2014\nthe package registry\u2014there is nothing unique about what it does. Another\nprogram, yarn, which can be installed from the NPM registry, fills the same\nrole as npm using a somewhat different interface and installation strategy.\nThis book won\u2019t delve further into the details of NPM usage. Refer to\nhttps:\/\/npmjs.org for further documentation and a way to search for packages.\nThe file system module\nOne of the most commonly used built-in modules in Node is the fs module,\nwhich stands for file system. It exports functions for working with files and\ndirectories.\nFor example, the function called readFile reads a file and then calls a call-\nback with the file\u2019s contents.\nlet {readFile} = require(\"fs\");\nreadFile(\"file.txt\", \"utf8\", (error, text) => {\n355 if (error) throw error;\nconsole.log(\"The file contains:\", text);\n});\nThe second argument to readFile indicates the character encoding used to\ndecode the file into a string. There are several ways in which text can be\nencoded to binary data, but most modern systems use UTF-8. So unless you\nhave reasons to believe another encoding is used, pass \"utf8\" when reading a\ntext file. If you do not pass an encoding, Node will assume you are interested\nin the binary data and will give you a Buffer object instead of a string. This is\nan array-like object that contains numbers representing the bytes (8-bit chunks\nof data) in the files.\nconst {readFile} = require(\"fs\");\nreadFile(\"file.txt\", (error, buffer) => {\nif (error) throw error;\nconsole.log(\"The file contained\", buffer.length, \"bytes.\",\n\"The first byte is:\", buffer[0]);\n});\nA similar function, writeFile, is used to write a file to disk.\nconst {writeFile} = require(\"fs\");\nwriteFile(\"graffiti.txt\", \"Node was here\", err => {\nif (err) console.log(`Failed to write file: ${err}`);\nelse console.log(\"File written.\");\n});\nHere it was not necessary to specify the encoding\u2014writeFile will assume\nthat when it is given a string to write, rather than a Buffer object, it should\nwrite it out as text using its default character encoding, which is UTF-8.\nThe fs module contains many other useful functions: readdir will return\nthe files in a directory as an array of strings, stat will retrieve information\nabout a file, rename will rename a file, unlink will remove one, and so on. See\nthe documentation at https:\/\/nodejs.org for specifics.\nMost of these take a callback function as the last parameter, which they call\neither with an error (the first argument) or with a successful result (the second).\nAs we saw in Chapter 11, there are downsides to this style of programming\u2014the\nbiggest one being that error handling becomes verbose and error-prone.\nThough promises have been part of JavaScript for a while, at the time of\n356 writing their integration into Node.js is still a work in progress. There is an\nobject promises exported from the fs package since version 10.1 that contains\nmost of the same functions as fs but uses promises rather than callback func-\ntions.\nconst {readFile} = require(\"fs\").promises;\nreadFile(\"file.txt\", \"utf8\")\n.then(text => console.log(\"The file contains:\", text));\nSometimes you don\u2019t need asynchronicity, and it just gets in the way. Many\nof the functions in fs also have a synchronous variant, which has the same\nname with Sync added to the end. For example, the synchronous version of\nreadFile is called readFileSync.\nconst {readFileSync} = require(\"fs\");\nconsole.log(\"The file contains:\",\nreadFileSync(\"file.txt\", \"utf8\"));\nDo note that while such a synchronous operation is being performed, your\nprogram is stopped entirely. If it should be responding to the user or to other\nmachines on the network, being stuck on a synchronous action might produce\nannoying delays.\nThe HTTP module\nAnother central module is called http. It provides functionality for running\nHTTP servers and making HTTP requests.\nThis is all it takes to start an HTTP server:\nconst {createServer} = require(\"http\");\nlet server = createServer((request, response) => {\nresponse.writeHead(200, {\"Content-Type\": \"text\/html\"});\nresponse.write(`\n<h1>Hello!<\/h1>\n<p>You asked for <code>${request.url}<\/code><\/p>`);\nresponse.end();\n});\nserver.listen(8000);\nconsole.log(\"Listening! (port 8000)\");\nIf you run this script on your own machine, you can point your web browser\n357 at http:\/\/localhost:8000\/hello to make a request to your server. It will respond\nwith a small HTML page.\nThe function passed as argument to createServer is called every time a\nclient connects to the server. The request and response bindings are objects\nrepresenting the incoming and outgoing data. The first contains information\nabout the request, such as its url property, which tells us to what URL the\nrequest was made.\nSo, when you open that page in your browser, it sends a request to your own\ncomputer. This causes the server function to run and send back a response,\nwhich you can then see in the browser.\nTo send something back, you call methods on the response object. The first,\nwriteHead, will write out the response headers (see Chapter 18). You give it\nthe status code (200 for \u201cOK\u201d in this case) and an object that contains header\nvalues. The example sets the Content-Type header to inform the client that\nwe\u2019ll be sending back an HTML document.\nNext, the actual response body (the document itself) is sent with response\n.write. You are allowed to call this method multiple times if you want to\nsend the response piece by piece, for example to stream data to the client as it\nbecomes available. Finally, response.end signals the end of the response.\nThe call to server.listen causes the server to start waiting for connections\non port 8000. This is why you have to connect to localhost:8000 to speak to\nthis server, rather than just localhost, which would use the default port 80.\nWhen you run this script, the process just sits there and waits. When a\nscript is listening for events\u2014in this case, network connections\u2014node will not\nautomatically exit when it reaches the end of the script. To close it, press\ncontrol-C.\nA real web server usually does more than the one in the example\u2014it looks\nat the request\u2019s method (the method property) to see what action the client is\ntrying to perform and looks at the request\u2019s URL to find out which resource\nthis action is being performed on. We\u2019ll see a more advanced server later in\nthis chapter.\nTo act as an HTTP client, we can use the request function in the http\nmodule.\nconst {request} = require(\"http\");\nlet requestStream = request({\nhostname: \"eloquentjavascript.net\",\npath: \"\/20_node.html\",\nmethod: \"GET\",\nheaders: {Accept: \"text\/html\"}\n}, response => {\n358 console.log(\"Server responded with status code\",\nresponse.statusCode);\n});\nrequestStream.end();\nThe first argument to request configures the request, telling Node what\nserver to talk to, what path to request from that server, which method to use,\nand so on. The second argument is the function that should be called when a\nresponse comes in. It is given an object that allows us to inspect the response,\nfor example to find out its status code.\nJust like the response object we saw in the server, the object returned by\nrequest allows us to stream data into the request with the write method and\nfinish the request with the end method. The example does not use write\nbecause GET requests should not contain data in their request body.\nThere\u2019s a similar request function in the https module that can be used to\nmake requests to https: URLs.\nMaking requests with Node\u2019s raw functionality is rather verbose. There\nare much more convenient wrapper packages available on NPM. For example,\nnode-fetch provides the promise-based fetch interface that we know from the\nbrowser.\nStreams\nWe have seen two instances of writable streams in the HTTP examples\u2014\nnamely, the response object that the server could write to and the request\nobject that was returned from request.\nWritable streams are a widely used concept in Node. Such objects have a\nwrite method that can be passed a string or a Buffer object to write something\nto the stream. Their end method closes the stream and optionally takes a value\nto write to the stream before closing. Both of these methods can also be given\na callback as an additional argument, which they will call when the writing or\nclosing has finished.\nIt is possible to create a writable stream that points at a file with the\ncreateWriteStream function from the fs module. Then you can use the write\nmethod on the resulting object to write the file one piece at a time, rather than\nin one shot as with writeFile.\nReadable streams are a little more involved. Both the request binding that\nwas passed to the HTTP server\u2019s callback and the response binding passed to\nthe HTTP client\u2019s callback are readable streams\u2014a server reads requests and\n359 then writes responses, whereas a client first writes a request and then reads\na response. Reading from a stream is done using event handlers, rather than\nmethods.\nObjects that emit events in Node have a method called on that is similar to\nthe addEventListener method in the browser. You give it an event name and\nthen a function, and it will register that function to be called whenever the\ngiven event occurs.\nReadable streams have \"data\" and \"end\" events. The first is fired every time\ndata comes in, and the second is called whenever the stream is at its end. This\nmodel is most suited for streaming data that can be immediately processed,\neven when the whole document isn\u2019t available yet. A file can be read as a\nreadable stream by using the createReadStream function from fs.\nThis code creates a server that reads request bodies and streams them back\nto the client as all-uppercase text:\nconst {createServer} = require(\"http\");\ncreateServer((request, response) => {\nresponse.writeHead(200, {\"Content-Type\": \"text\/plain\"});\nrequest.on(\"data\", chunk =>\nresponse.write(chunk.toString().toUpperCase()));\nrequest.on(\"end\", () => response.end());\n}).listen(8000);\nThe chunk value passed to the data handler will be a binary Buffer. We can\nconvert this to a string by decoding it as UTF-8 encoded characters with its\ntoString method.\nThe following piece of code, when run with the uppercasing server active,\nwill send a request to that server and write out the response it gets:\nconst {request} = require(\"http\");\nrequest({\nhostname: \"localhost\",\nport: 8000,\nmethod: \"POST\"\n}, response => {\nresponse.on(\"data\", chunk =>\nprocess.stdout.write(chunk.toString()));\n}).end(\"Hello server\");\n\/\/ \u2192 HELLO SERVER\nTheexamplewritestoprocess.stdout(theprocess\u2019sstandardoutput, which\n360 is a writable stream) instead of using console.log. We can\u2019t use console.log\nbecause it adds an extra newline character after each piece of text that it\nwrites, which isn\u2019t appropriate here since the response may come in as multiple\nchunks.\nA file server\nLet\u2019s combine our newfound knowledge about HTTP servers and working with\nthe file system to create a bridge between the two: an HTTP server that allows\nremote access to a file system. Such a server has all kinds of uses\u2014it allows web\napplications to store and share data, or it can give a group of people shared\naccess to a bunch of files.\nWhen we treat files as HTTP resources, the HTTP methods GET, PUT, and\nDELETE can be used to read, write, and delete the files, respectively. We will\ninterpret the path in the request as the path of the file that the request refers\nto.\nWe probably don\u2019t want to share our whole file system, so we\u2019ll interpret\nthese paths as starting in the server\u2019s working directory, which is the directory\ninwhichitwasstarted. IfIrantheserverfrom\/tmp\/public\/(orC:\\tmp\\public\n\\ on Windows), then a request for \/file.txt should refer to \/tmp\/public\/file\n.txt (or C:\\tmp\\public\\file.txt).\nWe\u2019ll build the program piece by piece, using an object called methods to\nstore the functions that handle the various HTTP methods. Method han-\ndlers are async functions that get the request object as argument and return a\npromise that resolves to an object that describes the response.\nconst {createServer} = require(\"http\");\nconst methods = Object.create(null);\ncreateServer((request, response) => {\nlet handler = methods[request.method] || notAllowed;\nhandler(request)\n.catch(error => {\nif (error.status != null) return error;\nreturn {body: String(error), status: 500};\n})\n.then(({body, status = 200, type = \"text\/plain\"}) => {\nresponse.writeHead(status, {\"Content-Type\": type});\nif (body && body.pipe) body.pipe(response);\nelse response.end(body);\n});\n361 }).listen(8000);\nasync function notAllowed(request) {\nreturn {\nstatus: 405,\nbody: `Method ${request.method} not allowed.`\n};\n}\nThis starts a server that just returns 405 error responses, which is the code\nused to indicate that the server refuses to handle a given method.\nWhen a request handler\u2019s promise is rejected, the catch call translates the\nerror into a response object, if it isn\u2019t one already, so that the server can send\nback an error response to inform the client that it failed to handle the request.\nThe status field of the response description may be omitted, in which case\nit defaults to 200 (OK). The content type, in the type property, can also be\nleft off, in which case the response is assumed to be plain text.\nWhen the value of body is a readable stream, it will have a pipe method that\nis used to forward all content from a readable stream to a writable stream. If\nnot, it is assumed to be either null (no body), a string, or a buffer, and it is\npassed directly to the response\u2019s end method.\nTo figure out which file path corresponds to a request URL, the urlPath\nfunction uses Node\u2019s built-in url module to parse the URL. It takes its path-\nname, which will be something like \"\/file.txt\", decodes that to get rid of\nthe %20-style escape codes, and resolves it relative to the program\u2019s working\ndirectory.\nconst {parse} = require(\"url\");\nconst {resolve, sep} = require(\"path\");\nconst baseDirectory = process.cwd();\nfunction urlPath(url) {\nlet {pathname} = parse(url);\nlet path = resolve(decodeURIComponent(pathname).slice(1));\nif (path != baseDirectory &&\n!path.startsWith(baseDirectory + sep)) {\nthrow {status: 403, body: \"Forbidden\"};\n}\nreturn path;\n}\n362 As soon as you set up a program to accept network requests, you have to\nstart worrying about security. In this case, if we aren\u2019t careful, it is likely that\nwe\u2019ll accidentally expose our whole file system to the network.\nFile paths are strings in Node. To map such a string to an actual file, there\nis a nontrivial amount of interpretation going on. Paths may, for example,\ninclude ..\/ to refer to a parent directory. So one obvious source of problems\nwould be requests for paths like \/..\/secret_file.\nTo avoid such problems, urlPath uses the resolve function from the path\nmodule, which resolves relative paths. It then verifies that the result is below\ntheworkingdirectory. Theprocess.cwdfunction(wherecwdstandsfor\u201ccurrent\nworking directory\u201d) can be used to find this working directory. The sep binding\nfrom the path package is the system\u2019s path separator\u2014a backslash on Windows\nand a forward slash on most other systems. When the path doesn\u2019t start with\nthe base directory, the function throws an error response object, using the\nHTTP status code indicating that access to the resource is forbidden.\nWe\u2019ll set up the GET method to return a list of files when reading a directory\nand to return the file\u2019s content when reading a regular file.\nOne tricky question is what kind of Content-Type header we should set when\nreturning a file\u2019s content. Since these files could be anything, our server can\u2019t\nsimply return the same content type for all of them. NPM can help us again\nhere. The mime package (content type indicators like text\/plain are also called\nMIME types) knows the correct type for a large number of file extensions.\nThe following npm command, in the directory where the server script lives,\ninstalls a specific version of mime:\n$ npm install mime@2.2.0\nWhen a requested file does not exist, the correct HTTP status code to return\nis 404. We\u2019ll use the stat function, which looks up information about a file, to\nfind out both whether the file exists and whether it is a directory.\nconst {createReadStream} = require(\"fs\");\nconst {stat, readdir} = require(\"fs\").promises;\nconst mime = require(\"mime\");\nmethods.GET = async function(request) {\nlet path = urlPath(request.url);\nlet stats;\ntry {\nstats = await stat(path);\n} catch (error) {\n363 if (error.code != \"ENOENT\") throw error;\nelse return {status: 404, body: \"File not found\"};\n}\nif (stats.isDirectory()) {\nreturn {body: (await readdir(path)).join(\"\\n\")};\n} else {\nreturn {body: createReadStream(path),\ntype: mime.getType(path)};\n}\n};\nBecause it has to touch the disk and thus might take a while, stat is asyn-\nchronous. Since we\u2019re using promises rather than callback style, it has to be\nimported from promises instead of directly from fs.\nWhen the file does not exist, stat will throw an error object with a code\nproperty of \"ENOENT\". These somewhat obscure, Unix-inspired codes are how\nyou recognize error types in Node.\nThe stats object returned by stat tells us a number of things about a file,\nsuch as its size (size property) and its modification date (mtime property).\nHere we are interested in the question of whether it is a directory or a regular\nfile, which the isDirectory method tells us.\nWe use readdir to read the array of files in a directory and return it to the\nclient. For normal files, we create a readable stream with createReadStream\nand return that as the body, along with the content type that the mime package\ngives us for the file\u2019s name.\nThe code to handle DELETE requests is slightly simpler.\nconst {rmdir, unlink} = require(\"fs\").promises;\nmethods.DELETE = async function(request) {\nlet path = urlPath(request.url);\nlet stats;\ntry {\nstats = await stat(path);\n} catch (error) {\nif (error.code != \"ENOENT\") throw error;\nelse return {status: 204};\n}\nif (stats.isDirectory()) await rmdir(path);\nelse await unlink(path);\nreturn {status: 204};\n};\n364 WhenanHTTPresponsedoesnotcontainanydata, thestatuscode204(\u201cno\ncontent\u201d) can be used to indicate this. Since the response to deletion doesn\u2019t\nneed to transmit any information beyond whether the operation succeeded,\nthat is a sensible thing to return here.\nYou may be wondering why trying to delete a nonexistent file returns a\nsuccess status code, rather than an error. When the file that is being deleted\nis not there, you could say that the request\u2019s objective is already fulfilled. The\nHTTP standard encourages us to make requests idempotent, which means that\nmaking the same request multiple times produces the same result as making it\nonce. In a way, if you try to delete something that\u2019s already gone, the effect\nyou were trying to do has been achieved\u2014the thing is no longer there.\nThis is the handler for PUT requests:\nconst {createWriteStream} = require(\"fs\");\nfunction pipeStream(from, to) {\nreturn new Promise((resolve, reject) => {\nfrom.on(\"error\", reject);\nto.on(\"error\", reject);\nto.on(\"finish\", resolve);\nfrom.pipe(to);\n});\n}\nmethods.PUT = async function(request) {\nlet path = urlPath(request.url);\nawait pipeStream(request, createWriteStream(path));\nreturn {status: 204};\n};\nWe don\u2019t need to check whether the file exists this time\u2014if it does, we\u2019ll\njust overwrite it. We again use pipe to move data from a readable stream to\na writable one, in this case from the request to the file. But since pipe isn\u2019t\nwritten to return a promise, we have to write a wrapper, pipeStream, that\ncreates a promise around the outcome of calling pipe.\nWhen something goes wrong when opening the file, createWriteStream will\nstill return a stream, but that stream will fire an \"error\" event. The stream\nfrom the request may also fail, for example if the network goes down. So we\nwire up both streams\u2019 \"error\" events to reject the promise. When pipe is done,\nit will close the output stream, which causes it to fire a \"finish\" event. That\u2019s\n365 the point where we can successfully resolve the promise (returning nothing).\nThe full script for the server is available at https:\/\/eloquentjavascript.net\/\ncode\/file_server.js. You can download that and, after installing its dependen-\ncies, run it with Node to start your own file server. And, of course, you can\nmodify and extend it to solve this chapter\u2019s exercises or to experiment.\nThe command line tool curl, widely available on Unix-like systems (such as\nmacOS and Linux), can be used to make HTTP requests. The following session\nbriefly tests our server. The -X option is used to set the request\u2019s method, and\n-d is used to include a request body.\n$ curl http:\/\/localhost:8000\/file.txt\nFile not found\n$ curl -X PUT -d hello http:\/\/localhost:8000\/file.txt\n$ curl http:\/\/localhost:8000\/file.txt\nhello\n$ curl -X DELETE http:\/\/localhost:8000\/file.txt\n$ curl http:\/\/localhost:8000\/file.txt\nFile not found\nThe first request for file.txt fails since the file does not exist yet. The PUT\nrequest creates the file, and behold, the next request successfully retrieves it.\nAfter deleting it with a DELETE request, the file is again missing.\nSummary\nNode is a nice, small system that lets us run JavaScript in a nonbrowser con-\ntext. It was originally designed for network tasks to play the role of a node\nin a network. But it lends itself to all kinds of scripting tasks, and if writing\nJavaScript is something you enjoy, automating tasks with Node works well.\nNPM provides packages for everything you can think of (and quite a few\nthings you\u2019d probably never think of), and it allows you to fetch and install\nthose packages with the npm program. Node comes with a number of built-in\nmodules, including the fs module for working with the file system and the http\nmodule for running HTTP servers and making HTTP requests.\nAll input and output in Node is done asynchronously, unless you explicitly\nuse a synchronous variant of a function, such as readFileSync. When calling\nsuch asynchronous functions, you provide callback functions, and Node will call\nthem with an error value and (if available) a result when it is ready.\n366 Exercises\nSearch tool\nOn Unix systems, there is a command line tool called grep that can be used to\nquickly search files for a regular expression.\nWrite a Node script that can be run from the command line and acts some-\nwhat like grep. It treats its first command line argument as a regular expression\nand treats any further arguments as files to search. It should output the names\nof any file whose content matches the regular expression.\nWhen that works, extend it so that when one of the arguments is a directory,\nit searches through all files in that directory and its subdirectories.\nUse asynchronous or synchronous file system functions as you see fit. Setting\nthings up so that multiple asynchronous actions are requested at the same time\nmight speed things up a little, but not a huge amount, since most file systems\ncan read only one thing at a time.\nDirectory creation\nThough the DELETE method in our file server is able to delete directories (using\nrmdir), the server currently does not provide any way to create a directory.\nAddsupportfortheMKCOLmethod(\u201cmakecollection\u201d), whichshouldcreatea\ndirectorybycallingmkdirfromthefsmodule. MKCOLisnotawidelyusedHTTP\nmethod, butitdoesexistforthissamepurposeintheWebDAV standard, which\nspecifies a set of conventions on top of HTTP that make it suitable for creating\ndocuments.\nA public space on the web\nSincethefileserverservesupanykindoffileandevenincludestherightContent\n-Type header, you can use it to serve a website. Since it allows everybody to\ndelete and replace files, it would be an interesting kind of website: one that\ncan be modified, improved, and vandalized by everybody who takes the time\nto create the right HTTP request.\nWrite a basic HTML page that includes a simple JavaScript file. Put the\nfiles in a directory served by the file server and open them in your browser.\nNext, as an advanced exercise or even a weekend project, combine all the\nknowledge you gained from this book to build a more user-friendly interface\nfor modifying the website\u2014from inside the website.\nUse an HTML form to edit the content of the files that make up the website,\nallowing the user to update them on the server by using HTTP requests, as\n367 described in Chapter 18.\nStart by making only a single file editable. Then make it so that the user\ncan select which file to edit. Use the fact that our file server returns lists of\nfiles when reading a directory.\nDon\u2019t work directly in the code exposed by the file server since if you make\na mistake, you are likely to damage the files there. Instead, keep your work\noutside of the publicly accessible directory and copy it there when testing.\n368 \u201cIf you have knowledge, let others light their candles at it.\u201d\n\u2014Margaret Fuller\nChapter21\nProject: Skill-Sharing Website\nA skill-sharing meeting is an event where people with a shared interest come\ntogether and give small, informal presentations about things they know. At a\ngardening skill-sharing meeting, someone might explain how to cultivate celery.\nOr in a programming skill-sharing group, you could drop by and tell people\nabout Node.js.\nSuchmeetups\u2014alsooftencalledusers\u2019 groupswhentheyareaboutcomputers\u2014\nare a great way to broaden your horizon, learn about new developments, or\nsimply meet people with similar interests. Many larger cities have JavaScript\nmeetups. They are typically free to attend, and I\u2019ve found the ones I\u2019ve visited\nto be friendly and welcoming.\nIn this final project chapter, our goal is to set up a website for managing\ntalks given at a skill-sharing meeting. Imagine a small group of people meeting\nup regularly in the o\ufb00ice of one of the members to talk about unicycling. The\nprevious organizer of the meetings moved to another town, and nobody stepped\nforward to take over this task. We want a system that will let the participants\npropose and discuss talks among themselves, without a central organizer.\nThefullcodefortheprojectcanbedownloadedfromhttps:\/\/eloquentjavascript.net\/\ncode\/skillsharing.zip.\nDesign\nThere is a server part to this project, written for Node.js, and a client part,\nwritten for the browser. The server stores the system\u2019s data and provides it to\nthe client. It also serves the files that implement the client-side system.\nThe server keeps the list of talks proposed for the next meeting, and the\nclient shows this list. Each talk has a presenter name, a title, a summary, and\nan array of comments associated with it. The client allows users to propose new\ntalks (adding them to the list), delete talks, and comment on existing talks.\nWhenever the user makes such a change, the client makes an HTTP request to\ntell the server about it.\n369 The application will be set up to show a live view of the current proposed\ntalks and their comments. Whenever someone, somewhere, submits a new talk\nor adds a comment, all people who have the page open in their browsers should\nimmediately see the change. This poses a bit of a challenge\u2014there is no way\nfor a web server to open a connection to a client, nor is there a good way to\nknow which clients are currently looking at a given website.\nA common solution to this problem is called long polling, which happens to\nbe one of the motivations for Node\u2019s design.\nLong polling\nTo be able to immediately notify a client that something changed, we need a\nconnection to that client. Since web browsers do not traditionally accept con-\nnections and clients are often behind routers that would block such connections\nanyway, having the server initiate this connection is not practical.\nWe can arrange for the client to open the connection and keep it around so\nthat the server can use it to send information when it needs to do so.\nBut an HTTP request allows only a simple flow of information: the client\nsends a request, the server comes back with a single response, and that is it.\nThere is a technology called WebSockets, supported by modern browsers, that\nmakes it possible to open connections for arbitrary data exchange. But using\n370 them properly is somewhat tricky.\nIn this chapter, we use a simpler technique\u2014long polling\u2014where clients\ncontinuously ask the server for new information using regular HTTP requests,\nand the server stalls its answer when it has nothing new to report.\nAs long as the client makes sure it constantly has a polling request open, it\nwill receive information from the server quickly after it becomes available. For\nexample, if Fatma has our skill-sharing application open in her browser, that\nbrowser will have made a request for updates and will be waiting for a response\nto that request. When Iman submits a talk on Extreme Downhill Unicycling,\nthe server will notice that Fatma is waiting for updates and send a response\ncontaining the new talk to her pending request. Fatma\u2019s browser will receive\nthe data and update the screen to show the talk.\nTo prevent connections from timing out (being aborted because of a lack of\nactivity), long polling techniques usually set a maximum time for each request,\nafter which the server will respond anyway, even though it has nothing to\nreport, after which the client will start a new request. Periodically restarting\nthe request also makes the technique more robust, allowing clients to recover\nfrom temporary connection failures or server problems.\nA busy server that is using long polling may have thousands of waiting\nrequests, and thus TCP connections, open. Node, which makes it easy to\nmanage many connections without creating a separate thread of control for\neach one, is a good fit for such a system.\nHTTP interface\nBefore we start designing either the server or the client, let\u2019s think about the\npoint where they touch: the HTTP interface over which they communicate.\nWe will use JSON as the format of our request and response body. Like in\nthe file server from Chapter 20, we\u2019ll try to make good use of HTTP methods\nand headers. The interface is centered around the \/talks path. Paths that\ndo not start with \/talks will be used for serving static files\u2014the HTML and\nJavaScript code for the client-side system.\nA GET request to \/talks returns a JSON document like this:\n[{\"title\": \"Unituning\",\n\"presenter\": \"Jamal\",\n\"summary\": \"Modifying your cycle for extra style\",\n\"comments\": []}]\n371 Creating a new talk is done by making a PUT request to a URL like \/talks\/\nUnituning, where the part after the second slash is the title of the talk. The PUT\nrequest\u2019s body should contain a JSON object that has presenter and summary\nproperties.\nSince talk titles may contain spaces and other characters that may not ap-\npearnormallyinaURL,titlestringsmustbeencodedwiththeencodeURIComponent\nfunction when building up such a URL.\nconsole.log(\"\/talks\/\" + encodeURIComponent(\"How to Idle\"));\n\/\/ \u2192 \/talks\/How%20to%20Idle\nA request to create a talk about idling might look something like this:\nPUT \/talks\/How%20to%20Idle HTTP\/1.1\nContent-Type: application\/json\nContent-Length: 92\n{\"presenter\": \"Maureen\",\n\"summary\": \"Standing still on a unicycle\"}\nSuch URLs also support GET requests to retrieve the JSON representation\nof a talk and DELETE requests to delete a talk.\nAdding a comment to a talk is done with a POST request to a URL like \/\ntalks\/Unituning\/comments, with a JSON body that has author and message\nproperties.\nPOST \/talks\/Unituning\/comments HTTP\/1.1\nContent-Type: application\/json\nContent-Length: 72\n{\"author\": \"Iman\",\n\"message\": \"Will you talk about raising a cycle?\"}\nTo support long polling, GET requests to \/talks may include extra headers\nthat inform the server to delay the response if no new information is available.\nWe\u2019ll use a pair of headers normally intended to manage caching: ETag and\nIf-None-Match.\nServers may include an ETag (\u201centity tag\u201d) header in a response. Its value is\na string that identifies the current version of the resource. Clients, when they\nlater request that resource again, may make a conditional request by including\nan If-None-Match header whose value holds that same string. If the resource\n372 hasn\u2019t changed, the server will respond with status code 304, which means \u201cnot\nmodified\u201d, telling the client that its cached version is still current. When the\ntag does not match, the server responds as normal.\nWeneedsomethinglikethis, wheretheclientcantelltheserverwhichversion\nof the list of talks it has, and the server responds only when that list has\nchanged. But instead of immediately returning a 304 response, the server\nshould stall the response and return only when something new is available or\na given amount of time has elapsed. To distinguish long polling requests from\nnormal conditional requests, we give them another header, Prefer: wait=90,\nwhich tells the server that the client is willing to wait up to 90 seconds for the\nresponse.\nThe server will keep a version number that it updates every time the talks\nchange and will use that as the ETag value. Clients can make requests like this\nto be notified when the talks change:\nGET \/talks HTTP\/1.1\nIf-None-Match: \"4\"\nPrefer: wait=90\n(time passes)\nHTTP\/1.1 200 OK\nContent-Type: application\/json\nETag: \"5\"\nContent-Length: 295\n[....]\nThe protocol described here does not do any access control. Everybody can\ncomment, modify talks, and even delete them. (Since the Internet is full of\nhooligans, putting such a system online without further protection probably\nwouldn\u2019t end well.)\nThe server\nLet\u2019s start by building the server-side part of the program. The code in this\nsection runs on Node.js.\n373 Routing\nOur server will use createServer to start an HTTP server. In the function\nthat handles a new request, we must distinguish between the various kinds of\nrequests (as determined by the method and the path) that we support. This\ncan be done with a long chain of if statements, but there is a nicer way.\nA router is a component that helps dispatch a request to the function that\ncan handle it. You can tell the router, for example, that PUT requests with\na path that matches the regular expression \/^\\\/talks\\\/([^\\\/]+)$\/ (\/talks\/\nfollowed by a talk title) can be handled by a given function. In addition, it\ncan help extract the meaningful parts of the path (in this case the talk title),\nwrapped in parentheses in the regular expression, and pass them to the handler\nfunction.\nThere are a number of good router packages on NPM, but here we\u2019ll write\none ourselves to illustrate the principle.\nThis is router.js, which we will later require from our server module:\nconst {parse} = require(\"url\");\nmodule.exports = class Router {\nconstructor() {\nthis.routes = [];\n}\nadd(method, url, handler) {\nthis.routes.push({method, url, handler});\n}\nresolve(context, request) {\nlet path = parse(request.url).pathname;\nfor (let {method, url, handler} of this.routes) {\nlet match = url.exec(path);\nif (!match || request.method != method) continue;\nlet urlParts = match.slice(1).map(decodeURIComponent);\nreturn handler(context, ...urlParts, request);\n}\nreturn null;\n}\n};\nThe module exports the Router class. A router object allows new handlers\nto be registered with the add method and can resolve requests with its resolve\nmethod.\nThe latter will return a response when a handler was found, and null other-\n374 wise. It tries the routes one at a time (in the order in which they were defined)\nuntil a matching one is found.\nThe handler functions are called with the context value (which will be the\nserver instance in our case), match strings for any groups they defined in their\nregularexpression, andtherequestobject. ThestringshavetobeURL-decoded\nsince the raw URL may contain %20-style codes.\nServing files\nWhen a request matches none of the request types defined in our router, the\nserver must interpret it as a request for a file in the public directory. It would\nbe possible to use the file server defined in Chapter 20 to serve such files, but\nwe neither need nor want to support PUT and DELETE requests on files, and we\nwould like to have advanced features such as support for caching. So let\u2019s use\na solid, well-tested static file server from NPM instead.\nI opted for ecstatic. This isn\u2019t the only such server on NPM, but it works\nwell and fits our purposes. The ecstatic package exports a function that can\nbe called with a configuration object to produce a request handler function.\nWe use the root option to tell the server where it should look for files. The\nhandler function accepts request and response parameters and can be passed\ndirectly to createServer to create a server that serves only files. We want to\nfirst check for requests that we should handle specially, though, so we wrap it\nin another function.\nconst {createServer} = require(\"http\");\nconst Router = require(\".\/router\");\nconst ecstatic = require(\"ecstatic\");\nconst router = new Router();\nconst defaultHeaders = {\"Content-Type\": \"text\/plain\"};\nclass SkillShareServer {\nconstructor(talks) {\nthis.talks = talks;\nthis.version = 0;\nthis.waiting = [];\nlet fileServer = ecstatic({root: \".\/public\"});\nthis.server = createServer((request, response) => {\nlet resolved = router.resolve(this, request);\nif (resolved) {\nresolved.catch(error => {\nif (error.status != null) return error;\n375 return {body: String(error), status: 500};\n}).then(({body,\nstatus = 200,\nheaders = defaultHeaders}) => {\nresponse.writeHead(status, headers);\nresponse.end(body);\n});\n} else {\nfileServer(request, response);\n}\n});\n}\nstart(port) {\nthis.server.listen(port);\n}\nstop() {\nthis.server.close();\n}\n}\nThis uses a similar convention as the file server from the previous chapter\nfor responses\u2014handlers return promises that resolve to objects describing the\nresponse. It wraps the server in an object that also holds its state.\nTalks as resources\nThe talks that have been proposed are stored in the talks property of the\nserver, an object whose property names are the talk titles. These will be\nexposed as HTTP resources under \/talks\/[title], so we need to add handlers\nto our router that implement the various methods that clients can use to work\nwith them.\nThe handler for requests that GET a single talk must look up the talk and\nrespond either with the talk\u2019s JSON data or with a 404 error response.\nconst talkPath = \/^\\\/talks\\\/([^\\\/]+)$\/;\nrouter.add(\"GET\", talkPath, async (server, title) => {\nif (title in server.talks) {\nreturn {body: JSON.stringify(server.talks[title]),\nheaders: {\"Content-Type\": \"application\/json\"}};\n} else {\nreturn {status: 404, body: `No talk '${title}' found`};\n}\n376 });\nDeleting a talk is done by removing it from the talks object.\nrouter.add(\"DELETE\", talkPath, async (server, title) => {\nif (title in server.talks) {\ndelete server.talks[title];\nserver.updated();\n}\nreturn {status: 204};\n});\nThe updated method, which we will define later, notifies waiting long polling\nrequests about the change.\nToretrievethecontentofarequestbody, wedefineafunctioncalledreadStream\n, which reads all content from a readable stream and returns a promise that\nresolves to a string.\nfunction readStream(stream) {\nreturn new Promise((resolve, reject) => {\nlet data = \"\";\nstream.on(\"error\", reject);\nstream.on(\"data\", chunk => data += chunk.toString());\nstream.on(\"end\", () => resolve(data));\n});\n}\nOne handler that needs to read request bodies is the PUT handler, which\nis used to create new talks. It has to check whether the data it was given\nhas presenter and summary properties, which are strings. Any data coming\nfrom outside the system might be nonsense, and we don\u2019t want to corrupt our\ninternal data model or crash when bad requests come in.\nIf the data looks valid, the handler stores an object that represents the new\ntalk in the talks object, possibly overwriting an existing talk with this title,\nand again calls updated.\nrouter.add(\"PUT\", talkPath,\nasync (server, title, request) => {\nlet requestBody = await readStream(request);\nlet talk;\ntry { talk = JSON.parse(requestBody); }\ncatch (_) { return {status: 400, body: \"Invalid JSON\"}; }\n377 if (!talk ||\ntypeof talk.presenter != \"string\" ||\ntypeof talk.summary != \"string\") {\nreturn {status: 400, body: \"Bad talk data\"};\n}\nserver.talks[title] = {title,\npresenter: talk.presenter,\nsummary: talk.summary,\ncomments: []};\nserver.updated();\nreturn {status: 204};\n});\nAdding a comment to a talk works similarly. We use readStream to get the\ncontent of the request, validate the resulting data, and store it as a comment\nwhen it looks valid.\nrouter.add(\"POST\", \/^\\\/talks\\\/([^\\\/]+)\\\/comments$\/,\nasync (server, title, request) => {\nlet requestBody = await readStream(request);\nlet comment;\ntry { comment = JSON.parse(requestBody); }\ncatch (_) { return {status: 400, body: \"Invalid JSON\"}; }\nif (!comment ||\ntypeof comment.author != \"string\" ||\ntypeof comment.message != \"string\") {\nreturn {status: 400, body: \"Bad comment data\"};\n} else if (title in server.talks) {\nserver.talks[title].comments.push(comment);\nserver.updated();\nreturn {status: 204};\n} else {\nreturn {status: 404, body: `No talk '${title}' found`};\n}\n});\nTrying to add a comment to a nonexistent talk returns a 404 error.\n378 Long polling support\nThe most interesting aspect of the server is the part that handles long polling.\nWhen a GET request comes in for \/talks, it may be either a regular request or\na long polling request.\nThere will be multiple places in which we have to send an array of talks to\nthe client, so we first define a helper method that builds up such an array and\nincludes an ETag header in the response.\nSkillShareServer.prototype.talkResponse = function() {\nlet talks = [];\nfor (let title of Object.keys(this.talks)) {\ntalks.push(this.talks[title]);\n}\nreturn {\nbody: JSON.stringify(talks),\nheaders: {\"Content-Type\": \"application\/json\",\n\"ETag\": `\"${this.version}\"`,\n\"Cache-Control\": \"no-store\"}\n};\n};\nThe handler itself needs to look at the request headers to see whether If-\nNone-Match and Prefer headers are present. Node stores headers, whose names\nare specified to be case insensitive, under their lowercase names.\nrouter.add(\"GET\", \/^\\\/talks$\/, async (server, request) => {\nlet tag = \/\"(.*)\"\/.exec(request.headers[\"if-none-match\"]);\nlet wait = \/\\bwait=(\\d+)\/.exec(request.headers[\"prefer\"]);\nif (!tag || tag[1] != server.version) {\nreturn server.talkResponse();\n} else if (!wait) {\nreturn {status: 304};\n} else {\nreturn server.waitForChanges(Number(wait[1]));\n}\n});\nIf no tag was given or a tag was given that doesn\u2019t match the server\u2019s current\nversion, the handler responds with the list of talks. If the request is conditional\nand the talks did not change, we consult the Prefer header to see whether we\nshould delay the response or respond right away.\nCallback functions for delayed requests are stored in the server\u2019s waiting ar-\n379 ray so that they can be notified when something happens. The waitForChanges\nmethod also immediately sets a timer to respond with a 304 status when the\nrequest has waited long enough.\nSkillShareServer.prototype.waitForChanges = function(time) {\nreturn new Promise(resolve => {\nthis.waiting.push(resolve);\nsetTimeout(() => {\nif (!this.waiting.includes(resolve)) return;\nthis.waiting = this.waiting.filter(r => r != resolve);\nresolve({status: 304});\n}, time * 1000);\n});\n};\nRegistering a change with updated increases the version property and wakes\nup all waiting requests.\nSkillShareServer.prototype.updated = function() {\nthis.version++;\nlet response = this.talkResponse();\nthis.waiting.forEach(resolve => resolve(response));\nthis.waiting = [];\n};\nThatconcludestheservercode. IfwecreateaninstanceofSkillShareServer\nand start it on port 8000, the resulting HTTP server serves files from the public\nsubdirectory alongside a talk-managing interface under the \/talks URL.\nnew SkillShareServer(Object.create(null)).start(8000);\nThe client\nThe client-side part of the skill-sharing website consists of three files: a tiny\nHTML page, a style sheet, and a JavaScript file.\nHTML\nIt is a widely used convention for web servers to try to serve a file named\nindex.html when a request is made directly to a path that corresponds to a\n380 directory. The file server module we use, ecstatic, supports this convention.\nWhen a request is made to the path \/, the server looks for the file .\/public\/\nindex.html (.\/public being the root we gave it) and returns that file if found.\nThus, if we want a page to show up when a browser is pointed at our server,\nwe should put it in public\/index.html. This is our index file:\n<!doctype html>\n<meta charset=\"utf-8\">\n<title>Skill Sharing<\/title>\n<link rel=\"stylesheet\" href=\"skillsharing.css\">\n<h1>Skill Sharing<\/h1>\n<script src=\"skillsharing_client.js\"><\/script>\nIt defines the document title and includes a style sheet, which defines a few\nstyles to, among other things, make sure there is some space between talks.\nAt the bottom, it adds a heading at the top of the page and loads the script\nthat contains the client-side application.\nActions\nThe application state consists of the list of talks and the name of the user, and\nwe\u2019ll store it in a {talks, user} object. We don\u2019t allow the user interface to\ndirectly manipulate the state or send off HTTP requests. Rather, it may emit\nactions that describe what the user is trying to do.\nThe handleAction function takes such an action and makes it happen. Be-\ncause our state updates are so simple, state changes are handled in the same\nfunction.\nfunction handleAction(state, action) {\nif (action.type == \"setUser\") {\nlocalStorage.setItem(\"userName\", action.user);\nreturn Object.assign({}, state, {user: action.user});\n} else if (action.type == \"setTalks\") {\nreturn Object.assign({}, state, {talks: action.talks});\n} else if (action.type == \"newTalk\") {\nfetchOK(talkURL(action.title), {\nmethod: \"PUT\",\nheaders: {\"Content-Type\": \"application\/json\"},\nbody: JSON.stringify({\npresenter: state.user,\nsummary: action.summary\n381 })\n}).catch(reportError);\n} else if (action.type == \"deleteTalk\") {\nfetchOK(talkURL(action.talk), {method: \"DELETE\"})\n.catch(reportError);\n} else if (action.type == \"newComment\") {\nfetchOK(talkURL(action.talk) + \"\/comments\", {\nmethod: \"POST\",\nheaders: {\"Content-Type\": \"application\/json\"},\nbody: JSON.stringify({\nauthor: state.user,\nmessage: action.message\n})\n}).catch(reportError);\n}\nreturn state;\n}\nWe\u2019ll store the user\u2019s name in localStorage so that it can be restored when\nthe page is loaded.\nThe actions that need to involve the server make network requests, using\nfetch, to the HTTP interface described earlier. We use a wrapper function,\nfetchOK, which makes sure the returned promise is rejected when the server\nreturns an error code.\nfunction fetchOK(url, options) {\nreturn fetch(url, options).then(response => {\nif (response.status < 400) return response;\nelse throw new Error(response.statusText);\n});\n}\nThis helper function is used to build up a URL for a talk with a given title.\nfunction talkURL(title) {\nreturn \"talks\/\" + encodeURIComponent(title);\n}\nWhen the request fails, we don\u2019t want to have our page just sit there, doing\nnothingwithoutexplanation. SowedefineafunctioncalledreportError, which\nat least shows the user a dialog that tells them something went wrong.\n382 function reportError(error) {\nalert(String(error));\n}\nRendering components\nWe\u2019ll use an approach similar to the one we saw in Chapter 19, splitting the\napplication into components. But since some of the components either never\nneed to update or are always fully redrawn when updated, we\u2019ll define those\nnot as classes but as functions that directly return a DOM node. For example,\nhere is a component that shows the field where the user can enter their name:\nfunction renderUserField(name, dispatch) {\nreturn elt(\"label\", {}, \"Your name: \", elt(\"input\", {\ntype: \"text\",\nvalue: name,\nonchange(event) {\ndispatch({type: \"setUser\", user: event.target.value});\n}\n}));\n}\nThe elt function used to construct DOM elements is the one we used in\nChapter 19.\nA similar function is used to render talks, which include a list of comments\nand a form for adding a new comment.\nfunction renderTalk(talk, dispatch) {\nreturn elt(\n\"section\", {className: \"talk\"},\nelt(\"h2\", null, talk.title, \" \", elt(\"button\", {\ntype: \"button\",\nonclick() {\ndispatch({type: \"deleteTalk\", talk: talk.title});\n}\n}, \"Delete\")),\nelt(\"div\", null, \"by \",\nelt(\"strong\", null, talk.presenter)),\nelt(\"p\", null, talk.summary),\n...talk.comments.map(renderComment),\nelt(\"form\", {\nonsubmit(event) {\n383 event.preventDefault();\nlet form = event.target;\ndispatch({type: \"newComment\",\ntalk: talk.title,\nmessage: form.elements.comment.value});\nform.reset();\n}\n}, elt(\"input\", {type: \"text\", name: \"comment\"}), \" \",\nelt(\"button\", {type: \"submit\"}, \"Add comment\")));\n}\nThe \"submit\" event handler calls form.reset to clear the form\u2019s content\nafter creating a \"newComment\" action.\nWhen creating moderately complex pieces of DOM, this style of program-\nmingstartstolookrathermessy. There\u2019sawidelyused(non-standard)JavaScript\nextension called JSX that lets you write HTML directly in your scripts, which\ncan make such code prettier (depending on what you consider pretty). Before\nyou can actually run such code, you have to run a program on your script to\nconvert the pseudo-HTML into JavaScript function calls much like the ones we\nuse here.\nComments are simpler to render.\nfunction renderComment(comment) {\nreturn elt(\"p\", {className: \"comment\"},\nelt(\"strong\", null, comment.author),\n\": \", comment.message);\n}\nFinally, the form that the user can use to create a new talk is rendered like\nthis:\nfunction renderTalkForm(dispatch) {\nlet title = elt(\"input\", {type: \"text\"});\nlet summary = elt(\"input\", {type: \"text\"});\nreturn elt(\"form\", {\nonsubmit(event) {\nevent.preventDefault();\ndispatch({type: \"newTalk\",\ntitle: title.value,\nsummary: summary.value});\nevent.target.reset();\n}\n}, elt(\"h3\", null, \"Submit a Talk\"),\n384 elt(\"label\", null, \"Title: \", title),\nelt(\"label\", null, \"Summary: \", summary),\nelt(\"button\", {type: \"submit\"}, \"Submit\"));\n}\nPolling\nTo start the app we need the current list of talks. Since the initial load is closely\nrelated to the long polling process\u2014the ETag from the load must be used when\npolling\u2014we\u2019ll write a function that keeps polling the server for \/talks and calls\na callback function when a new set of talks is available.\nasync function pollTalks(update) {\nlet tag = undefined;\nfor (;;) {\nlet response;\ntry {\nresponse = await fetchOK(\"\/talks\", {\nheaders: tag && {\"If-None-Match\": tag,\n\"Prefer\": \"wait=90\"}\n});\n} catch (e) {\nconsole.log(\"Request failed: \" + e);\nawait new Promise(resolve => setTimeout(resolve, 500));\ncontinue;\n}\nif (response.status == 304) continue;\ntag = response.headers.get(\"ETag\");\nupdate(await response.json());\n}\n}\nThis is an async function so that looping and waiting for the request is easier.\nIt runs an infinite loop that, on each iteration, retrieves the list of talks\u2014either\nnormally or, if this isn\u2019t the first request, with the headers included that make\nit a long polling request.\nWhen a request fails, the function waits a moment and then tries again.\nThis way, if your network connection goes away for a while and then comes\nback, the application can recover and continue updating. The promise resolved\nvia setTimeout is a way to force the async function to wait.\nWhen the server gives back a 304 response, that means a long polling request\n385 timed out, so the function should just immediately start the next request. If\nthe response is a normal 200 response, its body is read as JSON and passed to\nthe callback, and its ETag header value is stored for the next iteration.\nThe application\nThe following component ties the whole user interface together:\nclass SkillShareApp {\nconstructor(state, dispatch) {\nthis.dispatch = dispatch;\nthis.talkDOM = elt(\"div\", {className: \"talks\"});\nthis.dom = elt(\"div\", null,\nrenderUserField(state.user, dispatch),\nthis.talkDOM,\nrenderTalkForm(dispatch));\nthis.syncState(state);\n}\nsyncState(state) {\nif (state.talks != this.talks) {\nthis.talkDOM.textContent = \"\";\nfor (let talk of state.talks) {\nthis.talkDOM.appendChild(\nrenderTalk(talk, this.dispatch));\n}\nthis.talks = state.talks;\n}\n}\n}\nWhen the talks change, this component redraws all of them. This is simple\nbut also wasteful. We\u2019ll get back to that in the exercises.\nWe can start the application like this:\nfunction runApp() {\nlet user = localStorage.getItem(\"userName\") || \"Anon\";\nlet state, app;\nfunction dispatch(action) {\nstate = handleAction(state, action);\napp.syncState(state);\n}\npollTalks(talks => {\n386 if (!app) {\nstate = {user, talks};\napp = new SkillShareApp(state, dispatch);\ndocument.body.appendChild(app.dom);\n} else {\ndispatch({type: \"setTalks\", talks});\n}\n}).catch(reportError);\n}\nrunApp();\nIf you run the server and open two browser windows for http:\/\/localhost:8000\nnext to each other, you can see that the actions you perform in one window\nare immediately visible in the other.\nExercises\nThe following exercises will involve modifying the system defined in this chap-\nter. Toworkonthem, makesureyoudownloadthecodefirst(https:\/\/eloquentjavascript.net\/\ncode\/skillsharing.zip), have Node installed https:\/\/nodejs.org, and have in-\nstalled the project\u2019s dependency with npm install.\nDisk persistence\nThe skill-sharing server keeps its data purely in memory. This means that when\nit crashes or is restarted for any reason, all talks and comments are lost.\nExtend the server so that it stores the talk data to disk and automatically\nreloads the data when it is restarted. Do not worry about e\ufb00iciency\u2014do the\nsimplest thing that works.\nComment field resets\nThe wholesale redrawing of talks works pretty well because you usually can\u2019t\ntell the difference between a DOM node and its identical replacement. But\nthere are exceptions. If you start typing something in the comment field for a\ntalk in one browser window and then, in another, add a comment to that talk,\nthe field in the first window will be redrawn, removing both its content and its\nfocus.\nIn a heated discussion, where multiple people are adding comments at the\nsame time, this would be annoying. Can you come up with a way to solve it?\n387 Exercise Hints\nThe hints below might help when you are stuck with one of the exercises in\nthis book. They don\u2019t give away the entire solution, but rather try to help you\nfind it yourself.\nProgram Structure\nLooping a triangle\nYou can start with a program that prints out the numbers 1 to 7, which you\ncan derive by making a few modifications to the even number printing example\ngiven earlier in the chapter, where the for loop was introduced.\nNow consider the equivalence between numbers and strings of hash char-\nacters. You can go from 1 to 2 by adding 1 (+= 1). You can go from \"#\" to\n\"##\" by adding a character (+= \"#\"). Thus, your solution can closely follow\nthe number-printing program.\nFizzBuzz\nGoing over the numbers is clearly a looping job, and selecting what to print is\na matter of conditional execution. Remember the trick of using the remainder\n(%) operator for checking whether a number is divisible by another number (has\na remainder of zero).\nIn the first version, there are three possible outcomes for every number, so\nyou\u2019ll have to create an if\/else if\/else chain.\nThesecondversionoftheprogramhasastraightforwardsolutionandaclever\none. The simple solution is to add another conditional \u201cbranch\u201d to precisely\ntest the given condition. For the clever solution, build up a string containing\nthe word or words to output and print either this word or the number if there\nis no word, potentially by making good use of the || operator.\n388 Chessboard\nYou can build the string by starting with an empty one (\"\") and repeatedly\nadding characters. A newline character is written \"\\n\".\nTo work with two dimensions, you will need a loop inside of a loop. Put\nbraces around the bodies of both loops to make it easy to see where they start\nand end. Try to properly indent these bodies. The order of the loops must\nfollow the order in which we build up the string (line by line, left to right, top\nto bottom). So the outer loop handles the lines, and the inner loop handles the\ncharacters on a line.\nYou\u2019ll need two bindings to track your progress. To know whether to put a\nspace or a hash sign at a given position, you could test whether the sum of the\ntwo counters is even (% 2).\nTerminating a line by adding a newline character must happen after the line\nhas been built up, so do this after the inner loop but inside the outer loop.\nFunctions\nMinimum\nIf you have trouble putting braces and parentheses in the right place to get a\nvalid function definition, start by copying one of the examples in this chapter\nand modifying it.\nA function may contain multiple return statements.\nRecursion\nYour function will likely look somewhat similar to the inner find function in the\nrecursive findSolution example in this chapter, with an if\/else if\/else chain\nthat tests which of the three cases applies. The final else, corresponding to\nthe third case, makes the recursive call. Each of the branches should contain\na return statement or in some other way arrange for a specific value to be\nreturned.\nWhen given a negative number, the function will recurse again and again,\npassing itself an ever more negative number, thus getting further and further\naway from returning a result. It will eventually run out of stack space and\nabort.\n389 Bean counting\nYour function will need a loop that looks at every character in the string. It\ncan run an index from zero to one below its length (< string.length). If the\ncharacter at the current position is the same as the one the function is looking\nfor, it adds 1 to a counter variable. Once the loop has finished, the counter can\nbe returned.\nTake care to make all the bindings used in the function local to the function\nby properly declaring them with the let or const keyword.\nData Structures: Objects and Arrays\nThe sum of a range\nBuilding up an array is most easily done by first initializing a binding to []\n(a fresh, empty array) and repeatedly calling its push method to add a value.\nDon\u2019t forget to return the array at the end of the function.\nSince the end boundary is inclusive, you\u2019ll need to use the <= operator rather\nthan < to check for the end of your loop.\nThe step parameter can be an optional parameter that defaults (using the\n= operator) to 1.\nHaving range understand negative step values is probably best done by\nwriting two separate loops\u2014one for counting up and one for counting down\u2014\nbecause the comparison that checks whether the loop is finished needs to be >=\nrather than <= when counting downward.\nIt might also be worthwhile to use a different default step, namely, -1, when\nthe end of the range is smaller than the start. That way, range(5, 2) re-\nturns something meaningful, rather than getting stuck in an infinite loop. It is\npossible to refer to previous parameters in the default value of a parameter.\nReversing an array\nThere are two obvious ways to implement reverseArray. The first is to simply\ngo over the input array from front to back and use the unshift method on\nthe new array to insert each element at its start. The second is to loop over\nthe input array backwards and use the push method. Iterating over an array\nbackwards requires a (somewhat awkward) for specification, like (let i =\narray.length - 1; i >= 0; i--).\nReversingthearrayinplaceisharder. Youhavetobecarefulnottooverwrite\nelements that you will later need. Using reverseArray or otherwise copying\n390 the whole array (array.slice(0) is a good way to copy an array) works but is\ncheating.\nThe trick is to swap the first and last elements, then the second and second-\nto-last, and so on. You can do this by looping over half the length of the array\n(use Math.floor to round down\u2014you don\u2019t need to touch the middle element\nin an array with an odd number of elements) and swapping the element at\nposition i with the one at position array.length - 1 - i. You can use a local\nbinding to briefly hold on to one of the elements, overwrite that one with its\nmirror image, and then put the value from the local binding in the place where\nthe mirror image used to be.\nA list\nBuilding up a list is easier when done back to front. So arrayToList could iter-\nate over the array backwards (see the previous exercise) and, for each element,\nadd an object to the list. You can use a local binding to hold the part of the\nlist that was built so far and use an assignment like list = {value: X, rest:\nlist} to add an element.\nTo run over a list (in listToArray and nth), a for loop specification like this\ncan be used:\nfor (let node = list; node; node = node.rest) {}\nCan you see how that works? Every iteration of the loop, node points to the\ncurrent sublist, and the body can read its value property to get the current\nelement. At the end of an iteration, node moves to the next sublist. When that\nis null, we have reached the end of the list, and the loop is finished.\nThe recursive version of nth will, similarly, look at an ever smaller part of\nthe \u201ctail\u201d of the list and at the same time count down the index until it reaches\nzero, at which point it can return the value property of the node it is looking\nat. To get the zeroth element of a list, you simply take the value property of\nits head node. To get element N + 1, you take the Nth element of the list\nthat\u2019s in this list\u2019s rest property.\nDeep comparison\nYour test for whether you are dealing with a real object will look something like\ntypeof x == \"object\" && x != null. Be careful to compare properties only\nwhen both arguments are objects. In all other cases you can just immediately\nreturn the result of applying ===.\n391 Use Object.keys to go over the properties. You need to test whether both\nobjects have the same set of property names and whether those properties have\nidentical values. One way to do that is to ensure that both objects have the\nsame number of properties (the lengths of the property lists are the same).\nAnd then, when looping over one of the object\u2019s properties to compare them,\nalways first make sure the other actually has a property by that name. If they\nhave the same number of properties and all properties in one also exist in the\nother, they have the same set of property names.\nReturning the correct value from the function is best done by immediately\nreturning false when a mismatch is found and returning true at the end of the\nfunction.\nHigher-Order Functions\nEverything\nLike the && operator, the every method can stop evaluating further elements\nas soon as it has found one that doesn\u2019t match. So the loop-based version\ncan jump out of the loop\u2014with break or return\u2014as soon as it runs into an\nelement for which the predicate function returns false. If the loop runs to its\nend without finding such an element, we know that all elements matched and\nwe should return true.\nTo build every on top of some, we can apply De Morgan\u2019s laws, which state\nthat a && b equals !(!a || !b). This can be generalized to arrays, where all\nelements in the array match if there is no element in the array that does not\nmatch.\nDominant writing direction\nYour solution might look a lot like the first half of the textScripts example.\nYou again have to count characters by a criterion based on characterScript\nand then filter out the part of the result that refers to uninteresting (script-less)\ncharacters.\nFinding the direction with the highest character count can be done with\nreduce. If it\u2019s not clear how, refer to the example earlier in the chapter, where\nreduce was used to find the script with the most characters.\n392 The Secret Life of Objects\nA vector type\nLook back to the Rabbit class example if you\u2019re unsure how class declarations\nlook.\nAdding a getter property to the constructor can be done by putting the\nword get before the method name. To compute the distance from (0, 0) to\n(x, y), you can use the Pythagorean theorem, which says that the square of\nthe distance we are looking for is equal to the square of the x-coordinate plus\n\u221a\nthe square of the y-coordinate. Thus, x2 +y2 is the number you want, and\nMath.sqrt is the way you compute a square root in JavaScript.\nGroups\nThe easiest way to do this is to store an array of group members in an instance\nproperty. The includes or indexOf methods can be used to check whether a\ngiven value is in the array.\nYour class\u2019s constructor can set the member collection to an empty array.\nWhen add is called, it must check whether the given value is in the array or\nadd it, for example with push, otherwise.\nDeleting an element from an array, in delete, is less straightforward, but\nyou can use filter to create a new array without the value. Don\u2019t forget to\noverwrite the property holding the members with the newly filtered version of\nthe array.\nThe from method can use a for\/of loop to get the values out of the iterable\nobject and call add to put them into a newly created group.\nIterable groups\nIt is probably worthwhile to define a new class GroupIterator. Iterator in-\nstances should have a property that tracks the current position in the group.\nEvery time next is called, it checks whether it is done and, if not, moves past\nthe current value and returns it.\nThe Group class itself gets a method named by Symbol.iterator that, when\ncalled, returns a new instance of the iterator class for that group.\nBorrowing a method\nRememberthatmethodsthatexistonplainobjectscomefromObject.prototype\n.\n393 Also remember that you can call a function with a specific this binding by\nusing its call method.\nProject: A Robot\nMeasuring a robot\nYou\u2019ll have to write a variant of the runRobot function that, instead of log-\nging the events to the console, returns the number of steps the robot took to\ncomplete the task.\nYour measurement function can then, in a loop, generate new states and\ncount the steps each of the robots takes. When it has generated enough mea-\nsurements, it can use console.log to output the average for each robot, which\nis the total number of steps taken divided by the number of measurements.\nRobot efficiency\nThe main limitation of goalOrientedRobot is that it considers only one parcel\nat a time. It will often walk back and forth across the village because the parcel\nit happens to be looking at happens to be at the other side of the map, even if\nthere are others much closer.\nOne possible solution would be to compute routes for all packages and then\ntake the shortest one. Even better results can be obtained, if there are multiple\nshortest routes, by preferring the ones that go to pick up a package instead of\ndelivering a package.\nPersistent group\nThe most convenient way to represent the set of member values is still as an\narray since arrays are easy to copy.\nWhen a value is added to the group, you can create a new group with a copy\nof the original array that has the value added (for example, using concat).\nWhen a value is deleted, you filter it from the array.\nThe class\u2019s constructor can take such an array as argument and store it as\nthe instance\u2019s (only) property. This array is never updated.\nTo add a property (empty) to a constructor that is not a method, you have\nto add it to the constructor after the class definition, as a regular property.\nYou need only one empty instance because all empty groups are the same\nand instances of the class don\u2019t change. You can create many different groups\nfrom that single empty group without affecting it.\n394 Bugs and Errors\nRetry\nThe call to primitiveMultiply should definitely happen in a try block. The\ncorresponding catch block should rethrow the exception when it is not an\ninstance of MultiplicatorUnitFailure and ensure the call is retried when it is.\nTo do the retrying, you can either use a loop that stops only when a call\nsucceeds\u2014as in the look example earlier in this chapter\u2014or use recursion and\nhope you don\u2019t get a string of failures so long that it overflows the stack (which\nis a pretty safe bet).\nThe locked box\nThis exercise calls for a finally block. Your function should first unlock the\nbox and then call the argument function from inside a try body. The finally\nblock after it should lock the box again.\nTo make sure we don\u2019t lock the box when it wasn\u2019t already locked, check its\nlock at the start of the function and unlock and lock it only when it started\nout locked.\nRegular Expressions\nQuoting style\nThe most obvious solution is to replace only quotes with a nonword character\non at least one side\u2014something like \/\\W'|'\\W\/. But you also have to take the\nstart and end of the line into account.\nIn addition, you must ensure that the replacement also includes the charac-\nters that were matched by the \\W pattern so that those are not dropped. This\ncan be done by wrapping them in parentheses and including their groups in\nthe replacement string ($1, $2). Groups that are not matched will be replaced\nby nothing.\nNumbers again\nFirst, do not forget the backslash in front of the period.\nMatching the optional sign in front of the number, as well as in front of the\nexponent, can be done with [+\\-]? or (\\+|-|) (plus, minus, or nothing).\nThe more complicated part of the exercise is the problem of matching both\n\"5.\" and \".5\" without also matching \".\". For this, a good solution is to use\n395 the | operator to separate the two cases\u2014either one or more digits optionally\nfollowed by a dot and zero or more digits or a dot followed by one or more\ndigits.\nFinally, to make the e case insensitive, either add an i option to the regular\nexpression or use [eE].\nModules\nA modular robot\nHere\u2019s what I would have done (but again, there is no single right way to design\na given module):\nThe code used to build the road graph lives in the graph module. Because\nI\u2019d rather use dijkstrajs from NPM than our own pathfinding code, we\u2019ll\nmake this build the kind of graph data that dijkstrajs expects. This module\nexports a single function, buildGraph. I\u2019d have buildGraph accept an array\nof two-element arrays, rather than strings containing hyphens, to make the\nmodule less dependent on the input format.\nThe roads module contains the raw road data (the roads array) and the\nroadGraph binding. This module depends on .\/graph and exports the road\ngraph.\nThe VillageState class lives in the state module. It depends on the .\/\nroads module because it needs to be able to verify that a given road exists.\nIt also needs randomPick. Since that is a three-line function, we could just\nput it into the state module as an internal helper function. But randomRobot\nneeds it too. So we\u2019d have to either duplicate it or put it into its own module.\nSince this function happens to exist on NPM in the random-item package, a\ngood solution is to just make both modules depend on that. We can add the\nrunRobot function to this module as well, since it\u2019s small and closely related to\nstate management. The module exports both the VillageState class and the\nrunRobot function.\nFinally, the robots, along with the values they depend on such as mailRoute\n, could go into an example-robots module, which depends on .\/roads and\nexports the robot functions. To make it possible for goalOrientedRobot to do\nroute-finding, this module also depends on dijkstrajs.\nBy offloading some work to NPM modules, the code became a little smaller.\nEach individual module does something rather simple and can be read on its\nown. Dividing code into modules also often suggests further improvements to\nthe program\u2019s design. In this case, it seems a little odd that the VillageState\nand the robots depend on a specific road graph. It might be a better idea to\n396 make the graph an argument to the state\u2019s constructor and make the robots\nread it from the state object\u2014this reduces dependencies (which is always good)\nand makes it possible to run simulations on different maps (which is even\nbetter).\nIs it a good idea to use NPM modules for things that we could have written\nourselves? In principle, yes\u2014for nontrivial things like the pathfinding function\nyou are likely to make mistakes and waste time writing them yourself. For tiny\nfunctions like random-item, writing them yourself is easy enough. But adding\nthem wherever you need them does tend to clutter your modules.\nHowever, you should also not underestimate the work involved in finding an\nappropriate NPM package. And even if you find one, it might not work well\nor may be missing some feature you need. On top of that, depending on NPM\npackages means you have to make sure they are installed, you have to distribute\nthem with your program, and you might have to periodically upgrade them.\nSo again, this is a trade-off, and you can decide either way depending on\nhow much the packages help you.\nRoads module\nSince this is a CommonJS module, you have to use require to import the graph\nmodule. That was described as exporting a buildGraph function, which you\ncan pick out of its interface object with a destructuring const declaration.\nTo export roadGraph, you add a property to the exports object. Because\nbuildGraph takes a data structure that doesn\u2019t precisely match roads, the split-\nting of the road strings must happen in your module.\nCircular dependencies\nThe trick is that require adds modules to its cache before it starts loading the\nmodule. That way, if any require call made while it is running tries to load\nit, it is already known, and the current interface will be returned, rather than\nstarting to load the module once more (which would eventually overflow the\nstack).\nIf a module overwrites its module.exports value, any other module that has\nreceived its interface value before it finished loading will have gotten hold of\nthe default interface object (which is likely empty), rather than the intended\ninterface value.\n397 Asynchronous Programming\nTracking the scalpel\nThis can be done with a single loop that searches through the nests, moving\nforward to the next when it finds a value that doesn\u2019t match the current nest\u2019s\nname and returning the name when it finds a matching value. In the async\nfunction, a regular for or while loop can be used.\nTo do the same in a plain function, you will have to build your loop using\na recursive function. The easiest way to do this is to have that function re-\nturn a promise by calling then on the promise that retrieves the storage value.\nDepending on whether that value matches the name of the current nest, the\nhandler returns that value or a further promise created by calling the loop\nfunction again.\nDon\u2019t forget to start the loop by calling the recursive function once from the\nmain function.\nIn the async function, rejected promises are converted to exceptions by await\n. When an async function throws an exception, its promise is rejected. So that\nworks.\nIf you implemented the non-async function as outlined earlier, the way then\nworks also automatically causes a failure to end up in the returned promise.\nIf a request fails, the handler passed to then isn\u2019t called, and the promise it\nreturns is rejected with the same reason.\nBuilding Promise.all\nThe function passed to the Promise constructor will have to call then on each\nof the promises in the given array. When one of them succeeds, two things\nneed to happen. The resulting value needs to be stored in the correct position\nof a result array, and we must check whether this was the last pending promise\nand finish our own promise if it was.\nThe latter can be done with a counter that is initialized to the length of\nthe input array and from which we subtract 1 every time a promise succeeds.\nWhen it reaches 0, we are done. Make sure you take into account the situation\nwhere the input array is empty (and thus no promise will ever resolve).\nHandling failure requires some thought but turns out to be extremely simple.\nJust pass the reject function of the wrapping promise to each of the promises\nin the array as a catch handler or as a second argument to then so that a failure\nin one of them triggers the rejection of the whole wrapper promise.\n398 Project: A Programming Language\nArrays\nThe easiest way to do this is to represent Egg arrays with JavaScript arrays.\nThe values added to the top scope must be functions. By using a rest\nargument (with triple-dot notation), the definition of array can be very simple.\nClosure\nAgain, we are riding along on a JavaScript mechanism to get the equivalent\nfeature in Egg. Special forms are passed the local scope in which they are\nevaluated so that they can evaluate their subforms in that scope. The function\nreturned by fun has access to the scope argument given to its enclosing function\nand uses that to create the function\u2019s local scope when it is called.\nThis means that the prototype of the local scope will be the scope in which\nthe function was created, which makes it possible to access bindings in that\nscope from the function. This is all there is to implementing closure (though\nto compile it in a way that is actually e\ufb00icient, you\u2019d need to do some more\nwork).\nComments\nMake sure your solution handles multiple comments in a row, with potentially\nwhitespace between or after them.\nA regular expression is probably the easiest way to solve this. Write some-\nthing that matches \u201cwhitespace or a comment, zero or more times\u201d. Use the\nexec or match method and look at the length of the first element in the returned\narray (the whole match) to find out how many characters to slice off.\nFixing scope\nYouwillhavetoloopthroughonescopeatatime, usingObject.getPrototypeOf\nto go to the next outer scope. For each scope, use hasOwnProperty to find out\nwhether the binding, indicated by the name property of the first argument to\nset, exists in that scope. If it does, set it to the result of evaluating the second\nargument to set and then return that value.\nIf the outermost scope is reached (Object.getPrototypeOf returns null) and\nwe haven\u2019t found the binding yet, it doesn\u2019t exist, and an error should be\nthrown.\n399 The Document Object Model\nBuild a table\nYou can use document.createElement to create new element nodes, document.\ncreateTextNode to create text nodes, and the appendChild method to put nodes\ninto other nodes.\nYou\u2019ll want to loop over the key names once to fill in the top row and then\nagain for each object in the array to construct the data rows. To get an array\nof key names from the first object, Object.keys will be useful.\nToaddthetabletothecorrectparentnode, youcanusedocument.getElementById\nor document.querySelector to find the node with the proper id attribute.\nElements by tag name\nThe solution is most easily expressed with a recursive function, similar to the\ntalksAbout function defined earlier in this chapter.\nYou could call byTagname itself recursively, concatenating the resulting arrays\nto produce the output. Or you could create an inner function that calls itself\nrecursivelyandthathasaccesstoanarraybindingdefinedintheouterfunction,\nto which it can add the matching elements it finds. Don\u2019t forget to call the\ninner function once from the outer function to start the process.\nThe recursive function must check the node type. Here we are interested\nonly in node type 1 (Node.ELEMENT_NODE). For such nodes, we must loop over\ntheir children and, for each child, see whether the child matches the query while\nalso doing a recursive call on it to inspect its own children.\nThe cat's hat\nMath.cos and Math.sin measure angles in radians, where a full circle is 2\u03c0. For\na given angle, you can get the opposite angle by adding half of this, which is\nMath.PI. This can be useful for putting the hat on the opposite side of the\norbit.\nHandling Events\nBalloon\nYou\u2019ll want to register a handler for the \"keydown\" event and look at event.key\nto figure out whether the up or down arrow key was pressed.\n400 The current size can be kept in a binding so that you can base the new\nsize on it. It\u2019ll be helpful to define a function that updates the size\u2014both the\nbinding and the style of the balloon in the DOM\u2014so that you can call it from\nyour event handler, and possibly also once when starting, to set the initial size.\nYou can change the balloon to an explosion by replacing the text node with\nanother one (using replaceChild) or by setting the textContent property of its\nparent node to a new string.\nMouse trail\nCreating the elements is best done with a loop. Append them to the document\nto make them show up. To be able to access them later to change their position,\nyou\u2019ll want to store the elements in an array.\nCycling through them can be done by keeping a counter variable and adding\n1 to it every time the \"mousemove\" event fires. The remainder operator (%\nelements.length) can then be used to get a valid array index to pick the\nelement you want to position during a given event.\nAnother interesting effect can be achieved by modeling a simple physics\nsystem. Use the \"mousemove\" event only to update a pair of bindings that\ntrack the mouse position. Then use requestAnimationFrame to simulate the\ntrailing elements being attracted to the position of the mouse pointer. At\nevery animation step, update their position based on their position relative to\nthe pointer (and, optionally, a speed that is stored for each element). Figuring\nout a good way to do this is up to you.\nTabs\nOnepitfallyoumightrunintoisthatyoucan\u2019tdirectlyusethenode\u2019schildNodes\nproperty as a collection of tab nodes. For one thing, when you add the buttons,\nthey will also become child nodes and end up in this object because it is a live\ndata structure. For another, the text nodes created for the whitespace between\nthe nodes are also in childNodes but should not get their own tabs. You can\nuse children instead of childNodes to ignore text nodes.\nYou could start by building up an array of tabs so that you have easy access\nto them. To implement the styling of the buttons, you could store objects that\ncontain both the tab panel and its button.\nI recommend writing a separate function for changing tabs. You can either\nstore the previously selected tab and change only the styles needed to hide that\nand show the new one, or you can just update the style of all tabs every time\na new tab is selected.\n401 You might want to call this function immediately to make the interface start\nwith the first tab visible.\nProject: A Platform Game\nPausing the game\nAn animation can be interrupted by returning false from the function given\nto runAnimation. It can be continued by calling runAnimation again.\nSo we need to communicate the fact that we are pausing the game to the\nfunction given to runAnimation. For that, you can use a binding that both the\nevent handler and that function have access to.\nWhen finding a way to unregister the handlers registered by trackKeys, re-\nmemberthattheexact samefunctionvaluethatwaspassedtoaddEventListener\nmust be passed to removeEventListener to successfully remove a handler.\nThus, the handler function value created in trackKeys must be available to the\ncode that unregisters the handlers.\nYou can add a property to the object returned by trackKeys, containing\neither that function value or a method that handles the unregistering directly.\nA monster\nIf you want to implement a type of motion that is stateful, such as bounc-\ning, make sure you store the necessary state in the actor object\u2014include it as\nconstructor argument and add it as a property.\nRemember that update returns a new object, rather than changing the old\none.\nWhen handling collision, find the player in state.actors and compare its\nposition to the monster\u2019s position. To get the bottom of the player, you have\nto add its vertical size to its vertical position. The creation of an updated\nstate will resemble either Coin\u2019s collide method (removing the actor) or Lava\n\u2019s (changing the status to \"lost\"), depending on the player position.\nDrawing on Canvas\nShapes\nThe trapezoid (1) is easiest to draw using a path. Pick suitable center coordi-\nnates and add each of the four corners around the center.\n402 The diamond (2) can be drawn the straightforward way, with a path, or the\ninteresting way, with a rotate transformation. To use rotation, you will have to\napply a trick similar to what we did in the flipHorizontally function. Because\nyou want to rotate around the center of your rectangle and not around the point\n(0,0), you must first translate to there, then rotate, and then translate back.\nMake sure you reset the transformation after drawing any shape that creates\none.\nFor the zigzag (3) it becomes impractical to write a new call to lineTo for\neach line segment. Instead, you should use a loop. You can have each iteration\ndraw either two line segments (right and then left again) or one, in which case\nyou must use the evenness (% 2) of the loop index to determine whether to go\nleft or right.\nYou\u2019ll also need a loop for the spiral (4). If you draw a series of points, with\neach point moving further along a circle around the spiral\u2019s center, you get a\ncircle. If, during the loop, you vary the radius of the circle on which you are\nputting the current point and go around more than once, the result is a spiral.\nThe star (5) depicted is built out of quadraticCurveTo lines. You could\nalso draw one with straight lines. Divide a circle into eight pieces for a\nstar with eight points, or however many pieces you want. Draw lines be-\ntween these points, making them curve toward the center of the star. With\nquadraticCurveTo, you can use the center as the control point.\nThe pie chart\nYouwillneedtocallfillTextandsetthecontext\u2019stextAlignandtextBaseline\nproperties in such a way that the text ends up where you want it.\nA sensible way to position the labels would be to put the text on the line\ngoing from the center of the pie through the middle of the slice. You don\u2019t\nwant to put the text directly against the side of the pie but rather move the\ntext out to the side of the pie by a given number of pixels.\nThe angle of this line is currentAngle + 0.5 * sliceAngle. The following\ncode finds a position on this line 120 pixels from the center:\nlet middleAngle = currentAngle + 0.5 * sliceAngle;\nlet textX = Math.cos(middleAngle) * 120 + centerX;\nlet textY = Math.sin(middleAngle) * 120 + centerY;\nFor textBaseline, the value \"middle\" is probably appropriate when using\nthis approach. What to use for textAlign depends on which side of the circle\nwe are on. On the left, it should be \"right\", and on the right, it should be\n403 \"left\", so that the text is positioned away from the pie.\nIf you are not sure how to find out which side of the circle a given angle is on,\nlook to the explanation of Math.cos in Chapter 14. The cosine of an angle tells\nus which x-coordinate it corresponds to, which in turn tells us exactly which\nside of the circle we are on.\nA bouncing ball\nA box is easy to draw with strokeRect. Define a binding that holds its size or\ndefine two bindings if your box\u2019s width and height differ. To create a round\nball, start a path and call arc(x, y, radius, 0, 7), which creates an arc going\nfrom zero to more than a whole circle. Then fill the path.\nTo model the ball\u2019s position and speed, you can use the Vec class from\nChapter16. Giveitastartingspeed, preferablyonethatisnotpurelyverticalor\nhorizontal, and for every frame multiply that speed by the amount of time that\nelapsed. When the ball gets too close to a vertical wall, invert the x component\nin its speed. Likewise, invert the y component when it hits a horizontal wall.\nAfter finding the ball\u2019s new position and speed, use clearRect to delete the\nscene and redraw it using the new position.\nPrecomputed mirroring\nThe key to the solution is the fact that we can use a canvas element as a source\nimage when using drawImage. It is possible to create an extra <canvas> element,\nwithout adding it to the document, and draw our inverted sprites to it, once.\nWhen drawing an actual frame, we just copy the already inverted sprites to\nthe main canvas.\nSome care would be required because images do not load instantly. We\ndo the inverted drawing only once, and if we do it before the image loads, it\nwon\u2019t draw anything. A \"load\" handler on the image can be used to draw the\ninverted images to the extra canvas. This canvas can be used as a drawing\nsource immediately (it\u2019ll simply be blank until we draw the character onto it).\nHTTP and Forms\nContent negotiation\nBase your code on the fetch examples earlier in the chapter.\nAsking for a bogus media type will return a response with code 406, \u201cNot\nacceptable\u201d, which is the code a server should return when it can\u2019t fulfill the\n404 Accept header.\nA JavaScript workbench\nUse document.querySelector or document.getElementById to get access to the\nelements defined in your HTML. An event handler for \"click\" or \"mousedown\n\" events on the button can get the value property of the text field and call\nFunction on it.\nMake sure you wrap both the call to Function and the call to its result in a\ntry block so you can catch the exceptions it produces. In this case, we really\ndon\u2019t know what type of exception we are looking for, so catch everything.\nThe textContent property of the output element can be used to fill it with\na string message. Or, if you want to keep the old content around, create a\nnew text node using document.createTextNode and append it to the element.\nRemember to add a newline character to the end so that not all output appears\non a single line.\nConway's Game of Life\nTo solve the problem of having the changes conceptually happen at the same\ntime, try to see the computation of a generation as a pure function, which takes\none grid and produces a new grid that represents the next turn.\nRepresentingthematrixcanbedoneinthewayshowninChapter6. Youcan\ncount live neighbors with two nested loops, looping over adjacent coordinates\nin both dimensions. Take care not to count cells outside of the field and to\nignore the cell in the center, whose neighbors we are counting.\nEnsuring that changes to checkboxes take effect on the next generation can\nbe done in two ways. An event handler could notice these changes and update\nthe current grid to reflect them, or you could generate a fresh grid from the\nvalues in the checkboxes before computing the next turn.\nIf you choose to go with event handlers, you might want to attach attributes\nthat identify the position that each checkbox corresponds to so that it is easy\nto find out which cell to change.\nTo draw the grid of checkboxes, you can either use a <table> element (see\nChapter 14) or simply put them all in the same element and put <br> (line\nbreak) elements between the rows.\n405 Project: A Pixel Art Editor\nKeyboard bindings\nThe key property of events for letter keys will be the lowercase letter itself, if\nshift isn\u2019t being held. We\u2019re not interested in key events with shift here.\nA \"keydown\" handler can inspect its event object to see whether it matches\nany of the shortcuts. You can automatically get the list of first letters from the\ntools object so that you don\u2019t have to write them out.\nWhen the key event matches a shortcut, call preventDefault on it and dis-\npatch the appropriate action.\nEfficient drawing\nThis exercise is a good example of how immutable data structures can make\ncode faster. Because we have both the old and the new picture, we can compare\nthem and redraw only the pixels that changed color, saving more than 99\npercent of the drawing work in most cases.\nYou can either write a new function updatePicture or have drawPicture take\nan extra argument, which may be undefined or the previous picture. For each\npixel, the function checks whether a previous picture was passed with the same\ncolor at this position and skips the pixel when that is the case.\nBecause the canvas gets cleared when we change its size, you should also\navoid touching its width and height properties when the old picture and the\nnew picture have the same size. If they are different, which will happen when a\nnew picture has been loaded, you can set the binding holding the old picture to\nnull after changing the canvas size because you shouldn\u2019t skip any pixels after\nyou\u2019ve changed the canvas size.\nCircles\nYou can take some inspiration from the rectangle tool. Like that tool, you\u2019ll\nwant to keep drawing on the starting picture, rather than the current picture,\nwhen the pointer moves.\nTo figure out which pixels to color, you can use the Pythagorean theorem.\nFirst figure out the distance between the current pointer position and the start\nposition by taking the square root (Math.sqrt) of the sum of the square (Math\n.pow(x, 2)) of the difference in x-coordinates and the square of the difference\nin y-coordinates. Then loop over a square of pixels around the start position,\nwhose sides are at least twice the radius, and color those that are within the\n406 circle\u2019s radius, again using the Pythagorean formula to figure out their distance\nfrom the center.\nMake sure you don\u2019t try to color pixels that are outside of the picture\u2019s\nboundaries.\nProper lines\nThe thing about the problem of drawing a pixelated line is that it is really four\nsimilar but slightly different problems. Drawing a horizontal line from the left\nto the right is easy\u2014you loop over the x-coordinates and color a pixel at every\nstep. If the line has a slight slope (less than 45 degrees or \u00bc\u03c0 radians), you\ncan interpolate the y-coordinate along the slope. You still need one pixel per\nx position, with the y position of those pixels determined by the slope.\nBut as soon as your slope goes across 45 degrees, you need to switch the\nway you treat the coordinates. You now need one pixel per y position since the\nline goes up more than it goes left. And then, when you cross 135 degrees, you\nhave to go back to looping over the x-coordinates, but from right to left.\nYou don\u2019t actually have to write four loops. Since drawing a line from A to\nB is the same as drawing a line from B to A, you can swap the start and end\npositions for lines going from right to left and treat them as going left to right.\nSo you need two different loops. The first thing your line drawing function\nshould do is check whether the difference between the x-coordinates is larger\nthan the difference between the y-coordinates. If it is, this is a horizontal-ish\nline, and if not, a vertical-ish one.\nMake sure you compare the absolute values of the x and y difference, which\nyou can get with Math.abs.\nOnce you know along which axis you will be looping, you can check whether\nthe start point has a higher coordinate along that axis than the endpoint and\nswap them if necessary. A succinct way to swap the values of two bindings in\nJavaScript uses destructuring assignment like this:\n[start, end] = [end, start];\nThen you can compute the slope of the line, which determines the amount\nthe coordinate on the other axis changes for each step you take along your main\naxis. With that, you can run a loop along the main axis while also tracking\nthe corresponding position on the other axis, and you can draw pixels on every\niteration. Make sure you round the non-main axis coordinates since they are\nlikely to be fractional and the draw method doesn\u2019t respond well to fractional\ncoordinates.\n407 Node.js\nSearch tool\nYour first command line argument, the regular expression, can be found in\nprocess.argv[2]. The input files come after that. You can use the RegExp\nconstructor to go from a string to a regular expression object.\nDoing this synchronously, with readFileSync, is more straightforward, but\nif you use fs.promises again to get promise-returning functions and write an\nasync function, the code looks similar.\nTo figure out whether something is a directory, you can again use stat (or\nstatSync) and the stats object\u2019s isDirectory method.\nExploring a directory is a branching process. You can do it either by using\na recursive function or by keeping an array of work (files that still need to be\nexplored). To find the files in a directory, you can call readdir or readdirSync.\nThe strange capitalization\u2014Node\u2019s file system function naming is loosely based\non standard Unix functions, such as readdir, that are all lowercase, but then\nit adds Sync with a capital letter.\nTo go from a filename read with readdir to a full path name, you have to\ncombine it with the name of the directory, putting a slash character (\/) between\nthem.\nDirectory creation\nYou can use the function that implements the DELETE method as a blueprint\nfor the MKCOL method. When no file is found, try to create a directory with\nmkdir. When a directory exists at that path, you can return a 204 response\nso that directory creation requests are idempotent. If a nondirectory file exists\nhere, return an error code. Code 400 (\u201cbad request\u201d) would be appropriate.\nA public space on the web\nYou can create a <textarea> element to hold the content of the file that is being\nedited. A GET request, using fetch, can retrieve the current content of the file.\nYou can use relative URLs like index.html, instead of http:\/\/localhost:8000\/\nindex.html, to refer to files on the same server as the running script.\nThen, when the user clicks a button (you can use a <form> element and\n\"submit\" event), make a PUT request to the same URL, with the content of the\n<textarea> as request body, to save the file.\nYou can then add a <select> element that contains all the files in the server\u2019s\ntop directory by adding <option> elements containing the lines returned by a\n408 GET request to the URL \/. When the user selects another file (a \"change\" event\non the field), the script must fetch and display that file. When saving a file,\nuse the currently selected filename.\nProject: Skill-Sharing Website\nDisk persistence\nThe simplest solution I can come up with is to encode the whole talks object as\nJSONanddumpittoafilewithwriteFile. Thereisalreadyamethod(updated\n) that is called every time the server\u2019s data changes. It can be extended to write\nthe new data to disk.\nPick a filename, for example .\/talks.json. When the server starts, it can\ntry to read that file with readFile, and if that succeeds, the server can use the\nfile\u2019s contents as its starting data.\nBeware, though. The talks object started as a prototype-less object so that\nthe in operator could reliably be used. JSON.parse will return regular objects\nwith Object.prototype as their prototype. If you use JSON as your file format,\nyou\u2019ll have to copy the properties of the object returned by JSON.parse into a\nnew, prototype-less object.\nComment field resets\nThe best way to do this is probably to make talks component objects, with a\nsyncState method, so that they can be updated to show a modified version of\nthe talk. During normal operation, the only way a talk can be changed is by\nadding more comments, so the syncState method can be relatively simple.\nThe di\ufb00icult part is that, when a changed list of talks comes in, we have\nto reconcile the existing list of DOM components with the talks on the new\nlist\u2014deleting components whose talk was deleted and updating components\nwhose talk changed.\nTo do this, it might be helpful to keep a data structure that stores the talk\ncomponents under the talk titles so that you can easily figure out whether a\ncomponent exists for a given talk. You can then loop over the new array of\ntalks, and for each of them, either synchronize an existing component or create\na new one. To delete components for deleted talks, you\u2019ll have to also loop over\nthe components and check whether the corresponding talks still exist.\n409 Index\n! operator, 17, 31 | | operator, 17, 20, 50, 95, 327, 388\n!= operator, 16 {} (block), 28\n!== operator, 19 {} (object), 61, 65\n* operator, 12, 19, 146 200 (HTTP status code), 309, 358,\n*= operator, 34 362\n+ operator, 12, 15, 19, 146 204 (HTTP status code), 365\n++ operator, 34 2d (canvas context), 285\n+= operator, 34, 199 304 (HTTP status code), 372, 379,\n\u2212 operator, 12, 15, 19 385\n\u2212\u2212 operator, 34 400 (HTTP status code), 408\n\u2212= operator, 34 403 (HTTP status code), 363\n\/ operator, 12 404 (HTTP status code), 309, 363,\n\/= operator, 34 376, 378\n< operator, 16 405 (HTTP status code), 313, 362\n<= operator, 16 406 (HTTP status code), 404\n= operator, 23, 61, 347 500 (HTTP status code), 362\nas expression, 160, 162\na (HTML tag), 219, 233, 235, 318,\nfor default value, 46\n342\nin Egg, 209\nAbelson, Hal, 202\n== operator, 16, 19, 64, 80, 193\nabsolute positioning, 238, 242, 250,\n=== operator, 19, 81, 115, 391\n253, 259\n> operator, 16\nabsolute value, 76, 407\n>= operator, 16\nabstract data type, 97\n?: operator, 17, 20, 208\nabstract syntax tree, see syntax tree\n[] (array), 58\nabstraction, 5, 39, 83, 85, 202, 227,\n[] (subscript), 58, 59\n314, 347, 348\n% operator, 13, 33, 294, 388, 389,\nin Egg, 202\n401, 403\nwith higher-order functions, 82\n&& operator, 17, 20, 95\nabtraction\n410 of the network, 217 Apple, 223\nacceleration, 279 application, 1, 330, 370\nAccept header, 328, 404 arc, 290, 291\naccess control, 97, 142, 373 arc method, 290, 291, 404\nAccess-Control-Allow-Originheader, argument, 26, 46, 50, 74, 154, 202\n314 arguments object, 390\naction, 331, 333, 334 argv property, 351\nactiveElement property, 317 arithmetic, 12, 19, 210\nactor, 265, 271, 277 array, 59\u201362, 80\nadd method, 115 as matrix, 108, 264\naddEntry function, 64 as table, 66\naddEventListener method, 243, 244, counting, 93\n279, 360 creation, 58, 91, 333, 390, 394\naddition, 12, 115 filtering, 87\naddress, 77, 308 flattening, 95\naddress bar, 218, 308, 310 in Egg, 214\nadoption, 143 indexing, 58, 68, 71, 390, 401\nages example, 104 iteration, 68, 83, 86\nalert function, 221 length of, 59\nalpha, 344 methods, 70, 79, 86\u201388, 91, 94,\nalphanumeric character, 145 95\nalt attribute, 230 notation, 77\nalt key, 248 of rest arguments, 74\naltKey property, 248 random element, 123\nambiguity, 215 RegExp match, 147\nAmerican English, 146 representation, 77\nampersand character, 220, 311 searching, 67, 71\nanalysis, 128, 133 Array constructor, 333\nancestor element, 272 Array prototype, 100, 104\nAndroid, 249 array-like object, 227, 229, 252, 318,\nangle, 240, 290, 291, 403 324, 356\nangle brackets, 219, 220 Array.from function, 195, 353\nanimation, 239, 253, 259, 262, 267, arrays in egg (exercise), 214, 399\n304, 404 arrow function, 44, 99, 199\nbouncing ball, 306 arrow key, 259\nplatform game, 274, 275, 279\u2013 artificial intelligence, 117, 213\n281, 294, 302, 402 artificial life, 262, 329\nspinning cat, 238, 242 assert function, 140\nanyStorage function, 199, 201 assertion, 140\nappendChild method, 229, 400\n411 assignment, 23, 34, 160, 162, 215, bean counting (exercise), 56, 390\n399 beforeunload event, 255\nassumption, 139, 141 behavior, 165, 213\nasterisk, 12, 146 benchmark, 234\nasync function, 195, 196, 199, 201, Berners-Lee, Tim, 216\n385 best practices, 3\nasynchronousprogramming, 180, 181, bezierCurveTo method, 289\n183\u2013185, 195, 197, 199, 282 big ball of mud, 167\nin Node.js, 350, 356, 359, 364, binary data, 3, 10, 356\n367 binary number, 10, 11, 66, 132, 152,\nreading files, 324 323\nat sign, 263 binary operator, 12, 15, 22\nattribute, 219, 227, 232, 318, 334, binding, 4, 30, 62\n405 as\nautofocus attribute, 317 state, 30, 32\nautomatic semicolon insertion, 23 as state, 64, 160, 325\nautomation, 126, 131 assignment, 23, 42\nautomaton, 117 compilation of, 399\navatar, 262 definition, 23, 39, 42, 212, 215\naverage function, 90 destructuring, 77\nawait keyword, 195\u2013197, 200 exported, 174\naxis, 278, 286, 295, 296, 407 from parameter, 40, 48\nglobal, 40, 129, 283, 351, 352\nBabbage, Charles, 57\nin Egg, 209, 210\nbackground, 262, 270, 275\nlocal, 40\nbackground (CSS), 259, 262, 271\nmodel of, 24, 62, 64\nbackslash character\nnaming, 25, 35, 52, 75, 130\nas path separator, 363\nscope of, 40\nin regular expressions, 143, 145,\nundefined, 138\n157, 395\nvisibility, 41\nin strings, 14, 220\nbit, 3, 10, 11, 16, 66\nbacktick, 13, 15\nbitfield, 251\nbacktracking, 152, 156\nbitmap graphics, 293, 307\nball, 306, 404\nblack, 333\nballoon, 259\nblock, 28, 32, 39, 41, 44, 61, 136,\nballoon (exercise), 259, 400\n137, 203\nbanking example, 136\nblock comment, 36, 156\nBanks, Ian, 261\nblock element, 233, 235\nbaseControls constant, 346\nblocking, 181, 239, 257, 357\nbaseTools constant, 346\nblue, 333\n412 blur event, 254, 255 window, 243\nblur method, 317 browser wars, 223\nbody (HTML tag), 219, 220, 225 browsers, 8, 175\nbody (HTTP), 310\u2013313, 358, 365, bubbling, see event propagation\n366, 377 Buffer class, 356, 359, 360\nbody property, 225, 226, 228, 313 bug, 82, 128, 132, 156, 159, 165, 168,\nbold, 235 223\nBook of Programming, 10, 167, 350 building Promise.all (exercise), 201,\nBoolean, 16, 28, 30, 63, 144, 208, 210 398\nconversion to, 19, 20, 27, 31 bundler, 175\nBoolean function, 27 button, 243, 310, 318, 329\nborder (CSS), 233, 235 button (HTML tag), 221, 244, 248,\nborder-radius (CSS), 250 260, 319, 326, 329, 334\nbouncing, 263, 266, 275, 278, 306 button property, 245, 251, 335\nbound, 87 buttons property, 251, 335\nboundary, 150\u2013152, 157, 161, 165,\ncache, 172, 183\n300, 395\ncall method, 98, 104\nbox, 142, 224, 261, 262, 306, 404\ncall stack, 45, 47, 51, 60, 135, 136,\nbox shadow (CSS), 272\n138, 198\nbr (HTML tag), 337, 405\ncallbackfunction, 181, 183, 185, 186,\nbraces\n188, 190, 243, 280, 281, 334,\nblock, 5, 28, 389\n355, 356, 359, 379, 385\nbody, 84\ncamel case, 35, 236\nclass, 102\ncancelAnimationFramefunction, 257\nfunction body, 39, 44\ncanvas, 262, 284, 286\u2013289, 292\u2013299,\nin regular expression, 146\n303\u2013306, 404\nobject, 61, 65, 77\ncontext, 285, 286\nbranching, 150, 152\npath, 287\nbranching recursion, 49, 297\nsize, 285, 287\nbreak keyword, 33, 35\ncanvas (HTML tag), 285, 330, 334,\nbreakpoint, 133\n342, 344, 348, 406\nBritish English, 146\nCanvasDisplay class, 299, 300, 302\nbroadcastConnections function, 192\ncapitalization, 35, 102, 147, 236, 242,\nbrowser, 1, 6, 181, 216, 218, 220,\n360\n222, 223, 244, 262, 307, 308,\ncapture group, 148, 149, 154, 375\n310, 314, 319, 325, 343, 347,\ncareer, 261\n369\ncaret character, 145, 150, 161, 355\nenvironment, 25, 26, 308\ncarriage return, 161\nsecurity, 313, 370\ncascading, 236\nstorage, 325, 327\n413 Cascading Style Sheets, see CSS class attribute, 229, 232, 237, 269,\ncase conversion, 60 271, 272\ncase keyword, 35 class declaration, 102\ncase sensitivity, 147, 396 properties, 103\ncasual computing, 1 class hierarchy, 113\ncat\u2019s hat (exercise), 242 className property, 232\ncatch keyword, 135, 136, 139, 142, cleaning up, 136\n198, 395 clearing, 284, 294, 300, 404\ncatch method, 187 clearInterval function, 257\nCD, 10 clearRect method, 294, 404\ncelery, 369 clearTimeout function, 256, 257\ncell, 329 click event, 243, 244, 246, 249, 251,\nCelsius, 112 334, 405\ncenter, 273 client, 217, 314, 358, 369, 380, 381\ncentering, 239 clientHeight property, 233\ncertificate, 315 clientWidth property, 233\nchange event, 317, 321, 338, 405, 408 clientX property, 249, 252, 336, 337\ncharacter, 13, 14, 92, 93, 320 clientY property, 249, 252, 336, 337\ncharacter category, 163 clipboard, 222\ncharacter encoding, 356 clipping, 300\ncharacterCount function, 89 closePath method, 288\ncharacterScript function, 94, 96, 392 closing tag, 219, 221\ncharCodeAt method, 92 closure, 48, 214, 399, 400, 402\ncheckbox, 315, 321, 329, 405 closure in egg (exercise), 214, 399\nchecked attribute, 316, 321 code, 7, 155, 261\nchess board (exercise), 389 structure of, 22, 31, 39, 167, 176\nchessboard (exercise), 38 code golf, 165\nchicks function, 199, 200 code unit, 92\nchild node, 226, 227, 229 codePointAt method, 92\nchildNodes property, 227, 231, 401 coin, 261, 263, 278, 303\nchildren property, 228 Coin class, 267, 278\nChinese characters, 92, 94 collaboration, 216\nchoice, 150 collection, 5, 58, 60, 62, 80\nChrome, 223 collisiondetection, 274, 275, 278, 279,\ncircle, 240, 290, 291 402, 404\ncircle (SVG tag), 285 colon character, 17, 34, 61, 235\ncircles (exercise), 349, 406 color, 285, 286, 300, 330, 344\ncircular dependency, 179, 397 color (CSS), 235\ncircus, 70 color code, 333\nclass, 101, 102, 115, 119, 263, 331 color component, 333\n414 color field, 331, 333, 338 configuration, 160\ncolor picker, 331, 339, 341 connected graph, 126\ncolor property, 332 connection, 217, 308, 315, 370, 371\nColorSelect class, 339 connections binding, 192\ncomma character, 202 consistency, 36, 216, 226\ncommand key, 248, 348 console.log, 5, 9, 15, 26, 45, 47, 54,\ncommand line, 169, 350\u2013352, 367 133, 351, 360\ncomment, 36, 77, 155, 160, 215, 226, const keyword, 25, 41, 64, 75, 77\n369, 372, 378, 383 constant, 25, 75, 279\ncomment field reset (exercise), 387, constructor, 35, 101, 102, 113, 127,\n409 129, 136, 148, 157, 393, 394\nCOMMENT_NODE code, 226 content negotiation (exercise), 328,\ncomments in egg (exercise), 215, 399 404\nCommonJS, 352, 353 Content-Length header, 310\nCommonJS module, 179, 397 Content-Type header, 310, 358, 362,\nCommonJS modules, 171\u2013173, 179 363, 367\ncommunication, 216, 314 context, 285, 286\ncommunity, 350 context menu, 247\ncompareRobots function, 126 continuation, 183\ncomparison, 16, 19, 210, 390 continue keyword, 33\ndeep, 80, 391 control, 337, 339, 342, 343, 346\nof NaN, 16 control flow, 27, 85\nof numbers, 16, 27 asynchronous, 181, 196\nof objects, 64 conditional, 28\nof strings, 16 exceptions, 135, 136\nof undefined values, 19 functions, 45\ncompatibility, 6, 216, 223, 348, 355 loop, 30\u201332\ncompilation, 175, 212, 213, 399 control key, 248, 348\ncomplexity, 2, 3, 82, 113, 153, 237, control point, 289, 290\n268, 347 convention, 35\ncomponent, 330, 331, 337, 346 convergent evolution, 182\ncomposability, 5, 90, 176 Conway\u2019s Game of Life, 329\ncomputed property, 59, 327 coordinates, 115, 240, 249, 270, 273,\ncomputer, 1, 2 275, 276, 286, 290, 295, 296\nconcat method, 71, 95, 394, 400 copy-paste programming, 52, 168\nconcatenation, 15, 71, 400 copyright, 169\nconditional execution, 17, 28, 34, 38, correlation, 65, 66, 68\u201370\n208 corvid, 182\nconditional operator, 17, 20, 208 cosine, 75, 240\nconditional request, 372 countBy function, 93, 96\n415 counter variable, 30, 32, 240, 389, map, 104\n390, 398, 401 stack, 60\nCPU, 181 tree, 203, 225, 304\ncrash, 138, 141, 377, 387 data URL, 342, 343\ncreateElementmethod, 231, 334, 400 date, 145, 146, 148\ncreateReadStreamfunction, 360, 364 Date class, 148, 149, 169, 171\ncreateServer function, 357\u2013359, 374, date-names package, 171\n375 Date.now function, 149, 345\ncreateTextNode method, 230, 405 dblclick event, 249\ncreateWriteStreamfunction, 359, 365 De Morgan\u2019s laws, 392\ncrisp, 304 debouncing, 257\ncross-domain request, 314 debugger statement, 133\ncrow, 182, 183, 188, 194 debugging, 6, 128, 130, 132, 133, 136,\ncrow-tech module, 184 139, 140, 165\ncrying, 147 decentralization, 216\ncryptography, 315 decimal number, 10, 132, 152\nCSS,235\u2013237, 269\u2013272, 274, 284, 286, declaration, 235\n333, 381 decodeURIComponentfunction, 311,\nctrlKey property, 248, 348 362, 375\ncurl program, 366 deep comparison, 64, 80\ncurly braces, see braces deep comparison (exercise), 80, 391\ncursor, 320, 321 default behavior, 235, 247\ncurve, 289, 290 default export, 174\ncutting point, 269 default keyword, 35\ncwd function, 363 default value, 20, 46, 287, 327, 347\ncycle, 225 defineProperty function, 393\ndefineRequestTypefunction, 184, 189\nDark Blue (game), 261\ndegree, 290, 296\ndata, 2, 10, 57\nDELETEmethod, 309, 310, 313, 361,\ndata attribute, 232, 260\n364, 377\ndata event, 360\ndelete method, 115\ndata flow, 331, 348\ndelete operator, 62\ndata format, 77, 226\ndependence, 65\ndata loss, 387\ndependency, 167, 168, 170, 173, 179,\ndata set, 67, 86\n221, 354, 355\ndata structure, 57, 176, 177, 224,\ndeserialization, 78\n329\ndesign, 168\ncollection, 58\ndestructuring, 149\nimmutable, 121\ndestructuring assignment, 407\nlist, 80\ndestructuring binding, 76, 172, 347,\n416 397 graphics, 262, 269, 271, 272, 284,\ndeveloper tools, 7, 26, 133, 138 285, 304\ndialect, 175 interface, 226\ndialog box, 26 modification, 229\ndiamond, 306, 403 querying, 228, 237\ndigit, 10, 11, 132, 144\u2013147, 333 tree, 225\nDijkstra\u2019s algorithm, 177 dom property, 331\nDijkstra, Edsger, 117, 177 domain, 218, 310, 314, 326\ndijkstrajs package, 177, 396 domain-specificlanguage, 82, 132, 143,\ndimensions, 115, 233, 261, 262, 275, 214, 237\n285, 389 DOMDisplay class, 269, 270, 299\ndinosaur, 213 dominantdirection(exercise), 96, 392\ndirect child node, 237 done property, 345\ndirection (writing), 96 doneAt property, 345\ndirectory, 352, 355, 356, 361, 363, dot character, see period character\n364, 367, 408 double click, 249\ndirectorycreation(exercise), 367, 408 double-quotecharacter, 13, 165, 202,\ndisabled attribute, 318 220\ndiscretization, 262, 275, 281 download, 7, 168, 342, 353, 366, 369,\ndispatch, 34, 331\u2013333, 337, 346, 374, 387\n406 download attribute, 342\ndisplay, 269, 281, 282, 299, 303, 305 draggable bar example, 250\ndisplay (CSS), 235, 260 dragging, 250, 330, 340, 349\ndistance, 407 draw function, 339, 349\ndivision, 12, 13 drawImage method, 293, 295, 299,\ndivision by zero, 13 301, 302, 404\ndo loop, 31, 123 drawing, 224, 233, 239, 269, 284\u2013\ndoctype, 219, 220 286, 289, 297, 302, 303, 330,\ndocument, 218, 224, 255, 284 405\ndocument format, 314, 328 drawing program example, 250, 330\nDocument Object Model, see DOM drawPicture function, 335, 342, 348,\ndocumentation, 350 406\ndocumentElement property, 225 drop-down menu, 316, 322\ndollar sign, 25, 150, 154, 161 duplication, 168\nDOM, 225, 232\nECMAScript, 6, 173\nattributes, 232\nECMAScript 6, 6\ncomponents, 330, 331\neconomic factors, 347\nconstruction, 227, 229, 231, 334\necstatic package, 375\nevents, 244, 248\neditor, 32\nfields, 315, 320\n417 e\ufb00iciency, 49, 79, 91, 192, 212, 233, error tolerance, 220\n262, 272, 285, 335, 348 Error type, 136, 138, 140, 364\ne\ufb00icient drawing (exercise), 348, 406 ES modules, 173, 221\nEgglanguage, 202, 203, 206\u2013208, 210, escape key, 283\n211, 213\u2013215, 226 escaping\nelectronic life, 262 in HTML, 220, 221\nelegance, 49, 204 in regexps, 143, 145, 157\nelement, 219, 226, 228, 231 in strings, 14, 202\nELEMENT_NODE code, 226, 400 in URLs, 311, 362, 372, 375\nelements property, 318, 319 Escher, M.C., 284\nellipse, 239, 240 ETag header, 372, 379, 385\nelse keyword, 29 eval, 170\nelt function, 231, 334, 348, 383 evaluate function, 207, 208, 210\nemail, 315 evaluation, 170, 207, 213\nemoji, 14, 92, 163, 259 even number, 30, 55\nempty set, 156 event handling, 243\u2013245, 247, 253\u2013\nencapsulation, 97, 98, 106, 113, 244, 255, 262, 279, 282, 283, 293,\n268, 269 304, 319, 320, 334, 359, 402,\nencodeURIComponentfunction, 311, 405\n372, 382 event loop, 197\nencoding, 216 event object, 245, 249, 252\nencryption, 315 eventpropagation, 245, 246, 254, 255\nend event, 360 event type, 245\nend method, 358, 359, 362 every method, 95\nenemies example, 160 everything (exercise), 95, 392\nengineering, 223 everywhere function, 191\nENOENT (status code), 364 evolution, 143, 347, 355\nenter key, 319 exception handling, 135, 136, 138\u2013\nentity, 220 140, 142, 186, 187, 196, 198,\nenum (reserved word), 25 201, 398, 405\nenvironment, 25, 208 exception safety, 138\nequality, 16 exec method, 147, 148, 158, 159\nerror, 92, 128, 129, 132, 134, 138, execution order, 27, 43, 45\n139, 186, 188, 194 exercises, 2, 7, 37, 132\nerror event, 325, 365 exit method, 351\nerror handling, 128, 134, 135, 138, expectation, 247\n356, 362, 364, 382, 385 experiment, 3, 7, 165\nerror message, 206, 329 exploit, 222\nerror recovery, 134 exponent, 12, 166, 395, 396\nerror response, 309, 362, 365 exponentiation, 31, 33\n418 export keyword, 174 fillText method, 292, 293, 403\nexports object, 171, 173, 353, 397 filter method, 87, 90, 94, 120, 190,\nexpression, 22, 23, 27, 30, 33, 42, 392\u2013394\n202, 203, 207 finally keyword, 137, 142, 395\nexpressivity, 214 findIndex method, 94\nextension, 352 findInStorage function, 194, 195\nextraction, 148 findRoute function, 125, 193\nfinish event, 365\nfactorial function, 8\nFirefox, 223\nFahrenheit, 112\nfirewall, 370\nfallthrough, 35\nfirstChild property, 227\nfalse, 16\nfixed positioning, 253\nfarm example, 52, 54, 150\nfixing scope (exercise), 215, 399\nfetch function, 312, 328, 359, 382,\nFizzBuzz (exercise), 38, 388\n385, 408\nflattening (exercise), 95\nfield, 249, 310, 315, 318, 321, 325,\nflexibility, 6\n329, 330, 387\nflipHorizontally function, 302, 402\nFielding, Roy, 308\nflipHorizontally method, 296\nfile, 168, 323, 352, 364, 409\nflipping, see mirroring\naccess, 172, 175, 343, 355, 356\nfloating-point number, 11, 12\nimage, 330, 342, 343\nflood fill, 337, 340\nresource, 309, 310, 361, 363\nflooding, 192\nstream, 359\nflow diagram, 151, 152\nfile extension, 363\nfocus, 249, 254, 317, 318, 321, 348,\nfile field, 315, 323, 324\n387\nfile format, 160\nfocus event, 254, 255\nfile reading, 324\nfocus method, 317\nfile server, 381\nfold, see reduce method\nfileserverexample, 361, 363\u2013367, 408\nfont, 293\nfile size, 175\nfont-family (CSS), 236\nfile system, 323, 355, 356, 361, 363,\nfont-size (CSS), 259\n409\nfont-weight (CSS), 236\nFile type, 324\nfor attribute, 321\nFileReader class, 324, 325, 343\nfor loop, 32, 33, 68, 83, 95, 139, 390,\nfiles property, 324\n391\nfill function, 341\nfor\/of loop, 68, 93, 106, 108, 110,\nfill method, 288, 333\n393\nfilling, 286, 288, 292, 305\nforEach method, 86\nfillRect method, 286, 294\nform, 310, 311, 318, 319, 367\nfillStyle property, 286, 292, 333\nform (HTML tag), 315, 316, 318,\n419 384, 408 gaudy home pages, 259\nform property, 318 generation, 329, 405\nformatDate module, 171, 174 generator, 196\nfractal example, 297 GET method, 309, 310, 313, 319,\nfractional number, 12, 166, 262 359, 361, 363, 371, 376\nframe, 294, 302, 404 get method, 106\nframework, 54, 331 getAttribute method, 232\nfrequency table, 65 getBoundingClientRectmethod, 233,\nfs package, 355\u2013357 336\nfunction, 5, 26, 39, 44, 129, 202, 203, getContext method, 286\n211 getDate method, 149\napplication, 26, 27, 40, 45, 46, getElementById method, 229, 400\n49, 74, 87, 138, 202, 207 getElementsByClassNamemethod, 229\nas property, 60 getElementsByTagNamemethod, 228,\nas value, 39, 42, 47, 84, 85, 87, 231, 242, 400\n245, 280, 402 getFullYear method, 149\nbody, 39, 44 getHours method, 149\ncallback, see callback function getImageData method, 344\ndeclaration, 43 getItem method, 325, 327\ndefinition, 39, 43, 51 getMinutes method, 149\nhigher-order, 43, 84, 85, 87, 88, getMonth method, 149\n90, 154, 280 getPrototypeOf function, 100, 102,\nmodel of, 48 215, 399\nnaming, 52, 53 getSeconds method, 149\npurity, 54 getter, 111, 115, 266\nscope, 42, 169, 214 getTime method, 149\nFunction constructor, 171, 172, 210, getYear method, 149\n213, 329, 405 GitHub, 309\nfunction keyword, 39, 43 global object, 129\nFunction prototype, 100, 104 global scope, 40, 170, 210, 256, 351,\nfuture, 6, 25, 43, 307 352, 399\ngoalOrientedRobot function, 126\ngame, 261\u2013263, 279, 282, 299\nGoogle, 223\nscreenshot, 274, 303\ngossip property, 191\nwith canvas, 303\ngrammar, 22, 128, 160\ngame of life (exercise), 329, 405\ngraph, 118, 124, 177, 193, 305\nGAME_LEVELS data set, 282\ngraphics, 262, 269, 272, 284, 285,\ngarbage collection, 11\n293, 304, 305\ngarble example, 352\ngrave accent, see backtick\ngardening, 369\ngravity, 279\n420 greater than, 16 structure, 224, 226\ngreed, 155, 156 html (HTML tag), 220, 225\ngreen, 333 HTTP, 216\u2013218, 308\u2013311, 313\u2013315,\ngrep, 367 358, 365, 367, 370, 371\ngrid, 262, 270, 275, 276, 329, 405 client, 358, 366, 369\nGroup class, 115, 127, 197, 393 server, 357, 361, 380\ngroupBy function, 96 http package, 357, 358\ngrouping, 12, 28, 147, 148, 154, 395 HTTPS, 218, 314, 315, 359\ngroups (exercise), 115, 393 https package, 359\nhuman language, 22\nh1 (HTML tag), 219, 233\nHypertextMarkupLanguage, seeHTML\nhack, 173\nHypertextTransferProtocol, seeHTTP\nhandleAction function, 381\nhyphen character, 12, 144, 236\nhard disk, 176, 180, 183\nhard drive, 10, 323, 326, 350, 387 id attribute, 229, 237, 321\nhard-coding, 228, 306 idempotence, 189, 365\nhas method, 106, 115 idempotency, 408\nhash character, 215 identifier, 203\nhash sign, 333 identity, 63\nhasOwnProperty method, 106, 215, if keyword, 28, 162\n399 chaining, 29, 34, 388, 389\nhead (HTML tag), 219, 220, 225 If-None-Match header, 372, 379, 385\nhead property, 225 image, 230, 255, 284, 310\nheader, 309, 310, 313, 314, 358, 371 imagination, 261\nheaders property, 312, 313, 328 IME, 249\nheight property, 349, 406 img (HTML tag), 220, 230, 235, 255,\nhelp text example, 254 284, 293, 294, 343\nhexadecimal number, 152, 311, 333, immutable, 63, 121, 266, 332, 333,\n344 340, 345, 406\nhidden element, 235, 260 implements (reserved word), 25\nhigher-order function, see function, import keyword, 173\nhigher-order in operator, 62, 106\nhistory, 6, 347 includes method, 67, 68, 393\nhistoryUpdateState function, 345 indentation, 32\nHi\u00e8res-sur-Amby, 182 index, 58\nhooligan, 373 index property, 147\nHost header, 310 index.html, 380\nhref attribute, 219, 228, 232 index.js, 352\nHTML, 218, 224, 308, 325, 367 indexOfmethod, 71, 72, 94, 115, 144,\nnotation, 219 157, 393\n421 infinite loop, 33, 45, 139, 390 IP address, 218, 308, 310\ninfinity, 13 isDirectory method, 364, 408\ninfrastructure, 168 isEven (exercise), 55, 389\ninheritance, 100, 112\u2013114, 140, 364 isolation, 97, 167, 170, 222\nINI file, 160 iterable interface, 108, 393\nini package, 169, 173, 176, 353 iterator, 196\ninitialization, 255 iterator interface, 106, 108, 115\ninline element, 233, 235\nJacques, 57\ninner function, 42, 400\nJava, 6\ninner loop, 153\nJavaScript, 6\ninnerHeight property, 254\navailability of, 1\ninnerWidth property, 254\nflexibility of, 6\ninput, 134, 243, 262, 317, 350, 377\nhistory of, 6, 216\ninput (HTML tag), 254, 315, 320\u2013\nin HTML, 221\n323, 338, 343\nsyntax, 22\ninput event, 321\nuses of, 7\ninsertBefore method, 229, 230\nversions of, 6\ninstallation, 168\nweaknesses of, 6\ninstance, 101\nJavaScript console, 7, 15, 26, 133,\ninstanceof operator, 113, 140\n138, 329, 351\ninstruction, 3\nJavaScriptObjectNotation, seeJSON\ninteger, 12\njob, 291\nintegration, 143, 226\njoin method, 94, 104, 353\ninterface\njournal, 58, 61, 63, 64, 68\ncanvas, 284, 285\nJOURNAL data set, 67\ndesign, 54, 143, 149, 154, 158,\njournalEvents function, 68\n226, 227, 269, 287\nJSON, 77, 176, 183, 193, 313, 327,\nHTTP, 314, 371\n371, 372, 386, 409\nmodule, 167, 169\u2013171, 173, 176,\njson method, 313\n312, 353\nJSON.parse function, 78, 409\nobject, 97, 106, 110, 115, 127,\nJSON.stringify function, 78\n188, 265, 299, 320, 331\nJSX, 384\ninterface (reserved word), 25\njump, 4\ninternationalization, 162\njump-and-run game, 261\nInternet, 160, 216\u2013218, 222\njumping, 262, 279\nInternet Explorer, 222, 223\ninterpolation, 15\nKernighan, Brian, 128\ninterpretation, 7, 170, 207, 208, 212\nkey code, 279\ninterview question, 38\nkey property, 248, 400, 406\ninversion, 145\n422 keyboard, 25, 243, 247, 262, 279, 283, level, 262, 263, 269, 270, 272, 281,\n317, 318, 320, 348 282\nkeyboardbindings(exercise), 348, 406 Level class, 263\nkeyboard focus, see focus lexical scoping, 42\nkeydown event, 247, 257, 280, 348, library, 227, 331, 353, 354\n400, 406 license, 169\nkeyup event, 247, 280 line, 23, 31, 161, 284, 286\u2013289, 291,\nkeyword, 23, 25, 232 306, 403\nKhasekhemwy, 320 line break, 13, 161\nkill process, 358 line comment, 36, 156\nKnuth, Donald, 39 line drawing, 349, 407\nline width, 286, 295\nlabel, 293, 306\nlines of code, 211\nlabel (HTML tag), 321, 338\nlineTo method, 287\nlabeling, 321\nlineWidth property, 286\nlandscape example, 42\nlink, 219, 227, 228, 247, 249, 342\nLaozi, 180\nlink (HTML tag), 274\nLast-Modified header, 310\nlinked list, 80, 391\nlastChild property, 227\nlinter, 173\nlastIndex property, 158, 159\nLiskov, Barbara, 97\nlastIndexOf method, 71\nlist (exercise), 80, 391\nlatency, 175\nlisten method, 357, 358\nlava, 261\u2013263, 272, 275, 277, 278,\nlistening (TCP), 217, 357\n303\nliteral expression, 22, 143, 205, 207\nLava class, 266, 277\nlive data structure, 224, 231, 238,\nlayering, 194, 217\n401\nlayout, 233\u2013235\nlive view, 370, 371, 386, 409\nlaziness, 233\nlives (exercise), 282\nLe Guin, Ursula K., 2\nload event, 255, 293, 302, 324, 404\nleaf node, 226\nLoadButton class, 343\nleak, 222, 283\nlocal binding, 47, 215, 390\nlearning, 2, 6, 7, 369\nlocal scope, 40, 212\nleft (CSS), 238\u2013240, 242\nlocalhost, 357\nLEGO, 167\nlocalStorage object, 325, 326, 382\nlength property\nlocked box (exercise), 142, 395\nfor array, 59, 333\nlogging, 133\nfor string, 52, 56, 59, 73, 390\nlogical and, 17\nless than, 16\nlogical operators, 17\nlet keyword, 23, 24, 41, 64, 75, 77,\nlogical or, 17\n129\nlong polling, 370\u2013372, 377, 379, 385\n423 loop, 4, 5, 30, 32, 37, 38, 49, 68, 83, Math.tan function, 75\n84, 90, 91, 159, 189, 389, 390, mathematics, 49, 85\n403 Matrix class, 108, 332\ntermination of, 33 matrix example, 108, 112\nloop body, 31, 84 MatrixIterator class, 109\nlycanthropy, 57, 64 max example, 74\nmax-height (CSS), 272\nmachine code, 3, 213\nmax-width (CSS), 272\nmafia, 222\nmaximum, 27, 75, 89, 90\nmagic, 99, 202\nMeadowfield, 117\nmailRoute array, 124\nmeasuring a robot (exercise), 126,\nmaintenance, 169\n394\nmalicious script, 222\nmedia type, 314, 328, 363\nman-in-the-middle, 314\nmeetup, 369\nmap, 268, 319\nmemory, 3, 10\nmap (data structure), 104\ncall\nMap class, 105, 110, 195\nstack, 45\nmap method, 88, 90, 94, 99, 104,\norganization, 10, 23, 58, 63, 77\n120, 190, 264, 338\npersistence, 387\nMarcus Aurelius, 243\nspeed, 180, 212\nmatch method, 147, 159\nstructure\nmatching, 144, 150, 158, 165\nsharing, 80\nalgorithm, 151\u2013153\nmesh, 218\nMath object, 55, 59, 75\nmessage event, 256\nMath.abs function, 76, 407\nmeta key, 248\nMath.acos function, 75\nmetaKey property, 248, 348\nMath.asin function, 75\nmethod, 60, 98, 101, 129, 358\nMath.atan function, 75\narray, 70\nMath.ceil function, 76, 275, 301\nHTTP, 309, 314, 358, 366, 371,\nMath.cos function, 75, 240, 404\n374\nMath.floorfunction, 76, 123, 275, 301\ninterface, 97\nMath.max function, 27, 59, 74, 75,\nmethod attribute, 310\n300\nmethod call, 98\nMath.min function, 27, 55, 75, 300\nmethod property, 313\nMath.PI constant, 75, 290\nmethods object, 361\nMath.random function, 75, 123, 268,\nMicrosoft, 222, 223\n329\nmime package, 363\nMath.round function, 76\nMIME type, 328, 363\nMath.sin function, 75, 240, 268, 278\nmini application, 325\nMath.sqrt function, 67, 75, 393\nminifier, 175\n424 minimalism, 261 music, 261\nminimum, 27, 55, 75 mutability, 61, 63, 121\nminimum (exercise), 55, 389\nname attribute, 319, 322\nminus, 12, 166\nnamespace, 75\nMiro, Joan, 330\nnaming, 4, 6, 25\nmirror, 296, 307, 404\nNaN, 13, 16, 18, 128\nmirroring, 295, 296\nnegation, 15, 17\nMKCOL method, 367, 408\nneighbor, 329, 405\nmkdir function, 367, 408\nneighbors property, 190\nmodification date, 364\nnerd, 157\nmodifier key, 248\nnesting\nmodular robot (exercise), 178, 396\nin regexps, 153\nmodularity, 97, 331\nof arrays, 66\nmodule, 167, 169, 178, 269, 352, 353,\nof expressions, 22, 204\n374\nof functions, 42\ndesign, 176\nof loops, 38, 389\nmodule loader, 352\nof objects, 225, 228\nmodule object, 173\nof scope, 42\nmodule system, 169\nNetscape, 6, 222, 223\nmodulo operator, 13\nnetwork, 180, 216, 370\nMongolian vowel separator, 162\nabstraction, 194, 314\nmonster (exercise), 283, 402\nprotocol, 216\nMosaic, 222\nreliability, 188\nmotion, 262\nsecurity, 314\nmouse, 25\nspeed, 175, 180, 350\nmouse button, 245, 246, 249\nnetwork function, 194\nmouse cursor, 249\nnew operator, 101\nmouse trail (exercise), 259, 401\nnewline character, 13, 38, 145, 156,\nmousedownevent, 246, 249, 251, 334,\n161, 264, 405\n335, 405\nnext method, 108, 197, 393\nmousemoveevent, 250, 251, 257, 258,\nnextSibling property, 227\n260, 335, 349, 401\nnode, 225, 226\nmouseup event, 249, 251\nnode program, 351\nmoveTo method, 287, 291\nnode-fetch package, 359\nMozilla, 223\nNode.js, 7, 8, 26, 171, 181, 350\u2013353,\nmultiple attribute, 322\u2013324\n355\u2013359, 361, 363\u2013366, 369\u2013\nmultiple choice, 316\n371, 373, 387\nmultiple-choice, 316, 322\nnode_modules directory, 352, 354\nmultiplication, 12, 266, 278\nNodeList type, 227, 237\nmultiplier function, 48\n425 nodeName property, 242 obstacle, 274, 275\nnodeType property, 226, 400, 401 offsetHeight property, 233\nnodeValue property, 228 offsetWidth property, 233\nnonbreaking space, 162 on method, 360\nnot a number, 13 onclick attribute, 221, 244\nnotation, 173 onclick property, 334\nnote-taking example, 326 OpenGL, 285\nnotification, 370 opening tag, 219\nNPM, 168, 169, 171, 173, 175, 177, operator, 12, 15, 16, 20, 203, 210\n178, 352\u2013355, 363, 374, 375, application, 12\n387, 396 optimization, 49, 54, 234, 257, 262,\nnpm program, 353, 354, 363 272, 304, 307, 357\nnull, 18, 19, 50, 59, 77, 81, 134 option (HTML tag), 316, 317, 322,\nnumber, 11, 63, 144, 166, 395 408\nconversion to, 19, 27 optional, 146\nnotation, 11, 12 optional argument, 46, 79\nprecision of, 12 options property, 323\nrepresentation, 11 ordering, 217\nspecial values, 13 ordinal package, 171, 173\nNumber function, 27, 28, 35 organic growth, 167\nnumber puzzle example, 50 organization, 167\nNumber.isNaN function, 28 outline, 286\noutput, 15, 26, 133, 134, 210, 350,\nobject, 57, 61, 62, 97, 113\n405\nas\noverflow, 11\nmodule, 169\noverflow (CSS), 272\nas map, 268\noverlap, 275\ncreation, 77, 101, 327\noverlay, 236\nidentity, 63\noverriding, 103, 106, 112, 397\nmutability, 63\noverwriting, 365, 368, 377\nproperty, 26, 59, 75, 77, 99\nrepresentation, 77 p (HTML tag), 219, 233\nObject prototype, 99, 100 package, 168, 171, 352, 355\nobject-orientedprogramming, 97, 101, package (reserved word), 25\n106, 112, 119, 176 package manager, 168\nObject.assign function, 327, 333 package.json, 354, 355\nObject.createfunction, 100, 105, 211 padding (CSS), 271\nObject.keysfunction, 62, 81, 195, 391, page reload, 255, 319, 325\n400 pageX property, 249, 252\nObject.prototype, 105 pageXOffset property, 233\n426 pageY property, 249, 252 performance, 153, 175, 212, 233, 262,\npageYOffset property, 233, 254 304, 357\nPalef, Thomas, 261 periodcharacter, 26, 59, 74, 145, 156,\npanning, 336 166, 333\nparagraph, 219 persistence, 325, 369, 387, 409\nparallelism, 181, 310 persistent data structure, 119, 121,\nparameter, 26, 39, 40, 44, 46, 74, 76, 127, 132, 332, 340, 345, 402\n98, 130, 173 persistent group (exercise), 127\nparent node, 245 persistent map (exercise), 394\nparentheses, 12 PGroup class, 127, 394\narguments, 26, 39, 44, 84, 202 phase, 267, 278\nexpression, 22 phi coe\ufb00icient, 65\u201367\nin regular expressions, 147, 149, phi function, 67, 76\n151, 162, 395 phone, 249\nstatement, 28, 30, 32 physics, 274, 279, 401\nparentNode property, 227 physics engine, 275\nparse function, 206 pi, 12, 75, 240, 268, 290\nparseApply function, 205 PI constant, 75, 240\nparseExpression function, 204 pick function, 341\nparseINI function, 161, 168 picture, 284, 294, 304, 330, 345\nparsing, 78, 128, 161, 202\u2013204, 206, Picture class, 332, 343\n208, 210, 220, 224, 362, 379 picture property, 332\npassword, 315 PictureCanvas class, 334, 348\npassword field, 315 pictureFromImage function, 344\npath piechartexample, 291, 293, 306, 403\ncanvas, 291 ping request, 190\ncanvas, 287\u2013289, 402 pink, 333\nclosing, 288 pipe, 217\nfile system, 352, 361 pipe character, 150, 395\nURL, 309, 312, 361, 362, 371, pipe method, 362, 365\n374 pipeline, 175\npath package, 363 pixel, 233, 240, 249, 262, 270, 284\u2013\npathfinding, 124, 177, 193, 341 286, 293, 294, 300, 304, 307,\npatience, 349 330, 332, 336, 339, 341, 344,\npattern, 143\u2013145, 157 349, 406\npausing (exercise), 283, 402 pixel art, 294\npea soup, 83 PixelEditor class, 337, 346, 348\npeanuts, 70 pizza, 65, 66\npercent sign, 311 platform game, 261, 282\npercentage, 94, 253 Plauger, P.J., 128\n427 player, 261, 263, 272, 275, 278, 281, di\ufb00iculty of, 2\n294, 302, 303 history of, 3\nPlayer class, 266, 278 joy of, 1, 2\nplus character, 12, 146, 166 programminglanguage, 1, 3, 202, 213,\nPoignant Guide, 22 226, 350\npointer, 227 power of, 5\npointer event, 246, 334 programmingstyle, 3, 23, 31, 35, 268\npointerPosition function, 335 progress bar, 253\npolling, 243 project chapter, 117, 202, 261, 330,\npollTalks function, 385 369\npolymorphism, 106 promise, 201, 398\npop method, 60, 70 Promiseclass, 185, 187\u2013189, 195, 198,\nPopper, Karl, 231 201, 312, 325, 356, 359, 361,\nport, 217, 308, 357, 358 385, 398\npose, 294 Promise.all function, 190, 199, 201,\nposition, 233 398\nposition (CSS), 238, 242, 253, 262, Promise.reject function, 187\n271, 272 Promise.resolve function, 185, 189\nPOST method, 310, 311, 319, 372 promises package, 356\npostMessage method, 256 promptDirection function, 139, 140\npower example, 39, 47, 49 promptNumber function, 134\nprecedence, 12, 13, 17, 236, 237 propagation, see event propagation\npredicate function, 87, 91, 95 proper lines (exercise), 349, 407\nPrefer header, 373, 379, 385 property, 327\npremature optimization, 49 access, 26, 59, 98, 128, 347\npreventDefaultmethod, 247, 253\u2013255, assignment, 61\n279, 319, 336, 406 definition, 61, 65, 110\npreviousSibling property, 227 deletion, 62\nprimitiveMultiply(exercise), 142, 395 inheritance, 99, 101, 103\nprivacy, 222 model of, 62\nprivate (reserved word), 25 naming, 105, 107, 108\nprivate properties, 97 testing for, 62\nprivate property, 142 protected (reserved word), 25\nprocess object, 351, 363 protocol, 216\u2013218, 308, 309\nprocessor, 180 prototype, 99\u2013103, 105, 112, 211, 215,\nprofiling, 49 399, 409\nprogram, 22, 27 diagram, 103\nnature of, 2 prototype property, 101, 102\nprogram size, 82, 165, 268 pseudorandom number, 76\nprogramming, 1 public (reserved word), 25\n428 public properties, 97 read-eval-print loop, 351\npublic space (exercise), 367, 408 readability, 4, 5, 36, 49, 53, 135, 167,\npublishing, 355 208, 273, 306\npunch card, 3 readable stream, 359, 360, 362, 377\npure function, 53, 54, 79, 87, 176, readAsDataURL method, 343\n329, 405 readAsText method, 324\npush method, 60, 68, 70, 393 readdir function, 356, 364, 408\npushing data, 370 readdirSync function, 408\nPUT method, 309, 310, 361, 365, readFile function, 172, 355, 409\n371, 377, 408 readFileSync function, 357, 408\nPythagoras, 393 reading code, 7, 117\nPythagorean theorem, 406 readStorage function, 183\nreadStream function, 377, 378\nquadratic curve, 289\nreal-time, 243\nquadraticCurveTo method, 289, 403\nreasoning, 17\nquery string, 311, 372, 379\nrecipe analogy, 83\nquerySelector method, 238, 400\nrecord, 61\nquerySelectorAll method, 237, 322\nrect (SVG tag), 285\nquestion mark, 17, 146, 156, 311\nrectangle, 262, 275, 286, 306, 340\nqueue, 198\nrectangle function, 340, 406\nquotation mark, 13, 165\nrecursion, 45, 49, 50, 55, 80, 189,\nquoting\n195, 204, 206, 208, 228, 242,\nin JSON, 77\n297, 389, 391, 395, 398, 400\nof object properties, 61\nred, 333\nquoting style (exercise), 165, 395\nreduce method, 88\u201390, 94, 95, 338,\n392\nrabbit example, 98, 100\u2013102\nReferenceError type, 215\nradian, 240, 290, 296\nRegExp class, 143, 157, 408\nradio button, 315, 322\nregexp golf (exercise), 165\nradius, 349, 406\nregularexpression, 143\u2013145, 154\u2013156,\nradix, 10\n158, 160, 165, 205, 367, 374,\nraising (exception), 135\n375, 399, 408\nrandom number, 75, 76, 268\nalternatives, 150\nrandom-item package, 396\nbacktracking, 152\nrandomPick function, 122\nboundary, 150\nrandomRobot function, 122\ncreation, 143, 157\nrange, 87, 145\u2013147\nescaping, 143, 157, 395\nrange function, 5, 79, 390\nflags, 147, 154, 157, 396\nRange header, 313\nglobal, 154, 158, 159\nray tracer, 304\ngrouping, 147, 154\n429 internationalization, 162 198\nmatching, 151, 158 resource, 217, 218, 309, 310, 314,\nmethods, 144, 148, 157 361, 376\nrepetition, 146 response, 184, 188, 308\u2013310, 314, 358,\nrejecting (a promise), 186, 189, 198 362, 365\nrelative path, 173, 221, 352, 361, 408 Response class, 312\nrelative positioning, 238, 239 responsiveness, 243, 350\nrelative URL, 312 rest parameter, 74\nremainderoperator, 13, 33, 294, 388, restore method, 297, 298\n389, 401, 403 result property, 324\nremote access, 361 retry, 188\nremote procedure call, 314 returnkeyword, 40, 45, 101, 196, 389,\nremoveChild method, 229 392\nremoveEventListenermethod, 244, 402 return value, 27, 40, 134, 184, 392\nremoveItem method, 325 reuse, 54, 113, 167, 168, 353\nrename function, 356 reverse method, 79\nrendering, 285 reversing (exercise), 79, 390\nrenderTalk function, 383 rgb (CSS), 271\nrenderTalkForm function, 384 right-aligning, 242\nrenderUserField function, 383 rmdir function, 364, 367\nrepeat method, 73, 253 roadGraph object, 118\nrepeating key, 248 roads array, 117\nrepetition, 51, 146, 153, 156, 257 roads module (exercise), 179, 397\nreplace method, 154, 165, 395 robot, 117, 119, 122, 124, 126, 178\nreplaceChild method, 230, 401 robot e\ufb00iciency (exercise), 127, 394\nreplaceSelection function, 321 robustness, 371\nreportError function, 382 root, 225\nrequest, 184, 188, 217, 308\u2013310, 319, rotate method, 295, 296, 298\n357\u2013359, 366, 369 rotation, 306, 402\nrequest function, 188, 358, 359 rounding, 76, 133, 275, 276, 301, 407\nrequest type, 184 router, 370, 374\nrequestAnimationFramefunction, 239, Router class, 374\n255, 257, 280, 306, 401 routeRequest function, 194\nrequestType function, 189 routeRobot function, 124\nrequire function, 171, 172, 179, 352, routing, 192\n354, 363, 374 row, 241\nreserved word, 25 rule (CSS), 236, 237\nresolution, 173, 352 run function, 210\nresolve function, 363 run-time error, 131, 132, 134, 141,\nresolving (a promise), 185, 186, 189, 399\n430 runAnimation function, 280, 283 semantic versioning, 355\nrunGame function, 281, 282 semicolon, 22, 23, 33, 235\nrunLevel function, 281, 283 send method, 184, 188\nrunning code, 7 sendGossip function, 191\nrunRobot function, 122, 394 sep binding, 363\nsequence, 146\nSafari, 223\nserialization, 77, 78\nsandbox, 7, 57, 222, 224, 313\nserver, 217, 218, 308\u2013310, 312, 314,\nsave method, 297, 298\n350, 357, 358, 360, 361, 369,\nSaveButton class, 342\n373\nscale constant, 334\nsession, 327\nscale method, 295, 296\nsessionStorage object, 327\nscaling, 270, 293, 295, 301, 404\nset, 144, 145, 225\nscalpel (exercise), 201, 398\nset (data structure), 115, 127\nscheduling, 197, 350\nSet class, 115, 127, 394\nscientific notation, 12, 166\nset method, 106\nscope, 40\u201342, 47, 168, 170, 171, 173,\nsetAttribute method, 232, 334\n207, 210, 214, 215, 399\nsetInterval function, 257, 294\nscript (HTML tag), 221, 255\nsetItem method, 325\nSCRIPTS data set, 86, 89, 91, 93,\nsetter, 111\n96\nsetTimeout function, 183, 197, 256,\nscroll event, 253, 257\n257, 379, 385\nscrolling, 247, 253, 272, 273, 279,\nshape, 284, 287, 288, 290, 293, 306\n300\nshapes (exercise), 306, 402\nsearch method, 157\nshared property, 100, 103, 104\nsearch problem, 124, 151, 152, 228,\nshift key, 248, 406\n367\nshift method, 70\nsearch tool (exercise), 367, 408\nshiftKey property, 248\nsection, 160\nshort-circuit evaluation, 20, 50, 208,\nSecure HTTP, see HTTPS\n392\nsecurity, 222, 313, 314, 323, 325, 363,\nSICP, 202\n373\nside effect, 23, 27, 34, 40, 54, 63, 79,\nselect (HTML tag), 316, 317, 322,\n87, 158, 176, 200, 227, 229,\n323, 326, 330, 337, 338, 408\n230, 234, 287, 297, 311, 331,\nselected attribute, 323\n332\nselection, 320\nsign, 11, 166, 395\nselectionEnd property, 320\nsign bit, 11\nselectionStart property, 320\nsignal, 10\nselector, 237\nsimplicity, 213\nself-closing tag, 220\nsimulation, 119, 122, 261, 266, 329,\n431 401 src attribute, 220, 221\nsine, 75, 240, 268, 278 stack, see call stack, 60\nsingle-quote character, 13, 165, 221 stack overflow, 45, 49, 56, 389\nsingleton, 127 stack trace, 136\nskill, 330 standard, 6, 25, 35, 87, 136, 162,\nskill-sharing, 369 347, 350, 352\nskill-sharing project, 369, 371, 373, standard environment, 25\n380 standard output, 351, 360\nSkillShareApp class, 386 standards, 216, 223\nskipSpace function, 205, 215 star, 306, 403\nslashcharacter, 12, 36, 143, 156, 312, Star Trek, 289\n363, 408 startPixelEditor function, 346\nslice method, 71, 72, 87, 231, 390, startState constant, 346\n399 startsWith method, 362\nslope, 407 stat function, 356, 363, 364, 408\nsloppy programming, 258 state, 32, 119\nsmooth animation, 239 in\nSMTP, 217 binding, 23, 30, 34\nsocial factors, 347 iterator, 197\nsocket, 370 objects, 119, 264\nsome method, 91, 95, 190, 374 in objects, 299\nsorting, 225 ofapplication, 272, 330, 334, 345,\nsource property, 158 387\nspecial form, 202, 207, 208 of canvas, 286, 297\nspecial return value, 134, 135 persistence, 340\nspecialForms object, 208 transitions, 199, 331, 333\nspecificity, 237 statement, 22, 23, 27, 30, 32, 39, 61\nspeed, 1, 2, 306, 404 static (reserved word), 25\nspiral, 306, 403 static file, 371, 375\nsplit method, 119, 264 static method, 112, 115, 264, 394\nspread, 74, 333 Stats type, 364\nspread operator, 270 statSync function, 408\nsprite, 294, 301, 302 status code, 309, 351\nspy, 253 status property, 312, 382\nsquare, 27 stdout property, 360\nsquare bracket, 108 stoicism, 243\nsquare brackets, 58, 59, 74, 77, 145, stopPropagation method, 246\n322, 327, 390 storage function, 186\nsquare example, 39, 43, 44 stream, 217, 358\u2013360, 362, 365, 377\nsquare root, 67, 75, 393 strict mode, 129\n432 string, 13, 58, 60, 63, 92 SymmetricMatrix class, 112\nindexing, 56, 71, 73, 92, 147 synchronization, 386, 409\nlength, 38, 92 synchronousprogramming, 180, 195,\nmethods, 72, 147 357, 367\nnotation, 13 syncStatemethod, 332, 335, 338, 339,\nproperties, 72 348, 409\nrepresentation, 14 syntax\nsearching, 72 error, 25, 128, 129\nString function, 27, 106 expression, 22\nstroke method, 287\u2013289 function, 39, 43\nstrokeRect method, 286, 404 identifier, 25\nstrokeStyle property, 286 number, 11, 166\nstrokeText method, 292, 293 object, 61\nstroking, 286, 292, 305 of Egg, 202, 203\nstrong (HTML tag), 233, 235 operator, 12\nstructure, 168, 219, 224, 331 statement, 22, 23, 28, 30, 32, 34,\nstructure sharing, 80 135\nstyle, 235 string, 13\nstyle (HTML tag), 236 syntax tree, 203, 204, 206, 207, 225\nstyle attribute, 235, 236, 269 SyntaxError type, 205\nstyle sheet, see CSS\ntab character, 14, 32\nsubclass, 113\ntab key, 318\nsubmit, 316, 319\ntabbed interface (exercise), 260, 401\nsubmit event, 319, 384, 408\ntabindex attribute, 248, 318, 348\nsubstitution, 54\ntable, 66, 67, 271\nsubtraction, 12, 115\ntable (HTML tag), 241, 262, 270,\nsum function, 5, 79\n405\nsumming (exercise), 79, 390\ntable example, 400\nsumming example, 4, 82, 88, 211\ntableFor function, 67\nsuperclass, 113\ntag, 218, 220, 224, 237\nsurvey, 291\ntalk, 369, 376\u2013378\nSussman, Gerald, 202\ntalkResponse method, 379\nSVG, 284, 286, 304, 305\ntalksAbout function, 228\nswapping bindings, 407\ntalkURL function, 382\nswipe, 340\nTamil, 86\nswitch keyword, 34\ntampering, 315\nsymbiotic relationship, 182\ntangent, 75\nsymbol, 107\ntarget property, 246\nSymbol function, 107\ntask management example, 71\nSymbol.iterator symbol, 108\n433 "}