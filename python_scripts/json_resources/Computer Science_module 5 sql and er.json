{"text":"Module_5 \u2013 SQL & ER\n5.1 - Introduction and Background\nIn the world of today, record keeping is used amongst all types of people and entities. Whether\nfor individuals, businesses, or governments, record keeping is used to organize, store, and change data.\nOne of the main tools today that allows record keeping to be more efficient and practical is SQL.\nSQL, or Standard Query Language, is a type of language used to store, manipulate, and retrieve\ndata in and from a database. SQL has its origins in 1970 when Dr. Edgar F. \"Ted\" Codd created the\nrelational model of database management. SQL itself would appear 4 years later in 1974 when it was\ncreated at the IBM Research Laboratory in San Jose, California based on Codd\u2019s idea of a relational\ndatabase. In 1978, a product called System\/R was created by IBM to further develop these concepts. In\n1986, the first standard prototype of SQL was created by IBM, and in that same year, SQL was\nconsidered the official standard by the American National Standards Institute (SQL \u2013 Overview, 2020).\nUnlike Java, Python, or C, SQL is not a procedural language. Another contrast is that SQL is a\n4th-generation language, meaning it is more similar to regular human language and speech and is able to\nbe understood by an untrained person unlike Java, C, Python, or others considered 3rd generation\nlanguages (Williams, 2018).\nSince SQL allows for easier use, especially when it comes to some of the large organizations\nthat use it. Benefits include reduced training costs and increased productivity, because workers can\nfocus on a single language, making it easier to train new employees. Workers are able to learn SQL\nproficiently, allowing them to increase their productivity and maintain existing programs. The use of\nSQL on multiple machines in a company also allows for application portability. By using SQL,\napplication longevity is also improved, as standard languages do not go through frequent, large changes.\nThis means that rewriting of older applications is not common with the use of SQL. Another benefit of\nusing SQL is cross-system communication, which allows for the managing of data through multiple\napplications. These benefits mainly pertain to the use of SQL by corporations. Due to the fact that SQL\ncan be used by almost anyone and is efficient in record keeping, it is known as one of the best (if not the\nbest) language in its category (Ramesh, 2011).\nThe first ANSI SQL standards were published in 1986 and have been updated every few years\nafter that. The updated ANSI SQL standards of 1992 are known to have greatly revised its structure.\nThe structure now features three levels: Entry, Intermediate, and Full. These revisions have made SQL\nwhat it is today, constantly improving to better perform at the top level (Ramesh, 2011).\nSQL has many major components within its process that enable it to work or process data and\nexecute tasks:\n\u2022 Query Dispatcher\n\u2022 Optimization Engines\n\u2022 Classic Query Engine\n\u2022 SQL Query Engine With these components, the way a user interacts with SQL is by commands. These commands\nallow the user to execute a multitude of actions, including Create, Alter, Drop, Select, Insert, Update,\nDelete, Grant, and Revoke. Commands can be modified by clauses, which set the conditions for a\ncommand. These clauses include Where, From, and Using. These commands and clauses are just one\nexample of how SQL can be understood by an average person who has little experience in programming\n( SQL \u2013 Overview, 2020).\nThe highest ranking and\/or most popular database management systems today are Oracle, Microsoft SQL\nServer, MySQL, MongoDB, and PostgreSQL (2019 Database Trends - SQL vs. NoSQL, Top Databases,\nSingle vs. Multiple Database Use., 2019). Oracle is ranked the highest out of all database systems\nbecause of its level of functionality, portability, performance, recovery, speed, multiple database support,\nand reliability (Khamlichi, 2018). Many of these languages are capable of linking or syncing with other\ntypes of software and languages like Java. These attributes, among others, help make SQL the leading\ndata organization and collection language in the world.\n5.2 Define a Database using SQL data definition language\nIt is common knowledge to most who are familiar in the coding world that SQL is used\nuniversally to define databases and perform certain actions to interact with the content in those\ndatabases. Of these, there exist 4 major categories: Data Definition Languages, Data Query Languages,\nData Manipulation Languages, and Data Control Languages.\nA Data Definition Language, also known as DDL, is what consists of the \u201cSQL commands that\nare used to define the database schema\u201d (Varshini, D., 2019, August 26). DDL is also used to modify\nthe content within the database: the database objects as well as the schemas. There are many different\ncommands, including CREATE, DROP, ALTER, TRUNCATE, COMMENT, and RENAME. Each of\nthese commands has its own unique utility and function when implemented as a SQL query. For\ninstance, CREATE and DROP are used to simply create and delete database tables. ALTER can be\nused to add new columns to a table. So for example, if we had the table below:\nEmployeeName EmployeeID Position\nJohn 123 Engineer\nJeff 456 Accountant\nJason 789 QA\nEmployee (Kashefi 2020) If we wanted to add each employee\u2019s salary, we could use the command:\nALTER TABLE Employee\nADD Salary\nWhich would give us this table:\nEmployeeName EmployeeID Position Salary\nJohn 123 Engineer\nJeff 456 Accountant\nJason 789 QA\nEmployee (Kashefi 2020)\nAnd because the salary column was not filled, we are left with a new, blank column. If we wanted to\nclear all the information but leave the table and columns, we could use TRUNCATE:\nTRUNCATE TABLE Employee\nWhich would leave us with this table:\nEmployeeName EmployeeID Position Salary\nEmployee (Kashefi 2020)\nThe next category used to define a database with SQL is Data Query Language, or DQL. This\ncategory of language is actually used to perform manipulations to the data within schemas rather than the schemas themselves as mentioned above. The primary example of DQL is the SELECT command\nwhich selects a set of data which you want to perform your operation on and does this by retrieving the\ndata from the database (Varshini, D., 2019, August 26). It is also worth noting that the primary purpose\nof DQL is to get a schema relation based on the query submitted. More information on DQL, its\ncommands, and its uses can be found in Section 5.3.\nDML, or Data Manipulation Language, is the next major category, which deals with data present in\nthe database. This is different from DQL, because DQL only takes into consideration data from the\nschema object. It is also worth noting that this category includes most of the commonly used SQL\nstatements such as INSERT, DELETE, and UPDATE. These allow users to actually modify data in\nsmall increments, rather than make sweeping changes that would be seen in DDL. For example, let's\nlook back at this table:\nEmployeeName EmployeeID Position Salary\nEmployee (Kashefi 2020)\nCurrently this table is empty, but what if we wanted to add a new employee who has a name, ID,\nposition, and salary? We would use this command:\nINSERT INTO Employee(EmployeeName,EmployeeID,Position,Salary)\nVALUES (\u201cJonah\u201d, 159, Janitor, 1000000)\nWhich would leave us with this table:\nEmployeeName EmployeeID Position Salary\nJonah 159 Janitor 1000000 Employee (Kashefi 2020)\nNext is DCL, which stands for Data Control Language. This category is mostly concerned with\nthe rights and permissions of other users on the network database and has commands which manage\nthese. These commands such as GRANT and REVOKE simply grant or revoke permissions to a\nspecified user on the database system. This is important for both data security and data integrity. It\nensures that data can only be seen by people who must see it, and it also ensures data cannot be changed\nby someone who does not have an understanding of what is happening in the database.\nThe last category we will discuss is TCL. TCL was not mentioned above, as there is debate on\nwhether or not TCL is actually something that should be considered a major category within the data\ndefinition namespace. However, to be thorough we will touch on it briefly here. It essentially deals with\ntransactions of data within the database. It does this through the use of commands such as COMMIT,\nROLLBACK, SAVEPOINT, and SET TRANSACTION. All of these perform a certain action by\nspecified keyword on a transaction. This can give users the ability to control versions of their databases.\nThis can become important in the case of incorrect information or even a corrupted database.\n5.3 Write a single table query in SQL\nIn data science, a query is a call for a specific set, group, or combination of data. In order to\nquery a database, we need to use a language the database can understand (Gibbs, n.d.).Tables, on the\nother hand, are objects within a database that include some, or all, of the data from the database. This\ndata is organized into a grouping made up of rows and columns. The rows each represent a unique item\nfrom the database records. The columns each represent different attributes that the item contains (Cai et\nal., n.d.).\nStudentName StudentID ClassID Grade\nJohn 123 987 90\nJeff 456 654 83\nJason 789 321 97\n1. Student (Kashefi 2020) Above is an example table named Student. The first column represents the student\u2019s name. This student\nname is what we will use to name the unique items in the rows. For example, John is the name of a\nstudent. Every other column of that row contains data that describes him. No other row will have the\nexact same data. This makes his, and every other row unique.\nIn the example table, the columns represent attributes in the data. Every student has a name, a\nstudent ID, a class ID, and a grade.\nIn order to query from this table, we must use specific SQL commands. We must use the SELECT\ncommand to choose the columns in the table we are querying from. To select the correct table, the\nFROM command must be used. In order to ask for the entire table as a query, therefore:\nSELECT * FROM Student\nThe asterisk is a shorthand way to ask for every column. This shorthand is also used in other database\nand programming languages. This command would be read in plain English as \u201cselect all columns from\nthe student table.\u201d This would return everything from the above table, as the table is named Student and\nall of the information is in one column or another.\nNow what if we just wanted to know the name and grade for each student? This is how it would\nlook:\nSELECT StudentName, Grade FROM Student\nIn this example, we used SELECT to choose columns. Instead of an asterisk used for \u201call columns,\u201d we\nuse the specific column names \u201cStudentName\u201d and \u201cGrade,\u201d which are intuitively the name and grade\nof the student, and the columns are separated by a comma. The FROM command underneath once again\nchooses the correct table. In plain English, this is \u201cselect the columns student name and grade from the\nstudent table.\u201d This would be the returned table:\nStudentName Grade\nJohn 90\nJeff 83\nJason 97\nStudent (Kashefi 2020)\nThis query can be done with any combination of columns in the table, as long as the same formatting is\nused. The last staple command of SQL is WHERE. This command will only return a row if the\ninformation in one of the specific columns fits a specific condition of the query(\u201cLearn SQL:\nQueries Reference Guide,\u201d n.d.). To allow a better understanding, here is an example:\nSELECT StudentName, Grade\nFROM Student\nWHERE Grade < 95\nFor this example, we have the same queried table as above, except that any row with a grade above 95 is\nremoved. In plain English, this would be \u201cselect the columns student name and grade from the student\ntable if the student\u2019s grade is below 95.\u201d This would be the final queried table:\nStudentName Grade\nJohn 90\nJeff 83\nStudent (Kashefi 2020)\nThis is just a small part of all the possible ways to query in SQL, but they are the main ones that\ncan allow basic table queries to be practiced.\n5.4 Establish referential integrity using SQL\nReferential integrity is the accuracy and consistency of data in a relationship. Referential\nintegrity is a subset of data integrity, which is concerned with the accuracy and consistency of data as\nwhole in a database. When relationships occur, data is linked between two or more tables. A primary\nkey is the key or specific column in a parent table, and a foreign key is the key in a child table that\nreferences the primary key. Referential integrity requires that a foreign key references a primary key\n(Ian, 2016).\nThe tables below will show how referential integrity works within a database management system: Child Table Parent Table\nDepartment Employee\nEmployee ID Department Employee ID Age Salary\n6789 Marketing 6789 25 56000\n5632 R&D 5632 29 83000\nAs you can see in the tables above, Employee is the parent table and Department is the child table.\nThe primary key is the Employee ID and is referenced in the child table, therefore making it a foreign key\nin this table. The relationship is denoted by a curved line connecting the columns in the two different\ntables. As a result of this relationship a user will be prevented from:\n\u2022 Adding information in the child table if the same information is not also in the parent table\n\u2022 Changing data in the primary table that result in parentless keys in the child table (orphaned)\n\u2022 Deleting records from the parent table if they exist in the child table\nA lack of Referential integrity can result in records being lost and\/or inaccurate or confusing. This can\nhave serious and negative effects for entities that make use of database systems (Ian, 2016).\nTo ensure or establish referential integrity within SQL (Microsoft SQL Servers), it is necessary\nto establish variables (columns) as a primary key when creating tables. After creating the child table,\nexpand the database in project explorer and look at \u201ctable.\u201d After finding the table tree, expand it and\nright click on \u201ckeys.\u201d After right clicking, it will provide options, one of them being a \u201cnew foreign\nkey.\u201d Click \u201cnew foreign key\u201d and expand \u201cTables and columns specification.\u201d After expanding, click\non the 3 dots on the right side of the box. This will allow the user to enter a primary or parent able for\nforeign keys along with the specific column. After doing this, the tables will be linked to one another.\nThe user will only be able to perform tasks that are within the constraints of referential integrity.\nSQL and ER\nIt is very important to remember that a database is a model of a user\u2019s view of the world. The\nonly question is \u201cHow well does it fit the mental models of the people who are going to use the\ndatabase system?\u201d It is up to database administrators to create a SQL and Entity-Relationship (E-R)\nplatform and provide the needs to fit user requirements. ER-Assistant provides relationships that are\nexpressed using a different notation. It is easy to use but the entity boxes cannot be resized, leading to\ntext length limitations.\nEriwin uses solid vs. dashed lines for M:N relationships; this can only be specified on\n\u201cchildren\u201d in a relationship. These features mean that nearly any E-R diagram created using erwin\nwill be incorrect for this text. Figure_1 below illustrates the differences between the notation used in\nthe text and the notation used by erwin. Database Drawing such as Dia and Visio 2016 display names and roles of relationships and do not\ndistinguish between weak and strong entities (no rounded corners). Connecting lines are solid: Information Engineering (IE) began with the work of Clive data modeling tools which is one\nof the most popular notations for database design using with a crow's foot.\nA G E N T\nA G E N T\n1\n_\n:1\nV E H IC L E\nC A R 5.5 - Section Concise Summary\nSQL, a non-procedural query language, is a major database management system that helps\norganize and log data. Commands and clauses like CREATE, SELECT, etc. are what makes SQL work\nand gives it functionality. Using these commands and clauses, it is possible to create databases, create\ntables, edit data within tables, add columns and rows, create keys and so on.\nThe intuitive words and language that make up these tables allow people who may not be skilled\nin computer science to be able to use the system. Some of the commands are powerful in another sense\nas well: they allow the user to quickly scan through all of the given information and return only a\nspecific set based on any number of parameters that the user decides are necessary.\nUsing other commands, data can be linked between two tables, using characteristics such as\nReferential Integrity, primary keys, and foreign keys. Primary keys uniquely identify records in tables,\nwhile the foreign keys reference the primary key. The linking that results from this is called a\nrelationship. Referential integrity helps prevent the duplication of already existing data and it helps\nmake sure that necessary records aren\u2019t accidently deleted. Referential integrity gives SQL a way to\nmake sure that the data that is in the table is correct and updated due to constraints on what can be\nchanged, and who it can be changed by. The many features of SQL enable it to be the most popular\nquery language in the world.\nFurthermore, this module discusses the process of transforming a data model into a database\ndesign as various aspects of data models and designs, how they relate to each other, and how they relate\nto the systems analysis and design process in general and to the systems development life cycle (SDLC)\nin particular. Transforming a data model into a database design requires three major tasks: replacing each\nentity with a table and each attribute with a column, representing relationships and maximum cardinality\nby placing foreign keys, and representing minimum cardinality by defining actions to constrain activities\non values of primary and foreign keys.\nFour uses for ID-dependent entities are N:M relationships, association relationships, multivalued\nattributes, and archetype\/instance relationships. An association relationship differs from an intersection\ntable because the ID-dependent entity has no key data. In all ID-dependent entities, the key of the parent\nis already in the child. "}