{"text":"Chapter 1\nWhat is This Course About?\n1.1 Introduction\nComputerscience. Whatexactlyiscomputerscience? Why\u2014beyondtheobviousreasons\n\u2014 is it important? What do computer scientists do? What types of problems do they\nwork on? What approaches do they use to solve those problems? How, in general, do\ncomputer scientists think?\nQuestion 1. What do you think of when you hear \u201ccomputer science?\u201d Write a paragraph\nor list, or draw an image or diagram of what comes to mind.\nQuestion 2. What are the parts of computer science that are most interesting or impor-\ntant to you currently? Why?\nWhen you hear the term \u201ccomputer science\u201d perhaps you think of a specific computer.\nOr someone you know who works with computers. Or a particular computer use, say\nonline games or social networks. There are many, many different aspects of computing\nand computer science.\nFurthermore, there are a number of reasons why it is useful and important to know\nsomething about computer science. Computers are affecting our lives in many different\nways. For most of us, computers are playing or will play a significant role in the work we\ndo, in our recreational pursuits, in how we communicate with others, in our education,\nin our health care, etc. Think about the ways you encounter computers and computing,\neither directly or indirectly, in your daily life.\nWhat, more specifically, will this course cover? The foremost purpose of this course\nis to give you a greater understanding of the fundamentals of computer science: What\nis computer science, anyway? Is the the same as computer programming? What is a\ncomputer? Forexample, mostpeoplewouldagreethata\u201claptopcomputer\u201disacomputer,\nas is a \u201ctablet computer;\u201d but what about a smartphone? And how do computers work?\nFor example, we can store not only numbers and text in computers, but also images, video\nfiles, and audio files; how do computers handle such disparate data? And what are some\ninteresting and important subareas of computer science? For example, what is important\nto know about subareas such as computer graphics, networking, or databases? And why\n1 2 CHAPTER 1. WHAT IS THIS COURSE ABOUT?\nis any of this important? Isn\u2019t it sufficient for most people just to use computers, rather\nthan have a deeper understanding of computers and computer science?\nThese are all fundamental questions about computing, and in this course we\u2019ll look\nat them and other questions. In summary, one purpose of this course is to provide an\noverview of computer science that not only exposes you to computer science fundamentals\n\u2014 such as how a computer works on a rudimentary level \u2014 but also explores why these\nfundamentals are important.\nThere are two parts of this overview that deserve further explanation. This course\nfulfills the University of Minnesota liberal education mathematical thinking core require-\nment and the technology and society theme requirement. So while the main theme of this\ncourse is an overview of computer science, two essential subthemes are how mathematics\nis used in computer science, and how computer science affects, and is affected by, society.\nBoth subthemes fit well in an overview of computer science course. Computer sci-\nence relies heavily on mathematics (in fact, some colleges have computer science and\nmathematics programs in a joint department). Certain uses of mathematics in computer\nscience are obvious \u2014 for example, in computational tools such as spreadsheets \u2014 but\nthere are also many less obvious ways that mathematics is essential to computer science.\nFor example at the lowest level in a computer, data (whether that data is numeric, text,\naudio, video, etc.) is all represented in binary, i.e., as strings of 0\u2019s and 1\u2019s. This means\nthat to understand something very basic about computers you need to understand binary\nnumbers and operations.\nComputersarealsoaffectingsocietyinmanyways, fromtheuseofcomputer-generated\nimagery in films, to large government or commercial databases, to the multiple societal\neffects of the Internet. And society is affecting computers, for example through user\nbehavior and through different types of regulation.\nWhilemathematicsandtechnologyandsocietymightseemtoodifferenttobeincluded\ncomfortably in the same course, there are actually many computer science topics that are\nuseful to explore from both perspectives \u2014 in a sense, these different viewpoints are\n\u201ctwo sides of the same coin.\u201d For example, one topic in the course is computer security.\nMathematics plays a role in security, for example in encryption. And computer security\nalso has many societal aspects, for example national security, infrastructure security, and\nindividual security. Most of the topics in this course similarly have both mathematical\nunderpinnings and societal aspects, and exploring these topics from both perspectives will\nresult in a richer understanding.\n1.2 What This Course Isn\u2019t\nThere are a number of different types of introductory computer science courses. So, in\naddition to explaining what this course is, it is also useful to state what it is not.\nThis is not a programming course. Programming is a central activity in computer\nscience, but it is not the whole of computer science. Because programming is important,\nwe\u2019ll spend some time on it. However, because computer science is much more than 1.2. WHAT THIS COURSE ISN\u2019T 3\nprogramming, and because this is an overview course, that time will be only a small part\nof the course \u2014 probably a few weeks.\nIf you wish to take a programming course, the University of Minnesota, like most other\ncolleges and universities, offers a number of different introductory programming courses.1\nThis is not a computer applications course. Manycollegesanduniversitieshavecourses\nthat cover basic computer applications. For example, a popular choice is teaching how to\nuse a word processor, a spreadsheet, a database management program, and presentation\nsoftware. These and other applications are important parts of computer science, and so\nin this course you will get a chance to work with some applications that might be new to\nyou. However \u2014 like programming \u2014 using applications is only part of learning about\ncomputer science, and so application use will be only a small part of this course.\nThis is not a \u201ccomputer literacy\u201d or \u201ccomputer fluency\u201d course. There are a vari-\nety of definitions of computer literacy or computer fluency. For example the Wikipedia\ndefinition, derived from a report from the U.S. Congress of Technology Assessment, is\n\u201cthe knowledge and ability to use computers and related technology efficiently, with a\nrange of skills covering levels from elementary use to programming and advanced problem\nsolving.\u201d2 Parts of this course will involve using computers to gain a variety of skills.\nFor example, in the labs and homeworks in this course you will do a variety of computer-\nrelated tasks such as performing web searches, constructing web pages, doing elementary\ncomputer programming, and working with databases. However, this is just one part,\nrather than the totality, of the course. So this course shares some characteristics of a\ncomputer literacy course, but overall it has a wider focus than that type of course.\nThis is not a \u201cgreat ideas in computer science\u201d course. One current trend in com-\nputer science introductory courses is to study computer science through its important,\nfundamental ideas.3 And this course does cover some key ideas. For example, an early\ntopic we\u2019ll study is how all data in computers, whether that data be numeric, text, video,\netc. is represented within the computer as 0\u2019s and 1\u2019s. In general, the topics in the\ncourse are fundamental to computer science. However, this course also differs from a\ngreat ideas course. It is not focused solely on ideas, but explores broadly a number of\ncomputer-related issues, subtopics, and computer skills. Moreover, to fulfill the Univer-\nsityofMinnesotaliberaleducationrequirementsthiscoursefocusesmoreonmathematical\nthinking, and on technology and society, than a typical great ideas course would.\nIn addition to programming, applications, computer fluency, and great ideas, there\nare a number of other types of introductory computer science courses. Some are courses\n1Specifically, CSci 1103 is a Java programming course for non-majors, CSci 1113 is a C++ program-\nming course for science and engineering majors, and CSci 1133 is an introductory Python programming\nand computer concepts course for computer science majors.\n2See http:\/\/en.wikipedia.org\/wiki\/Computer literacy. Accessed May 20, 2105.\n3For example, see http:\/\/denninginstitute.com\/pjd\/GP\/GP-site\/welcome.html (accessed May\n20,2015),PeterDenning\u2019s\u201cGreatPrinciplesofComputerScience\u201dwebsite. Thissiteorganizesprinciples\ninto seven categories: computation, communication, coordination, recollection, automation, evaluation,\nand design. There are a number of good ideas, insights, and frameworks in this and related approaches,\nand in fact many of the key ideas in this course will relate in some way to Denning\u2019s principles. 4 CHAPTER 1. WHAT IS THIS COURSE ABOUT?\nthat survey a variety of computer science topics. Others focus on professional software\ndevelopment practices. Still others look at computing through a particular \u201clens\u201d such\nas networks or computational biology. And so on. This course has some common char-\nacteristics with these other courses, but also has significant differences. In particular,\nthe biggest difference is this course blends an overview of computer science with a strong\nemphasis on mathematics, and on society and technology; this is a balance of emphases\nthat has a number of advantages, but is not usually seen in introductory computer science\ncourses.\n1.3 What Are These Note About?\nThere is no textbook for this course. The reason for this is that although there are a\nnumber of excellent \u201cintroduction to computer science\u201d textbooks, none is a good fit for\nthis course. Instead, these notes are the \u201ctextbook.\u201d\nSpecifically, in order to fulfill the University of Minnesota liberal education require-\nments, both mathematical thinking and technology and society need to be significant\nparts of this course. Many textbooks present an introduction to computer science though\nprogramming, or through how computers work, or through some other aspect of comput-\ning. However, there is not a suitable text that combines an overview of computer science\nwith both sufficient mathematical and sufficient society and technology emphases.\nBut these notes are not a textbook in the traditional sense. For example, they are\nneither as long nor as detailed as a textbook. There are a few reasons for this.\nOne is this course has a number of different parts, and these notes are kept short so\nreading them doesn\u2019t take so much time as to interfere with other course activities. An-\nother is that there are a number of online resources such as tutorials, reference guides, and\ninstructional videos freely available on the Internet, and that you can use as supplemental\nresources. (In an overview of computing course it is particularly appropriate to make use\nof educational resources that others have been good enough to post. Being able to learn\nfrom different resources that perhaps were created for slightly different audiences, and\nthat might use slightly different notation, etc. is a good skill to have.) A third, related\nreason is that there will also be some additional required readings. These will usually be\nshort, online readings that we will use to explore topics in more depth.\nAnother key distinction between these notes and a traditional textbook is that these\nnotes often focus on fundamental or background material \u2014 material that you can often\nlearn most efficiently from reading. Using this background material to solve various\nproblems, or to explore technology and society issues is more difficult, and so many of the\ncourse learning activities will be done during \u201clecture\u201d time or during lab, and will build\non rather than repeat this fundamental material. 1.4. CSCI 1001 AND LIBERAL EDUCATION 5\n1.4 CSci 1001 and Liberal Education\nCSci 1001 fulfills two University of Minnesota liberal education requirements: the math-\nematical thinking core requirement, and the technology and society theme requirement.\nThis section explains how the course satisfies the criteria for these requirements.\n1.4.1 Why Liberal Education?\nAt first glance, it might seem odd that a course entitled \u201cOverview of Computer Science\u201d\nfulfillsliberaleducationrequirements. Whatdoescomputersciencehavetodowithliberal\neducation?\nHowever, a course such as CSci 1001 is a good fit for certain liberal education require-\nments. Understanding computers well involves exploring them from a variety of different\nviewpoints. This includes understanding not only how computers work \u2014 including, for\nexample, the mathematical underpinnings of computer science \u2014 but also how they are\naffecting, and are affected by society. In summary, to have a good understanding of com-\nputersandcomputerscienceitisimportanttoexplorethemfromavarietyofperspectives,\nincluding the perspectives embodied in some of the liberal education requirements.\n1.4.2 Mathematical Thinking\nQuestion 3. What do you think of when you hear the word \u201cmathematics?\u201d Write a\nparagraph or list, or draw an image or diagram of what comes to mind.\nQuestion 4. Based on your experience with computers, write a list of some places where\nmathematics is used in computing.\nWhat do computers and mathematics have in common? Why is it appropriate for an\noverviewofcomputersciencecoursetosatisfytheliberaleducationmathematicalthinking\nrequirement?\nTo fulfill the mathematical thinking requirement, a course must fulfill the following\ncriteria4\n\u2022 The course exhibits the dual nature of mathematics both as a body of knowledge\nand as a powerful tool for applications.\n\u2022 Students manipulate mathematical or logical symbols.\n\u2022 The prerequisite math requirements and mathematics used must be at least at levels\nthat meet the standards for regular entry to the University.\nTherestofthissubsectionexplainshowthesecriteriarelatetothematerialandthemes\nin this course.\n4From http:\/\/onestop.umn.edu\/faculty\/lib eds\/guidelines\/mathematical thinking.html,\naccessed May 20, 2015. 6 CHAPTER 1. WHAT IS THIS COURSE ABOUT?\nThe course exhibits the dual nature of mathematics both as a body of knowledge and as a\npowerful tool for applications.\nMuch of the use of mathematics in this course is applying mathematical ideas and opera-\ntions to solve computer science problems. There are a number of important mathematical\nunderpinnings of computer science, and so understanding computer science involves being\nable to solve mathematical problems involving these underpinnings. At the same time,\nthe different uses of mathematics in this course exemplify characteristics of mathematics\nas a whole, and of the close tie between the fields of mathematics and computer science.\nFor instance the mathematics in the course illustrates the following:\n1. The reliance of many key ideas in computer science, such as data representation, on\nmathematics.\n2. The use of special mathematics- or logic-related notation and terminology in many\nparts of computer science.\n3. The ability to represent and work with many different types of data in the com-\nputer, and the related ability to represent and work with quantities in different\nrepresentations using a variety of operations.\n4. The need for rigor in solving problems, analyzing situations, or specifying compu-\ntational processes.\n5. The use of numbers and arithmetic in solving computational problems. However,\nrather than being simple arithmetic problems, these problems often have some spe-\ncial characteristics such as involving repeated operations, or involving extremely\nlarge or extremely small numbers.\n6. The existence of a variety of different algorithms for solving such diverse problems\nas pattern matching, counting specified values in a table of data, or finding the\nshortest path between two nodes in a graph.\nStudents manipulate mathematical or logical symbols.\nSolving many of the problems in this course will involve doing some mathematics, and\ntherefore manipulating mathematical or logical symbols. Here are a few examples:\n1. In exploring low-level logical operations you\u2019ll need to manipulate binary represen-\ntation and logical operators.\n2. In studying the growth rate of algorithms you\u2019ll need to work with the \u201cbig-O\u201d and\n\u201cbig-\u0398\u201d notations commonly used by computer scientists.\n3. Inspecifyingcomputationalprocessesyou\u2019llneedtouse\u201cpseudocode\u201doraprogram-\nming language. These share many notational characteristics with mathematical or\nlogical symbols, especially when the computational processing involves a large num-\nber of numeric computations. 1.4. CSCI 1001 AND LIBERAL EDUCATION 7\nThe prerequisite math requirements and mathematics used must be at least at levels that\nmeet the standards for regular entry to the University.\nThe level of mathematics in this course is introductory-level college mathematics. As\nsuch, the mathematics is not advanced, and there is no mathematical prerequisite for this\ncourse beyond the requirements needed for admission to the University. At the same time,\nthe mathematics in this course goes beyond high school mathematics even though many\nof the types of mathematics used in this course appear in some high school mathematics\ncourses.\nAs an example, one appearance of mathematics in this course is binary (or base 2)\nrepresentation. This is a topic that often appears in high school mathematics courses,\nand the basics of binary representation are not complicated. In this course we review such\nbasics as how to convert numbers between decimal (base 10) and binary representation,\nand how to do simple operations such as adding two binary numbers. However, we also\nuse binary representation in additional ways that underpin the workings of computers.\nHere are a few examples:\n1. We\u2019ll look at a few different ways to represent numbers in binary representation.\nForexample,computersusuallydonotusethestraightforwardbinaryrepresentation\nwhen representing integers, but rather use \u201ctwo\u2019s complement\u201d form. So part of this\ncourse is learning not only about the \u201cusual\u201d binary representation, but also about\nthese alternatives.\n2. We\u2019ll look at various issues with binary representation, such as the number of \u201cbits\u201d\nused, that are important in determining the range and precision of numbers used\nby computers.\n3. In addition to representing numbers, we will also look at how computers use binary\nrepresentation to represent and operate on other types of data such as text, colors,\nand images.\n4. In addition to basic operations such as binary addition, we will also look at other\noperations on binary representations. For example, logical operations are important\nin masking colors in image processing, and in implementing arithmetic operations\nin low-level computer hardware.\nIn summary, even though many mathematical topics in this course appear in high school\nmathematics, they go beyond the usual high school treatment of those topics in breadth\nor depth.\n1.4.3 Technology and Society\nQuestion 5. What do you think of when you hear \u201ctechnology and society?\u201d Write a\nparagraph or list, or draw an image or diagram of what comes to mind. 8 CHAPTER 1. WHAT IS THIS COURSE ABOUT?\nQuestion 6. Based on your experience with computing, write a list of examples of how\ncomputing is affected, and being affected by, society.\nTo fulfill the technology and society requirement, a course must fulfill the following\ncriteria5\n\u2022 The course examines one or more technologies that have had some measurable im-\npact on contemporary society.\n\u2022 The course builds student understanding of the science and engineering behind the\ntechnology addressed.\n\u2022 Students discuss the role that society has played in fostering the development of\ntechnology as well as the response to the adoption and use of technology.\n\u2022 Students consider the impact of technology from multiple perspectives that include\ndevelopers, users\/consumers, as well as others in society affected by the technology.\n\u2022 Students develop skills in evaluating conflicting views on existing or emerging tech-\nnology.\n\u2022 Students engage in a process of critical evaluation that provides a framework with\nwhich to evaluate new technology in the future.\nTherestofthissubsectionexplainshowthesecriteriarelatetothematerialandthemes\nin this course.\nThe course examines one or more technologies that have had some measurable impact on\ncontemporary society.\nThe topic of this course is computers and computing. Computers have affected society in\nnumerous and diverse ways, some of which we\u2019ll explore in this course. And current and\nfuture computer applications will affect society in even more ways.\nThe course builds student understanding of the science and engineering behind the tech-\nnology addressed.\nThrough this course you should get an understanding of how computers work. This\nincludes understanding the basics of computer hardware and computer software.\nMore broadly, however, computer science relies on results from other areas of science,\nengineering, and related fields. The most prominent example of this we will see in this\ncourse is various ways that mathematics is essential in computer science.\nStudents discuss the role that society has played in fostering the development of technology\nas well as the response to the adoption and use of technology.\nTechnology affects society. However, it is not a one-way street. Society also affects\ntechnology. For example, society fosters technology by means such as government support\n5From http:\/\/onestop.umn.edu\/faculty\/lib eds\/guidelines\/technology and society.html,\naccessed May 20, 2015. 1.4. CSCI 1001 AND LIBERAL EDUCATION 9\nfor research. As another example, individuals, businesses, and other organizations adopt\nand use technology in ways often not foreseen by the technology\u2019s creators.\nIn this course we\u2019ll look at a variety of instances of how society affects technology.\nTheseincludegovernmentfundingfortheearlyInternet, Internetregulation, howbusiness\nconsiderations affect computing products, and societal aspects of computer security.\nStudents consider the impact of technology from multiple perspectives that include devel-\nopers, users\/consumers, as well as others in society affected by the technology.\nIn many topics in computers and society there are multiple stakeholders. These can in-\nclude individual users, developers, companies (producers, consumers, and intermediaries),\ngovernment bodies, professional organizations, and other types of organizations. These\ndifferent stakeholders often have different views and different goals.\nIn this course we will often look at technology and society issues from numerous\nperspectives. Sometimes we will focus on a specific perspective or the role of a specific\nstakeholder. However, other times we will explore issues more broadly: Who are the\nstakeholders? What is their role in this issue? What are their goals? etc.\nStudents develop skills in evaluating conflicting views on existing or emerging technology.\nOneoftenhearsconflictingviewsoncomputerandsocietyissues. Computersarebeneficial\nfor society. Computers are harmful to society. The Internet is making it easier for\npeople to communicate and is bringing people together. The Internet is making people\nmore isolated. Computers and automation are robbing people of jobs. Computers and\nautomation create jobs.\nIn this course we\u2019ll often explore issues that are contentious and\/or complicated. How\ndo we avoid a superficial, one-sided understanding of such issues? How do we resolve\nconflicting claims about such issues?\nStudents engage in a process of critical evaluation that provides a framework with which\nto evaluate new technology in the future.\nComputing technology not only has had massive effects on society, but it is continuing to\naffectsociety. Notadaygoesbywithoutsometechnologicaladvanceinvolvingcomputing.\nIn many ways the \u201ccomputer revolution\u201d is just beginning.\nOne goal of this course is that you\u2019ll learn enough about computing in general, about\ntrends in computing, and about computing and society that you\u2019ll be able to evaluate\nnew technology. Note \u201cevaluate\u201d here might mean different things in different contexts.\nFor instance, it might mean give an informed projection about whether a new computer\nproduct will be successful or not. Or it might mean predict future computer advances in\na certain area. Or it might mean analyze whether a new computer application is more\nlikely to be beneficial than harmful.\n1.4.4 How These Requirements Will Appear in the Coursework\nBoth the mathematical thinking and technology and society requirements will appear\nprominently in the coursework you do. In particular, many of the individual homework 10 CHAPTER 1. WHAT IS THIS COURSE ABOUT?\nassignments will involve mathematics in some way, shape, or form. Similarly, many lab\nproblems will also often involve mathematics. And some in-class activities will be practice\nfor these labs and homework problems.\nA few of the homework and lab problems will involve the technology and society\ntheme. Moreover, most weeks there will be short writing and\/or an in-class discussion of\nthe technology and society aspect of the course topics.\nFinally, both mathematical thinking and technology and society problems will be on\nthe exams, with questions often similar to those on the homework or from the in-class\nactivities or discussions.\n1.5 Course Structure\nThe course has a number of components:\n\u2022 Class lectures will explore important topics from computer science. This includes\nboth technical aspects and computers and society aspects.\n\u2022 Technical in-class exercisesprovidepracticeontechnicalaspectsofthecurrenttopic.\nProblems will usually be mathematical to fulfill the math liberal education core\ncriteria; however, occasional society and technology questions will also be included.\n\u2022 Discussions\/exercises on society and technology provide a chance for interactive\ndiscussion and debate of current computer science-related social issues.\n\u2022 Weekly laboratory exercises allow hands-on exploration of course content. These lab\nsessions occur in a classroom laboratory where exercises can be completed by pairs\nof students working on computers.\n\u2022 Reading assignments are designed to prepare you for homework, labs, exams, and\ndiscussions.\n\u2022 Written problem assignments help you explore computer science concepts in depth.\nUnless otherwise stated, these assignments must be completed individually, and will\nbe due about every other week.\n\u2022 Other occasional in-class or between-class assignments, for example short writing\nassignments, serve a variety of functions and will be explained further in class.\n\u2022 Exams give you a chance to demonstrate your knowledge of the course material.\nThere will be one or two midterms exams and a final exam. See the course syllabus\nand\/or web page for more information.\nNotethatthein-classexercises, labs, etc. areallimportantpartsofthecourse, andwill\ncontribute to your course grade. It is therefore important that you attend class (including 1.6. TIPS FOR DOING WELL 11\nthe lab). It is also important that you do any assigned preliminary work, including any\nreading or writing, prior to lecture and lab.\nAdditional information on these components, as well as important administrative ma-\nterial such as exam and assignment rules, will be posted on the course web page.\n1.6 Tips For Doing Well\nHerearesometipsfordoingwellinCSci1001. Althoughmostofthesearestraightforward,\nthey are particularly relevant to a course such as this one.\n\u2022 Show up. A large part of doing well in this course is showing up. Don\u2019t miss class\nunless you have a valid excuse (such as illness). And if you do miss class then check\nwith others to see what you have missed.\nThe labs, in-class exercises, and discussions are all important parts of the course.\nSometimes they are important learning activities in and of themselves; other times\ntheir purpose is practice to help on the homework problems and exams. To empha-\nsize their importance, a portion of the class grade is devoted to the labs, and to\nin-class activities such as in-class exercises or discussions.\n\u2022 Start the homework early. Most homework will be posted a couple weeks before it is\ndue. Usually when it is posted you will have seen enough material to start at least\nsome of the problems. Starting early will give you enough time to think about the\nmore difficult questions, and to ask questions during office hours.\n\u2022 Come to office hours if you have questions. If you have any questions on the home-\nwork, or are having trouble with it, please come to office hours.\n\u2022 Do the reading. We will usually assume you\u2019ve done the assigned reading, and done\nitbeforeclass. Sometimeswe\u2019lluseclasstimetogooversomeparticularlyimportant\nand\/or challenging parts of the reading. Other times the class lecture will use the\nreading as a starting point, but not re-explain it in detail.\n\u2022 Get to know others in the class. Many people learn better if they discuss class ma-\nterial with others. Get to know people in the class, form study groups, etc. Some\nof the assignments in the class \u2014 notably the labs \u2014 are designed as group assign-\nments. Others such as the homework and exams are individual work; however, even\non these you are welcome to do preliminary studying in groups, but your answers\non the assignment and exams must be yours alone. (See the further explanation on\nthe class web page for more details.)\n\u2022 Use the web resources. Throughout the semester we will post additional resources\nto the course web page. Moreover, a number of other online resources are mentioned\nin these notes. See which of these are most useful to you, and use them accordingly. 12 CHAPTER 1. WHAT IS THIS COURSE ABOUT?\n\u2022 Realize that some material in this course might be easy, but some might be hard.\nStudents in this class come from a variety of backgrounds. Often, students will find\nsome parts of the course easy, but then find other parts require significantly more\ntime and effort.\n\u2022 Persist: Many students will find at least part of this course to be challenging. If you\nhave not seen, for example, topics such as algorithms before, they will seem foreign\nand will take time to master. Do the reading, ask questions as needed, and practice\ndoing problems.\n\u2022 Try to apply this material to your major or to other interests: Much of the informa-\ntion or skills in this course are applicable to a wide variety of areas. Think about\nhow what you are learning in this course might be applicable to other courses you\nare taking, or to other areas of your interest.\n1.7 Additional Questions\nHere are additional introductory questions, some of which will likely be used for between-\nclass or in-class exercises or discussion.\nQuestion 7. How do you use computers? List the most important ways.\nQuestion 8. Write down a list of movies in which computing plays a major role. For\neach movie, indicate whether computing is portrayed as beneficial, harmful, beneficial in\nsome ways but harmful in others, or neutral.\nQuestion 9. Do you think computers, on the whole, have more positive effects than neg-\native ones, more negative ones than positive, or about equal positive and negative effects?\nWhy?\nQuestion 10. List some ways computers are beneficial to society. Then list some ways\nthey are harmful.\nQuestion 11. Suppose you were to write a novel, play, screenplay, etc. about some aspect\nof computers and society. Describe what the theme or themes of your work would be.\nQuestion 12. What does technology mean? What are some important ways you use\ntechnology in your daily life?\nQuestion 13. Suppose you had to write a short essay or short story entitled \u201cComputers\nand Me.\u201d What would be some key points or themes in that work?\nQuestion 14. Suppose you had to write a short essay or short story entitled \u201cTechnology\nand Me.\u201d What would be some key points or themes in that work? Chapter 2\nAlgorithms\nPrecisely, step by step.\n2.1 Introduction\n2.1.1 Introductory Problem\nConsider the following problem:1\nMobile robots must navigate through their environment without bumping into obsta-\ncles. Consider the following obstacle avoidance problem. Suppose you have a very simple\nrectangular maze. There\u2019s a designated start square, a designated finish square, a single\npath from start to finish, and no dead ends. Suppose you also have a robot that can do\nthe following:\n\u2022 moveForward: move forward one square.\n\u2022 turnLeft: turn ninety degrees to its left.\n\u2022 turnRight: turn ninety degrees to its right.\n\u2022 startInMaze: this places the robot at the start square, and orients it so its first\nvalid move is straight ahead.\n\u2022 checkForWall: check if there is a wall immediately ahead, and return true if there\nis and false if there isn\u2019t.\n\u2022 checkForMazeEnd: this checks if the robot is at the end square, and returns true if\nit is and false if it isn\u2019t.\n1These notes will often start a chapter with a problem from a previous offering of CSci 1001. These\nproblems will give you an introduction to the chapter topic, as well as an example of some types of\nproblems that might appear in the homework or exams. A solution to the introductory problem will\nusually, but not always, appear at the end of the chapter.\n13 14 CHAPTER 2. ALGORITHMS\nUsing a correct combinations of these, along with other basic operations such as get\n(for input), set (to assign a name to a value used in the program), or print (for output),\ndevise an algorithm that gets a maze as input, places the robot on the start square, and\nnavigates the robot through the maze. Once the robot reaches the end, the algorithm\nshould print out a message stating it is at the end, and another stating how many moves\nit made navigating the maze.\n2.1.2 Introductory Comments\nSome universities have a class on \u201cGreat Ideas in Computer Science.\u201d As mentioned in\nChapter 1, our class differs from these great ideas classes in significant ways. However, it\nalso has similarities. In particular, the topics in this class focus on key ideas that make\ncomputer technology and practice possible.\nThefirstkeyideawe\u2019llexploreisthatofanalgorithm. Roughlyspeaking, analgorithm\nis a set of precise instructions for solving a problem. (We\u2019ll look at a more specific\ndefinition in class.) This concept is essential because accomplishing any task with a\ncomputer requires clearly and unambiguously specifying the steps a computer should\nperform to complete the task. Because this is so central to what computers do, we will\nuse algorithms again and again in this class.\nWhy, more specifically, are algorithms important? How do they appear in this class?\nHow do they relate to the course\u2019s liberal education requirements? What should you be\nable to do with algorithms? How do people represent algorithms? What is the connection\nbetween algorithms and computer programs? This chapter addresses these and related\nquestions.\n2.1.3 Motivation\nAlgorithms might seem like an odd starting topic for this class. Are algorithms really\nthat important?\nThey are. In fact, some computer scientists see algorithms as the central concept in\ncomputer science. As mentioned above, before solving a problem with a computer there\nmust be a precise specification of the steps the computer must perform. This precise\nspecification is an algorithm. Computer programs are implementations of algorithms, so\nalgorithms underlie programming. To understand how efficient a computer solution to a\nproblem is, computer scientists analyze algorithms. To create a more efficient solution\ncomputer scientists try to improve existing algorithms or discover alternative algorithms.\n(Or they might prove that a more efficient algorithm cannot exist.) There are some\nalgorithms that are important generally, such as algorithms for searching for an item in\na list, or sorting all items in a list.2 And there are important algorithms for subareas of\n2In fact, there are a number of different searching and sorting algorithms; for example, think about\nhow many different ways you can put a shuffled deck of cards in order. 2.1. INTRODUCTION 15\ncomputer science, for instance algorithms for coloring and rendering shapes in computer\ngraphics, and algorithms for merging two different database tables.\nAlgorithms will occur throughout much of this class; for example, we will see algo-\nrithms again in the chapters on algorithmic complexity and computer programming.\n2.1.4 Skills\nOnce we complete this topic, you should be able to do the following:\n1. Be able to explain what an algorithm is and isn\u2019t, why algorithms are important to\ncomputer science, and how algorithms are usually represented.\n2. Given a purported algorithm, be able to determine whether it is indeed a valid\nalgorithm; if it is not, be able to say why it is deficient.\n3. Given an incorrect algorithm or partially complete algorithm, be able to identify\nany errors, and correct or complete the algorithm.\n4. Given an algorithm, be able to trace through it and explain what it is doing.\n5. Given an algorithm to solve one problem, and given a second, related problem, be\nable to modify the algorithm to solve the related problem.\n6. Given a problem whose solution can be expressed as an algorithm, write a correct\nand valid algorithm to solve that problem.\n2.1.5 Algorithms and the Liberal Education Requirements\nHow do algorithms embody the liberal education requirements? While algorithms are not\nthe usual type of mathematics like algebra or calculus, they nonetheless exhibit many\nmathematical characteristics and require a variety of mathematical skills. For example:\n\u2022 Algorithms require the specificity, clarity, and attention to detail that is a charac-\nteristic of mathematics.\n\u2022 Algorithms use special keywords, notation, or conventions (such as indentation to\nindicate algorithm structure). This is similar to the use of special notation, etc. in\nmathematics.\n\u2022 Algorithms describe computational processes. Specifically, an algorithm describes\na procedure for doing a sequence of computations. Often individual computations\nare simple (for example, simple additions or comparisons rather than sophisticated\nmathematical functions), but the entire sequence constitutes a complicated compu-\ntational process. 16 CHAPTER 2. ALGORITHMS\nAlgorithms are also related to the society and technology theme. The readings, dis-\ncussions, and the occasional homework and\/or lab questions ask you to think about such\nquestions as\n\u2022 What types of tasks can computers do and what can\u2019t they do? Or, put another\nway, what types of tasks can be solved by algorithms, and what types cannot?\n\u2022 Is increasing automation a benefit or a concern?\n\u2022 What are some current societal problems that computer practitioners are trying to\nsolve by finding new algorithms or improving existing ones?\n2.2 Specifying Algorithms\n2.2.1 An Example\nSuppose you write software for a construction firm. For a given construction project, the\nsoftware maintains a list of on the job injuries: how many injuries occurred the first day,\nhow many the second day, etc. You need to write a function that goes through all the\ndays and counts the number of days that no injuries occurred. (Note different projects\nmight have different total numbers of days. Since we need to be flexible, let n stand for\nthe total number of days for any given project.) Here is a description of an algorithm for\nthat task:\nAlgorithm 1\nInput: A total number of days n, and a list A, with A[i] giving the number of on-the-job\ninjuries on day i.\nOutput: A message stating the number of days with 0 on-the-job injuries.\n1 Get n\n2 Get A[1], ..., A[n]\n3 Set i to 1\n4 Set countZeros to 0\n5 While i <= n\n6 If A[i] equals 0, then\n7 Set countZeros to countZeros + 1\n8 Set i to i + 1\n9 Print \u2018The number of zeros in the list is \u2019, countZeros\n10 Stop\nThis is a description of an algorithm for solving the problem. The algorithm is given in\npseudocode. Pseudocode, as the name suggests, is somewhat like programming code, but\nnot quite. Computer scientists often use pseudocode rather than a natural language (such 2.2. SPECIFYING ALGORITHMS 17\nas English) description because natural language is usually imprecise. And they usually\nuse pseudocode rather than an actual programming language for a number of reasons,\nincluding that pseudocode avoids many language rules programmers need to remember\nwhen writing program code. For example, some programming languages require a line\nof code to end with specific punctuation such as a semicolon. Remembering this (and\nremembering the exceptions where a semicolon is forbidden) is an extra burden we would\nlike to avoid when focusing only on the steps the computer must do to solve the problem.\nProblem 1: Think about some other reasons why pseudocode is often preferable to\nnatural language and to programming code for algorithm specification.\n2.2.2 Algorithm Characteristics\nBefore exploring pseudocode further, let\u2019s return to the question \u201cwhat is an algorithm?\u201d\nRecall that, generally speaking, an algorithm is a specific set of instructions for solving a\ngiven problem. More specifically, though, algorithms have certain characteristics:\n1. Input specified. The algorithm must specify any input. Note in the example above\nthe input is the number of days as well as the list containing the number of injuries\nfor each day. Two additional notes: First, since there are many different possible\ntypes of input, it is often important to specify not only what the input is, but also\nits type (examples: \u201ca string S containing alphabetic characters and digits,\u201d and\n\u201ca list A of nonnegative integers\u201d). Second, occasionally we will omit the input\nspecification for an algorithm for the sake of brevity. However, in your course work\nplease include the input specification unless otherwise instructed.\n2. Output specified. The algorithm must specify any output. Usually the output is a\nnumber, string, message, list, or some combination of these. As with input, occa-\nsionally we will omit the output specification; however, you should always include\nit unless instructed otherwise.\n3. Correctness. This characteristic is straightforward: an algorithm must solve the\nproblem correctly for all possible valid input.\n4. Finite. The algorithm finishes in a finite amount of time. Put another way, the\nalgorithm will always solve the problem and stop.\n5. Precise. Each step in the algorithm is precise, to the point it should need no further\nexplanation or expansion. Moreover, each step in the algorithm is doable by a\ncomputer. Note that the algorithm above avoids instructions such as \u201cGet the\ninput\u201d, \u201cFind all the 0\u2019s in the list,\u201d, \u201cOutput the message\u201d, or other instructions\nthat are ambiguous or insufficiently precise.\nPut another way, if the pseudocode for an algorithm is given to a programmer, he\nor she should have no questions about how the algorithm works. For that reason, 18 CHAPTER 2. ALGORITHMS\nturning pseudocode into program code is often straightforward (as computer tasks\ngo).\n6. Generality. The algorithm isn\u2019t so specific that it solves the problem only under\ncertain unnecessary restrictions. For example, the algorithm above solves the prob-\nlem for a general number of days n. The number is not restricted to a single value\n\u2014 an algorithm that solved the problem only for projects that lasted, say, exactly\n14 days would not be very useful.3\nProblem 2: Consider the following set of instructions. It is a valid algorithm or not? If\nit is not, state which characteristic or characteristics it does not possess.\n(Purported) Algorithm 2\nInput: A total number of days n, and a list A, with A[i] giving the maximum temperature\nin degrees Fahrenheit on day i.\n1 Get n\n2 Get A[1], ..., A[n]\n3 Set maxTemp to A[1]\n4 Set i to 2\n5 While i <= n\n6 If A[i] > maxTemp\n7 Set maxTemp to A[i]\n8 Print \u2018The maximum temperature was \u2019, maxTemp\n9 Stop\n2.2.3 Pseudocode Characteristics\nNote some characteristics of the pseudocode description in Algorithm 1:\n\u2022 It is highly structured. It contains a sequence of operations along with the control\ninstructions if and while.\n\u2022 It contains a mixture of English and operations. Specifically, it contains some En-\nglish words such as get, if, and print, and some mathematical notation and op-\nerations such as n, A[1], and addition.\n\u2022 All the instruction in it are low-level. Put another way, each step is specific \u2014\nspecific enough that a person should be able to perform the instructions without\nfurther explanation.\n3Actually the algorithm is more general than stated \u2014 it counts the number of zeros in an arbitrary\nlistofnumbersregardlessofwhetherthelistholdsnumberofon-the-jobinjuriesonaconstructionproject,\nmaximum temperatures, number of diabetes-related hospital admissions, numbers of times you played\nTetris, etc. 2.3. PSEUDOCODE 19\nThese characteristics describe pseudocode: it is sufficiently specific and low-level to be\nused in algorithm specification, but contains a simple structure and enough English con-\nstructs that it is easier to read and understand than computer code. In the next section\nwe\u2019ll look at the details of pseudocode.\n2.3 Pseudocode\nLearning the basics of pseudocode is not difficult. Instead the challenge is using the basics\nto specify algorithms. This section presents pseudocode basics. In subsequent sections\nwe\u2019ll look at using the basics.\nBefore beginning, we should note there are many different versions of pseudocode.\nAll versions allow you to specify any algorithm, so all versions have much in common.\nHowever, they often differ in instruction names or other conventions. The version of\npseudocode in this class is a simple one. However, be aware that different textbooks\nmight use other versions.\n2.3.1 Sequence, Selection, Repetition\nTo describe an algorithm, you need three basic control mechanisms:\n\u2022 Sequence. Unless otherwise specified, steps are followed in sequence, one after an-\nother. So the algorithm above executes Line 1, then Line 2, then Line 3, etc.\n\u2022 Selection. There are times when we want steps to be performed only if a certain\ncondition or conditions hold. Line 7 in Algorithm 1 is done only if the condition in\nLine 6 is true. The if statement in Line 6 is an example of a selection statement.\n\u2022 Repetition. Often there are parts of algorithms that are repeated many times. An\nexample of this is the \u201cwhile loop\u201d in Lines 5\u20138 in Algorithm 1; this loop allows the\nalgorithm to check each number in the list.\nPseudocode must include these three control mechanisms. Sequence is easy \u2014 simply\nlist the steps in order. (Note line numbers are not absolutely necessary, so we will include\nthem only when useful.) Selection uses the if construct and its variants such as if-else.\nRepetition uses while loops or for loops.\n2.3.2 Indentation\nNotice the indentation in Algorithm 1. This indicates the \u201cscope\u201d of the while and if\ninstructions there. Specifically, the indentation of Lines 6 through 8 indicates the \u201cbody\u201d\nof the while loop that starts in Line 5. The indentation lets a reader know that the\ninstructions in Lines 6 through 8 should be performed as long as the condition in Line 20 CHAPTER 2. ALGORITHMS\n5 is true. Once Line 5 is executed when that condition is no longer true, the algorithm\nskips to Line 9.4\nNotice also the further indentation in Line 7. This is the body of the if statement.\nThe indentation indicates that this statement should be executed only if the condition in\nLine 6 is true. If the condition is false, then the algorithm skips Line 7 and resumes with\nLine 8.\nLine 7 is a single-statement body of the if instruction. Multiple-statement bodies,\nsuch as the one for the while loop, are also possible for if statements. For example,\nsuppose each time a 0 was found you wanted the algorithm not only to update the count,\nbut also to print a short message. Then you could include another line right after Line 7,\nwith the same level of indentation:\n6 If A[i] equals 0, then\n7 Set countZeros to countZeros + 1\n7b Print \u2018No injuries on day \u2019, i\n8 Set i to i + 1\nLines 7 and 7b would be executed if the condition in Line 6 is true. Otherwise, neither\nwould be executed, and the algorithm would skip to Line 8.\nAs Algorithm 1 indicates, you can \u2018nest\u2019 control structures. In particular, it has an if\nstatement within a while loop. Pseudocode has only a few basic building blocks, but can\ndescribe very complicated algorithms because of the ways you can combine these building\nblocks. You can place loops within loops (this is useful, for example, if you are looping\nthrough a table: one loop will step through the columns, the other through the rows),\nif\u2019s within if\u2019s (useful when you have complicated selection conditions), loops within\nif\u2019s or if\u2019s within loops, etc.\n2.3.3 Other Basic Pseudocode Commands\nIn addition to if statements and their variants such as if-else, and while and for\nstatements,5 pseudocode has a few other basic building blocks. Each of these appears in\nAlgorithm 1 above.\n\u2022 get allows the algorithm to obtain input.\n\u2022 set allows the algorithm to assign a value to a variable.\n\u2022 printallowsthealgorithmtooutputamessageorthevalueofoneormorevariables.\n4NotethattheloopconditioninLine5mustbecomefalseatsomepointforthealgorithmtocontinue\npast the loop and eventually stop. A loop that never stops is called an \u201cinfinite loop.\u201d\n5The if-else and for statements haven\u2019t been discussed yet. Problem 3 below contains an example\nof if-else use. However, for loops won\u2019t appear until later in the class. 2.4. ADDITIONAL COMMENTS ON PSEUDOCODE 21\n\u2022 stop indicates the termination of the algorithm. Usually it is the last line of the\nalgorithm, but complicated algorithms may have more than one stop. For example,\nit is possible to have a stop statement at the end of an if-body.6\nIn addition to these basic building blocks, pseudocode can use basic arithmetic and other\noperations. Algorithm 1 contains arithmetic comparisons in Lines 5 and 6, and simple\nadditions in Lines 7 and 8. Pseudocode can also include other operations including sub-\ntraction, multiplication, division, exponentiation, and finding remainders; using functions\nsuch as square roots, sines and cosines, and logarithms; comparing alphabetic characters,\nor concatenating two alphabetic strings.\n2.4 Additional Comments on Pseudocode\nThis section contains additional comments on a few potentially confusing aspects of pseu-\ndocode.\n2.4.1 Different Ways of Expressing an Operation\nThere are a number of different ways to express the same concept using pseudocode. For\nexample, suppose we want to set the value of the variable s to 42. Ways to write this\ninclude\ns = 42\nSet s = 42\nSet s to 42\nSet the value of s to 42\ns <- 42\nWhatever way you write operations like this should be precise, and should be used consis-\ntently; but otherwise use whichever alternative you feel most comfortable with. Moreover,\nwhen you are given an algorithm, recognize that it might use slightly different terms and\nnotation than you\u2019ve seen in class.\n2.4.2 What is a Variable?\nThe language surrounding \u201cvariables\u201d can be a little complicated. Here are two issues.\nThe next subsection discusses an additional one.\nFirst, variables can hold any values that can be represented within a computer. Often\nthis is a number, e.g., Set x to 42. However, it could also be a list or a character string,\nfor example Set A to the list 1,2,3,4,5 or Set A to the string \"TTCCAGC\", or\n6Some versions of pseudocode omit the stop command with the understanding that an algorithm\nstops when it runs out of lines to execute. 22 CHAPTER 2. ALGORITHMS\nSet A to the string \"string\". Notice in all these cases there is a difference between\nthe variable name, and the variable value. For example, in Set x to 42 the variable\nname is x, while the value is 42.\nSecond, we indicate strings by enclosing them in single or double quotes. So, e.g., the\nstatement Set a to \u2018b\u2019 means set the value of the variable a to the single character\n\u2018b\u2019. However, the statement Set a to b means set the value of the variable a to the\nvalue of the variable b. Note the reason for the possible confusion here \u2014 any character\nor string can be a variable name, or it can be a character value assigned to a variable.\nIt\u2019s important to keep these two different uses straight.\nProblem 3: To explore the difference between variables names and values further, trace\nthrough the following code and figure out what it prints:\n1 Set a to \u2018x\u2019\n2 Set b to \u2018y\u2019\n3 If a equals b then\n4 Set a to \u2018b\u2019\n5 Else\n6 Set a to b\n7 Print a\n8 Stop\nThe answer is at the end of this chapter.\n2.4.3 Lists, etc.\nLists, strings, and tables have a variable name (e.g., A in Algorithm 1 above), but contain\na number of values. So when working with them we also need to keep track of a string\nlocation, list position, etc. Consider Set myString to \"CGATG\". Then the second item\nin the string is the character \u2018G\u2019. Notice that if we want to refer to that item we can\u2019t just\nsay \u201cthe character \u2018G\u2019 in the string\u201d since there can be more than one \u2018G\u2019. So in this case\nthere is the string name, A, the location in the string, 2, and the value at that location,\n\u2018G\u2019.\nOne additional caution: there are different terms for \u2018location\u2019. Some algorithms will\nreferencethesecondlocationinthestringmyStringbysaying\u2018index2\u2019, \u2018slot2\u2019, \u2018subscript\n2\u2019, \u2018location 2\u2019, \u2018entry 2\u2019, \u2018item 2\u2019, \u2018position 2\u2019, \u2018myString[2]\u2019, myString and so on. The\n2\nlack of a standard term and notation for this can be confusing. However if you keep the\nkey point here in mind \u2014 that in a list or string there is a name, a location (or index,\netc.), and the value in the list or string at that location \u2014 you\u2019ll find it easier to work\nwith lists and strings. 2.4. ADDITIONAL COMMENTS ON PSEUDOCODE 23\n2.4.4 Variable Names\nIn pseudocode (as in most programming languages) you can name variables anything\nreasonable. Here are some general guidelines.\n\u2022 Descriptive names: Usedescriptivevariablenames. Forexample, ifyouarecounting\nthe number of times something occurs in a list or table, then the variable name\nis usually something like count. Longer or more descriptive names are possible,\nincluding multiword names such as countZeros or count zeros (note these use\ncapitalization and the underscore, respectively \u2014 you should not have a space in a\nvariable name). You don\u2019t want to get carried away with too long of a name, but\nusing a descriptive name can help keep variables straight, and make an algorithm\neasier to read.\nAs an example, suppose you are working with a table and need to keep track of the\ncurrent row and column. So you could call the related variables row and column, or\nr and c. Both these choices are more descriptive to someone reading the algorithm\nthan, say, a and b, or x and y.7\n\u2022 Loop control variables: i and j are commonly used as loop control variables, e.g.,\nWhile i < 10.\n\u2022 n: The variable n is often used to hold an input value, as in the following:\nGet n\nPrint \u2018n squared is \u2019, n * n\nA second common use is to indicate the length of a list (or some other upper limit).\nSuppose you have a list of the number of hours per day you worked over an n-day\nperiod. The following algorithm computes the total number of hours you worked:\nAlgorithm 3: Sum the numbers in a list\nInput: A total number of days n, and a list of numbers A.\nOutput: A message stating the sum of all the numbers in the list A.\nGet n\nGet A[1],..., A[n]\nSet i to 1\nSet sum to 0\nWhile i <= n\n7Asanotherexample, rewritethepseudocodeinSection2.4.2byreplacingthevariablenamesaandb\nby firstChar and secondChar, respectively. But leave the value \u2018b\u2019 in Line 4 as it is. The pseudocode\nshould be easier to understand. 24 CHAPTER 2. ALGORITHMS\nSet sum to sum + A[i]\nSet i to i+1\nPrint \u2018The list sum is \u2019, sum\nStop\n2.4.5 Pseudocode Summary\nIn pseudocode you do not have a large number of basic building blocks. You have a way\nof getting input, a get statement. You have a way of assigning values to variables, a set\nstatement. You have the usual low-level operations on numbers, characters, strings, and\nlists. For example, you can add two numbers, compare two numbers, etc. You have an\nif statement, and variants such as if-else. You have loop statements while and for.\nYou use indentation to indicate the scope of a selection or loop construct. You have an\noutput statement print. And you have a stop statement. Although later in the class\nwe\u2019ll see a few more parts of pseudocode, these are the essential parts and are enough to\nspecify both simple and complicated algorithms.\n2.5 Some Practice\nThis section contains some introductory practice problems. Answers are at the end of the\nchapter.\n2.5.1 Writing Pseudocode Fragments\nProblem 4: One stepping stone to writing an entire algorithm is to make sure you can\nwrite small fragments of pseudocode. Write pseudocode to do the following. In each case\nassume you have already gotten any input. Moreover, do not worry about printing any\noutput.\na. Set count to 0 if a is less than 5.\nb. Set count to 0 if a is less than 5 and b is less than 2; otherwise set count to 1.\nc. Add 1 to a five-digit odometer reading. Note a five-digit odometer can show values\nbetween 0 and 99999. Adding 1 to any odometer reading will simply increase that\nreading by 1 \u2014 for example 67817 will go to 67818 \u2014 except if the reading is 99999,\nin which case it will roll over to 0.\nd. Calculate the sum of the integers between 1 and 42.\ne. Count the number of T\u2019s in a genomic sequence (i.e., a sequence consisting of char-\nacters \u2018A\u2019, \u2018C\u2019, \u2018G\u2019, or \u2018T\u2019) A[1],...,A[n]. 2.5. SOME PRACTICE 25\nf. Count the number of times the two-character sequence \u2018TG\u2019 appears in a genomic\nsequence A[1],...,A[n]. That is, count the number of times a \u2018T\u2019 occurs in a\nlocation that is immediately followed by a \u2018G\u2019 in the next location.\n2.5.2 Reading an Algorithm\nProblem 5: Consider the following algorithm:\nAlgorithm 4:\nInput: A nonempty string of characters S S ...S , and a positive integer n giving the\n1 2 n\nnumber of characters in the string.\nOutput: See the related problem below.\n1 Get n\n2 Get S S ...S\n1 2 n\n3 Set count to 1\n4 Set ch to S\n1\n5 Set i to 2\n6 While i \u2264 n\n7 If S equals ch\ni\n8 Set count to count+1\n9 Set i to i+1\n10 Print ch, \u2018 appeared \u2019, count, \u2018 times.\u2019\n11 Stop\na. What is printed if the input string is pepper?\nb. What is printed if the input string is CACCTGGTCCAAC?\nc. What is the output of this algorithm (in general)? Be precise.\nd. Suppose line 3 was changed to Set count to 0. How would your answer to part\n(c) change?\n2.5.3 Common Mistakes\nThere are a numerous mistakes that can come up in writing pseudocode. Some are easier\nto make than others, and even experienced computer practitioners make them from time\nto time.\nProblem 6: Suppose you are studying lake level data for a certain lake. This data\nreports the lake levels over a number of days, compared to the lake\u2019s average (mean)\nlevel. Negative data correspond to times when the lake level was below average, positive\nto when it was above. So, for example, a lake level of \u2212.23 meters means that at the\ntime of that reading the lake was .23 meters lower than average. A reading of .12 meters 26 CHAPTER 2. ALGORITHMS\nmeans the level was .12 meters above the average level at the time of that reading. You\nwould like to know how many readings were below the lake average.\nMore generally, the following pseudocode attempts to count the number of negative\nentries in an input list A[1],..., A[n]:\n1 Get n\n2 Get A[1],..., A[n]\n3 Set countNegativeEntries to 0\n4 While i < n\n5 If A[j] <= 0, then\n6 Set countNegativeEntries to countNegativeEntries + 1\n7 Print \u2018The number of negative entries is \u2019, countNegativeEntries\n8 Stop\nIdentify and correct any mistakes in this pseudocode.\n2.6 Two Examples For Class\nHere are two additional algorithm examples we will use in class. The first one performs\na common operation, counting the number of times a given character occurs in a string\n(think of specific examples where this can be useful.) The second algorithm counts the\nnumber of times a given pattern (which can consist of more than one character) occurs\nin a string. This algorithm is more complicated, so expect to spend some time examining\nit. 2.7. WRITING ALGORITHMS: HOW TO BEGIN? 27\nAlgorithm 5: Character Count\nInput: A string length n and a text string S S ...S of alphabetic characters, as well as\n1 2 n\na search character ch.\nOutput: A message indicating how many times ch appears in S.\n1 Get n\n2 Get S S ...S\n1 2 n\n3 Get ch\n4 Set i to 1\n5 Set count to 0\n6 While i \u2264 n do\n7 If S equals ch then\ni\n8 Set count to count+1\n9 Set i to i+1\n10 Print ch, \u2018 appeared \u2019, count, \u2018 times.\u2019\n11 Stop\nAlgorithm 6: Pattern Matching\nInput: A string length n and a text string S S ...S of alphabetic characters, as well as\n1 2 n\na pattern length m and a pattern P P ...P of alphabetic characters.\n1 2 m\nOutput: A message indicating each time the pattern P matches a substring of S.\n1 Get n\n2 Get S S ...S\n1 2 n\n3 Get m\n4 Get P P ...P\n1 2 m\n5 Set i to 1\n6 While i \u2264 n\u2212m+1 do\n7 Set j to 1\n8 Set matchOK to true\n9 While j \u2264 m and matchOK equals true then\n10 If P (cid:54)= S then\nj i+j\u22121\n11 Set matchOK to false\n12 Set j to j +1\n13 If matchOK equals true then\n14 Print \u2019Match found between positions \u2019, i, \u2019 and \u2019, i+m\u22121\n15 Set i to i+1\n16 Stop\n2.7 Writing Algorithms: How to Begin?\nWhen you are writing an algorithm from scratch, often the most difficult part is getting\nstarted. Inclasswewilldiscusstechniques\u2014suchastop-downdesign, workingaconcrete 28 CHAPTER 2. ALGORITHMS\nexample, or figuring out what you need to keep track of during an algorithm \u2014 that can\nbe helpful. Here we\u2019ll give an example of one of these techniques, top-down design.\nSuppose you are given a maze8 that consists of a 10 \u00d7 10 grid. That is, the maze\nconsists of 10 rows and 10 columns of squares. Suppose that you can specify a row and\ncolumn number, and do a check isOpenNorth, that returns true if there is an opening\non the \u201cnorth\u201d side of the current square, and false otherwise. Also, you can do checks\nisOpenEast, isOpenWest, and isOpenSouth to check the east, west, and south sides,\nrespectively.\nSuppose further that, instead of solving the maze, you need to write an algorithm\nto go though and count the number of maze locations that are enclosed on exactly three\nsides (that is, the locations where there are walls on any three of the sides, but an opening\non the fourth). To do this you are allowed to step through the maze as if it were a table,\ni.e., row by row and column by column. Put another way, you don\u2019t need to follows paths\nthrough the maze to visit each square; instead you have a \u201cbirds-eye view.\u201d\nWhat are the major tasks such an algorithm would need to do? A very crude high\nlevel outline is\nGet input\nCount locations enclosed on exactly 3 sides\nOutput result\nOf these three items, the second will be the most complicated, so let\u2019s focus on it and\nbreak it down further. We need to step through all the locations and count the number\nof walls. So a more detailed breakdown can be something like this:\nStep through each location\nIf the current location has exactly 3 walls\nCount it\nNote that this isn\u2019t pseudocode yet, though. For example, what does it mean to step\nthrough each location? What does it mean to count it? So we can be more specific:\nFor each row r\nFor each column c\nIf the location at row r column c is enclosed on exactly 3 sides\nAdd one to the count\nWe\u2019re closer. But there are still additional details we need to include. For example, For\neach row r is still imprecise, as is For each column c. Another issue is we need to\ninitialize count, and update it when appropriate. Here\u2019s another attempt:\n8Important: If there is a maze problem on the homework, some parts of the notes will be helpful on\nthat problem, but other parts will not. Do not rely overmuch on this example in solving any homework\nproblem involving mazes. 2.8. QUESTIONS TO THINK ABOUT FOR CLASS 29\nSet r to 1\nSet c to 1\nSet count to 0\nWhile r <= 10\nWhile c <= 10\nIf the location at row r column c is enclosed on exactly 3 sides\nSet count to count + 1\nSet c to c + 1\nSet r to r + 1\nTo complete this part, notice that the condition If the location is enclosed on\nexactly 3 sides still needs to be made more specific as well.\nProblem 7: Make the following line more specific:\nIf the location at row r column c is enclosed on exactly 3 sides\n2.8 Questions to Think About For Class\nHere are questions to think about for class.\n1. What types of problems can be solved by algorithms? What types can\u2019t, or can\u2019t\neasily?\n2. Thinkaboutanareayouareinterestedinoutsideofcomputerscience. Arethereany\nprocesses in that area that need to be carefully and precisely specified (regardless\nof whether they are done by computer or not)?\n3. Cooking recipes, and instructions for putting together furniture are two analogies\nused for algorithms. For each one, explain how it is like an algorithm, and how it is\nnot. Also, think of other analogies.\n4. Suppose you are explaining algorithms to another student. What is hard about\nalgorithms \u2014 what would you be sure to explain very carefully?\n5. Come up with some specific examples where you might want the following: (a) a\ntriply nested loop, (b) a loop inside an if statement, (c) one if statement inside\nanother.\n2.9 Additional Practice\nHere are three additional practice problems. Solutions are in the next section.\nProblem 8: Trace through Algorithm 6, the pattern matching algorithm, when the text\nstring S is CGCCCTACCGGCACC and the pattern string P is CC. Specifically, (a) state what 30 CHAPTER 2. ALGORITHMS\nthe output would be, and (b) each time line 15 is reached write the current values of i\n(before 1 is added to i in that line), j, and matchOK.\nProblem 9: This question again asks you to consider the pattern matching algorithm,\nAlgorithm 6. Suppose that instead of printing a message whenever there was a match,\nyou just want the algorithm to output the number of times matches occur. For example,\nsuppose the text string S is ATGCATAGATT, and the pattern P is AT. Then the algorithm\nshould output only the message\nThere were 3 matches.\nModify the pattern-matching algorithm to do this. For your answer you may either write\nthe entire algorithm, or you may just indicate exactly what needs to be added or modified\nexactly where.\n2.10 Problem Solutions\n2.10.1 Introductory Problem\nHere is a model solution to the problem at the beginning of this chapter. Note that for\nsome problems, including this one, there is more than one possible correct solution. So\nthis is one possible algorithm, but not the only possible correct one.\n1 Get the input maze\n2 startInMaze\n3 moveForward\n4 Set count to 1\n5 While checkForMazeEnd returns false\n6 If checkForWall returns true\n7 turnRight\n8 If checkForWall returns true\n9 turnLeft \/\/ turn back to original heading\n10 turnLeft \/\/ now turn left from that heading\n11 moveForward\n12 Set count to count+1\n13 Print \u2018Robot found end of maze.\u2019\n14 Print \u2018Number of moves: \u2019, count\n15 Stop\n2.10.2 Additional Problems\nProblem 1: This problem will likely be discussed in class or lab. 2.10. PROBLEM SOLUTIONS 31\nProblem 2: It is not a valid algorithm. It is neither correct nor finite since the i value\nis always 2 (the algorithm should contain a line Set i to i + 1 between Lines 7 and\n8) indented at the same level as the if in Line 6). Also, it fails to specify the output\nexplicitly.\nHere is a correct version:\n(Corrected) Algorithm 2\nInput: A total number of days n, and a list A, with A[i] giving the maximum temperature,\nin degrees Fahrenheit, on day i.\nOutput: A message stating the maximum temperature.\n1 Get n\n2 Get A[1], ..., A[n]\n3 Set maxTemp to A[1]\n4 Set i to 2\n5 While i <= n\n6 If A[i] > maxTemp\n7 Set maxTemp to A[i]\n8 Set i to i + 1\n9 Print \u2018The maximum temperature was \u2019, maxTemp\n10 Stop\nProblem 3: The pseudocode would print out the character \u2018y\u2019. Note in line 3, a and b\ndo not have equal values, since a has value \u2018x\u2019 and b has value \u2018y\u2019. So the else statement\nis executed, setting the value of a to the value of b, namely \u2018y\u2019.\nProblem 4:\n[a.]\nIf a < 5\nSet count to 0\n[b.]\nIf a < 5 and b < 2\nSet count to 0\nElse\nSet count to 1\n[c.]\nIf odometerReading equals 99999\nSet odometerReading to 0\nElse\nSet odometerReading to odometerReading + 1 32 CHAPTER 2. ALGORITHMS\n[d.]\nSet i to 1\nSet sum to 0\nWhile i <= 42\nSet sum to sum + i\nSet i to i + 1\n[e.]\nSet i to 1\nSet countT to 0\nWhile i <= n\nIf A[i] equals \u2018T\u2019\nSet countT to countT + 1\nSet i to i + 1\n[f.]\nSet i to 1\nSet countTG to 0\nWhile i <= n - 1\nIf A[i] equals \u2018T\u2019 and A[i+1] equals \u2018G\u2019\nSet countTG to countTG + 1\nSet i to i + 1\nProblem 5:\na. p appeared 3 times.\nb. C appeared 6 times.\nc. A message stating the number of times the first character of the word appears in\nthe word.\nd. The number in the output message would be the number of times the first character\nof the word appears in the word, excluding the first occurrence.\nProblem 6: There are six errors.\n1. i is never initialized \u2014 there should be a line Set i to 1 prior to the while loop.\n2. The loop continuation condition is incorrect: i < n stops before the last item in\nthe list, A[n]. The loop condition should be i <= n.\n3. In line 5 A[j] should be A[i]. 2.10. PROBLEM SOLUTIONS 33\n4. In line 5 <= should be <.\n5. i is never updated in the loop: there should be a line Set i to i + 1 at the end\nof the while loop.\n6. The print line\u2019s indentation is incorrect: In the pseudocode the incorrect indenta-\ntion places the print line inside the while loop, meaning it is executed during each\niteration of that loop. It should be executed only once, after the while loop is done.\nTherefore its indentation should be the same as the \u2018While\u2019 in Line 4.\nProblem 7:\nSet countOpenings to 0\nIf isOpenNorth at row r column c equals true\nSet countOpenings to countOpenings + 1\nIf isOpenEast at row r column c equals true\nSet countOpenings to countOpenings + 1\nIf isOpenSouth at row r column c equals true\nSet countOpenings to countOpenings + 1\nIf isOpenWest at row r column c equals true\nSet countOpenings to countOpenings + 1\nIf countOpenings equals 3\nSet count to count + 1\nProblem 8:\na. The output would be\nMatch found between positions 3 and 4\nMatch found between positions 4 and 5\nMatch found between positions 8 and 9\nMatch found between positions 14 and 15\nb. Here are the values immediately prior to each execution of the line 15: 34 CHAPTER 2. ALGORITHMS\ni j matchOK\n--- --- -------\n1 3 false\n2 2 false\n3 3 true\n4 3 true\n5 3 false\n6 2 false\n7 2 false\n8 3 true\n9 3 false\n10 2 false\n11 2 false\n12 3 false\n13 2 false\n14 3 true\nProblem 9: Here is one possibility.\nInput: A string length n and a text string S S ...S of alphabetic characters, as well as\n1 2 n\na string length m and a pattern P P ...P of alphabetic characters.\n1 2 m\nOutput: A message indicating the number of times the pattern P matches a substring of\nS. (changed)\n1 Get n\n2 Get S S ...S\n1 2 n\n3 Get m\n4 Get P P ...P\n1 2 m\n5 Set i to 1\n6 Set count to 0 \/\/ Added\n7 While i \u2264 n\u2212m+1 do\n8 Set j to 1\n9 Set matchOK to true\n10 While j \u2264 m and matchOK equals true then\n11 If P (cid:54)= S then\nj i+j\u22121\n12 Set matchOK to false\n13 Set j to j +1\n14 If matchOK equals true then\n15 Set count to count+1 \/\/ Changed\n16 Set i to i+1\n17 Print \u2018There were \u2019, count, \u2018 matches.\u2019 \/\/Added\n18 Stop Chapter 3\nData Representation\nIt is all 0\u2019s and 1\u2019s.\n3.1 Introductory Problem\nComputers often represent colors as an RGB (red-green-blue) triple of numbers, where\neach of the red, green, and blue components is an integer between 0 and 255. For example,\nthecolor(255,0,10)hasfullred,nogreen,andasmallamountofblue. Writeanalgorithm\nthat takes as input the RGB components for a color, and returns a message indicating\nthe largest component or components. For example, if the input color is (100, 255, 0),\nthe algorithm should output \u201cLargest component(s): green\u201d. And if the input color\nis (255, 255, 255), then the algorithm should output \u201cLargest component(s): red,\ngreen, blue\u201d.\n3.2 Overview\nOne amazing aspect of computers is they can store so many different types of data. Of\ncourse computers can store numbers. But unlike simple calculators they can also store\ntext; and they can store colors, and images, and audio, and video, and many other types\nof data. And not only can they store many different types, but they can also analyze\nthem, and they can transmit them to other computers. This versatility is one reason why\ncomputers are so useful, and affect so many areas of our lives.\nTo understand computers and computer science, it is important to know something\nabout how computers deal with different types of data. Let\u2019s return to colors. How are\ncolors stored in a computer? The introductory problem states one way, namely as an\nRGB triple. This is not the only possible way: RGB is just one of many color systems.\nFor example, sometimes colors are represented as an HSV triple: by hue, saturation, and\nvalue. However, RGB is the most common color representation in computer programs.\nThis leads to a deeper issue: how are numbers stored in a computer? And why is it\n35 36 CHAPTER 3. DATA REPRESENTATION\nimportantanywaythatweunderstandhownumbers, andotherdifferenttypesofdata, are\nstored and processed in a computer? This chapter deals with these and related questions.\nIn particular, we will look at the following:\n1. Why is this an important topic?\n2. How do computers represent numbers?\n3. How do computers represent text?\n4. How do computers represent other types of data such as images?\n5. What is the binary number system and why is it important in computer science?\n6. How do computers do basic operations such as addition and subtraction?\n3.2.1 Goals\nUpon completing this chapter, you should be able to do the following:\n1. Be able to explain how, on the lowest level, computers represent both numeric and\ntext data, as well as other types of data such as color data.\n2. Be able to explain and use the basic terminology in this area: bit, byte, megabyte,\nRGB triple, ASCII, etc.\n3. Be able to convert numbers and text from one representation to another.\n4. Be able to convert integers from one representation to another, for example from\ndecimal representation to two\u2019s complement representation.\n5. Be able to add and subtract numbers written in unsigned binary or in two\u2019s com-\nplement representation.\n6. Be able to explain how the number of bits used to represent data affects the range\nand precision of the representation.\n7. Be able to explain in general how computers represent different types of data such\nas images.\n8. Be able to do calculations involving amounts of memory or download times for\ncertain datasets. 3.2. OVERVIEW 37\n3.2.2 Data Representation and Mathematics\nHow is data representation related to the liberal education mathematics requirement?\nAs you might guess, there is a strong connection. Computers store all data in terms of\nbinary (i.e., base 2) numbers. So to understand computers it is necessary to understand\nbinary. Moreover, you need to understand not only binary basics, but also some of the\ncomplications such as the \u201ctwo\u2019s complement\u201d notation discussed below.\nBinary representation is important not only because it is how computers represent\ndata, but also because so much of computers and computing is based on it. For example,\nwe will see it again in the chapter on machine organization.\n3.2.3 Data Representation and Society and Technology\nThe computer revolution. That is a phrase you often hear used to describe the many ways\ncomputers are affecting our lives. Another phrase you might hear is the digital revolution.\nWhat does the digital revolution mean?\nNowadays, many of our devices are digital. We have digital watches, digital phones,\ndigital radio, digital TVs, etc. However, previously many devices were analog. According\nto the Merriam-Webster online dictionary1 \u201canalog\u201d means \u201cof or relating to a device\nor process in which data is represented by physical quantities that change continuously.\u201d\nThink, for example, of an old watch with second, minute, and hour hands that moved\ncontinuously (although very slowly for the minute and hour hands). Compare this with\nmany modern-day watches that shows a digital representation of the time such as 2:03:23.\nThis example highlights a key difference between analog and digital devices: analog\ndevices rely on a continuous phenomenon and digital on a discrete one. As a second\nexample of this difference, an analog radio receives audio radio broadcast signals which\nare transmitted as radio waves, while a digital radio receives signals which are streams of\nnumbers.2\nThe digital revolution refers to the many digital devices, their uses, and their effects.\nThese devices include not only computers, but also other devices or systems that play a\nmajor role in our lives, such as communication systems.\nBecause digital devices usually store numbers using the binary number system, a\nmajor theme in this chapter is binary representation of data. Binary is fundamental to\ncomputers and computer science: to understand how computers work, and how computer\nscientists think, you need to understand binary. The first part of this chapter therefore\ncovers binary basics. The second part then builds on the first and explains how computers\nstore different types of data.\n1http:\/\/www.merriam-webster.com\/dictionary\/. Accessed Oct. 1, 2013.\n2Actually, it\u2019s more complicated than that because some devices, including some digital radios, in-\ntermix digital and analog. For example, a digital radio broadcast might start in digital form, i.e., as a\nstream of numbers, then be converted into and transmitted as radio waves, then received and converted\nback into digital form. Technically speaking the signal was modulated and demodulated. If you have a\nmodem (modulator-demodulator) on your computer it fulfills a similar function. 38 CHAPTER 3. DATA REPRESENTATION\n3.3 Representation Basics\n3.3.1 Introduction\nThe algorithms chapter discussed ways to describe a sequence of operations. Computer\nscientists use algorithms to specify behavior of computers. But for these algorithms to be\nuseful they need data, and so computers need ways to represent data.3\nPeople have many ways to represent even a very simple number. For example, the\nnumber four can be represented as 4 or IV or |||| or 2 + 2, etc. How do computers\nrepresent numbers? (Or text? Or audio files?)\nThe way computers represent and work with numbers is different from how we do.\nSince early computer history the standard has been the binary number system. Com-\nputers \u201clike\u201d binary because it is extremely easy for them. However, binary is not easy\nfor humans. Most of the time people do not need to be concerned with the internal\nrepresentations that computers use; however, sometimes they do.\n3.3.2 Why Binary?\nSuppose you and some friends are spending the weekend at a cabin. The group will travel\nin two separate cars, and you all agree that the first group to arrive will leave the front\nlight on to make it easier for the later group. When the car you are in arrives at the cabin\nyou will be able to tell by the light if your car arrived first. The light therefore encodes\ntwo possibilities: on (the other group has already arrived) or off (the other group hasn\u2019t\narrived yet).\nTo convey more information you could use two lights. For example, both off could\nmean the first group hasn\u2019t arrived yet, the first light off and second on indicate the first\ngrouphasarrivedbutlefttogetsupplies, thefirstonandsecondoffthatthegrouparrived\nbut left to go fishing, and both on that the group has arrived and hasn\u2019t left.\nNote the key ideas here: a light can be on or off (we don\u2019t allow different level of light,\nmultiple colors, etc.), just two possibilities. But the second is that if we want to represent\nmore than two choices we can use more lights.\nThis on or off idea is a powerful one. There are two and only two distinct choices\nor states: on or off, 0 or 1, black or white, present or absent, large or small, rough or\nsmooth, etc. \u2014 all of these are different ways of representing possibilities. One reason\nthe two-choice idea is so powerful is it is easier to build objects \u2014 computers, cameras,\nCDs, etc. \u2014 where the data at the lowest level is in two possible states, either a 0 or a\n1.4\n3Actually we need not only data, but a way to represent the algorithms within the computer as well.\nHow computers store algorithm instructions is discussed in a later chapter.\n4Of course how a 0 or 1 is represented varies according to the device. For example, in a computer the\ncommonwaytodifferentiatea0froma1isbyelectricalproperties, suchasusingdifferentvoltagelevels.\nIn a fiber optic cable, the presence or absence of a light pulse can differentiate 0\u2019s from 1\u2019s. Optical\nstorage devices can differentiate 0\u2019s and 1\u2019s by the presence or absence of small \u201cdents\u201d that affect the 3.3. REPRESENTATION BASICS 39\nIn computer representation, a bit (i.e., a binary digit) can be a 0 or a 1. A collection of\nbits is called a bitstring. A bitstring that is 8 bits long is called a byte. Bits and bytes are\nimportant concepts in computer storage and data transmission, and later on we\u2019ll explain\nthem further along with some related terminology and concepts. But first let\u2019s look at\nthe basic question of how a computer represents numbers.\n3.3.3 Review of the Decimal Number System\nWe all know decimal (i.e., base 10) representation and use it every day. So, for example,\nthe number one hundred and twenty-four is 1\u00d7100+2\u00d710+4\u00d71. We can emphasize\nthis by writing the powers of 10 over the digits in 124:\n102 101 100\n1 2 4\nSo if we take what we know about base 10 and apply it to base 2 we can figure out\nbinary. But first recall that a bit is a binary digit and a byte is 8 bits. In this file most\nof the binary numbers we talk about will be one byte long.\n(Computers actually use more than one byte to represent most numbers. For example,\nmost numbers are actually represented using 32 bits (4 bytes) or 64 bits (8 bytes). The\nmore bits, the more different values you can represent: a single bit permits 2 values, 2 bits\ngive 4 values, 3 bits gives 8 values, ..., 8 bits give 256 values, and in general n bits gives\n2n values. When looking at binary examples we\u2019ll usually use 8 bit numbers to make the\nexamples manageable.)\n3.3.4 Unsigned Binary\nWhen we talk about decimal, we deal with 10 digits \u2014 0 through 9 (that\u2019s where decimal\ncomes from). In binary we only have two digits, that\u2019s why it\u2019s binary. The digits in\nbinary are 0 and 1. You will never see any 2\u2019s or 3\u2019s, etc. If you do, something is wrong.\nA bit will always be a 0 or 1.\nCounting in binary proceeds as follows:\n0 (decimal 0)\n1 (decimal 1)\n10 (decimal 2)\n11 (decimal 3)\n100 (decimal 4)\n101 (decimal 5)\n...\nreflectivity of locations on the disk surface. 40 CHAPTER 3. DATA REPRESENTATION\n(Old joke: \u201cThere are 10 types of people in the world. Those who understand binary and\nthose who don\u2019t.\u201d)\nThe next thing to think about is what values are possible in one byte. Let\u2019s write out\nthe powers of two in a byte:\n27 26 25 24 23 22 21 20\n128 64 32 16 8 4 2 1\nAs an example, the binary number 10011001 is\n1\u00d7128+0\u00d764+0\u00d732+1\u00d716+1\u00d78+0\u00d74+0\u00d72+1\u00d71 = 153.\nNote each of the 8 bits can either be a 0 or a 1. So there are two possibilities for the\nleftmost bit, two for the next bit, two for the bit after that, and so on: two choices for\neach of the 8 bits. Multiplying these possibilities together gives 28 or 256 possibilities. In\nunsigned binary these possibilities represent the integers between 0 (all bits 0) to 255 (all\nbits 1).\n3.3.5 Decimal to Binary Conversion\nOne task you will need to do in this class, and which computer scientists often need to do,\nis to convert a decimal number to or from a binary number. The last subsection showed\nhow to convert binary to decimal: take each power of 2 whose corresponding bit is a 1,\nand add those powers together.\nSuppose we want to do a decimal to binary conversion. As an example, let\u2019s convert\nthe decimal value 75 to binary. Here\u2019s one technique that relies on successive division by\n2:\n75\/2 quotient=37 remainder=1\n37\/2 quotient=18 remainder=1\n18\/2 quotient=9 remainder=0\n9\/2 quotient=4 remainder=1\n4\/2 quotient=2 remainder=0\n2\/2 quotient=1 remainder=0\n1\/2 quotient=0 remainder=1\nWe then take the remainders bottom-to-top to get 1001011. Since we usually work with\ngroup of 8 bits, if it doesn\u2019t fill all eight bits, we add zeroes at the front until it does. So\nwe end up with 01001011.\nProblem 1: Write an algorithm that specifies the process given in the example above to\nconvert a decimal integer to binary. Here is the input and output specification:\nInput: a nonnegative positive integer n.\nOutput: a list of digits b ,b ,...,b ,b where b is the 1\u2019s digit, b the 2\u2019s digit, and b\nk k\u22121 1 0 0 1 k\nthe largest (i.e., leftmost digit) in the binary representation of n (note we aren\u2019t adding\nany 0\u2019s to the front to get a predetermined length.) 3.3. REPRESENTATION BASICS 41\nThe algorithm before Problem 1 is one common method for decimal to binary conver-\nsion. Here is another. Let\u2019s convert the decimal value 87 to binary. We start by finding\nthe largest power of two that is not greater than 87. It is 64. We then put a \u20181\u2019 in the\n64 (i.e., the 26) place in the binary representation of 87, and next subtract 64 from 87 to\nget 23. Now the next power of 2 down from 64 is 32. Since 23 is less than 32 we put a \u20180\u2019\nin the 32 place. The next power down is 16. Since 23 is greater than 16, we put a \u20181\u2019 in\nthe 16 place, subtract 16 from 23 to get 7, and continue with the process. Here is a short\nwrite-up of the remaining steps.\nThe next power of 2 downward is 8.\nIs 7 greater than or equal to 8?\nNo, so put a 0 in the 8 place.\nThe next power of 2 downward is 4.\nIs 7 greater than or equal to 4?\nYes, so put a 1 in the 4 place, and subtract 4 from 7 to get 3.\nThe next power of 2 downward is 2.\nIs 3 greater than or equal to 2?\nYes, so put a 1 in the 2 place, and subtract 2 from 3 to get 1.\nThe next power of 2 downward is 1.\nIs 1 greater than or equal to 1?\nYes, so put a 1 in the 1 place, and subtract 1 from 1 to get 0.\nSince the we have considered all powers of 2 down to 2 to the 0th power,\nnamely 1, we stop.\nHere is the representation of 87, written as a byte with the powers of two written above\neach bit:\n27 26 25 24 23 22 21 20\n128 64 32 16 8 4 2 1\n0 1 0 1 0 1 1 1\nEither of the two techniques above will work for converting decimal to binary.\nTip: Memorize the first 10 or so powers of 2. You\u2019ll be using them extensively in this\nclass.\nProblem 2: In one episode of the TV show The Simpsons the character Homer Simpson\nwrote the following:\n398712 +436512 = 447212.\n(Leave aside for now the question of whether this is a correct equation.) Represent each\nof the three numbers 3987, 4365, and 4472 in binary. Use as many bits as needed for each\nnumber (you will need more than eight). 42 CHAPTER 3. DATA REPRESENTATION\n3.3.6 Addition of Binary Numbers\nIn addition to storing data, computers also need to do operations such as addition of data.\nHow do we add numbers in binary representation?\nAddition of bits has four simple rules:\n0 0 1 1\n+0 +1 +0 +1\n0 1 1 10\nNow if we have a binary number consisting of multiple bits we use these four rules, plus\n\u201ccarrying\u201d. Here\u2019s an example:\n00110101\n+ 10101100\n11100001\nHere\u2019s the same example, but with the carried bits listed explicitly, i.e., a 0 if there is no\ncarry, and a 1 if there is:\ncarry : 0111100\n00110101\n+ 10101100\n11100001\nWe can check binary operations by converting each number to decimal: with both\nbinary and decimal we\u2019re doing the same operations on the same numbers, but with\ndifferent representations. If the representations and operations are correct the results\nshould be consistent. Converting 00110101 to decimal produces 53 (do the conversion on\nyour own to verify its accuracy), and converting 10101100 gives 172. Adding these yields\n225, which, when converted back to binary is indeed 11100001.\nBut ... binary addition of two 8-bit numbers doesn\u2019t always work quite right:\n01110100\n+ 10011111\n100010011\nNote there are 9 bits in the result, but there should only be 8 in a byte. Here is the sum\nin decimal:\n116\n+ 159\n275 3.4. OTHER REPRESENTATIONS RELATED TO BINARY 43\nNote 275 is greater than 255, which is the maximum we can hold in an 8-bit number.\nThis results in a condition called overflow. Overflow is not an issue if the computer can\ngo to a 9-bit binary number; however, if the computer only has 8 bits set aside for the\nresult, overflow can result in the program not running, or not running correctly.\n3.3.7 Subtraction of Binary Numbers\nOnce again, let\u2019s start by looking at single bits:\n0 0 1 1\n\u22120 \u22121 \u22120 \u22121\n0 \u22121 1 0\nNotice that in the \u22121 case what we often want to do is get a bit value 1, and borrow. So\nlet\u2019s apply this to an 8-bit problem:\n10011101\n\u2212 00100010\n01111011\nwhich is the same as (in base 10)\n157\n\u2212 34\n123\nHere\u2019s the binary subtraction again with the borrowing shown:\nborrow : 1100010\n10011101\n\u2212 00100010\n01111011\nMost people find binary subtraction significantly harder than binary addition.\nProblem 3: In the last subsection we saw that overflow was a possible problem when\ntwo binary numbers were added. Can it (or a similar condition) occur when one binary\nnumber is subtracted from another?\n3.4 Other Representations Related to Binary\nYou might have had questions about the binary representation in the last section. For\nexample, what about negative numbers? What about numbers with a fractional part? 44 CHAPTER 3. DATA REPRESENTATION\nAren\u2019t all those 0\u2019s and 1\u2019s difficult for humans to work with? Etc. These are good\nquestions. In this and the next two sections we\u2019ll look at a few other representations that\nare used in computer science and are related to binary.\n3.4.1 Hexadecimal\nComputers are good at binary. Humans aren\u2019t. Binary is hard for humans to write, hard\nto read, and hard to understand. But what if we want a number system that is easier to\nread, etc. but still is closely tied to binary in some way?\nOne possibility is hexadecimal, i.e., base 16. But using a base greater than 10 imme-\ndiately presents a problem. Specifically, we run out of digits after 0 to 9 \u2014 we can\u2019t use\n10, 11, etc. because those have multiple digits within them. So instead we use letters: A\nis 10, B 11, C 12, D 13, E 14, and F 15, as shown in Figure 3.1. So the digits we\u2019re using\nare 0 through F instead of the 0 through 9 in decimal, or the 0 and 1 in binary.\nFigure 3.1: Hexadecimal digits and their decimal equivalents\nHexadecimal Decimal\nDigit Equivalent\n0 0\n1 1\n2 2\n3 3\n4 4\n5 5\n6 6\n7 7\n8 8\n9 9\nA 10\nB 11\nC 12\nD 13\nE 14\nF 15\nWe also have to reexamine the value of each place. In hexadecimal, each place rep-\nresents a power of 16. A two-digit hexadecimal number has a 16\u2019s place and a 1\u2019s place. 3.4. OTHER REPRESENTATIONS RELATED TO BINARY 45\nFor example, D8 has D in the 16\u2019s place, and 8 in the 1\u2019s place:\n161 160\n16 1\nD 8\nSo the hexadecimal number D8 equals 13\u00d716+8\u00d71 = 216 in decimal. Note any two\ndigit hexadecimal number, however, can represent the same amount of information as one\nbyte of binary. So it\u2019s easier for us to read or write.\nWhenworkingwithanumber, therearetimeswhenwhichrepresentationisbeingused\nisn\u2019t clear. For example, does 10 represent the number ten (so the representation is deci-\nmal), the number two (the representation is binary), the number sixteen (hexadecimal),\nor some other number? Often, the representation is clear from the context. However,\nwhen it isn\u2019t we use a subscript to clarify which representation is being used, for example\n10 for decimal, versus 10 for binary, versus 10 for hexadecimal.\n10 2 16\nHexadecimal numbers can have more hexadecimal digits than two. For example,\nconsider FF0581A4, which uses the following powers of 16:\n167 166 165 164 163 162 161 160\nF F 0 5 8 1 A 4\nSo in decimal this is\n15\u00d7167 +15\u00d7166 +0\u00d7165 +5\u00d7164 +8\u00d7163 +1\u00d7162 +10\u00d7161 +4\u00d7160\n= 15\u00d7268435456+15\u00d716777216+0\u00d71048576+5\u00d765536\n+8\u00d74096+1\u00d7256+10\u00d716+4\u00d71\n= 4,278,550,948\nProblem 4: How many bits are required to store the hexadecimal number FF0581A4?\nHexadecimal doesn\u2019t appear often, but it is used in some places, for example sometimes\nto represent memory addresses (you\u2019ll see this in a future chapter) or colors. Why is\nit useful in such cases? Consider a 24-bit RGB color with 8 bits each for red, green,\nand blue. Since 8 bits requires 2 hexadecimal digits, a 24-bit color needs 6 hexadecimal\ndigits, rather than 24 bits. For example, FF0088 indicates a 24-bit color with a full red\ncomponent, no green, and a mid-level blue.\nNow there are additional types of conversion problems:\n\u2022 Decimal to hexadecimal\n\u2022 Hexadecimal to decimal\n\u2022 Binary to hexadecimal\n\u2022 Hexadecimal to binary 46 CHAPTER 3. DATA REPRESENTATION\nHere are a couple examples involving the last two of these.\nLet\u2019s convert the binary number 00111100 to hexadecimal. To do this, break it into\ntwo 4-bit parts: 0011 and 1100. Now convert each part to decimal and get 3 and 12.\nThe 3 is a hexadecimal digit, but 12 isn\u2019t. Instead recall that C is the hexadecimal\nrepresentation for 12. So the hexadecimal representation for 00111100 is 3C.\nRather than going from binary to decimal (for each 4-bit segment) and then to hex-\nadecimal digits, you could go from binary to hexadecimal directly using Figure 3.2.\nFigure 3.2: Hexadecimal digits and their decimal and binary equivalents\nHexadecimal Decimal Binary\nDigit Equivalent Equivalent\n0 0 0000\n1 1 0001\n2 2 0010\n3 3 0011\n4 4 0100\n5 5 0101\n6 6 0110\n7 7 0111\n8 8 1000\n9 9 1001\nA 10 1010\nB 11 1011\nC 12 1100\nD 13 1101\nE 14 1110\nF 15 1111\nNow let\u2019s convert the hexadecimal number D6 to binary. D is the hexadecimal rep-\nresentation for 13 , which is 1101 in binary. 6 in binary is 0110. Put these two parts\n10\ntogether to get 11010110. Again we could skip the intermediate conversions by using the\nhexadecimal and binary columns in the Figure 3.2.\n3.4.2 Sign\/Magnitude Notation\nThus far we\u2019ve been working with positive numbers. What above negatives? For example,\nsuppose the temperature is \u221215\u25e6 F. How would we represent this in binary?\nOne possibility is to use one bit to indicate the sign of the number. Let\u2019s use the\nleftmost bit: instead of it being the 128\u2019s place we interpret it to indicate that the number\nis negative if that bit is a 1, and the number is positive if that bit is a 0. So, for 3.4. OTHER REPRESENTATIONS RELATED TO BINARY 47\nexample, positive 39 is 00100111, but \u221239 would be 10100111. We call this representation\nsign\/magnitude binary, or just sign\/magnitude for short.\nThis representation works, but only to some extent. Let\u2019s take a minute and look at\nthe tradeoffs. First, with the unsigned binary representation in the last section, we can\nrepresenttheintegers0to255withasinglebyte. Withthesign\/magnituderepresentation\nwe can still only represent at most 256 different possibilities. Note that the smallest\nnumber will be when all the bits are 1:\nsign 26 25 24 23 22 21 20\n+\/\u2212 64 32 16 8 4 2 1\n1 1 1 1 1 1 1 1\nThis number is \u2212(64+32+16+8+4+2+1) = \u2212127 in decimal.5\nHow about the largest number: This will be when all bits save the leftmost are 1:\nsign 26 25 24 23 22 21 20\n+\/\u2212 64 32 16 8 4 2 1\n0 1 1 1 1 1 1 1\nThis is the same number as above, except +127 instead of \u2212127.\nSo by using this sign\/magnitude notation we trade off representing more positive\nnumbers for being able to represent some negative numbers.\nNote that this representation allows 127 positive numbers, 127 negative numbers, and\n0. This is 255 possibilities. You might remember that with unsigned binary a byte can\nrepresent 256 possibilities: the numbers 1 to 255, as well as 0. Where did the other\npossibility go with sign\/magnitude representation?\nNotice that 10000000 and 00000000 both represent 0 (\u22120 and +0, respectively, which\nare both the same value, 0). This complicates matters. For example, suppose you are\nwriting an accounting program and wanted the program to check if revenue\u2212expeditures\nequals 0. Doing this would require two checks, one against 10000000, and one against\n00000000. This might not seem like a big deal, but it is just one of a number of compli-\ncations that having two 0 representations introduces.\nLet\u2019s look at another problem with sign\/magnitude representation. Does addition\nwork? For example, what happens if we add 30 to \u221239? Will the usual way of doing\nbinary addition work? We should get \u22129. Here\u2019s what we do get:\n00011110\n+ 10100111\n11000101\n5Notethatinthiscalculation64+32+...+2+1=27\u22121. Ingeneral2m+2m\u22121+2m\u22122+...+21+20 =\n2m+1\u22121. This is a useful formula to remember. 48 CHAPTER 3. DATA REPRESENTATION\nWe know this number is negative, but what is it? It\u2019s the negative of 64+4+1, or \u221269.\nSo instead of adding 30, we subtracted 30.\nThisisnotaninsurmountableproblem; therearewaystofixit. However, wewouldlike\na representation to be as efficient as possible for frequently performed operations. Is there\na better option than sign\/magnitude binary? Is there a representation that allows both\npositive and negative numbers, but that is more efficient? We\u2019ll see such a representation\nin the next section.\n3.5 Two\u2019s Complement Representation\nTwo\u2019s complement is another method for representing numbers in binary. It\u2019s hard to\nunderstandatfirst, butthekeypointsareitallowsrepresentingbothpositiveandnegative\nnumbers, and does so in such a way that it avoids the problems that arise with the\nsign\/magnitude representation.\n3.5.1 Two\u2019s Complement Representation Basics\nHere is one way to think about two\u2019s complement representation. We can start at 0 and\ncount up:\n00000000\n00000001\n00000010\n00000011\n...\nAnd we can start at 0 but count down. What do we get if we start at 000000000 and\nsubtract one at a time? We get the sequence (ignore for now the carry that \u201cfalls off\u201d the\nleft end):\n11111111\n11111110\n11111101\n11111100\n...\nThis gives some hint as to how two\u2019s complement works. Specifically, for normal unsigned\nbinary we have the following powers of 2 for each bit:\n128 64 32 16 8 4 2 1\nFor sign\/magnitude notation we have leftmost bit indicating the sign:\n-\/+ 64 32 16 8 4 2 1 3.5. TWO\u2019S COMPLEMENT REPRESENTATION 49\nTwo\u2019s complement representation uses a different leftmost bit. Specifically, rather than\nbeing the 128\u2019s place, or indicating the sign, the leftmost bit corresponds to negative 128:\n-128 64 32 16 8 4 2 1\nOne effect of this is the numbers that a byte can represent in two\u2019s complement don\u2019t\nrange from 0 to 255 (as in unsigned binary). Instead the smallest number is \u2212128 (in\ntwo\u2019s complement 100000000), and the largest is +127 (in two\u2019s complement 01111111).\nLet\u2019s look at how we do conversions in this new representation. Here\u2019s an outline of\nan algorithm for converting from decimal to two\u2019s complement:\nInput: an integer (represented in decimal) between \u2212128 and 127\nOutput: the two\u2019s-complement representation of the number.\nConvert the absolute value of the number to binary\nIf the number is negative\nComplement the binary representation (change 0\u2019s to 1\u2019s, and 1\u2019s to 0\u2019s)\nAdd one to the binary representation\nNotice that changing a positive integer (between 0 and 127) to two\u2019s-complement is\nthe same as we\u2019ve already learned \u2014 you get the same bits as with the unsigned binary\nrepresentation because the \u2212128 bit will be 0. But let\u2019s look at an example of converting\na negative number. Specifically, let\u2019s convert \u221299 to two\u2019s complement.\nFirst we convert 99 to binary: 01100011\nThen complement the bits: 10011100\nThen add one: 10011101\nWe can do a two\u2019s complement to decimal conversion to check our work:\n10011101 = 1\u00d7(\u2212128)+1\u00d716+1\u00d78+1\u00d74+1\u00d71 = \u2212128+16+8+4+1 = \u221299.\n3.5.2 Addition and Subtraction\nWe can now do two\u2019s complement addition using the usual binary process. For example,\nconsider (\u221299)+42. Note the two\u2019s complement representation of 42 is 00101010, and of\n\u221299 is 10011101. Adding these gives\n10011101\n+ 00101010\n11000111\nNotice if you convert the result from two\u2019s complement to decimal you get 1\u00d7(\u2212128)+\n1\u00d764+1\u00d74+1\u00d72+1\u00d71 = \u221257, which is correct. 50 CHAPTER 3. DATA REPRESENTATION\nHere are a couple more examples. First 107 + (\u221267). The two\u2019s complement repre-\nsentation of 107 is 01101011, and of \u221267 is 1011101. Adding these gives\n01101011\n+ 10111101\n00101000\n(You can ignore for now the carry that falls off the left end.)\nNext (\u221227)+(\u221267). The two\u2019s complement representation of \u221227 is 11100101, and\nof \u221267 is 1011101. Adding these gives\n11100101\n+ 10111101\n10100010\n(Again, you can ignore for now the carry that falls off the left end.)\nOverflow can still be a problem with two\u2019s complement; it\u2019s a problem any time you\nhaveafixednumberofbits. Forexample,ifyouadd(\u2212128)+(\u2212128)yougetthefollowing:\n10000000\n+ 10000000\n00000000\nwith a 1 bit carried off the left end. This is not the correct answer. Or if you add 64 +\n64 you get another wrong result\n01000000\n+ 01000000\n10000000\nwhich is again incorrect.\nSo while two\u2019s complement has many advantages, computers do need to do special\nchecks of the leftmost bit and any leftover carry bits to ensure there isn\u2019t any overflow.\nThe rules on this are as follows:\n1. If the leftmost bit of both numbers to be added are 0, and the result of adding the\ntwo numbers gives a 1 as the leftmost bit of the result, then (as in the example\nimmediately above) overflow has occurred.\n2. If the leftmost bit of both numbers to be added are 1, then the leftmost bit of the\nresult (excluding any carry bit off the left end) is a 0, then overflow has occurred.\n3. In all other cases the result is correct, and we ignore any carry bit that \u201cfalls off\u201d\nthe left end of the result. 3.6. RANGE 51\nOne final reminder on two\u2019s complement: It presents an elegant and efficient way of\ndealing with subtraction, namely by turning a subtraction problem into an addition one.\nWe actually already used this observation in one of the examples above, since 107+(\u221267)\nis the same as 107\u221267. But here is another example.\nSuppose we want to do the subtraction 81\u221227 using two\u2019s complement. Note that in\ntwo\u2019s complement 81 is 01010001 and 27 is 00011011. But rather than subtracting these\ndirectly, we can write 81 \u2212 27 as an addition problem, namely 81 + (\u221227). So instead\nof working with the representation of 27, we use the two\u2019s complement representation of\n\u221227, which we find by complementing 00011011 (change 0\u2019s to 1\u2019s and vice versa) and\nthen adding 1. That is, we do the following:\n00011011 start with the binary representation of 27\n11100100 flip all the bits\n11100101 add 1 to get the two\u2019s complement representation of \u221227\nNow do the addition:\n01010001\n+ 11100101\n00110110\nNote that because the leftmost bits of both numbers being added are a 0 and a 1, overflow\ndoes not occur. And we ignore the carry bit that falls off the left edge. Moreover, the\nresult checks: 0\u00d7(\u2212128)+0\u00d764+1\u00d732+1\u00d716+0\u00d78+1\u00d74+1\u00d72+0\u00d71 = 54,\nwhich is correct.\n3.6 Range\nBefore looking at how computers store other types of data, let\u2019s explore range further.\nThe range of a representation is the set of numbers it can represent.\nUp to this point we\u2019ve been working primarily with bytes, or 8-bit bitstrings. Most\ncomputers and computer programs use more bits to represent numbers. For example, it\u2019s\ncommon to use 16 bits (2 bytes), or 32 bits (4 bytes), or even 64 bits to represent integers.\nLet\u2019s examine how many more possibilities these additional bits provide. Consider the\nfollowing questions:\n1. How many different possibilities are there with 16 bits?\n2. How many different possibilities are there with 32 bits?\n3. If you use an unsigned binary representation with 16 bits, what decimal values can\nbe represented?\n4. If you use a two\u2019s complement representation with 32 bits, what decimal values can\nbe represented? 52 CHAPTER 3. DATA REPRESENTATION\nTo answer the first and second question, remember that each bit has two possibilities:\n0 or 1. So if you have one bit, you have two possibilities. If you have two bits, you\nhave four possibilities. If three, then eight. If four, then 16. And in general, if you\nhave n bits, you have 2n possibilities. So 16 bits provide 216 = 65,536 possibilities.\n32 bits provide 232 = 4,294,967,296 (over 4 billion) possibilities. (And 64 bits provide\n18,446,744,073,709,551,616.)\nNowexaminea16-bitunsignedbinaryrepresentation. Aswejustsaw, youhave65,536\npossibilities. However, we include 0 as one of these, so the maximum decimal number in\nthis representation is 65,535.\nNext, consider a 32-bit two\u2019s complement representation. The largest number in this\nrepresentationhasallbitssavetheleftmostbeing1. Thishasvalue230+229+\u00b7\u00b7\u00b7+21+20 =\n231 \u2212 1 = 2,147,483,647. The smallest (i.e., most negative) number in this representa-\ntion has leftmost bit 1 and all other bits 0. This has value \u2212231 = \u22122,147,483,648.\nSo for 32-bit two\u2019s complement, the range is all integers between \u22122,147,483,648 and\n2,147,483,647, inclusive.\nNote that the more bits a representation has, the larger its range. Therefore, it might\nseem like a good strategy to always use an extremely large number of bits. However, there\nis a tradeoff: the more bits, the more space a computer needs to store a number, the less\nefficient the program will be. If, for example, you are storing a large number of colors, and\nthe colors are in RGB color representation with 8 bits each for the red, green, and blue\ncolor components, then there is no need to use a 32-bit two\u2019s complement representation\nfor each component.\nOften programmers don\u2019t know in advance how large the range needs to be. For\nexample, companies grow, and a small company that has tens of thousands of dollars of\nyearly revenue currently might have millions of dollars of yearly revenue in a decade. In\ngeneral, programs try to provide a large enough range that they can store all numbers\nthat will reasonably occur in the running of the program. If they provide too large of a\nrange, they are not as efficient as they could be. If they provide too small of a range, the\nprogram will not be able to handle all numbers that arise \u2014 for example, overflow might\noccur.\nSuppose you are keeping track of a company\u2019s yearly revenue in a computer program.\nYou don\u2019t know in advance how large these numbers might be, but if you are familiar\nwith the company you could estimate the needed range. But suppose your estimate is\nincorrect. Can\u2019t a computer just automatically use extra bits to get a larger range?\nThe answer to this question is \u201cyes, but ...\u201d. It is certainly possible for computers\nto do this. However, it is more complicated, so programs or computer languages that\nallow varying representation sizes are less efficient than those where items have a fixed\nlength. For this reason, many computer languages require items to have a fixed length\nduring program execution. However, some other languages allow the representation size\nto change. Once again, it is a matter of tradeoffs. 3.7. FLOATING POINT NUMBERS 53\n3.7 Floating Point Numbers\nOf course not all numbers are integers. A gallon of milk might cost $3.75. The distance\nin miles of a 10K race is (to the nearest tenth of a mile) 6.2. The number of days in a\nyear is about 365.24 (which is the reason for leap years). Computers call such numbers,\nwhere there is a fractional part or digits to the right of the decimal point floating point\nnumbers. We\u2019ve seen how computers store integers. How do they represent floating point\nnumbers?\nFloating point representation is interesting, but also complicated. Rather that going\ninto all the details here, we will just make a few key, high-level observations:\n1. Many of the issues with integer representation also occur with floating point numbers.\nFor example, there is again a trade-off between how many possible numbers you can\nrepresent, and how many bits you use.\n2. Floating point representations break a number into parts and include each part in\nthe representation. Specifically, recall scientific notation. For example, in scientific\nnotation the number 32,000,000 would be represented as 3.2\u00d7107. When computers\nrepresent a floating point number, they represent it as the mantissa, which is 3.2 in\nthe example above, and the exponent, which is 7.\n(Note that the mantissa above is still not an integer. However, just as we can\nrepresent the price of an object as an integral number of cents rather than dollars,\nfor example 375 cents instead of $3.75, so we can also adjust a fixed width floating\npoint number and represent it as an integer, as long as we know where the decimal\npoint was originally.)\n3. How many bits you use for the mantissa and exponent affects the representation\u2019s\nprecision and range.\nBecause we need to store both the mantissa and exponent, there needs to be a\nstandard for how many bits to devote to each. The more bits for one, the larger\nnumber of possible values it can take on, but the fewer bits for the other. A larger\nnumber of bits for the mantissa will give more precision, that is more digits to the\nright of the decimal point. But a larger number of bits for the exponent will give a\nlarger exponent range.\nComputer engineers have devised a number of standards for this. For example, the\nIEEE 7540 standard for a 32-bit floating point number results in about 7 decimal\ndigits of accuracy, and allows exponents for powers of 10 between about 10\u221238 and\n1038. The standard for a 64-bit number gives both more precision (15 or 16 decimal\ndigits) and a larger exponent range (giving powers of 10 between about 10\u2212308 and\n10308).\n4. There are a number of additional complications with floating point numbers. Ob-\nviously, adding numbers that have both a mantissa and an exponent will be sig- 54 CHAPTER 3. DATA REPRESENTATION\nnificantly more complicated that adding, say, two 8-bit two\u2019s complement integers.\nMoreover, there are other complications such as the desirability of including a rep-\nresentation for infinity, as well as for \u201cNaN\u201d (not a number) to indicate the result\nof an operation such as division by 0. We won\u2019t go into the details for this.\nHowever, there are two additional complications that deserve mentioning. The first\nis that computers cannot represent all numbers. Just as you can\u2019t write down all\nthe digits in the decimal representation of 1\/3, since it is .3333... with the three\u2019s\ngoing on forever, so a computer can\u2019t exactly represent many numbers exactly. The\nsecond complication is that, in a case like this, the computer does the same thing\nwe often do if we need to work with the decimal representation of 1\/3: it uses an\napproximation rather than the exact number. This means \u2014 since all fixed-length\nrepresentations have a finite, set number of bits \u2014 that representing numbers in a\ncomputer can result in round-off error. Moreover, round-off error can accumulate\nover a sequence of operations. This raises questions of how accurate the results of\nnumerical computations are. For example, if a company is using a computer to do a\nwind tunnel simulation of a new airplane wing design, should they trust the results?\nNumerical analysisandnumerical computationarethebranchesofmathematicsand\ncomputer science that deal with these and other computational issues.\n3.8 Text\nSo far this chapter has covered only numbers. Numbers are certainly important, but much\nof our data and much of what we do on computers doesn\u2019t involve numbers. Many people\nwho use computers primarily work with text: typing papers, reports, emails, etc. How do\ncomputers store text, i.e., character data?\nTo work with text, a computer must turn it into numbers, i.e., into binary. This\nrequires each text character having a numerical equivalent. Then the computer works\nwith these numbers, and thereby works with text.\nThere are, of course, many possible ways to do this, and many associated questions.\nFor instance, how many bits will we need? The Latin alphabet has 26 characters, so if\nwe use a fixed bitstring length for all characters we need the smallest n so that 2n \u2265 26,\nnamely 5. But that\u2019s not quite right \u2014 we need both upper and lower case, so 52\npossibilities. But even that is not right, since we also need punctuation marks. Moreover,\nit would also be nice to be able to encode items such as a tab or return or escape: non-\nprinting characters that can play a role in printed text or in computer operations.\nASCII is a commonly used encoding that uses 8 bits, i.e., one byte, per character. For\nexample, here are some ASCII equivalents: the capital \u2018A\u2019 is represented by the decimal\nnumber 65 (equivalently, the binary 01000001), the capital \u2018B\u2019 by 66, lower case \u2018a\u2019 by 97,\nthe semicolon by 59, the space by 32, the escape key by 27, and the digit 4 by 52.6 The\n6Note that ASCII needs to represent all these characters, including the digits 0 through 9. This can\nbe a little confusing because we\u2019ve just gotten through discussing how computers represent numbers in 3.8. TEXT 55\nentire ASCII table can be found online. For example, see http:\/\/www.asciitable.com\nor http:\/\/www.ascii-table.com.\nNote that even though we are mostly discussing decimal equivalents here, within the\ncomputer those equivalents are stored in binary. This brings up an important principal:\na bitstring in and of itself has little meaning; it is only when you (or the computer)\nknow what type of representation is being used that you (or it) can say what the bitstring\nrepresents. For example, consider the bitstring 01000001 (which equals 65 ). We just\n10\nsaw that if we interpret it as ASCII, it represents the character \u2018A\u2019. If we interpret it\nas unsigned binary, it represents the (decimal) number 65. Or, as another example,\n11000001 represents 193 in unsigned binary, \u221265 in sign\/magnitude binary, and \u221263 in\ntwo\u2019s complement.7\nHowever, with only one byte per character, ASCII is limited. Specifically, what if you\nwant additional characters beyond those given in ASCII? For example, what if you want\nto use the Greek alphabet?\nUNICODE is a set of standards for representing text in non-Latin alphabets, such\nas Russian, Arabic, Balinese, and Chinese. It can represent over 65,000 symbols by\ngiving each one a 16-bit representation. For example, a Greek lower case letter pi has\nunicode representation 003C in hexadecimal.8 And the Old Coptic small letter dja has\nrepresentation 2CD9. You can find the UNICODE character charts online, for example\nat http:\/\/www.unicode.org.\nLet\u2019s go back to working with ASCII. Suppose we\u2019re working with a program using\nASCII. How much space does it take to encode a page of text? Obviously that will depend\nonanumberoffactorsincludingthepageheightandwidth,fontsize,andinterlinespacing.\nConsider this set of notes. There are roughly 40 lines per page, and roughly 80 characters\nper line. This gives 3200 characters. In ASCII each character takes a single byte, so this\nis a little over 3000 bytes. In terms of computer file sizes, this is not much, not at all.9\nWhen we get to audio and image files below, we will see they take much more space. This\nleads to another principle: text and numbers are easy (to store, transmit, etc.); images,\naudio, etc. are hard.\nbinary. Why does ASCII need to represent character digits differently? Suppose you needed to decide\nhow to encode the page above. Note it contains not only alphabetic characters but also numbers. Which\nis easier: encoding the numbers one way and the text characters another, or encoding all the characters\nusing the same system? ASCII makes the latter choice for reasons of efficiency. Computers have special\nmechanisms \u2014 such as declarations in computer programs and programming languages \u2014 to specify\nwhen numbers need to be represented directly in binary rather than in ASCII.\n711000001alsohasameaninginASCII;however,therearedifferentversionsofASCIIforthedecimal\nequivalents 128 to 255. For example, in the ISO Latin-1 extended ASCII encoding, 11000001 represents\na capital \u2018A\u2019 with an acute punctuation symbol.\n8Here we are following the identification convention at http:\/\/www.unicode.org and using hexadec-\nimal since it is easier to read and write than 16-bit binary.\n9If you use a word processing program, the program might also store additional information (which\nwill take additional space) about page format, font size and type, etc. However, the overall file size will\nstill be relatively small. 56 CHAPTER 3. DATA REPRESENTATION\nFigure 3.3: Some Important Memory Amounts\nMemory Amount Power of Two Approximation\n1 kilobyte (KB) 210 bytes thousand bytes\n1 megabyte (MB) 220 bytes million bytes\n1 gigabyte (GB) 230 bytes billion bytes\n1 terabyte (TB) 240 bytes trillion bytes\n1 petabyte (PB) 250 bytes quadrillion bytes\n1 exabyte (EB) 260 bytes quintillion bytes\n3.9 Bytes, Kilobytes, Megabytes, and More\nIn the last section we saw that a page of text could take a few thousand bytes to store.\nImages files might take tens of thousands, hundreds of thousands, or even more bytes.\nMusic files can take millions of bytes. Movie files can take billions. There are databases\nthat consist of trillions or quadrillions of bytes of data.\nComputer science has special terminology and notation for large numbers of bytes, as\nshown in Figure 3.3. There are still higher numbers or smaller quantities of these types.\nSee, for example, http:\/\/en.wikipedia.org\/wiki\/Binary prefix.\nKilobytes, megabytes, etc. are important enough for discussing file sizes, computer\nmemory sizes, etc. that you should know both the terminology and the abbreviations.\nOne caution: file sizes are usually given in terms of bytes (or kilobytes, megabytes, etc.).\nHowever, some quantities in computer science are usually given in terms involving bits.\nFor example, download speeds are often given in terms of bits per second. \u201cMbps\u201d is an\nabbreviation for megabits (not megabytes) per second. Notice the \u2018b\u2019 in Mbps is a lower\ncase, while the \u2018b\u2019 in MB (megabytes) is capital.\nIn the context of computer memory, the usual definition of kilobytes, megabytes, etc.\nis a power of two. For example, a kilobyte is 210 = 1024 bytes, not a thousand. In some\nother situations, however, a kilobyte is defined to be exactly a thousand bytes. This can\nobviously be confusing. For the purposes of this class, the difference will usually not\nmatter. That is, in most problems we do, an approximation will be close enough. So, for\nexample, if we do a calculation and find a file takes 6,536 bytes, then you can say this is\napproximately 6.5 KB, unless the problem statement says otherwise.10\n10The difference between \u201cround\u201d numbers, such as a million, and powers of 2 is not as pronounced\nfor smaller numbers of bytes as it is for larger. A kilobyte is 210 =1024 bytes, which is only 2.4% more\nthan a thousand. A megabyte is 220 =1,048,576 bytes, about 4.9% more than one million. A gigabyte\nis about 7.4% bytes more than a billion, and a terabyte is about 10.0% more bytes than a trillion. In\nmost of the file size problems we do, we\u2019ll be interested in the approximate size, and being off by 2% or\n5% or 10% won\u2019t matter. But of course there are real-world applications where it does matter, so when\ndoing file size problems keep in mind we are doing approximations, not exact calculations. 3.10. IMAGE FILES, AUDIO FILES, AND VIDEO FILES 57\n3.10 Image Files, Audio Files, and Video Files\nImages, audio, and video are other types of data. How computers represent these types\nof data is fascinating but complex. For example, there are perceptual issues (e.g., what\ntypes of sounds can humans hear, and how does that affect how many numbers we need\nto store to reliably represent music?), size issues (as we\u2019ll see below, these types of data\ncan result in large file sizes), standards issues (e.g., you might have heard of JPEG or\nGIF image formats), and other issues.\nWe won\u2019t be able to cover image, audio, and video representation in depth: the details\nare too complicated, and can get very sophisticated. For example, JPEG images can rely\non an advanced mathematical technique called the discrete cosine transform. However, it\nis worth examining a few key high-level points about image, audio, and video files:\n1. Computers can represent not only basic numeric and text data, but also data such\nas music, images, and video.\n2. They do this by digitizing the data. At the lowest level the data is still represented\nin terms of bits, but there are higher-level representational constructs as well.\n3. There are numerous ways to encode such data, and so standard encoding techniques\nare useful.\n4. Audio, image, and video files can be large, which presents challenges in terms of\nstoring, processing, and transmitting these files. For this reason most encoding\ntechniques use some sophisticated types of compression.\n3.10.1 Images\n\u201cThe largest and most detailed photograph of our galaxy ever taken has been\nunveiled.\nThe gigantic nine-gigapixel image captures more than 84 million stars at the\ncore of the Milky Way.\nItwascreatedwithdatagatheredbytheVisibleandInfraredSurveyTelescope\nfor Astronomy (VISTA) at the European Southern Observatory\u2019s Paranal Ob-\nservatory in Chile.\nIf it was printed with the resolution of a newspaper it would stretch 30 feet\nlong and 23 feet tall, the team behind it said, and has a resolution of 108,200\nby 81,500 pixels.11\nWhile this galaxy image is obviously an extreme example, it illustrates that images\n(even much smaller images) can take significant computer space. Here is a more mundane\n11From http:\/\/www.huffingtonpost.co.uk\/2012\/10\/25\/largest-ever-photo-of-the-galaxy-\nvista n 2014208.html. Accessed Nov. 5, 2013. 58 CHAPTER 3. DATA REPRESENTATION\nexample. Suppose you have an image that is 1500 pixels wide, and 1000 pixels high. Each\npixel is stored as a 24-bit color. How many bytes does it take to store this image?\nThis problem describes a straightforward but naive way to store the image: for each\nrow, for each column, store the 24-bit color at that location. The answer is (1500 \u00d7 1000)\npixels \u00d7 24 bits\/pixel \u00d7 1 byte\/8 bits = 4.5 million bytes, or about 4.5MB.\nNote the file size. If you store a number of photographs or other images you know\nthat images, and especially collections of images, can take up considerable storage space.\nYou might also know that most images do not take 4.5MB. And you have probably heard\nof some image storage formats such as JPEG or GIF.\nWhy are most image sizes tens or hundreds of kilobytes rather than megabytes? Most\nimages are stored not in a direct format, but using some compression technique. For\nexample, suppose you have a night image where the entire top half of the image is black\n((0,0,0) in RGB). Rather than storing (0,0,0) as many times as there are pixels in the\nupper half of the image, it is more efficient to use some \u201cshorthand.\u201d For example, rather\nthan having a file that has thousands of 0\u2019s in it, you could have (0,0,0) plus a number\nindicatinghowmanypixelsstartingtheimage(ifyoureadlinebylinefromtoptobottom)\nhave color (0,0,0).\nThis leads to a compressed image: an image that contains all, or most, of the infor-\nmation in the original image, but in a more efficient representation. For example, if an\noriginal image would have taken 4MB, but the more efficient version takes 400KB, then\nthe compression ratio is 4MB to 400KB, or about 10 to 1.\nComplicated compression standards, such as JPEG, use a variety of techniques to\ncompress images. The techniques can be quite sophisticated.\nHow much can an image be compressed? It depends on a number of factors. For many\nimages, a compression ratio of, say, 10:1 is possible, but this depends on the image and\non its use. For example, one factor is how complicated an image is. An uncomplicated\nimage (say, as an extreme example, if every pixel is black12), can be compressed a very\nlarge amount. Richer, more complicated images can be compressed less. However, even\ncomplicated images can usually be compressed at least somewhat.\nAnother consideration is how faithful the compressed image is to the original. For\nexample, many users will trade some small discrepancies between the original image and\nthe compressed image for a smaller file size, as long as those discrepancies are not easily\nnoticeable. A compression scheme that doesn\u2019t lose any image information is called a loss-\nless scheme. One that does is called lossy. Lossy compression will give better compression\nthan lossless, but with some loss of fidelity.13\n12You might have seen modern art paintings where the entire work is a single color.\n13See, for example, http:\/\/computer.howstuffworks.com\/question289.htm for examples of the in-\nterplay between compression rate and image fidelity. 3.10. IMAGE FILES, AUDIO FILES, AND VIDEO FILES 59\n3.10.2 Video\nSuppose you have a 10 minute video, 256 x 256 pixels per frame, 24 bits per pixel, and 30\nframes of the video per second. You use an encoding that stores all bits for each pixel for\neach frame in the video. What is the total file size? And suppose you have a 500 kilobit\nper second download connection; how long will it take to download the file?\nThis problem highlights some of the challenges of video files. Note the answer to the\nfile size question is (256 \u00d7 256) pixels \u00d7 24 bits\/pixel \u00d7 10 minutes \u00d7 60 seconds\/minute\n\u00d7 30 frames per second = approximately 28 Gb, where Gb means gigabits. (This is\nabout 28\/8 = 3.5 gigabytes.) With a 500 kilobit per second download rate, this will take\n28Gb\/500 Kbps, or about 56,000 seconds. This is over 15 hours, longer than many people\nwould like to wait. And the time will only increase if the number of pixels per frame is\nlarger (e.g., in a full screen display) or the video length is longer, or the download speed\nis slower.\nSo video file size can be an issue. However, it does not take 15 hours to download a ten\nminute video; as with image files, there are ways to decrease the file size and transmission\ntime. Forexample,standardssuchasMPEGmakeusenotonlyofimagecompressiontech-\nniquestodecreasethestoragesizeofasingleframe,butalsotakeadvantageofthefactthat\nasceneinoneframeisusuallyquitesimilartothesceneinthenextframe. There\u2019sawealth\nof information online about various compression techniques and standards, storage media,\netc. For example, see http:\/\/electronics.howstuffworks.com\/question596.htm and\nthe links there.\n3.10.3 Audio\nIt might seem, at first, that audio files shouldn\u2019t take anywhere as much space as video.\nHowever, if you think about how complicated audio such as music can be, you probably\nwon\u2019t be surprised that audio files can also be large.\nSound is essentially vibrations, or collections of sound waves travelling through the\nair. Humans can hear sound waves that have frequencies of between 20 and 20,000 cycles\nper second.14 To avoid certain undesirable artefacts, audio files need to use a sample rate\nof twice the highest frequency. So, for example, for a CD music is usually sampled 44,100\nHz, or 44,100 times per second.15 And if you want a stereo effect, you need to sample on\ntwo channels. For each sample you want to store the amplitude using enough bits to give\na faithful representation. CDs usually use 16 bits per sample. So a minute of music takes\n44,100 samples \u00d7 16 bits\/samples \u00d7 2 channels \u00d7 60 second\/minute \u00d7 1 byte\/8 bits =\nabout 10.5MB per minute. This means a 4 minute song will take about 40MB, and an\n14This is just a rough estimate since there is much individual variation as well as other factors that\naffect this range.\n15Hz, or Hertz is a measurement of frequency. It appears in a variety of places in computer science,\ncomputerengineering, andrelatedfieldssuchaselectricalengineering. Forexample, acomputermonitor\nmight have a refresh rate of 60Hz, meaning it is redrawn 60 times per second. It is also used in many\notherfields. Asanexample, inmostmoderndayconcertmusic, AabovemiddleCistakentobe440Hz. 60 CHAPTER 3. DATA REPRESENTATION\nhour of music will take about 630 MB, which is (very) roughly the amount of memory a\ntypical CD will hold.16\nNote, however, that if you want to download a 40 MB song over a 1Mbps connection,\nit will take 40MB\/1Mbps, which comes to about 320 seconds. This is not a long time, but\nitwouldbedesirableifitcouldbeshorter. So\u2014notsurprisingly\u2014therearecompression\nschemes that reduce this considerably. For example, there is an MPEG audio compression\nstandard that will compress 4 minutes songs to about 4MB, a considerable reduction.17\n3.11 Additional Problems\nProblem 5: (a) What is the result of the following 8-bit unsigned binary operations?\nGive the result in unsigned binary. (i) 00101011 + 01100110. (ii) 11101000 \u2212 00110101.\n(b)Whatistheresultofthefollowing8-bittwo\u2019scomplementbinaryoperations? Givethe\nresult in two\u2019s complement binary. (i) 00110011 + 10011001. (ii) 11110011 + 10010101.\n(c) Convert the following problem into two\u2019s complement binary and perform addition to\nget the resulting two\u2019s complement binary solution: 80\u2212117. Hint: Remember this can\nbe written as an addition problem: 80+(\u2212117).\nProblem 6: Suppose you have a color represented as a red, green, blue triple, with\neach component an integer between 0 and 255 represented as an 8-bit unsigned binary\nnumber. The red component is 10010011, the green 11111000, and the blue 00001111.\nWhat happens if, in an attempt to make the color lighter, you add 00100000 to teach\ncomponent?\nProblem 7: Latin alphabetic characters can be represented using their ASCII equiva-\nlents. Write the decimal representation of all the characters in \u201cPei, I.M.\u201d (don\u2019t forget\nthat the punctuation and blank space are considered characters here; but don\u2019t include\nthe quotation marks).\n16See, for example, http:\/\/www.howstuffworks.com\/cd.htm for more information about how CDs\nwork. In general, there is a wealth of web sites about audio files, formats, storage media, etc.\n17Remember there is also an MPEG video compression standard. MPEG actually has a collection of\nstandards: see, for example, http:\/\/en.wikipedia.org\/wiki\/Moving Picture Experts Group. 3.12. PROBLEM SOLUTIONS 61\n3.12 Problem Solutions\nIntroductory Problem:\nInput: Three integers between 0 and 255, inclusive, that represent respectively the red,\ngreen, and blue components of a color.\nOutput: A message stating the largest component or components.\n1 Get r, g, and b\n2 Print \u2018Largest component\u2019\n3 If r > b and r > g\n4 Print \u2018red\u2019\n5 Else if g > r and g > b\n6 Print \u2018green\u2019\n7 Else if b > r and b > g\n8 Print \u2018blue\u2019\n9 Else if r equals g and r > b\n10 Print \u2018red, green\u2019\n11 Else if r equals b and r > g\n12 Print \u2018red, blue\u2019\n13 Else if g equals b and g > r\n14 Print \u2018green, blue\u2019\n15 Else\n16 Print \u2018red, green, blue\u2019\n17 Stop\nProblem 1:\nInput: a nonnegative positive integer n.\nOutput: a list of digits b ,b ,...,b ,b where b is the 1\u2019s digit, b the 2\u2019s digit, etc.,\nk k\u22121 1 0 0 1\nwith b the largest (i.e., leftmost digit) in the binary representation of n (note we aren\u2019t\nk\nadding any 0\u2019s to the front to get a predetermined length.)\n1 Get n\n2 Set k to 0\n3 While n > 0\n4 Set b[k] to the remainder of n\/2\n5 Set n to the quotient of n\/2\n6 Set k to k + 1\n7 While k > 0\n8 Set k to k-1\n9 Print b[k] 62 CHAPTER 3. DATA REPRESENTATION\nProblem 2: 3987 = 111110010011 , 4365 = 1000100001101 , and\n10 2 10 2\n4472 = 1000101111000 .\n10 2\nProblem 3: It is possible to get a negative number. For example, 32 \u221264 = \u221232 ,\n10 10 10\nwhich is not in the range 0 to 255.\nProblem 4: FF0581A4 has 8 hexadecimal digits, and since each digit takes four bits\n16\nto store, the number requires 32 bits.\nProblem 5 : (a)(i)\ncarry : 1101110\n00101011\n+ 01100110\n10010001\n(ii)\nborrow : 0110111\n11101000\n\u2212 00110101\n10110011\n(b)(i)\ncarry : 0110011\n00110011\n+ 10011001\n11001100\n(ii)\ncarry : 1110111\n11110011\n+ 10010101\n10001000\nAs discussed above, the carry bit that \u201cfalls of the left end\u201d can be ignored.\n(c) The two\u2019s complement representation for 80 is 01010000. The two\u2019s complement for\n\u2212117 is 10001011. The resulting calculation is then\ncarry : 0000000\n01010000\n+ 10001011\n11011011 3.13. ADDITIONAL RESOURCES 63\nProblem 6 :You would get an overflow error on the green component.\nProblem 7 :\nText: P e i , space I . M .\nASCII: 80 101 105 44 32 73 46 77 46\n3.13 Additional Resources\n\u2022 http:\/\/computer.howstuffworks.com\/bytes.htm . An overview and selected de-\ntails of data representation and related topics from howstuffworks. 64 CHAPTER 3. DATA REPRESENTATION Chapter 4\nLogic\nHow do we know if it is true?\n4.1 Introduction\n4.1.1 Introductory Puzzles\nSam Loyd was a famous 19th and early-20th century puzzle author. Here are his instruc-\ntions for one of his most famous puzzles, \u201cBack from the Klondike,\u201d which (according to\nWikipedia) first appeared in the New York Journal and Advertiser in April 24, 1898:\nStart from that heart [rather than a heart, the grid below uses underlining]\nin the center and go three steps in a straight line in any one of the eight\ndirections, north, south, east or west, or on the bias, as the ladies say, north-\neast, northwest, southeast or southwest. When you have gone three steps in a\nstraight line, you will reach a square with a number on it, which indicates the\nsecond day\u2019s journey, as many steps as it tells, in a straight line in any of the\neight directions. From this new point when reached, march on again according\nto the number indicated, and continue on, following the requirements of the\nnumbers reached, until you come upon a square with a number which will\ncarry you just one step beyond the border, when you are supposed to be out\nof the woods and can holler all you want, as you will have solved the puzzle.\n65 66 CHAPTER 4. LOGIC\n4 7 7\n5 4 4 8 3 3 4 6 3\n1 4 5 1 1 1 4 5 1 7 1 3 5\n4 9 4 9 6 7 5 5 5 8 7 6 6 8 5\n3 7 2 9 8 3 5 6 7 3 9 1 8 7 5 8 5\n1 4 7 8 4 2 9 2 7 1 1 8 2 2 7 6 3\n7 2 1 8 5 5 3 1 1 3 1 3 3 4 2 8 6 1 3\n4 2 6 7 2 5 2 4 2 2 5 4 3 2 8 1 7 7 3\n4 1 6 5 1 1 1 9 1 4 3 4 4 3 1 9 8 2 7\n4 3 5 2 3 2 2 3 2 4 2 5 3 5 1 1 3 5 5 3 7\n2 7 1 5 1 1 3 1 5 3 3 2 4 2 3 7 7 5 4 2 7\n2 5 2 2 6 1 2 4 4 6 3 4 1 2 1 2 6 5 1 8 8\n4 3 7 5 1 9 3 4 4 5 2 9 4 1 9 5 7 4 8\n4 1 6 7 8 3 4 3 4 1 3 1 2 3 2 3 6 2 4\n7 3 2 6 1 5 3 9 2 3 2 1 5 7 5 8 9 5 4\n1 6 7 3 4 8 1 1 1 2 1 2 2 8 9 4 1\n2 5 4 7 8 7 5 6 1 3 5 7 8 7 2 9 3\n6 5 6 4 6 7 2 5 2 2 6 3 4 7 4\n2 3 1 2 3 3 3 2 1 3 2 1 1\n7 4 4 5 7 3 4 4 7\n3 3 4\nThis set of notes usually contains solutions for the introductory puzzles; however, it\nwon\u2019t include one for the Klondike puzzle (you can do an online search for a solution if\nyou wish; better yet, solve it yourself). Instead, we will use this puzzle in another way:\n1. Try to solve the puzzle manually. What strategies do you find yourself using?\n2. What would an algorithm for solving this puzzle by computer look like? You don\u2019t\nneed to write the entire algorithm; just give a high-level description.\nConsider the a second, similar puzzle, which does have a solution later in this chapter:\nYou are planning a vacation to Canada with some of your relatives, and you and they\nvote on which city below to visit. One city got four votes, two got two votes, two got\none vote, and the remaining two cities got zero votes. Use logic and the clues below to\ndetermine how many votes each city got.\nQuebec City\nToronto\nOttawa\nMontreal\nSt. John\u2019s (Newfoundland)\nCharlottetown\nHalifax\nHere are the clues. Make sure you explain how you obtained your answer. 4.1. INTRODUCTION 67\na. Ottawa and Quebec City got different numbers of votes.\nb. Montreal either got the most votes, or it got zero votes.\nc. Quebec City got more votes than Halifax did.\nd. In the list of cities above, each of the two cities that got two votes has a city that\ngot no votes immediately above it in the list.\ne. Either Halifax got one fewer vote than Toronto did, or it got one fewer vote than\nOttawa did.\nBoth of these problems are examples of logic puzzles. Such puzzles are useful because\n(in addition to many people finding them fun) solving them requires the same types of\nlogical reasoning that is needed for many real-world problems in computer science and in\nother fields.\n4.1.2 Overview\nLogic is a field in and of itself. For example, there are entire classes devoted to it. Logic is\nan essential part of mathematics and philosophy \u2014 to name two fields it is closely related\nto \u2014 but also is important elsewhere. And, not surprisingly, it is important in computer\nscience.\n\u201cLogic\u201dcanmeanmanydifferentthingstocomputerscientists. Forexample,computer\narchitects often deal with bit-level logic. A specific example of this is applying logical\noperations like AND and OR on a bit-by-bit basis to two bytes of data. Computer\nprogrammers must deal with program logic such as the different branches a program can\ntake depending on conditions in the program. Computer programmers, system designers,\nand others use logic to analyze and\/or solve problems, analogous to what you might have\ndone on the problems in the last subsection. And theoretical computer scientists must\nprove results using logically rigorous arguments. The resulting proofs are often quite\nsimilar to proofs you might have seen in a math class. Finally, computer scientists, and\nall people, use logic when communicating with a natural language such as English.\nThis chapter will explore a variety of different uses of logic in computer science and\ncomputer engineering.\n4.1.3 Why is Logic Important?\nLogic might seem like a dry, abstract subject. However, as the examples in the previous\nsubsection show, logic is an essential part of computing. It is important in how com-\nputers work, for example, in how computers do low-level operations. It is important in\nhow computer programs work. And it is important in many other ways for computer\nprofessionals.\nBut why is it important to people who want to know about computing, but not at the\nsame level as computer professionals? Here are three reasons: 68 CHAPTER 4. LOGIC\n1. Becauselogicissofundamentaltohowcomputerswork,andhowcomputerscientists\nand computer professionals think about and solve problems, it is important to have\na basic understanding of logic to understand computers and computer science.\n2. People use logic in everyday computer use. For example, suppose you want to do\nan Internet search for information on greyhounds (the dog breed). If you just type\nin \u201cgreyhound\u201d you will also get a number of links related to Greyhound buses. So\nyou can refine your search terms to include \u201cgreyhound\u201d but exclude \u201cbus.\u201d This is\na (simple) use of logic. As a second example, suppose you maintain a database for\na University club. The club asks you to generate a report (based on the database\ninformation) of all members who have been in the club for more than two years,\nwho are in the College of Liberal Arts, and who are not currently officers of the\nclub. Specifying this database query involves the use of logic.\n3. Logic is important in analyzing and discussing societal issues. Topics such as Inter-\nnet privacy, Internet forum rules and norms, and computer security often involve\nintense discussion. How persuasive are arguments people make about such issues?\nLogic is one (of many) factors people use to gauge the persuasiveness of arguments\nand the reliability of information.\nMore generally, the skills you need to solve the various logic problems in this class are\nskills that computer practitioners often use. Being able to do tasks such as performing\nlogical operations on bitstrings, evaluating a logical expression, and solving logic puzzles\nare important not only in and of themselves, but also because they are part of, or are\nrelated to, many other tasks computer practitioners do.\nAs this class progresses we\u2019ll continue to use logic as part of certain future topics. For\nexample our next topic, computer organization, once again involves bit-level representa-\ntion and operations. And later on we\u2019ll use logical techniques as part of solving counting\nproblems, analyzing algorithms, and doing computer programming.\n4.1.4 Relation to the Mathematics Liberal Education Require-\nment\nLogic is very closely related to the mathematics liberal education requirement: logic uses\nspecial symbols and notation, operations, rules, etc. Logicians often need to prove results,\nanalyze problems, or do logical calculations. And mathematics relies on logic for the rules\nof how mathematics \u201cworks.\u201d\n4.1.5 Relation to the Society and Technology Requirement\nNever before in human history has so much information been so readily available to so\nmany people. And never before has there been so much information that is incorrect,\nbiased, incomplete, or in some other way inaccurate. 4.2. LOGICAL OPERATORS AND LOW-LEVEL LOGIC 69\nWith the Internet playing a larger and larger role in how people communicate, for ex-\nample in discussion of societally important topics, information reliability is critical. When\nyou visit a website, how do you know what you read there is correct, or at least mostly\ncorrect? What types of criteria or guidelines do you use? Part of assessing information\nreliability is based on logic. This logic is not the low-level formal logic that, for example,\ncomputer engineers use when designing computer circuits. Instead it is a more informal,\nhigher-levellogic. Forexample, doestheinformation\u201cmakesense?\u201d Doesthesitesupport\nany nonobvious claims it makes? Do any claims follow from previous statements or from\nother information that is known to be true?\n4.1.6 Goals\nUpon completing this topic, you should be able to do the following:\n1. Be able to do computations involving logical operators such as AND, OR, and NOT.\n2. Be able to evaluate the truth value of given logical statements.\n3. Be able to solve simple or moderate-difficulty logic puzzles.\n4. Be able to explain and use guidelines for evaluating the reliability of information on\nweb sites.\n4.2 Logical Operators and Low-Level Logic\n4.2.1 Introduction to Logical Operators\nThe last chapter covered how to add binary numbers. But how do computers do basic\noperations such as binary addition? It isn\u2019t something that happens magically. Instead,\ncomputers have circuitry, designed by computer engineers, for doing fundamental opera-\ntions. We\u2019ll explore this topic from a computer hardware perspective in the next chapter,\nwhich is on machine organization. In this chapter we\u2019ll look at one component of that\ncircuitry: logical operations (which are implemented as an important part of the circuitry,\nnamely as logic gates).\nWhat is a logical operation or logical operator? You are familiar with arithmetic\noperators such as addition, subtraction, exponentiation, etc. You are also familiar with\nrelational operators such as greater than, equal to, not equal to, etc. Logical operators\nindicate logical operations such as AND and OR. In this section we\u2019ll look in detail at\nthese operators and operations. In particular, we\u2019ll look at a type of logic called Boolean\nlogic. 70 CHAPTER 4. LOGIC\n4.2.2 Logical AND\nLet\u2019s look at AND first. Suppose you have two true statements, such as \u201cMars is a planet\nin our solar system\u201d and \u201cThe Martian atmosphere is roughly 100 times thinner than\nEarth\u2019s.\u201d The combined statement \u201cMars is a planet in our solar system and the Martian\natmosphere is roughly 100 times thinner than Earth\u2019s\u201d is also true. However, suppose you\nhave the statement \u201cThe average temperature on Mars is approximately 70\u25e6 Fahrenheit.\u201d\nThis is false (Mars is significantly colder). The combined statement \u201cMars is a planet in\nour solar system and the average temperature on Mars is approximately 70\u25e6 Fahrenheit\u201d\nis false: because of the \u201cand\u201d both parts of the statement must be true for the entire\nstatement to be true.\nThe AND operation applied to two statements A and B is therefore given by the\nfollowing table, where each row gives a possible combination of truth values for A and B:\nA B A AND B\nTrue True True\nTrue False False\nFalse True False\nFalse False False\nOf course, computers don\u2019t have a way of representing \u2018true\u2019 and \u2018false\u2019 directly. They\nneed to encode it in binary in some way. Computer scientists and logicians often use \u2018T\u2019\nfor true and \u2018F\u2019 for false. So we could, for example, use the ASCII equivalents for \u2018T\u2019\nand \u2018F\u2019. That is one alternative, but it is overkill. We have only two possible values to\nrepresent, \u2018T\u2019 and \u2018F\u2019, so we really need only one bit.1 Therefore we can use a bit value\nof 1 to represent true, and 0 for false. Here is the table above in terms of 0\u2019s and 1\u2019s:\nA B A AND B\n1 1 1\n1 0 0\n0 1 0\n0 0 0\nUsing bit-level logical operations in computers is a powerful idea. Not only are compo-\nnents such as AND gates a building block of computercircuits, i.e., of the actual computer\nhardware, but logical operations come up surprisingly often in computer programming.\nFor example bit-level logical operations have been used in areas such as computer graphics\nand image processing. For that reason computer programming languages include logical\noperations.\nAs an example of how logical operators are useful in doing other computer operations,\nconsider how computer languages might implement an absolute value function for integers\nrepresented using the 8-bit sign\/magnitude binary representation discussed in the last\n1Remember one bit allows us to represent two possibilities, two bits allow four, three bits allow eight,\netc. 4.2. LOGICAL OPERATORS AND LOW-LEVEL LOGIC 71\nchapter. Recall this representation has the leftmost bit indicating the sign of the number:\nif the bit is 0, the number is positive; it the bit is 1, the number is negative. Suppose you\nare working with climate data and are tracking when the first frost occurs at a particular\nlocation. Suppose further that the first frost has historically occurred on Oct. 15, and\nthe data value for each year is represented by the number of days the first frost occurred\nbefore or after Oct. 15. For example, a data value 2 means the first frost occurred two\ndays after Oct. 15, that is, on Oct. 17. A data value of \u22125 means the first frost occurred\nfive days before Oct. 15, on Oct. 10.\nSuppose your analysis requires not the exact dates the first frosts occurred, but how\nmuch those dates varied from the Oct. 15 average. So, for example, Oct. 10 and Oct. 20\nare both five days from Oct. 15, so you would want both days represented by +5 rather\nthan having Oct. 10 represented by \u22125.\nHow can a computer change the data to remove any minus signs? One way is to do\na simple logical operation with each data item. Specifically, note what happens when we\nhave a value X and perform the operation X AND 01111111. Since the leftmost bit of\n01111111 is 0, and a bitwise AND with 0 always yields 0, the sign bit of the result will\nalways be 0. And since a bitwise AND with 1 always yields the bit value you are ANDing\nwith 1, that is 0 AND 1 = 0 and 1 AND 1 = 1, the other seven bits of the result are\nidentical to the corresponding bits in X.\nHere is an example where we have a data value in the top line, and are ANDing it with\nthe 01111111 in the second line to get the result in the bottom line. Remember this is a\nbitwise operation, so it is done column by column and there is no carrying, borrowing, etc.\nNote the effect is to strip away the leading 1, that is, make the sign bit 0 and therefore\nmake the data value positive.\n1 1 0 0 0 1 1 0\nAND 0 1 1 1 1 1 1 1\n0 1 0 0 0 1 1 0\n4.2.3 Logical OR and XOR\nWhat are other basic logical operations? There are a number of them. As you might\nguess another is OR. A statement A OR B is true if A or B or both are true, and false if\nA and B are both false. Related to OR is XOR. Sometimes when we use \u201cor\u201d in natural\nlanguage we mean \u201cone or the other or both\u201d. Sometimes it means \u201cone or the other but\nnot both.\u201d For example, which of these two meanings apply to the \u201cor\u201d in the statement\n\u201cThe silent auction will end Friday or Saturday?\u201d2 With computers it is often important\nto be very clear about which interpretation we want. So computers distinguish between\nthe regular or operation OR, and the \u201cexclusive or\u201d XOR. Here is a table listing both\noperations. Note they differ only when A and B are both true.\n2Ambiguitiessuchasthoseinthestatement\u201cI\u2019llgoskiiingFridayorSaturday\u201disonereasonlanguage\nunderstanding is so difficult for computers (and sometimes for humans as well). 72 CHAPTER 4. LOGIC\nA B A OR B A XOR B\n1 1 1 0\n1 0 1 1\n0 1 1 1\n0 0 0 0\nRemember that we are giving the operation in terms of bit values 0 and 1. But if you\nreplace 1 with \u2018T\u2019 and 0 with \u2018F\u2019 you get the operations in terms of true and false.\n4.2.4 Logical NOT, Equivalence, and Implication\nAnother logical operation is NOT. Unsurprisingly, if A is true (equivalently 1), NOT(A)\nis false (0), and vice versa. NOT takes only a single argument:\nA NOT(A)\n1 0\n0 1\nTwo other operators that are useful are the equivalence operator, indicated by a triple\nhorizontal bar \u2261, and the implication operator, indicated by an arrow \u2192. Equivalence is\nstraightforward: A and B are equivalent if and only if they have the same value:\nA B A \u2261 B\n1 1 1\n1 0 0\n0 1 0\n0 0 1\nImplication is harder, but is very important since implications occur often. An impli-\ncation is of the form \u201cIf A, then B\u201d. Here is the table:\nA B A \u2192 B\n1 1 1\n1 0 0\n0 1 1\n0 0 1\nLet A be the statement \u201cThe Gopher women\u2019s hockey team won their game last night,\u201d\nand B be the statement \u201cThe Gopher women\u2019s hockey team won the league champi-\nonship.\u201d Then A implies B is \u201cIf the Gopher women\u2019s hockey team won their game last\nnight, then they won the league championship.\u201d It\u2019s no surprise that if A is true and B\nis true (they won the game, and they are the league champions) then the statement A\nimplies B is true. And it is no surprise that if A is true and B is false (the team won but\nis not the league champion), then A implies B is false. 4.2. LOGICAL OPERATORS AND LOW-LEVEL LOGIC 73\nHowever, the other two cases can be confusing. Suppose the team lost the game last\nnight, and is not the league champion. So A is false, and B is also false. Should the\nstatement \u201cIf the Gopher women\u2019s hockey team won their game last night, then they won\nthe league championship\u201d be true or false? Logicians say that statement is logically true.\nTo understand this, let\u2019s look at another example. Let A be the statement \u201cYou get\n98% or more average in this class,\u201d and B be the statement \u201cYou get an A in the class.\u201d\nThink of the implication \u201cIf you get 98% or more average in this class, then you get an\nA in the class\u201d as a contract. Under which truth values of A and B are the terms of\nthe contract upheld (and so the implication statement should be true), and under which\ntruth values are the terms violated (and so the implication statement should be false)?\n\u2022 If you got a 98% or more average, and you got an A, then the terms are upheld.\nThat is, T \u2192 T is T (true) makes sense.\n\u2022 If you got a 98% or more average, and you did not get an A, then the terms are\nviolated: T \u2192 F is F (false) makes sense.\n\u2022 If you got less than 98% average, you might or might not have gotten an A. For\nexample, maybe you got an A because you had a 97% average and that was enough\nto be in the A range. Or maybe you had a lower grade and got a C+. In either\ncase the contract is not violated because the contract only stipulates what happens\nif you got a 98% or higher. So F \u2192 T does not violate the terms of the contact,\nand so it evaluates to T (true). Similarly, F \u2192 F does not violate the terms of the\ncontact, so it evaluates to T (true).3\nIn the next section we\u2019ll consider compound logical statements: statements consisting\nof logical substatements joined by logical operators. Before we leave this section, however,\nhere are two additional notes:\nFirst, there are other logical operations. For example, there is a NOR operation.\nHowever, the ones above are the most important for this class, and the other operators\ncan be expressed in terms of them. For example, NOR is a combination of NOT and\nOR. Second, a caution on notation: unfortunately there are many different symbols and\nnames used for logical operations. Here, we will use the symbols above, writing out AND,\n3Hereisonemoreexplanationofwhylogicalimplicationisdefinedthewayitis. Specifically, itshows\nwhy if A \u2192 B is true, and A is false, you cannot assume B must be false. Consider the joke \u201cThe\nphilosopher Rene Descartes walks into a bar. The bartender asks him if he\u2019d like a drink. \u2018I think not,\u2019\nDescartes replies, and then vanishes as if he was never there.\u201d\nThe joke of course relies on the listener recalling Descartes statement \u201cCogito, ergo sum\u201d \u2014 \u201cI think,\nthereforeIam.\u201d Orwecanrewordthisas\u201cIfIthink,thenIexist.\u201d Thisisatrueimplication(leaveaside\ndeeper discussions of what it means to think, and what it means to exist). It then relies on humorously\nequating the the meaning of \u201cI think not\u201d with with the meaning of \u201cI don\u2019t think.\u201d At this stage we\nhave A \u2192 B (\u201cIf I think, then I exist\u201d) is true, and A (\u201cI think\u201d) is false. The joke than relies on the\nlogicalfallacythatB(\u201cIexist\u201d)mustalsobefalse. ThefallacythatifA\u2192Bistrue,andAisfalse,then\nBmustbefalseiscommonenoughthatlogicianshaveaspecialfancynameforit: denyingtheantecedent. 74 CHAPTER 4. LOGIC\nOR, XOR, and NOT, and using the symbol \u2192 and \u2261 for the implication and equivalence\noperators, respectively. However, other works use other symbols and other names. As\nan example AND is sometimes indicated by \u2018\u2227\u2019, a dot \u2018.\u2019, or an ampersand \u2018&\u2019, and is\nsometimes called \u201clogical conjunction\u201d instead of \u201cand.\u201d Wikipedia has a good page on\nlogical symbols at http:\/\/en.wikipedia.org\/wiki\/List of logic symbols.\n4.3 Compound Logical Statements\nLogical statements can get complicated and can involve more than two (sub)statements\nand more than one logical operator. For example, suppose you are searching for omelet\nrecipes, and want to include basil or chives (or possibly both), but do not want the recipe\nto include shallots. If you do an advanced search in Google, you can specify words that\nthe page must contain, a list of words that the page must contain at least one of, or\nwords that should not be on the page. So for example, we could specify the recipe search\ncontains \u201comelet\u201d and at least one of \u201cbasil\u201d or \u201cchive\u201d but does not contain \u201cshallot.\u201d\nLet us use the following \u201cshorthand\u201d:\nA : The page being considered contains the word \u201comelet\u201d.\nB : The page being considered contains the word \u201cbasil\u201d.\nC : The page being considered contains the word \u201cchive\u201d.\nD : The page being considered contains the word \u201cshallot\u201d.\nThen the search we are specifying is A AND (B OR C) AND NOT(D).\nSuppose a page contains the word \u201comelet\u201d (A is true), does not contain \u201cbasil\u201d (B is\nfalse), does not contain \u201cchive\u201d (C is false), and does not contain \u201cshallot\u201d (D is false).\nDoes that page fulfill your search criteria? You can probably see it does not: the logical\nexpression becomes T AND (F OR F) AND NOT(F). Notice F OR F evaluates to F, and\nNOT(F) evaluates to T. So the statements simplifies to T AND F AND T. Notice this is\na statement with three truth values and two AND operations. Absent any parentheses,\nwe evaluate this statement left to right: T AND F evaluates to F, so T AND F AND T\nsimplifies to F AND T, which evaluates to F.\nThere are rules for which operations to perform first in compound statements. For\nexample, when a compound statement contains operators of different types and no paren-\ntheses, then AND operations should be done before OR operations, just as multiplication\nis done before addition in regular arithmetic. However, because these rules are mildly\ncomplicated, we will use parentheses to indicate the order of operations. For example,\nthe rules of logic dictate that in A OR NOT B AND C, first NOT B would be evaluated,\nthen the result of that would be AND\u2019ed with C, and then the OR would be performed.\nBut rather than write A OR NOT B AND C, we will write A OR (NOT(B) AND C).\nNote this is logically equivalent, but explicitly shows the order of operations. 4.3. COMPOUND LOGICAL STATEMENTS 75\nSuppose, however, we wanted a slightly different statement. The logical expression\nA OR (NOT(B AND C)) is similar to the one in the last paragraph, but the parentheses\noverride the usual order of operations and dictate that we do the AND operation before\nthe NOT. So this is a different logical expression than the one in the previous paragraph.\nSimilarly, due to its parentheses (A OR (NOT(B))) AND C is different still, since it\nperforms the OR before the AND.\nProblem 1: Does the order of operations matter if all the operations in a compound\nstatement are the same? For example in A AND B AND C, does it matter if we evaluate\nA AND B first versus evaluating B AND C? How about for implication? Does (A \u2192 B)\n\u2192 C always evaluate to the same logical value as A \u2192 (B \u2192 C)?\nHere is another example: suppose you have the following statements:\nA : The database record being considered is for a person whose last name starts with\nan \u2018F\u2019.\nB : The database record being considered is for a person whose first name starts with\nan \u2018F\u2019.\nC : The database record being considered is for a person whose occupation is \u2018writer\u2019.\nD : The database record being considered is for a person who was born before 1900.\nSuppose we wanted to return true for each record where the first or last name started\nwith \u2018F,\u2019 the person is (or was) a writer, and the person was born in 1900 or later. So, for\nexample, the search criteria should return true for the fiction writer Jasper Fforde (born\nin 1961), but false for (2013 Nobel Prize winner) Alice Munro.\nWhatwouldthelogicalstatementbewhenexpressedintermsofA,B,C,Dandlogical\noperators? And what would this statement evaluate to under all possible assignments of\ntruth values to A, B, C, and D?\nThe logical statement would be (((A OR B) AND C) AND (NOT(D))). To show its\nvalue under all possible assignments of truth values, we can construct the truth table\nshown on the next page. This truth table shows all possible combinations of truth values\nfor the A, B, C, and D, as well as the resulting truth value of the entire statement. In this\ncase there are four \u201clogical variables\u201d A, B, C, and D. Each can take on two values, T\nor F, so there are 24 = 16 different possible assignments. The table also shows the truth\nvalue of intermediate steps.\nTruth tables are one way of working with compound logical statements. They have\nadvantages: they provide all possibilities in a structured way. However, they also have\ndisadvantages. For example, sometimes you don\u2019t need to evaluate all possibilities. More-\nover, as the table shows, if the logical statement has a large number of different logical\nvariables, then the table will have a large number of rows.\nThe next problem shows another use for truth tables: 76 CHAPTER 4. LOGIC\nA B C D NOT(D) A OR B (A OR B) AND C (((A OR B) AND C)\nAND (NOT(D)))\nT T T T F T T F\nT T T F T T T T\nT T F T F T F F\nT T F F T T F F\nT T T T F T T F\nT F T F T T T T\nT F F T F T F F\nT F F F T T F F\nT F T T F T T F\nF T T F T T T T\nF T F T F T F F\nF T F F T T F F\nF F T T F F F F\nF F T F T F F F\nF F F T F F F F\nF F F F T F F F\nProblem 2: Use truth tables to prove or disprove that NOT(A AND B) always has the\nsame value as NOT(A) OR NOT(B). That is, for all possible assignments of truth values\nto A and B will NOT(A AND B) always evaluate to the same value as NOT(A) OR\nNOT(B)?\nOften, we are not concerned with all possible truth values, but are given some logical\nstatements whose truth we know or can find out, and are also given a compound logical\nstatement based on the original statements. For example, suppose we have the following:\nA : The Art Institute of Chicago has Picasso\u2019s painting The Old Guitarist in its\npermanent collection.\nB : The Art Institute of Chicago has Grant Wood\u2019s painting American Gothic in its\npermanent collection.\nC : The Art Gallery of Ontario has a sculpture court of Henry Moore works.\nD : Joseph Mallard William Turner\u2019s painting Rain, Steam, and Speed is in the per-\nmanent collection of the Art Gallery of Ontario.\nStatements A, B, and C are true, but D is false (the painting is in the National Gallery\nin London).\nSuppose someone claims that \u201cThe Art Institute of Chicago has both Picasso\u2019s The\nOld Guitarist and Wood\u2019s American Gothic; or the Art Gallery of Ontario either has 4.4. MORE BITWISE OPERATIONS 77\na Henry Moore sculpture court or contains Turner\u2019s Rain, Steam, and Speed (but not\nboth).\u201d Write this statement in terms of A, B, C, D and logical operators, and then\nevaluate its truth value.\nTo write the statement, note the first part is A AND B, and the second part is C XOR\nD. (It is a little unclear whether \u201cbut not both\u201d applies to the first or second \u2018or\u2019; the\nword \u2018either\u2019 is used to indicate it applies to the second.) By the sentence punctuation,\nwe do these operations, and then OR the results. So we get (A AND B) OR (C XOR D).\nNow since A, B, and C are true (T), and D is false (F), we get\n(A AND B) OR (C XOR D)\n= (T AND T) OR (T XOR F)\n= T OR T\n= T\nProblem 3: Consider the statement \u201cThe Art Institute of Chicago has Picasso\u2019s The\nOld Guitarist or Wood\u2019s American Gothic (or both); and it is not the case that the Art\nGallery of Ontario has both a Henry Moore sculpture garden and Turner\u2019s Rain, Steam,\nand Speed.\u201d Write this statement in terms of A, B, C, D and logical operators, and then\nevaluate its truth value.\n4.4 More Bitwise Operations\nLet\u2019s extend the material in the last section to bitwise operations. That is, this section\nexplores applying a sequence of bitwise operations to bytes of data.\nIt will do this by looking at an example from image processing. Suppose you have a\ngrayscale image, that is, an image where each pixel is represented a certain gray value\nrather than an RGB triple. We\u2019ll use a single byte for each pixel with the byte value\nindicating the pixel\u2019s intensity: for example, 00000000 is black, 10000000 is a mid-level\ngray, and 11111111 is white. Suppose a pixel\u2019s intensity is given by X = 10111101. What\nis the result of the bitwise operation (NOT (X)) AND 11110000?\nTo answer this question, we first apply NOT to X, changing each 1 to 0 and each 0\nto 1, to obtain 01000010. Here is this operation with the NOT of each original bit shown\ndirectly below it.\n1 0 1 1 1 1 0 1\nNOT 0 1 0 0 0 0 1 0\nNow we AND this result with 11110000:\n0 1 0 0 0 0 1 0\nAND 1 1 1 1 0 0 0 0\n0 1 0 0 0 0 0 0 78 CHAPTER 4. LOGIC\nProblem 4: Give an English explanation of what (NOT(X)) AND 11110000 does to the\npixel with original gray value X.\nProblem 5: Suppose a pixel\u2019s intensity is given by X = 10111101. What is the result of\nthe bitwise operation (NOT (X)) XOR 11100111?\n4.5 Information Reliability\nOne of the many ways we judge if information is reliable is whether the information\npresented is logically convincing. There are different ways that an argument can fail to be\nconvincing. One problem occurs if the facts used as a basis for the argument are incorrect.\nFor example, the claim \u201cSince the Internet was invented in France, countries other than\nthe U.S. should have a larger role in Internet governance\u201d is not very convincing. The\nreason for this is that the premise \u201cthe Internet was invented in France\u201d is not true\n(French researchers contributed to the creation of the Internet, but the bulk of the work\nwas done in the United States). So even if you believe that countries other than the U.S.\nshould have a larger role in Internet governance you would not find the given argument\nconvincing because the premise is false. Logicians call this an unsound argument.\nAnother way arguments can fail to be convincing is when the conclusion does not\nfollow from the premises. Such as argument is said to be invalid. For example, if we are\ntrying to figure out a file error, and we know (i) today the file is not up-to-date; (ii) the\nfile was either updated correctly last night, or an error message was sent to a log file, or a\nsystem administrator delayed the update. Then the conclusion \u201cthe system administrator\ndelayed the update\u201d does not follow logically since it is possible that an error message\nwas sent to a log file instead.\nHere\u2019s a tricky point: just because this is an invalid argument does not mean you\ncan reason that the conclusion \u201cthe system administrator delayed the update\u201d is false.\nThe administrator might or might not have delayed the update. Based on the argument,\nhowever, you don\u2019t know which of the two possibilities (the administrator delayed the\nupdate or an error message was sent to a log file) occurred. An invalid argument just\nmeans that the given argument does not logically support the conclusion being true.\nAnother problem with applying logic to natural language arguments is that most\nwriting, out of necessity, is not detailed enough that we can apply formal logic. Unless\nyou are writing a rigorous mathematical proof (and probably not even then), you skip\nsteps, assume certain background knowledge, etc.\nFor example, consider the claim \u201cif a person were to keep walking in a line parallel\nto the equator, he or she would eventually return to where they started. Note there are\nsome very large assumptions here: the reader knows earth is round(ish), knows what\nthe equator is, understands that \u2018walk\u2019 is meant figuratively rather than literally, realizes\nthat concerns such as the amount of time and resources needed are being excluded from\nconsideration, etc.\nWhen people write, sometimes they err on the side of providing too much detail and 4.6. THINGS TO THINK ABOUT 79\ntrying too hard to provide conclusions. More common, however, is the opposite error:\nproviding too little detail, or arguments that are too weak. It is too easy for a writer to\nassume the audience has the same background and mind-set as he or she does.4 Part of\nthis is the use of logic in writing, and part of it is other considerations.\nIn conclusion of this section, then, logic plays an important role in information reliabil-\nity, both in writers convincing their readers, and in readers assessing written information.\nHowever, there are also other aspects of information reliability that we will discuss further\nin other class activities.\n4.6 Things to Think About\nHere are some questions to think about. We will discuss some of these further in class.\n1. Think of an area outside of computer science. This could be another field, a hobby,\nwork-related, etc. How is logic used in that area?\n2. As one of the examples in this chapter illustrates, logic is often used in database\nqueries. If you have ever used a database program, list some queries you have\nperformed and indicate what logical operators they use.\n3. When you write, what techniques do you use to convince the reader that the con-\nclusions you are making are correct?\n4. When you read information on the Internet, how do you assess whether that infor-\nmation is reliable?\n4.7 Additional Problems\nProblem 6: Let A be the statement \u201cThe exercise regimen improved recovery times, on\naverage, by at least one week in knee replacement patients.\u201d Let B be the statement \u201cThe\nimproved surgical technique improved recovery times, on average, by at least one week in\nknee replacement patients.\u201d Fill in the following logic tables:\nA B NOT A NOT(A) AND B (NOT (A) AND B) XOR B\nT T\nT F\nF T\nF F\n4Some writing advice from David Foster Wallace\u2019s essay \u201cAuthority and American Usage\u201d: \u201c(1) Do\nnot presume the reader can read your mind \u2014 anything you want the reader to visualize or consider or\nconclude, youmustprovide; (2)Donotpresumethereaderfeelsthesamewaythatyoudoaboutagiven\nexperience or issue \u2014 your argument cannot just assume as true the very thing you\u2019re trying to argue\nfor.\u201d 80 CHAPTER 4. LOGIC\nA B A XOR B A AND B (A XOR B) OR (A AND B)\nT T\nT F\nF T\nF F\nProblem 7: ViewtheFortuneMagazine2012listofthe1000largestUSCorporations, on\nthewebathttp:\/\/money.cnn.com\/magazines\/fortune\/fortune500\/2012\/full list\/.\nIndicate whether each of the following statements is true or false:\n(i) Hewlett-Packard has more revenue than Apple, and has more profit than International\nBusiness Machines (IBM).\n(ii) If Apple has more profit than Microsoft and Amazon.com has more profit than\nHewlett-Packard, then Google has more profit than Cisco Systems.\n(iii) Microsoft has more profit than each of the following: Hewlett-Packard, IBM, Dell,\nIntel, Amazon.com, and Google.\n(iv) Either Cisco Systems has more revenue than Sysco, or Cisco Systems has more profit\nthan Sysco, but not both.\n(v) If Honeywell International has less revenue than Oracle, then either Microsoft has\nmore profit than Oracle or Apple has more profit than Oracle, but not both.\n(vi) Intel has more revenue than Amazon.com or AT&T has more profit than Microsoft,\nand it is not the case that both Intel and Microsoft each have more profit than Cisco\nSystems.\n(vii) Intel and Medtronic both appear on the Top 100 list, or AT&T and Verizon Com-\nmunications each have more profit than Microsoft.\nProblem 8: Sometime algorithms work at the bit level. (For example, serious encryption\ntechniques use a variety of bit-level operations so the encrypted message is difficult to\n\u201ccrack.\u201d) These algorithms are difficult to trace, but doing so is a good exercise in\nunderstanding both algorithms and bit operations. Consider the following algorithm:\nInput: two 4-bit binary strings a and b.\nOutput: one 4-bit binary string output\n1 Set i = 1\n2 While i < 4\n3 output[i] = b[i+1]\n4 Set i = i+1\n5 Set output[4] = 1\n6 Set i = 1\n7 While i \u2264 4\n8 output[i] = output[i] AND (NOT(a[i]))\n9 Set i = i+1\n10 Set tmp = output[4] 4.8. PROBLEM SOLUTIONS 81\n11 Set output[4] = output[3]\n12 Set output[3] = tmp\n13 Print output\n14 Stop\nNote: In the pseudocode for this problem we use the notation output[i] to mean the value\nof the ith bit of binary string output, read left to right. So output[1] is the most significant\n(leftmost) bit and output[4] is the least significant (rightmost) bit, as shown in this figure:\nmost significant =\u21d2 least significant\n| 1 | 2 | 3 | 4 |\nsmallest index =\u21d2 largest index\nFor example, if a = 0011, then a[1] = 0 and a[4] = 1. If b = 1010, then b[1] = 1 and b[4]\n= 0.\n(i) Trace through the algorithm for input a = 0011, b = 1010. Specifically, (a) show\nthe values of i and output immediately before each time Line 4 is executed, (b) show the\nvalues of i and output immediately before each time Line 9 is executed, and (c) show what\nis printed. In part (a), if a variable is not yet assigned a value when Line 4 is executed,\nleave the value for that variable blank.\n(ii) Trace through the algorithm for input a = 1001, b = 1111. Specifically, (a) show\nthe values of i and output immediately before each time Line 4 is executed, (b) show the\nvalues of i and output immediately before each time Line 9 is executed, and (c) show what\nis printed. In part (a), if a variable is not yet assigned a value when Line 4 is executed,\nleave the value for that variable blank.\nProblem 9: Suppose you can evaluate the logical expression A XOR NOT B AND A in any\norder you want. How many different possible orders of evaluation are there?\n4.8 Problem Solutions\nSecond Introductory Problem:\nHere are the vote totals, followed by a line of reasoning to obtain the totals. Other\nlines of reasoning were possible as well.\nQuebec City 4\nToronto 0\nOttawa 2\nMontreal 0\nSt. John\u2019s 2\nCharlottetown 1\nHalifax 1\nObservation 1: From Clue (b) Montreal either had 0 or 4 votes.\nObservation 2: From Clue (c) Quebec City had more votes than Halifax, meaning Quebec\nCity did not get 0 votes and Halifax did not get 4 votes. 82 CHAPTER 4. LOGIC\nObservation 3: From Clue (d) we get the following. Note that since there are two cities\nwith two votes, and two with no votes, every city with two votes must be immediately\nbelow a city with no votes, and every city with no votes must be immediately above a\ncity with 2 votes. (i) Quebec City did not get 2 votes since it has no city above it in the\nlist to get 0 votes. (ii) Toronto did not get 2 votes, since it is below Quebec City, which\nby Observation 2 did not get 0 votes. (iii) Ottawa did not get 0 votes since it is above\nMontreal, which by Observation 1 did not get 2 votes. (iv) Halifax did not get 0 votes\nsince there is no city below it to get 2 votes.\nObservation 4: Halifax got 1 vote. This is because it did not get 0 or 4 votes by obser-\nvations 3(iv) and 2, respectively. Moreover, by Clue (e) there was a city with one more\nvote than Halifax. Since no city got 3 votes, Halifax could not have gotten 2 votes. The\nonly option left is it got 1 vote.\nObservation 5: Ottawa must have gotten 2 votes. This is because by Clue (e) either\nToronto or Ottawa got one more vote than Halifax. By Observation 4 Halifax got 1 vote,\nso either Toronto or Ottawa got 2. However, Toronto did not get 2 votes by Observation\n3(ii). So Ottawa got 2 votes.\nObservation 6: By Observation 5 and Clue (d), Toronto got 0 votes.\nObservation 7: Quebec City got 4 votes. This is because, by Clue (c), it must have more\nthan the number of votes Halifax did, which is 1 by Observation 4. Moreover, Quebec\nCity did not get 2 votes by Observation 3(i). So the only option left is 4 votes.\nObservation 8: Montreal got 0 votes. This is because it had either 0 or 4 votes. But only\none city got 4 votes, and by Observation 7 that city was Quebec City. So the only option\nleft for Montreal is 0 votes.\nObservation 9: St. John\u2019s got 2 votes. This is because it is immediately below a city,\nMontreal, which by Observation 8 got 0 votes. So by Clue (d) and the comment in\nObservation 3, St. John\u2019s must have gotten 2 votes.\nObservation 10: Only one city, Charlottestown, remains. And all the vote numbers are\naccounted for except for one city with 1 vote. So Charlottestown must have gotten 1 vote.\nProblem 1:\nThe order is sometimes, but not always, important. AND is independent of the order\nused: A AND B AND C will evaluate to true, regardless of which AND is evaluated first,\nif and only if all of A, B, and C are true. Similarly, A OR B OR C will evaluate to true,\nagain regardless of the order, if and only if at least one of A, B, or C is true. However, this\norder independence is not true of all operations: (A \u2192 B) \u2192 C does not always evaluate\nto the same truth value as A \u2192 (B \u2192 C). For example, let A be false, B be false, and C\nbe false. Then (A \u2192 B) \u2192 C simplifies to (F \u2192 F) \u2192 F, and so to T \u2192 F, and so to F.\nBut A \u2192 (B \u2192 C) simplifies to F \u2192 (F \u2192 F), and so to F \u2192 T, and so to T. 4.8. PROBLEM SOLUTIONS 83\nProblem 2:\nHere is a truth table showing the equivalence. Note the two bold columns have identical\nvalues:\nA B A AND B NOT (A AND B) NOT(A) NOT(B) NOT(A) OR NOT(B)\nT T T F F F F\nT F F T F T T\nF T F T T F T\nF F F T T T T\nProblem 3:\nThestatementis(AORB)AND(NOT(CORD)).NoticethatstatementusesORrather\nthan XOR, and that the punctuation and phrasing indicates the order of operations.\nSubstituting the truth values gives\n(A OR B) AND (NOT (C AND D))\n= (T OR T) AND (NOT (T AND F))\n= T AND (NOT (F))\n= T AND T\n= T\nProblem 4 :\nThe NOT inverts the intensity, so intense gray values would go to dark ones, and vice\nversa (for example white goes to black, and black to white). The AND then takes the\nresult and \u201crounds down\u201d to the nearest multiple of 16 (for example, a value of 18 is\n10\nrounded to 16 , a value of 89 to 80 , etc.).\n10 10 10\nProblem 5:\nApplying (NOT (X)) XOR 11100111 to X = 10111101 gives 01000010 for applying NOT\nto X, and then the XOR gives\n0 1 0 0 0 0 1 0\nXOR 1 1 1 0 0 1 1 1\n1 0 1 0 0 1 0 1\nProblem 6:\nA B NOT A NOT(A) AND B (NOT(A) AND B) XOR B\nT T F F T\nT F F F F\nF T T T F\nF F T F F 84 CHAPTER 4. LOGIC\nA B A XOR B A AND B (A XOR B) OR (A AND B)\nT T F T T\nT F T F T\nF T T F T\nF F F F F\nProblem 7:\nFirst, here are the relevant rows from the Fortune 500 table.\nMillions of dollars\nRank Company Revenue Profit\n10 Hewlett-Packard 127,245.0 7,074.0\n11 AT&T 126,723.0 3,944.0\n15 Verizon Communications 110,875.0 2,404.0\n17 Apple 108,249.0 25,922.0\n19 International Business Machines 106,916.0 15,855.0\n37 Microsoft 69,943.0 23,150.0\n44 Dell 62,071.0 3,492.0\n51 Intel 53,999.0 12,942.0\n56 Amazon.com 48,077.0 631.0\n64 Cisco Systems 43,218.0 6,490.0\n69 Sysco 39,323.5 1,152.0\n73 Google 37,905.0 9,737.0\n77 Honeywell International 37,059.0 2,067.0\n82 Oracle 35,622.0 8,547.0\n164 Medtronic 15,933.0 3,096.0\nFor each part, to decide whether a statement is true we\n1. split the statement into logically simple parts and give each part a symbolic name\nsuch as a or b;\n2. evaluate the truth of each simple part;\n3. express the complete statement in terms of logical operations (AND, OR, NOT,\netc.) and simple parts;\n4. evaluate the logical expression.\n(i) a: Hewlett-Packard has more revenue than Apple: true\nb: Hewlett-Packard has more profit than International Business Machines: false\na AND b:\ntrue AND false\nANSWER: false 4.8. PROBLEM SOLUTIONS 85\n(ii) a: Apple has more profit than Microsoft: true\nb: Amazon.com has more profit than Hewlett-Packard: false\nc: Google has more profit than Cisco Systems: true\nIF (a AND b), THEN c:\nIF (true AND false), THEN true\nIF false, THEN true\nANSWER: true\n(iii) a: Microsoft has more profit than Hewlett-Packard: true\nb: Microsoft has more profit than IBM: true\nc: Microsoft has more profit than Dell: true\nd: Microsoft has more profit than Intel: true\ne: Microsoft has more profit than Amazon.com: true\nf: Microsoft has more profit than Google: true\na AND b AND c AND d AND e AND f\ntrue and true and true and true and true and true\nANSWER: true\n(iv) a: Cisco Systems has more revenue than Sysco: true\nb: Cisco Systems has more profit than Sysco: true\na XOR b\ntrue XOR true\nANSWER: false\n(v) a: Honeywell International has less revenue than Oracle: false\nb: Microsoft has more profit than Oracle: true\nc: Apple has more profit than Oracle: true\nIF a THEN (b XOR c)\nIF false THEN (true XOR true)\nIF false THEN false\nANSWER: true\n(vi) a: Intel has more revenue than Amazon.com: true\nb: AT&T has more profit than Microsoft: false\nc: Intel has more profit than Cisco Systems: true\nd: Microsoft has more profit than Cisco Systems: true\n(a OR b) AND NOT(c AND d)\n(true OR false) AND NOT(true AND true)\ntrue AND NOT(true)\ntrue AND false\nANSWER: false 86 CHAPTER 4. LOGIC\n(vii) a: Intel appears on the Top 100 list: true\nb: Medtronic appears on the top 100 list: false\nc: AT&T has more profit than Microsoft: false\nd: Verizon Communications has more profit than Microsoft: false\n(a AND b) OR (c AND d)\n(true AND false) OR (false AND false)\nfalse OR false\nANSWER: false\nProblem 8.\n(i) Here is the trace at Line 4, at line 9, and the final output:\nLine 4 i output[1] output[2] output[3] output[4]\n1 0\n2 0 1\n3 0 1 0\nLine 9 1 0 1 0 1\n2 0 1 0 1\n3 0 1 0 1\n4 0 1 0 0\nPrinted 0 1 0 0\n(ii) Here is the trace at Line 4, at line 9, and the final output:\nLine 4 i output[1] output[2] output[3] output[4]\n1 1\n2 1 1\n3 1 1 1\nLine 9 1 0 1 1 1\n2 0 1 1 1\n3 0 1 1 1\n4 0 1 1 0\nPrinted 0 1 0 1\nProblem 9: There are three possibilities: (A XOR NOT(B)) AND A; A XOR (NOT(B) AND\nA); (A XOR NOT(B AND A).\n4.9 Additional Resources\nHere are some additional resources: 4.9. ADDITIONAL RESOURCES 87\n\u2022 http:\/\/computer.howstuffworks.com\/boolean1.htm . This file from howstuff-\nworks explains in detail how the Boolean logic in this chapter is important in com-\nputer hardware. This not only explains this connection further, but also explains\nsome items that will appear briefly in the next chapter.\n\u2022 http:\/\/www.nlm.nih.gov\/bsd\/disted\/pubmedtutorial\/020 350.html . A fairly\nsimple tutorial from the National Institute of Health\u2019s U.S. National Library of\nMedicine explaining simple searches of medical databases. The examples show use\nof AND, OR, and NOT.\n\u2022 http:\/\/en.wikipedia.org\/wiki\/Reliability of Wikipedia. ThisisaWikipedia\narticle about Wikipedia. It is fairly long, but not all sections are relevant for this\nclass. In addition to this page, Wikipedia also contains other pages about its relia-\nbility, such as http:\/\/en.wikipedia.org\/wiki\/Wikipedia%3AAcademic use. 88 CHAPTER 4. LOGIC Chapter 5\nMachine Organization\nIt is still all 0\u2019s and 1\u2019s.\n5.1 Introduction\n5.1.1 Introductory Problem\nSuppose you work at an arboretum. You have a list of 100 data records for trees. Each\nrecord contains three data: the first is the type of tree, stored as a 6-character string\n(assume you have abbreviated codes for the tree names so you do not have to store the\nentire, potentially lengthy, name). The second is the year the tree was planted, stored as\na 16-bit integer. The third is the diameter of the tree the last time it was measured. This\nis stored as a 32-bit floating point number.\n(a) How much memory does the list take?\n(b) Assume all the records are stored one right after the other, with the first record\nat memory location (given in hexadecimal, since memory locations are often given in\nhexadecimal) 3b2201aa. What memory location or locations are occupied by the last\nrecord? Give your answer in hexadecimal.\n5.1.2 Overview\nHow do computers work?\nIn the past few chapters you\u2019ve seen parts of this puzzle. The chapter on data repre-\nsentation used binary numbers for storing different types of data. The chapter on logic\nbriefly mentioned implementing computer operations in circuits containing logic gates.\nAnd the chapter on algorithms used sequences of (higher-level) instructions to solve prob-\nlems and perform tasks. But how do the algorithms\u2019 instructions work on a lower level?\nAnd how do all these parts \u2014 data, low-level operations, and high-level instructions \u2014\ncome together?\n89 90 CHAPTER 5. MACHINE ORGANIZATION\nAlgorithms are implemented in a computer language such as Java, C++, or Python.\nSooneanswertothefirstquestioninthelastparagraphisthatalgorithmsareenteredinto\nthe computer as text representing the computer program. And in the data representation\nchapter we saw that computers can represent text in ASCII. But this raises still other\nquestions. For example, how does a computer distinguish between text representing com-\nputer instructions, and text representing data? And even if an instruction is recognized\nas an operation and not as data, how does a computer, on a low level, actually perform\nthat operation?\nComputer instructions, on a low level, are still all 0\u2019s and 1\u2019s. While instructions in an\nalgorithm specification are implemented in a computer language such as Java, these in-\nstructions are eventually converted into machine instructions, which have a binary equiv-\nalent. For example, for a particular computer a bitstring 0001101011 might mean \u201ccheck\nif the value of the variable I am about to give you (the location of) is equal to 0.\u201d\nNote this means, on one hand, that computer instructions are another type of data,\nstored in computer memory along with the other data the computer holds. On the other\nhand, computer instructions are a special type of data, and do not use ASCII equivalents;\ninstead they use other binary equivalents called operation codes, or opcodes for short. And\ncomputers must work with these operation codes differently than they do \u201cregular\u201d data.\nThe purpose of this chapter is to delve further into the inner workings of comput-\ners. Although this will be a brief and simplified version of how computers work,1 it will\nnonetheless cover key ideas about computers, computer science, and computer engineer-\ning. In summary, in this chapter we\u2019ll look questions such as\n\u2022 How, on a low level, do computers work?\n\u2022 How do computers represent instructions?\n\u2022 How are computer hardware and software related?\n\u2022 What are the important parts of a computer, and what is important to know about\nthem?\n5.1.3 Motivation\nHow do things work? We usually do not need to understand the \u201cinner workings\u201d of\ntechnological devices in order to use them: how they work is hidden away behind a simple\ninterface. Think, for example, of driving a car. You need to know how to start the car,\nhow to steer it, how to stop it, etc. You do not need to know how the engine works, how\nthe electrical system works, or the exact composition of the tires. That all is hidden.\n1How computers work is very complicated. For example, there are entire classes devoted to subparts\nof this topic. Here are a few at the University of Minnesota: CSci 2021, Machine Organization; EE 2001,\nIntroduction to Circuits and Electronics; EE 2301, Introduction to Digital System Design; EE 2361,\nIntroduction to Microcontrollers; CSci 4203\/EE 4363, Computer Architecture. 5.1. INTRODUCTION 91\nSimilarly, to be a computer user of office software such as spreadsheets, of a web\nbrowser, or of a statistical analysis package, etc. you do not need to know how the\ncomputer works \u201cunder the hood.\u201d\nOn the other hand, there are times when it is useful to know about computer hardware\nand the inner workings of a computer. Suppose you are buying a new computer and it\nis advertised as having \u201ccache memory.\u201d What does that mean? Is it good or bad? Or\nsuppose it has a one terabyte hard disk. Is that a large amount of memory? Or suppose\na program tells you there is a \u201cbus error.\u201d What do busses have to do with computers?\nKnowingatleastalittleaboutcomputerhardwarecanbehelpfulwhenbuyingcomputers,\nor when working with some programs.\nMoreover, this is a chapter where a number of key ideas in computer science come\ntogether. Specifically, this chapter, more than any other chapter, explains how computers\npull together algorithms, data, and logic, and actually do things.\n5.1.4 How This Topic Relates to the Mathematics Requirement\nIn this chapter you will again see the connections between computing and mathematics\nthat appeared in previous chapters. These include binary numbers, carefully stepping\nthrough a computational process, and doing arithmetic problems related to memory space\nor access time.\n5.1.5 How This Topic Relates to the Society and Technology\nTheme\nThe increasing effects of computers on society are based on computers\u2019 increasing capa-\nbilities. Twenty years ago laptops, streaming audio and video, social networks site, etc.\nwere uncommon, if they existed at all. However, continual and dramatic improvements in\ncomputer capabilities, for example increases in computer speed and in computer memory,\nhave made possible what we take for granted nowadays.\nTo understand how computers have advanced \u2014 and what further advances are likely\nin the future \u2014 we need to know the basics of how computers work. So, for example, we\nneed to know what the main parts of a computer are, we need to know something about\ncomputer speed, we need to know about computer memory, etc. This chapter discusses\nthose basics. And in the next chapter, which is on Moore\u2019s Law, we will focus specifically\non how computer hardware has advanced and is advancing.\n5.1.6 Goals\nUpon completing this topic, you should be able to do the following:\n1. Be able to list different parts of a computer (this includes explaining any relevant\nterms), why they are important, and how they are related. 92 CHAPTER 5. MACHINE ORGANIZATION\n2. Be able to explain, on a low level, how computers work.\n3. Be able to relate computer component characteristics to common tasks. (Example:\nis 256K of memory enough to store the text from a normal sized book?).\n4. Be able to solve arithmetic problems involving computer components. (Example:\nSuppose you download a 3MB file over a 250Kbps connection. How long will it\ntake?).\n5. Be able to read, translate, and trace through the execution of a given short sequence\nof machine instructions.\n5.2 An Analogy\nUnderstandingtheterminology, motivationfor, andimportantcharacteristicsofcomputer\nparts can be difficult. So we will start with an analogy.\nSuppose you do woodworking, and have a work area including a workbench, a set of\ntools and supplies adjacent to your workbench, and lesser-used supplies and tools located\nelsewhere in the room. Suppose further you are creating a holiday decoration (pick your\nfavorite holiday). To construct the decoration you are following a set of instructions. You\nput a printed copy of the instructions on the workbench so you can easily follow it. And\nyou put the wood and other supplies you will be using on the side of the workbench.\n(If woodworking doesn\u2019t appeal to you, then think about any process using materi-\nals, tools, and instructions; possibilities include creating a garden, constructing a floral\narrangement, or restringing a guitar.)\nThe instructions are step-by-step, so you follow them one at a time. Sometimes a step\ninvolves taking material and performing an operation on it (e.g., \u201ccut a 1\/4 inch diameter\ndowel to a length of 4 inches\u201d). Note this involves finding the specific piece, getting the\ntool (a saw, presumably) from the nearby set of tools, cutting the piece, returning the\nsaw to its place (or you might set it down directly on the workbench if you will be using it\nagain very soon), and setting the cut piece aside (unless it is being used again very soon).\nSometimes the step involves a number of substeps (consider, for example, all the substeps\ninvolved in drilling a hole in a piece of wood: marking the location of the hole, finding\nthe right size drill bit, etc.). Usually a step requires getting supplies or tools that are at\nhand; but sometimes it involves supplies or tools farther away. For example, suppose a\nstep asks you to use a clamp that you use so infrequently that you store it in a drawer on\nthe other side of the room. Then you need to move to the other side of the room, locate\nthe clamp, and carry it back to the workbench. Sometimes you might even need to go\nfarther away (e.g., to a hardware store) to get additional material or tools.\nHow is this like a computer running a program? Like all analogies, this one isn\u2019t an\nexact parallel, but it does serve to illustrate several key points:\n\u2022 There is a center of activity (the workbench) where you do the work. In a computer\nthere is a CPU (central processing unit) where most of the operations are done. 5.3. CHAPTER STRUCTURE 93\n\u2022 The overall operation is broken into a sequence of steps. Most steps involve reading\nthecurrentinstruction, understandingwhatitmeans, retrievinganyneededsupplies\nand tools, performing the operations, placing the result somewhere, returning any\ntoolsusedtotheirdesignatedlocations, andthengoingtothenextinstruction. This\nprocess is repeated again and again until all the needed steps have been performed.\nSimilarly a computer loads a program into memory, and follows the program\u2019s in-\nstructions one by one. Individual steps involve decoding the instruction, fetching\nanyneededvaluesfromwherevertheyarestored, performingthespecifiedoperation,\nand then placing the results somewhere they can be accessed later.\n\u2022 There are different locations where items are kept. Sometimes supplies or tools\nare set near the center of the workbench when they are part of the current or an\nupcoming step. Sometimes they are kept on the side of the workbench for easy\naccess. Some are in the adjacent storage area. Some are elsewhere. Note the closer\nan item is, the less time it takes to find and fetch it. Ideally, all items you need are\nlocated nearby and are easy to find. However, many projects will involve getting at\nleast some items from further away.\nSimilarly, computers contain different types of memory such as register memory,\ncache memory, main memory, and secondary memory (these types will be explained\nlater in this chapter). Some memory can be accessed very quickly, but is smaller\nand more expensive in cost. Other memory is cheaper and more plentiful, but has\na significantly slower access time.\n\u2022 There are a variety of different types of supplies and tools. Similarly, a computer\nprogram involves data (including different types of data), program instructions from\nthe program the computer is running, and instructions from other helper programs\nthat are needed for the program to run.\n\u2022 You are \u201cmanaging the process\u201d by gathering all the needed items, putting them in\nthe appropriate locations, finding and fetching items as needed, stepping through\nthe instructions one-by-one and remembering where you are in the instruction list,\nreturning items to their locations when you are done with them, etc.\nSimilarly in a computer there is a \u201cmanager\u201d \u2014 the operating system \u2014 that keeps\ntrack of everything and performs those higher-level operations such as moving data\nfrom memory to the CPU.\nThe remainder of this chapter will explore some of these computer parts and processes\nin more detail.\n5.3 Chapter Structure\nThis chapter will have a slightly different structure than most other chapters in this set\nof notes. So this section provides a \u201croadmap\u201d to the remainder of this chapter and 94 CHAPTER 5. MACHINE ORGANIZATION\ninstructions about some online resources.\nMachine organization is an area where there are a number of useful introductory-level\nonline resources. So we will rely heavily on those resources, asking you to read them for\nsome basic information. This chapter will provide some additional basic material, and\nprovide some example problems.\nThe three web resources listed below provide much of the basic material you will need\nto know. Each of these makes some important points about computers, and two of them\nalso contain some useful diagrams. However, the sites also contain more information\nthan we need: make sure you understand the key points, but don\u2019t worry if you don\u2019t\nunderstand all the details. In particular, focus on the following three items from the sites:\n\u2022 An understanding of the key parts of computers. The sites mention a number of\ncomponents, so you should understand both the names and purposes.\n\u2022 An understanding of how the parts relate to each other. Two of the sites have very\nuseful diagrams illustrating key relations.\n\u2022 Tradeoffs. Two sites mention tradeoffs such as memory cost versus access time or\nprocessor speeds versus computer cost.\nThe \u201cTerminology\u201d section (5.4) below contains a brief explanation of important terms;\nthis might be useful as you read the sites. The sites also contain links to additional sites\nwith even further information. You don\u2019t need to follow these links, although you are\ncertainly welcome to explore them if you like.\nHere are the three sites you should read:\n\u2022 http:\/\/en.wikibooks.org\/wiki\/Computers for Beginners\/Buying A Computer.\nThisisaWikibookspageonbuyingacomputer. Whilesomematerialhereneedsup-\ndating (a common problem when discussing computer capabilities since they change\nquickly) and sometimes the page uses too much terminology for our purposes, this\nresource is nonetheless a good introduction to the different parts of a computer and\nthe range of differences that exist in those parts. Read the entire page.\n\u2022 http:\/\/computer.howstuffworks.com\/computer-memory1.htm. This is the How-\nStuffWorks \u201cHow Computer Memory Works\u201d article. Pay particular attention to\nthe different types of memory (e.g., main memory, register, cache, hard disk); how\nthey work in general; and the motivation for, and characteristics of each. Read this\nentire article.\n\u2022 http:\/\/computer.howstuffworks.com\/microprocessor.htm. This is the How-\nStuffWorks \u201cHow Microprocessors work\u201d article. Read the first five pages, paying\nparticular attention to the diagram and description, on page 3, of the different parts\nof the central processing unit. The page 5 description of microprocessor instructions\nis also useful. A section below will provide a further explanation of such instructions\non an even lower level. 5.4. MACHINE ORGANIZATION TERMS 95\nThe remainder of this chapter then provides the following additional material:\n\u2022 A list of machine organization terms. This will provide a quick reference for terms\nthat come up in the readings and elsewhere in the class.\n\u2022 An explanation of memory addresses and storing data in computer memory.\n\u2022 Information on machine instructions.\n\u2022 Some quick comments and tables on memory sizes and processor speeds.\n\u2022 Brief comments on system software.\n\u2022 Brief comments on computational models.\n\u2022 Some further questions to think about.\n\u2022 Example problems and their solutions.\n5.4 Machine Organization Terms\nBecause of all the terminology and concepts associated with machine organization, this\nsection lists a number of terms and give a brief explanation of each. While not all terms\nare included here, the most important are.\n\u2022 ALU (arithmetic\/logic unit): part of a processor that handles low-level arithmetic\n(e.g., addition) or logic (e.g., comparing two numbers).\n\u2022 address field: bits used to designate the memory location associated with an in-\nstruction. For example, the command LOAD A means load the contents of memory\naddress A into the register; and in machine code the location of \u2018A\u2019 must be repre-\nsented in binary in the address field for that command.\n\u2022 address field width: the number of bits in the address field. This number must be\nenough that each memory location in the computer\u2019s main memory has its own\nunique address. An n-bit memory field therefore allows the computer to have at\nmost 2n memory locations.\n\u2022 assembly language: a low-level language that has a symbolic name such as LOAD\nor COMPARE for each machine instruction.\n\u2022 bus: a means for moving data around within a computer.\n\u2022 cache memory: special (but limited size) memory that allows faster access than\nmain memory. 96 CHAPTER 5. MACHINE ORGANIZATION\n\u2022 compiler: one type of program that translates program code written in a high-level\nlanguage into machine code.\n\u2022 CPU (central processing unit): the main processor in the computer.\n\u2022 FLOPS (floating point operations per second): one measure of a computer\u2019s speed.\nPowerful computers\u2019 speeds are in the giga-FLOPS or even tera-FLOPS range.\n\u2022 GPU: (graphical processing unit): a processor that handles the computationally-\nintensive graphics operations such as drawing graphics objects to the screen.\n\u2022 Hertz: a measure of frequency. MHz, or megahertz, is millions of cycles per second.\nGHz, or gigahertz, is billions of cycles per second. Processor speeds are usually in\nthe MHz or GHz range.\n\u2022 high-level language (or HLL): a language such as Java, Python or C++. One char-\nacteristic of such languages is that they contain keywords such as for, print, etc.\nthat are more easily understood by humans than opcodes are.\n\u2022 instruction set: the set of low-level commands for a processor. These command\ninclude commands such as LOAD or JUMP.\n\u2022 interpreter: one type of program that translates program code written in a high-\nlevel language into machine code. For example, you will use a Python interpreter\nin this class.\n\u2022 machine code: program code which has been compiled or interpreted into its binary\nrepresentation. The machine code version of a program is also called the executable\nversion or the binary version.\n\u2022 main memory (or primary memory): the \u201cworking memory\u201d of a computer. For\nmost personal computers main memory measures in hundreds of megabytes or in\ngigabytes, and holds programs as they run, data that is being used, etc.\n\u2022 memory: in general, any part of the computer used to store values, including sec-\nondary memory, main memory, cache memory, or registers. However, often the term\n\u201cmemory\u201d is used to refer only to main memory.\n\u2022 memory address: the numeric identifier (usually given in binary or hexadecimal, but\nsometimes in decimal) of the location of a byte in memory.\n\u2022 memory value: the value of the bits stored in a given memory location. Each byte\nin memory has both an address and a value.\n\u2022 MIPS: millions of instructions per second. One measure of a computer\u2019s speed. 5.5. MEMORY ADDRESSES 97\n\u2022 opcode: (or op code): a binary string that represents a command from a processor\u2019s\ninstruction set.\n\u2022 opcode width: the number of bits used for opcodes. This will vary from machine to\nmachine. The number of bits used must allow each command in the instruction set\nto have its own unique opcode; so an n-bit opcode width allows an instruction set\nof at most 2n commands.\n\u2022 program counter: when the computer is executing a program, the program counter\nholds the memory address of the instruction currently being executed. Once that\ninstruction is finished, then the program counter is updated to the address location\nof the next instruction.\n\u2022 register: special, very small-sized memory in the CPU. Registers are used to tem-\nporarily hold values during low-level computer operations.\n\u2022 storage: a term that usually refers to secondary memory (hard drives, CDs, floppy\ndisks (for older computers), magnetic tapes, thumb drives, etc.).\n5.5 Memory Addresses\nTo understand how computers work, it is important to understand how computers store\ndata. Specifically, in this section we\u2019ll look at how computers store variables. Much of\nthis applies to more general data as well.\nSuppose we are writing a computer program that analyzes poetry. One function we\nwant the program to do is find the average number of lines of a group of poems. If we\nwere to do this, the program would might have the following outline:2\nSet numberOfPoems to 0\nSet lineSum to 0\nWhile there are still poems to consider\nGet the next poem\nSet numberOfPoems to numberOfPoems + 1\nSet n to be the number of lines in that poem\nSet lineSum to lineSum + n\nIf numberOfPoems equals 0\nPrint \u2018No poems to analyze.\u2019\nElse\nPrint \u2018Average Number of Lines: \u2019, lineSum\/numberOfPoems\n2Notethisisanoutline,buttobeavalidpseudocodespecificationsomelineswouldneedtoberefined\nfurther. 98 CHAPTER 5. MACHINE ORGANIZATION\nRemember from Chapter 1 that numberOfPoems, lineSum, and n are called variables\nsince their value might vary as the algorithm progresses. This is in contrast to constants,\nwhose values remain the same throughout a program. For example, if you were writing\na program to compute the volume of a sphere, you would use a formula involving the\nnumber \u03c0, which is approximately 3.14159. The number \u03c0 is a constant: its value does\nnot change.3\nTo understand how computers work with variables, let\u2019s assume further that some\nof the poems you are analyzing have disputed lines, i.e., lines which might be in some\npublications of the poems, but which experts are unsure actually belong to the poem.\nSuppose you have a count numDisputedLines and do the following:\nprint \u2018Do you wish to add the disputed lines (y\/n)?\u2019\nget ch\nif ch equals \u2018y\u2019\nlineSumAug = lineSum + numDisputedLines\nelse\nlineSumAug = lineSum\nSuppose at the start of this code lineSum had value 1066, and numDisputedLines had\nvalue 42. Suppose the user didn\u2019t want to add the disputed lines, so the else part is\nexecuted. So now we have both lineSum and lineSumAug equal to 1066. Suppose further\nthat, for whatever reason, the value of lineSum is then changed by the line\nlineSum = lineSum + 10\nThis changes the value of lineSum to 1076. Now what is the value of lineSumAug?\nShould it be 1066, because that is what it is set to in the else part above? Or should\nit be 1076: does equating the two variables in the else part link them so lineSumAug\nchanges whenever lineSum does?\nThe answer here is that lineSumAug still equals 1066. While this might seem like\na silly example, it hinges on an important point, namely how the computer interprets\nthe line lineSumAug = lineSum. It is setting the value of lineSumAug to the value of\nlineSum; but it is not linking the names of the two variables.\nVariables in computer programs, therefore, are not just values, but involve both names\nand values. Moreover, they are even more than names and values. For example, in many\nlanguages it is possible to have two different variables, in different parts of the program,\nthat share the same name. Therefore, variables are a collection of information, including\nthe variable\u2019s value, name, location in memory when the program is running, and type.\nLet\u2019s look at these further. You can think of computer memory4 as a long list of\nlocations. Each location is a byte (equivalently, 8 bits), and computers will put values\n3As an aside, we usually approximate \u03c0 to just a few digits, but \u03c0 is an irrational number \u2014 it\ngoes on and on forever without any consecutively repeating pattern. People have used computers to\ncalculate trillions of digits of \u03c0. For more information, see the many informative web sites such as\nhttp:\/\/en.wikipedia.org\/wiki\/Pi or http:\/\/www.joyofpi.com\/pilinks.html.\n4In this section \u201cmemory\u201d refers to main memory. 5.5. MEMORY ADDRESSES 99\ninto, modify values within, or take values out of those locations. When a computer\nprogram runs, it needs memory for doing what it needs to do, and this includes needing\nspace for its variables. Let\u2019s suppose we\u2019re working with the number of lines example\nabove. The computer system would therefore assign memory space for lineSum and\nlineSumAug, along with the other variables involved. How do we refer to or identify this\nspace?\nEach location in memory has an address. In some ways this is similar to house ad-\ndresses, since each house on a street often has an identifying number. But this analogy\nonly goes so far. For example, you will probably not be surprised that computer scien-\ntists and computer engineers will often write memory addresses in binary or (because the\nnumber of bits is usually large) hexadecimal.\nLet\u2019s suppose we have a small device that has 65,536 memory locations. Note this\nis a power of 2, namely 216; this is not a coincidence since maximum memory sizes for\ncomputing devices are almost always powers of 2. The device therefore needs an address\nfield width of 16; that is, each address consists of 16 bits as shown in the left-hand\ncolumn below. (If we wished, we could use hexadecimal or even decimal to represent the\naddresses.) All the values in the right column are set to 00000000. In an actual computer,\nthese values would usually be different.\nAddress Value\n0000000000000000 00000000\n0000000000000001 00000000\n0000000000000010 00000000\n0000000000000011 00000000\n\u00b7\u00b7\u00b7 \u00b7\u00b7\u00b7\n1111111111111100 00000000\n1111111111111101 00000000\n1111111111111110 00000000\n1111111111111111 00000000\nThe computer does not actually store the addresses in the left hand side; it stores only\nthe values and can figure out the addresses as needed. This is emphasized in the table\nabove by the missing left-side boundary line.5 However, we\u2019ll usually include addresses\nin memory diagrams since we\u2019ll need to use the addresses to refer to specific memory\nlocations.\nProblem 1: Writethetableabovewiththeaddressesrepresentedinhexadecimal. (Leave\nthe values in binary.)\n5Actually,sometimescomputersstoreaddressesasvalues,thatis,asthecontentinamemorylocation.\nForexample,languagessuchasCandC++allowpointervariables. Apointervariable\u201cpointsto\u201danother\nvariable by storing that other variable\u2019s address as the pointer variable\u2019s value. Pointers are one of the\nmost confusing and error-prone part of programming. Because of this some programming languages do\nnot include them, or severely limit their use. 100 CHAPTER 5. MACHINE ORGANIZATION\nWe\u2019ll use hexadecimal representation of the addresses from now on. So a computer\nmightassignlocation88f0toholdthevalueoflineSum. Doesthismeanitassignslocation\n88f1 to hold the value of lineSumAug? Recall from the last chapter that different types of\ndata take different amounts of space. Let\u2019s suppose that both line counts are represented\nin the program as 16-bit integers. Location 88f0 (and all other locations) only hold 8\nbits. So lineSum needs not only location 88f0, but also 88f1. And the computer needs\nto \u201cremember\u201d that lineSum uses 16-bits. That is why a variable specification needs to\ninclude its type.\nNow let\u2019s look again at what happens, on this low level, for the following three lines\nof code:\nlineSum = 1066\nlineSumAug = lineSum\nlineSum = lineSum + 10.\nAssume when the computer system starts to run the program it sets aside memory lo-\ncations 88f0 and 88f1 for lineSum and 88f2 and 88f3 for lineSumAug. Note 1066 =\n10\n0000010000101010 and 1076 = 0000010000110100 . Assume all these locations for\n2 10 2\nthese variables contain the value 0000000000000000 originally. Then assigning 1066 to\nlineSum changes the corresponding values:\nAddress Value\n88f0 00000100\n88f1 00101010\n88f2 00000000\n88f3 00000000\nThen the line lineSumAug = lineSum puts the value of the latter into the former:\nAddress Value\n88f0 00000100\n88f1 00101010\n88f2 00000100\n88f3 00101010\nFinally, adding 10 to lineSum changes that variable\u2019s value:\nAddress Value\n88f0 00000100\n88f1 00110100\n88f2 00000100\n88f3 00101010 5.6. MACHINE INSTRUCTIONS 101\n5.6 Machine Instructions\nFor an algorithm to run on a computer, someone needs to implement it as a computer\nprogram. However, computersneedtoprocessprogramsfurtherbeforetheycanrunthem.\nA program written in a high-level language such as Java or Python must first be\nconverted to machine instructions. This is done by a special program called a compiler\nor interpreter, and produces a machine code or executable version of the program.6\nDifferent types of computers have different instruction sets. An executable file for\none type of computer will often not run on other types of computers. This is one reason\nwhy there are different versions of programs such as Microsoft Office for different types\nof machines.\nInstruction sets consist of very low-level instructions. Some instructions are ones you\nwould recognize, such as addition. Others are related to the inner workings of computers.\nForexample, hereisasimplesetofaboutadozenmachineinstructionsforasingle-register\nprocessor. Actual instruction sets are longer and more complicated, but this set will serve\nto illustrate the basics of machine code.\nOp Code Operation Meaning\n00000000 IN A Have the user input a number; store it in address A\n00000001 OUT A Output the contents from address A in decimal\n00000010 CLEAR A Set the contents of address A to 0\n00000011 STORE A Copy the register contents to the contents of address A\n00000100 LOAD A Load the contents of address A into the register\n00000101 INCREMENT A Add 1 to the contents of address A\n00000110 DECREMENT A Subtract 1 from the contents of address A\n00000111 ADD A Add the contents of address A to the contents of the\nregister and store the result in the register\n00001000 COMPARE A If the contents of address A are greater than the contents\nof the register, set the GT flag to 1, else to 0\n00001001 JUMP L Take the next instruction from address L\n00001010 JUMPGT L Take the next instruction from address L\nif the GT flag is 1\n00001011 STOP Stop program execution\nWhen a program is turned into machine code, all the instructions in a high-level\nprogramminglanguageareturnedintotheopcodesformachineinstructions. Forexample,\nsuppose we have a simple loop:\n6This explanation is somewhat simplified as there are multiple details we are omitting. For example,\nthe program code often needs to be linked with pre-existing library code. 102 CHAPTER 5. MACHINE ORGANIZATION\nGet i\nSet sum to 0\nWhile i is greater than 0\nSet sum to sum + i\nSet i to i - 1\nPrint sum\nHow would we turn this into machine instructions in terms of opcodes? Note for some\nlines there is an equivalent machine instruction:\nGet i IN I\nSet sum to 0 CLEAR SUM\nSet i to i - 1 DECREMENT I\nPrint sum OUT SUM\nHowever, other lines require more than one machine instruction. For example, Set sum\nto sum + i requires a sequence of three steps:\nLOAD SUM\nADD I\nSTORE SUM\nMoreover, both the beginning and end of the loop require care. For the beginning, we first\nwant to check if i is greater than 0. This itself requires multiple steps: Clear a location\nso it holds the value 0. Then load that 0 value into the register. Next, compare the value\nof i to that 0 register value. If the value of i is greater than 0, then the GT flag (a special\nbit in the processor memory) is set to 1. We then check that bit and, if it is 1, jump to\nthe first instruction in the loop; if it is 0, we jump to the first instruction past the loop.\nSo the single if line yields the following, where Z corresponds to 0, and L1 and L2 are the\nmemory addresses of the instructions Set sum to sum + i and Print i, respectively:7\nCLEAR Z\nLOAD Z\nCOMPARE I\nJUMPGT L1\nJUMP L2\nAfter executing the line at the end of the loop, namely, Set i to i-1, we want to jump\nuptothestartoftheloop. ThisrequiresaJUMPtotheaddressoftheCLEARinstruction\nabove. Finally, we also want a STOP at the end of the program.\nPutting all these parts together produces the following, where we have given line\nnumbers to jump destinations:\n7Notethissequenceisnotunique(seeifyoucanthinkofotherwaystoperformthesametaskbutwith\na different sequence of instructions from the given machine instruction set). Moreover, actual machine\ninstructionsetsarelarger,andwouldusuallyrequirefewerinstructionsfortheloop\u2019sbeginningline. The\nkey point remains, however: one line of an algorithm, or one line of high-level programming code often\ncorresponds to several lines of machine instructions. 5.6. MACHINE INSTRUCTIONS 103\nIN A\nCLEAR SUM\n50 CLEAR Z\nLOAD Z\nCOMPARE I\nJUMPGT 70\nJUMP 100\n70 LOAD SUM\nADD I\nSTORE SUM\nDECREMENT I\nJUMP 50\n100 OUT SUM\nSTOP\nThisisanexampleofassembly code. However,itisstillnotbinary. Tochangeassembly\ncode to machine code we need to perform two additional steps. First we replace opera-\ntion names with binary opcodes. For example, IN becomes 00000000, CLEAR becomes\n00000010, etc. Second, we replace all variables and line numbers with binary numbers\nrepresenting memory locations. We can\u2019t choose arbitrary locations, but the operating\nsystem can assign line numbers based on where it places the machine code when that\ncode is to be executed; and it can assign memory locations for the variables based on\nwhere there is convenient available memory. So, for example, if the system placed the\nfirst instruction at memory location 11001100, we could get the following table:\nMemory Location Op Code Address Assembly Code\n11001100 00000000 11100100 IN I\n11001110 00000010 11100110 CLEAR SUM\n11001100 00000010 11101000 CLEAR Z\n11001110 00000100 11101000 LOAD Z\n11010000 00001000 11100100 COMPARE I\n11010010 00001010 11010110 JUMPGT 70\n11010100 00001001 11100000 JUMP 100\n11010110 00000100 11100110 LOAD SUM\n11011000 00000111 11100100 ADD I\n11011010 00000011 11100110 STORE SUM\n11011100 00000110 11100100 DECREMENT I\n11011110 00001001 11001100 JUMP 50\n11100000 00000001 11100110 OUT SUM\n11100010 0001011 STOP\n11100100 I\n11100110 SUM\n11101000 Z 104 CHAPTER 5. MACHINE ORGANIZATION\nEmpty table locations are unused or will be filled during the program\u2019s execution. Note\nthat most instruction lines involve an opcode and an associated address. The opcodes in\nthis example take one byte; assume that line numbers and variables will also consist of\na single byte value. So each line involves two bytes. Therefore the diagram shows two\nmemory locations side by side in each row with only the address of the leftmost location\nof the pair being given.\nTo review, this table shows the machine code, the 0\u2019s and 1\u2019s, corresponding to the\nsmall piece of pseudocode at the start of this section. The leftmost column gives the\nmemory addresses; these are not explicitly stored in the computer but are given here for\nreference. The second column from the left holds opcode values (except in the bottom\nthree rows). These are the instructions that the computer will perform: to execute the\nprogram, the computer steps through each memory location containing the instructions,\nand performs the instruction associated with the opcode. As part of this, the computer\nusually needs an associated memory address; these are given in the next column over. Put\nanother way, the contents of the third column are binary numbers that are stored in the\ncomputer; each of these numbers (except for the bottom four rows) provides a memory\nlocation for the operation given by the opcode immediately to its left. The bottom three\nrows are for variables in the program. The contents of the memory locations will be filled\nin, changed, and perhaps output as the program execution progresses.8\nThis example is admittedly complicated. Manually tracing through machine code or\nconverting higher-level instructions into machine code is tedious and error-prone. That is\nwhy most programming is done in higher-level languages, with compilers or interpreters\ntranslating the high-level code to machine code.\n5.7 Some Quantities\nThis section contains two tables. The first contains memory terms such as megabyte\nand gigabyte. These are important to remember since they come up frequently. It also\ncontains some useful equivalents of memory amounts.9 The second table contains prefixes\nfor fractions of a second.\n8To further stress the point that machine instructions and program variables are similar within a\ncomputer, i.e., all0\u2019sand1\u2019s, hereisonetypeofcomputersecurityattack: Theattackerfeedsaprogram\na much larger input string that the program expected. The program puts this string into memory, but\nbecause of its large size the input overflows its assigned memory locations and fills some memory after\nthose locations. The overlong input contains some some malicious code placed there by the attacker.\nThe attacker\u2019s intent is for this code to overwrite part of a usual program and allow the attacker to gain\ncontrol of the machine. Note this attack relies on being able to mix computer instructions and data.\n9These equivalents are based on a similar table in G. Michael Schneider and Judith L. Gersting\u2019s\nInvitation to Computer Science. 5.8. SYSTEM SOFTWARE 105\nFigure 5.1: Some Memory Equivalents: Approximation in Terms of Printed Material\nPrefix Approx. Amount Equivalent\n1 byte 8 bits a single ASCII character\n1 kilobyte (KB) a thousand bytes a single small page of text\n1 megabyte (MB) a million bytes a long novel, or two or three shorter ones\n1 gigabyte (GB) a billion bytes a large wallful of books\n1 terabyte (TB) a trillion bytes a large library\n1 petabyte (PB) a quadrillion bytes all libraries in the U.S.\nFigure 5.2: Some Important Fractional Time Durations\nName Duration Duration (in words)\n1 millisecond (ms) 10\u22123 seconds one-thousandth of a second\n1 microsecond (\u00b5s) 10\u22126 seconds one-millionth of a second\n1 nanosecond (ns) 10\u22129 seconds one-billionth of a second\n1 picosecond (ps) 10\u221212 seconds one-trillionth of a second\n1 femtosecond (fs) 10\u221215 seconds one-quadrillionth second\n5.8 System Software\nThe sections above occasionally mentioned the operating system, compilers, and inter-\npreters. These are examples of system software, that is, \u201chelper\u201d software whose purpose\nis to assist the computer in accomplishing other tasks. For example, compilers and in-\nterpreters turn programs in high-level languages to machine code. The operating system\nmanages not only the running of programs, but also many other tasks the computer needs\nto perform to run smoothly. For example, you might be using a spreadsheet at the same\ntime you are streaming music and downloading a data set from a web site. The computer\nneeds to juggle all these tasks so that none interferes with the others.\nWe won\u2019t have time to investigate system software in detail. Here are the key points\nyou should know:\n1. Not all programs have a user\u2019s goal as their primary purpose. System programs\u2019\npurpose is to \u201cmake the computer work.\u201d\n2. Specific examples of system software include operating systems such as Linux, Win-\ndows, and MacOS. Other examples include compilers and interpreters such as the\nPython interpreter used in this class. 106 CHAPTER 5. MACHINE ORGANIZATION\n3. System software often performs invisible work: usually users don\u2019t even know a\nsystem program is running.\n4. Some system software is large and complicated. For example, operating systems\nconsist of millions of lines of code.\n5. System programs are programs. So at the lowest level they are 0\u2019s and 1\u2019s as well.\n5.9 Some Additional Notes\nThe computer model in this chapter is just one possible type of computer. There are\nother possible models. For example, parallel computers have a number of processors that\nwork simultaneously. If a problem can be broken into independent or nearly independent\nsubproblems, then different subproblems can be assigned to different processors, allowing\nthe problem to be solved in less time.\nSuppose a problem would normally take 500 minutes to solve. Suppose moreover that\nyou have a 32-processor machine, the problem can be broken into 32 subproblems that\ncan run simultaneously, and each subproblem can be solved in 1\/32nd of the time of the\noriginal problem. Then each subproblem requires 500\/32 minutes, or roughly 16 minutes.\nThere would be some time breaking the original problem into subproblems, combining the\nsubproblem answers for an overall answer, etc. But the key point of parallel computation\nis that some problems can be broken into subproblems that can be solved in parallel.10\nNowadays, many PCs are actually small multiprocessor machines. For example, a\n\u201cquadcore\u201d machine has four main processors. Remember, however, that this does not\nguarantee that all programs will run four times as fast: many programs cannot be easily\nbroken into independent subparts.\nThere are still other computation models as well. For example, quantum computing is\na current research topic. Quantum computers rely on an entirely different model of com-\nputation, and if they become a reality they will usher in significant changes in computer\ncapabilities.\n5.10 Further Questions\nHere are some further questions to think about.\n1. See if you can explain the basics of how computers work (or some part of how\ncomputers work, such as how different types of computer memory are organized) to\nsomeone who is unfamiliar with it.\n10An alternative to parallel computation is distributed computation. Instead of having the subprob-\nlems solved on different processors on the same machine, distribute the subproblems to different single-\nprocessormachines. Forexample,youcoulddistributetheexampleproblemtoanetworkof32PCs. The\ncost of many single-processor machines is usually less than that of a corresponding parallel computer.\nHowever, the data transmission times (over a network rather than within a machine) will be larger. 5.11. ADDITIONAL PROBLEMS 107\n2. Think of another field you are interested in. Do low-level computer basics relate to\nthis field in any way? For example, are there any special computational devices used\nin that field and, if so, how much memory do they have? Or does the field require\nregular computers with special capabilities such as enhanced graphics capabilities\nor extremely large amounts of memory?\n3. Try to find out the computing characteristics of any computers or computational\ndevices you have. For example, if you have a laptop, what is its processor speed? If\nyou have an MP-3 player, how much memory does it have?\n4. Think about how you use computers and what computer capabilities are most im-\nportant. For example, if you work with large video files, large amounts of memory\nare important.\n5.11 Additional Problems\nProblem 2: Answer the following arithmetic problems on computer organization.\n(a) Suppose a computer has a maximum memory size of 4MB. What is the needed address\nfield width?\n(b) Suppose a computer has an opcode field of 9 bits. What is the maximum number of\ninstructions in its instruction set?\n(c) If a computer has an average memory access time of 10 nsec, and an average cache\nmemory access time of 2 nsec, and the cache hit rate is 50%, then what is the overall\naverage access time? A 50% cache hit rate means half the time the computer accesses the\ncache and finds the data; but the other half it accesses the cache, does not find the data,\nand therefore must get it from main memory.\n(d) Assume you have a list of 50 numbers, each of which takes 32 bits to store. The first\nnumber in the list is stored at memory address 803762 , and the numbers are stored\n10\nconsecutively in memory. What is the memory address of the first memory location after\nthe last number in the list?\nProblem 3: Answer the following questions related to memory size. Show your work.\n(a) The Apollo 11 spacecraft had 2KB of RAM.\n(i) What is the minimum address field width needed for 2KB of memory?\n(ii) Would the novel Pride and Prejudice fit into 2KB of memory?\n(iii) Would a typical MP-3 file for a three (or so) minute song fit into 2KB of memory?\n(If you don\u2019t know the approximate length of an MP-3 file for a 3 minute song, look it\nup somewhere).\n(b) Suppose you have a computer with 1.2TB of free hard disk space.\n(i) About how many images could you store in 1.2TB if the average image size is 400KB? 108 CHAPTER 5. MACHINE ORGANIZATION\n(ii) About how many short videos could you store in this space if the average video file\nsize is 25MB?\n(iii) About how many movies could you store in this space if the average movie file size\nis 2GB?\nProblem 4: (Thisproblemistedious. Onepointofdoingitistogetagoodunderstanding\nof why most programmers do not program in machine code or assembly code). Suppose\nyou have the following 4-bit instruction set. Note this is a different instruction set than\nin the example above. Below, \u2018R\u2019 indicates the register.\nOp Code Operation Meaning\n0000 CLEAR A Set the contents of address A to 0\n0001 STORE A Copy the contents of R to the contents of address A\n0010 LOAD A Load the contents of address A into R\n0011 INCREMENT A Add 1 to the contents of address A\n0100 DECREMENT A Subtract 1 from the contents of address A\n0101 ADD A Add the contents of address A to the contents of R\nand store the result in R\n0110 COMPARE A If the contents of address A are greater than the\ncontents of R, set the GT flag to 1, else to 0. If\nthe contents are equal, set the EQ flag to 1, else to 0.\n0111 JUMP L Take the next instruction from address L\n1000 JUMPGT L Take the next instruction from address L\nif the GT flag is 1\n1001 JUMPEQ L Take the next instruction from address L\nif the EQ flag is 1\n1010 IN A Have the user input a number; store it in address A\n1011 OUT A Output the contents from address A in decimal\n1100 STOP Stop program execution\n1101 unused\n1110 unused\n1111 unused\nSuppose further that the machine you are using has a 4-bit address field width. Note\nthat in this problem a machine instruction and its associated memory location require 8\nbits total: 4 for the instruction, and 4 for the location. So an instruction-address pair\nrequires a single byte, in contrast to the 2 bytes in the example above.\nNow suppose the program counter contains the value 0000 \u2014 i.e., it is pointing to the\nvery first memory location \u2014 and the memory contents are as shown in the table below.\nThis problem asks you to trace through the machine code in the contents of that table.\nNote the content at location 0000 is 10101110. This value contains opcode 1010 (the\nleftmost 4 bits) which means \u2018IN,\u2019 and its address field value is 1110. So this instruction\ngets an input value and places it in memory location 1110. Assume all the variables in this\nprogram are 8-bit integers, so each variable takes one memory location. After completing 5.12. PROBLEM SOLUTIONS 109\nthis operation, the program counter changes to 0001; the content there is 10101111. This\ninstruction gets an 8-bit input value and places it in memory location 1111. Similarly,\nthe subsequent memory content consists of opcodes for additional instructions and their\nrelated memory locations.\nMemory\nAddress Content\n0000 10101110\n0001 10101111\n0010 00101110\n0011 01101111\n0100 10001001\n0101 10011100\n0110 10111110\n0111 10111111\n1000 01111101\n1001 10111111\n1010 10111110\n1011 01111101\n1100 10111111\n1101 11000000\n1110 00000000\n1111 00000000\n(a) What does the code in the table immediately above do if the input for the instruction\nat location 0000 is the value 5 (i.e, 00000101 ) and the input for the instruction at 0001 is\n2\nthe value 8 (i.e, 00001000 )? Trace through the machine code above starting at location\n2\n0000. For each executed instruction, state what it does. Then state what value or values,\nif anything, the program outputs.\n(b) Do the same if the input for the instruction at location 0000 is 140 (10001100 ) and\n10 2\nthe input for the instruction at 0001 is also 140 .\n10\n5.12 Problem Solutions\nIntroductory Problem:\n(a) Each record has a 6-character code, a 16-bit (or 2-byte) integer, and a 32-bit (or\n4-byte) floating point number. Recall from the last chapter that in ASCII each character\ntakes one byte, so the code takes 6 bytes. Therefore each record takes 6 + 2 + 4 = 12\nbytes. Multiply this by the number of records, i.e., 100, to get 1200 bytes, or a little more\nthan a kilobyte. 110 CHAPTER 5. MACHINE ORGANIZATION\n(b) The first record is at location 3b2201aa . Note to get the start of the second record\n16\nwe add 12 , to get the start of the third record we add (2 \u00d7 12) , etc. And so to get\n10 10\nthe start of the last, i.e., 100th, record we add (99\u00d712) = 1188 to the first record\u2019s\n10 10\nlocation.\nThis is somewhat tricky since the first location is in hexadecimal. Let\u2019s change part\nof it to decimal, add in decimal, then convert back to hexadecimal. It turns out we don\u2019t\nneed to convert the entire hexadecimal location; we can just convert the last part since\nthe number we are adding is relatively small, and there won\u2019t be any carrying that would\naffect the first part. So let\u2019s convert the last four digits, 01aa . In decimal this equals\n16\n0\u00d7163 +1\u00d7162 +10\u00d7161 +10\u00d7160 = 256+160+10 = 426. Add 1188 to get 1614\nin decimal. Now convert back to hexadecimal: note 1614 is less than 163 = 4096, but\n162 = 256 divides into it six times with a remainder of 78. Then 161 divides into 78 four\ntimes with a remainder of 14. So the last four digits of the hexadecimal location are 064e,\nand the entire hexadecimal number for the last location is 3b22064e.\nNow we need to find the final memory location occupied by the 100th record. All\nrecords are 12 bytes long, and we just found that the first byte of the 100th record has\nlocation 3b22064e. To find the address of the second byte of the record we add one to\nthis starting address. To find the address of the third byte of the record we add two to\nthe starting address. Etc. So to find the address of the final (12th) byte of the record, we\nadd 11 .\n10\nYou might be able to do this directly in hexadecimal. If not, you can convert the final\ntwo digits of the hexademical address 3b22064e to decimal: 4e = 4\u00d7161 +14\u00d7160 =\n16\n78 . Then add 11 bytes to get 89 . Then convert back to hexadecimal: 16 divides into\n10 10 10\n89 five time with a remainder of nine. So the address of the last byte of the last record\nis, in hexadecimal, 3b220659.\nProblem 1:\nAddress Value\n0000 00000000\n0001 00000000\n0002 00000000\n0003 00000000\n\u00b7\u00b7\u00b7 \u00b7\u00b7\u00b7\nfffc 00000000\nfffd 00000000\nfffe 00000000\nffff 00000000\nProblem 2:\n(a) 22 bits since 222 bytes = 4MB.\n(b) If the opcode field has n bits, then there are at most 2n possible instructions. So the\nmaximum is 29 = 512 instructions. 5.12. PROBLEM SOLUTIONS 111\n(c) .5\u00d72 nsec + .5\u00d7(10+2) nsec = 7 nsec.\n(d) 32 bits is 4 bytes, and so the list takes 4\u00d750 = 200 bytes to store. So the list takes\nlocations 803762 to 803961, and the next address is 803962.\nProblem 3:\n(a)(i) 11, since 211 bytes = 2KB.\n(ii) No. 2KB is roughly enough space to store 2 small pages of text, not enough for an\nentire novel.\n(iii) No. A typical MP-3 file for a 3 minute song is a few MB in size.\n(b)(i) 1.2TB\/400KB is approximately equal to 1,200,000,000,000 divided by 400,000,\nwhich equals 3 million.\n(ii)1.2TB\/25MBisapproximatelyequalto1,200,000,000,000dividedby25,000,000,which\nequals 48,000.\n(ii) 1.2TB\/2GB is approximately equal to 1,200,000,000,000 divided by 2,000,000,000,\nwhich equals 600.\nProblem 4:\nThe opcode sequence is equivalent (but not line by line) to the following pseudocode.\nTo make the code clearer, we\u2019ll call the content of memory location 1110 \u2018X\u2019, and of 1111\n\u2018Y\u2019.\n1 Get X\n2 Get Y\n3 If Y < X then\n4 Print X\n5 Print Y\n6 Else if Y > X\n7 Print Y\n8 Print X\n9 Else\n10 Print Y\n11 Stop\n(a) For input X = 5 and Y = 8, the code outputs 8 followed by 5. A detailed explanation\nis in the first table below. As above, the table calls the content of memory location 1110\n\u2018X\u2019, and of 1111 \u2018Y\u2019.\n(b) For input X = 140 and Y = 140 the code outputs 140, printed only once. A detailed\nexplanation is in the second table below. As above, the table calls the content of memory\nlocation 1110 \u2018X\u2019, and of 1111 \u2018Y\u2019. 112 CHAPTER 5. MACHINE ORGANIZATION\nMemory\nAddress Content\n0000 10101110 Gets value of 5 and stores it in X\n0001 10101111 Gets value of 8 and stores it in Y\n0010 00101110 Load the value of X (5) into R\n0011 01101111 Compares value of Y (8) with value in R (5);\nSets GT flag to 1\n0100 10001001 Jumps to instruction at location 1001\n0101 10011100 Not executed\n0110 10111110 Not executed\n0111 10111111 Not executed\n1000 01111101 Not executed\n1001 10111111 Outputs value of Y (8)\n1010 10111110 Outputs value of X (5)\n1011 01111101 Jump to instruction at location 1101\n1100 10111111 Not executed\n1101 11000000 Stop\n1110 00000000\n1111 00000000\nMemory\nAddress Content\n0000 10101110 Gets value of 140 and stores it in X\n0001 10101111 Gets value of 140 and stores it in Y\n0010 00101110 Load the value of X (140) into R\n0011 01101111 Compares value of Y (140) with value in R (140);\nSets EQ flag to 1\n0100 10001001 Checks GT flag but does not jump\n0101 10011100 Checks EQ flag and jumps to address 1100\n0110 10111110 Not executed\n0111 10111111 Not executed\n1000 01111101 Not executed\n1001 10111111 Not executed\n1010 10111110 Not executed\n1011 01111101 Not executed\n1100 10111111 Prints value of Y (140)\n1101 11000000 Stop\n1110 00000000\n1111 00000000 5.13. ADDITIONAL RESOURCES 113\n5.13 Additional Resources\nHere are additional resources. The first three items appeared above in the \u201cChapter\nStructure\u201d section and are required reading. See that section for more information.\n\u2022 http:\/\/en.wikibooks.org\/wiki\/Computers for Beginners\/Buying A Computer.\nWikibooks page on buying a computer. This provides background on different parts\nof computers, as well as the basic decisions you need to make when buying a com-\nputer.\n\u2022 http:\/\/computer.howstuffworks.com\/computer-memory1.htm. This is the How-\nStuffWorks \u201cHow Computer Memory Works\u201d page. This page gives details about\ncomputer memory. Specifically, it covers many of the basics mentioned in class, as\nwell as providing additional detail for people who\u2019d like more information.\n\u2022 http:\/\/computer.howstuffworks.com\/microprocessor.htm. This is the How-\nStuffWorks \u201cHow Microprocessors work\u201d page. Like the item above, this page cover\nmany of the basics mentioned in class, as well as providing additional details for\nthose who are interested.\n\u2022 http:\/\/en.wikipedia.org\/wiki\/Megabyte. Wikipedia megabyte page. This page\nalso contains a chart with different byte multiples.\n\u2022 http:\/\/www.simetric.co.uk\/si time.htm. Table with fractional seconds. This\npage also contains useful conversions such as the number of seconds in a year. 114 CHAPTER 5. MACHINE ORGANIZATION Chapter 6\nMoore\u2019s Law\nFaster, smaller, cheaper.\n6.1 Introduction\n6.1.1 Introductory Problems\nProblem 1: Suppose you have the choice of the following means of compensation: Alter-\nnative 1 gives you $100 daily for 12 days. Alternative 2 gives you $1 on the first day, $2\non the second, $4 on the third, $8 on the fourth, etc. for 12 days, with each day after the\nfirst doubling the previous day\u2019s amount. Which alternative would give you more pay?\nProblem 2: Suppose a certain type of computer has 40MB of memory currently, and\nthe amount of memory is likely to double every two years for the next decade. How much\nmemory is the computer likely to have 10 years from now?\n6.1.2 Introductory Explanation\n\u201cWhen the group moved to California to become part of Lucasfilm, we got\nclose to making a computer-animated movie ... But when it came time to\nharden the deal and run the numbers for the contracts, I discovered to my\ndismay that computers were still too slow: The projected production cost was\ntoo high and the computation time way too long. We had to back out of the\ndeal. This time, we did know enough detail to correctly apply Moore\u2019s Law\nand it told us that we had to wait another five years to start making the first\nmovie. And sure enough, five years later Disney approached us to make Toy\nStory.\n\u201cMoore\u2019s Law told us that the new company we were starting, Pixar, had to\nbide its time ... \u201d1\n1From \u201cHow Pixar Used Moore\u2019s Law to Predict the Future\u201d, Alvy Ray Smith, in Wired magazine,\n115 116 CHAPTER 6. MOORE\u2019S LAW\nIn the early days of computing \u2014 the 1950\u2019s and 1960\u2019s \u2014 computers were large objects\nthat often filled a good part of a room. Today cell phones or calculators contain more\ncomputing capability than these large early machines. In fact the computing capability of\na cell phone, for example, dwarfs that of a personal computer from just a couple decades\nago.\nThis fast change is exhilirating, but also challenging. How can individuals, businesses,\nand other organizations keep up with this rapid pace of computing change? On one hand,\nthe answer is they cannot \u2014 it is impossible to stay current with all computer advances,\nto always use the latest hardware and software, and to always predict what thenext round\nof advances will be.\nOn the other hand, there are some tools that are useful both for understanding past\nadvances in computing, and for trying to predict future advances. One of the most\nimportant of these tools is Moore\u2019s Law: that the density of transistors on a computer\nchip will double every two years. This is important because higher transistor density\nleads to computational devices that are smaller (in size), less costly, and more powerful\nin terms of computational ability.\nMoore\u2019s Law is not a law in the same sense as a physical law \u2014 say Newton\u2019s Laws\nof Motion \u2014 or in the legal sense. Instead, it is an observation or model.2 In particular,\nalthough there is nothing that required Moore\u2019s Law to hold in the past, it has been\nremarkably accurate in describing past advances in transistor density. And although there\nis nothing that guarantees Moore\u2019s Law will hold in the future, it is nonetheless a useful\ntool for predicting possible future advances. In short, Moore\u2019s Law is both descriptive of\npast computer advances and predictive of likely future advances.\nOne often hears variants of Moore\u2019s Law. For example, sometimes the time period is\nsaidto beevery 18months. Sometimes thelawis statedthatcomputing power ormemory\nwill double every two years. These variants aren\u2019t quite accurate; at the same time they\naren\u2019t all wrong either. For example, while computer speed is not directly proportional\nto transistor density, it is related.\nDoubling every two years leads to a type of increase called exponential growth, a term\nthat is sometimes misused to mean rapid growth of any kind. We\u2019ll look at an exact\ndefinition of exponential growth in a section below. Roughly speaking, though, it means\nwhat you are measuring follows a formula like\ncount at time t = 100\u00d72t.\nNotice how the count progresses as t increases: when t = 0 the count is 100, when t = 1\nthe count is 200, when t is 2, the count is 400, and so on, with the count doubling each\ntime t increases by 1.\nApril 17, 2013; available online at\nhttp:\/\/www.wired.com\/opinion\/2013\/04\/how-pixar-used-moores-law-to-predict-the-future\/\n2One reason for the importance of mathematics in general is its effectiveness in modeling many phe-\nnomena. Mathematical modelingisthesubareaofmathematicsthatdealswithquestions\u201cWhatdifferent\ntypes of mathematical models are there?\u201d, \u201cHow do we measure \u2018how good\u2019 a model is?\u201d, \u201cHow do we\npredict how well a given time-dependent model will hold in the future?\u201d, etc. 6.1. INTRODUCTION 117\nFigure 6.1: A function that doubles every two time periods\nt t\/2 2t\/2\n0 0 1\n2 1 2\n4 2 4\n6 3 8\n8 4 16\n10 5 32\n12 6 64\nTo better understand Moore\u2019s Law, let\u2019s look at a function that doubles every two\nyears, namely f(t) = 2t\/2. Some values for the function are shown in Table 6.1. The\npattern in that table is, of course, a pattern you have seen before since similar patterns\narose when we explored machine organization and data representation. In particular,\nnote the rapid growth of the function values, a growth whose importance we will explore\nfurther in the next section.\n6.1.3 Why is Moore\u2019s Law Important?\nMoore\u2019s Law is important to people who work with computers for the reasons mentioned\nin the last section. First, since it has modeled the increase in transistor density so well,\nit is an explanatory tool for the rapid increases in computers. Second, it is also a tool for\npredicting advances in computing in the future.\nBut why is Moore\u2019s Law important in this class? Why should it be important to you?\nHere are a few reasons.\nFirst, one goal in this class is to understand both computers and how computer scien-\ntists \u201csee the world.\u201d Moore\u2019s Law is a powerful tool for computer scientists and engineers\nas they understand, discuss, and analyze computers and computing.\nSecond, Moore\u2019s Law helps us appreciate the rapid advances that have occurred in\ncomputer technology. For example, in the early days of computing, computers were large\nmachines that filled the better part of a room, and were so expensive that they were not\nowned by individuals but only by government organizations, large businesses, or research\nuniversities. Nowadaysthecomputationalabilitiesofacellphonedwarfthecomputational\nabilities of those early computers.\nThird, Moore\u2019s Law helps us understand the effect these rapid advances in computers\nhave had on society. The fact that computers are becoming more powerful, smaller, and\ncheaper has many societal ramifications, some of which we\u2019ll explore elsewhere in this\nclass.\nFourth, Moore\u2019s Law furnishes a tool for predicting future changes in computing, and 118 CHAPTER 6. MOORE\u2019S LAW\nits possible effects on society. Like Pixar in the opening quote of this chapter, we might\nbe interested in predicting when the time will be right for a certain application.\nFinally, Moore\u2019s Law is an example of exponential growth. This is a very important\nidea, not only in computer science, but also in other areas such as biology, physics, and\nfinance. It is not uncommon to hear that something is \u201cgrowing exponentially.\u201d Under-\nstanding what this means is important in understanding many issues affecting individuals\nand society.\nIn summary, Moore\u2019s Law helps us understand, explain, and analyze\n\u2022 computers and their underpinnings;\n\u2022 the rapid advances in computer technology;\n\u2022 the many societal effects of these rapid advances;\n\u2022 possible future changes in computing technology, and the effects of those changes\non society; and\n\u2022 exponential growth.\nProblem 3: Why specifically might Moore\u2019s Law be interesting to you? Give specifics\nabout why any of the reasons mentioned are particularly important to you, or give other\nreasons why Moore\u2019s Law might be interesting.\n6.1.4 Topic Goals\nUpon completing this topic, you should be able to do the following.\n\u2022 Explain what Moore\u2019s Law is and why it is important.\n\u2022 BeabletouseMoore\u2019sLawtoexplainsomepastadvancesincomputing,andanalyze\nsome predictions about computing\u2019s future.\n\u2022 Be able to explain what exponential growth is, and why it is important.\n\u2022 Be able to find characteristics of, and do computations with, functions that exhibit\nexponential growth.\n6.1.5 Moore\u2019s Law and the Liberal Education Requirements\nMoore\u2019s Law is related to both liberal education requirements in this class: it is a math-\nematical model of a very important aspect of computer hardware, namely transistor den-\nsity. And this model involves exponential growth, which is an important concept in many\nareas, not just computer hardware or computer science.\nBoth the descriptive and predictive features of Moore\u2019s Law also are useful in thinking\nabout technology and society. As mentioned in the previous sections, Moore\u2019s Law is\nuseful in understanding, discussing, and analyzing past effects of computers on society,\nand in predicting future effects. 6.2. MORE ABOUT EXPONENTIAL GROWTH 119\n6.2 More About Exponential Growth\nWhat exactly does \u201cexponential growth\u201d mean? As mentioned above, it commonly is\nused to denote rapid growth. But technically speaking it means the growth of functions\nof the form\nf(t) = a\u00d7bt\nwhere b > 1.0. This might seem very abstract, but it has some easy to understand and\nimportant characteristics.\nFirst, notice that at time t = 0 the function has value a \u00d7 b0 = a \u00d7 1 = a. So\nthe constant a gives an initial value of whatever we are counting. Second, notice that\nwhenever we add 1 to t \u2014 regardless of what the actual value of t is \u2014 the function value\nincreases by a factor of b since f(t+1)\/f(t) = (a\u00d7bt+1)\/(a\u00d7bt) = bt+1\/bt = b.\nTo make this more concrete, consider a drawing design problem. Suppose you have a\nsquare. You replace the middle third of each edge of the square with three line segments\nto get the more complicated edge shape shown in Figure 6.2. This turns each edge into\nFigure 6.2: One side\u2019s segment(s) after replacing the middle third\na sequence of five line segments. Since you do this for each of the four original edges of\nthe square, the total number of segments becomes 20. You repeat this process a second\ntime. Now the 20 become 100. Doing this a third time yields 500.\nProblem 4: What is the function giving the line segment count after t applications of\nthis process?\nIt is sometimes useful to write an exponential growth function in the slightly different\nform a\u00d7brt. For example, the function f(t) = 2t\/2 is in this form. We could write this\n\u221a\nfunction as f(t) = ( 2)t \u2014 this is the exact same function \u2014 but the form f(t) = 2t\/2 is\noften more informative. Notice that in this case r = 1\/2; this corresponds to a doubling\nperiod of two times steps. If r = 1\/5 the function is 2t\/5, which doubles every five time\nsteps. If r = 3 the doubling period would be every 1\/3 time steps. In general the doubling\nperiod is 1\/r time steps.3\n3Notice how r affects the yearly rate of increase. The ratio of the count from time t+1 to time t is\nf(t+1)\/f(t)=(a\u00d7br(t+1))\/(a\u00d7brt)=br. So, for example, the yearly rate of increase for the function\n\u221a\nf(t)=2t\/2 is 21\/2 = 2\u22481.4. 120 CHAPTER 6. MOORE\u2019S LAW\nIf we replace the 2 with a 3, i.e., consider f = 3rt, then similar observations hold for\nthe tripling period. For example if r = 1\/2 then the function will triple every two time\nsteps.4\nProblem 5: Consider the function f(t) = 200\u00d74t. What is its initial value, i.e., its value\nwhen t = 0? By what factor does it increase every time period?\nAs mentioned above, people sometimes mistakenly call any type of rapid growth ex-\nponential growth. To explore this further, suppose you find that the number of dwellings\nin a city has roughly followed the function g(t) = 200 + 100t2. Note that g(0) = 200,\ng(1) = 300, g(2) = 600, g(3) = 1100, g(4) = 1800 and so on. This function does grow\nquickly. Moreover it is greater than the function f(t) = 2t\/2 for small values of t. But\nthe growth of g is not exponential: g does not have the exponential growth form. This in\nturn means that\n\u2022 unlike an exponential function, the ratio g(t+1)\/g(t) is not constant, but actually\ndecreases as t gets larger;\n\u2022 when t gets sufficiently large, any exponential growth function will be larger and\ngrow faster than g.\nAs a final note, while most functions that grow exponentially also grow rapidly, that\nis not always the case. For example, if you have an initial investment of $1,000 that is\ngrowing at 4% compounded annually, then your amount after t years is 1000 \u00d7 1.04t.\nNote that each year this function increases by a factor of 1.04. If you are familiar with\ncompound interest you know that the compounding \u2014 the exponential growth ratio of\n1.04 \u2014 has a powerful cumulative effect. However, is this rapid growth? The answer to\nthat is context dependent. A growth rate of 1.04 is significantly more than, say, a growth\nrate of 1.01. However, it is significantly less than the rapid rate of a function such as 2t.\nProblem 6: Compare the following functions: 2t\/2, 1000\u00d7t3, 2t, 100\u00d71.05t, 3t. Which\nis largest when t = 0? Which grows more quickly and is largest once t is large?\n6.3 How Long Will Moore\u2019s Law Continue to Hold?\nMoore\u2019s Law cannot hold forever. Yet Moore\u2019s Law has continued to model transistor\ndensity accurately, even in the face of frequent predictions of its imminent demise. Part of\nthe story of Moore\u2019s Law has been how chemists, material scientists, electrical engineers,\ncomputer engineers, etc. have overcome seemingly insurmountable technical difficulty\nafter technical difficulty to continually improve computer chip design and manufacture.\nHowever, at some point the technical difficulties will be too much.5 Similar to a\nbusinesswhoseprofitsaredoublingeveryyear, oranappwhosenumberofusersisgrowing\n4Iftheconstantr isnegative,thenthecountisactuallydecreasing. Exponential decayisanimportant\nconceptinmathematicsandisusedtomodelphenomenasuchasradioactivedecay,orcertaindrugeffects\nin pharmacology.\n5Some observers have already claimed that the doubling period has slowed recently. 6.4. QUESTIONS 121\nby a factor of 10 every quarter (of a year), there will be a time at which that growth rate\nwill no longer hold. Perhaps that time will come soon; perhaps it will not come for many\nyears. Perhaps it will come abruptly; perhaps it will arrive gradually. Or perhaps there\nwill be a revolution, such as quantum computing, that will cause a discontinuous leap in\ncomputer capabilities, and will require a different model of computation. It is difficult\nto predict what the future will hold. However, it is likely that computer capabilities will\ncontinue to increase significantly and rapidly in the future.\n6.4 Questions\nHere are some additional questions to think about. We will discuss some of these in class.\n1. Explain in your own words what Moore\u2019s Law is and why it is important.\n2. Explain in your own words what exponential growth is, and why is is important.\n3. Choose an area (other than computer science) you are interested in. Can you think\nof any examples of exponential growth in that area?\n6.5 Problem Solutions\nProblem 1: Alternative 1 gives you 12\u00d7$100 = $1200. Alternative 2 gives you 1+2+\n4+...+211 = $4095. So Alternative 2 gives more total compensation.\nProblem 2: The amount of memory will double five times in 10 years, so the amount\nwill be 40\u00d725 = 40\u00d732 = 1280 MB or about 1.28GB.\nProblem 3: Answers will vary.\nProblem 4: 4\u00d75t.\nProblem 5: The initial value is f(0) = 200. Each time period the function increases by\na factor of 4.\nProblem 6: When t = 0 we have 1000\u00d7t3 equals 1000, 100\u00d71.05t equals 100, and all\nthe other functions are 1. Here are the functions in terms of increasing order of growth\nas t gets large: 1000\u00d7t3, 100\u00d71.05t, 2t\/2, 2t, 3t.\n6.6 Additional Resources\nHere are some online resources on Moore\u2019s Law and exponential growth:\n\u2022 http:\/\/news.cnet.com\/FAQ-Forty-years-of-Moores-Law\/2100-1006 3-5647824.html.\n\u201cFAQ: Forty Years of Moore\u2019s Law\u201d. This CNET article, from 2005, explains the\nbasics of Moore\u2019s Law. 122 CHAPTER 6. MOORE\u2019S LAW\n\u2022 http:\/\/www.wired.com\/opinion\/2013\/04\/how-pixar-used-moores-law-to\n-predict-the-future\/ \u201cHow Pixar Used Moore\u2019s Law to Predict the Future\u201d.\nThis Wired magazine article provides an example of how researchers and businesses\nuse Moore\u2019s Law to predict future computing capabilities.\n\u2022 http:\/\/en.wikipedia.org\/wiki\/Moore\u2019s law. This Wikipedia page on Moore\u2019s\nLaw contains both some introductory material, as well as a number of interesting\ndetails, related information, and some advanced material.\n\u2022 http:\/\/en.wikipedia.org\/wiki\/Exponential growth. This Wikipedia page on\nexponential growth provides a number of examples, as well as some additional\n(mostly advanced) material.\n\u2022 http:\/\/computer.howstuffworks.com\/moores-law.htm. ThisHowStuffWorksar-\nticle provides background information about Moore\u2019s Law. It is recommended for\nstudents who want to know more background than we will cover in class. Chapter 7\nComputer Security\nIs security computing\u2019s \u201cAchilles\u2019 heel?\u201d1\n7.1 Introduction\n7.1.1 Introductory Problem\nThe alphabetic string UGG\u2019N QBGG OEUO BJAN QBGG was obtained by encrypting a well-\nknown saying using an alphabetic substitution cipher. That is, each letter in the original\nsaying was replaced by another letter. If a letter appeared more than once in the original\nsaying, it was always replaced by the same letter. What is the original saying?\n7.1.2 Overview\nComputer security is an important and complicated topic. It affects individuals, groups,\ncompanies, and governments. Because of the breadth and depth of this topic, we will not\neven come close to covering it in full. Instead we\u2019ll look at at questions such as\n\u2022 What is \u201ccomputer security\u201d and why is it important?\n\u2022 What are some of the issues in computer security?\n\u2022 How do encryption and decryption work?\n\u2022 What are the most important things to know about computer security?\nSome of these issues are addressed in this chapter. Others we\u2019ll explore further during\nclass time.\n1\u201cAchilles\u2019 heel: a fault or weakness that causes or could cause someone or something to fail.\u201d From\nthe Merriam-Webster online dictionary http:\/\/www.merriam-webster.com\/. Accessed Nov. 21, 2013.\n123 124 CHAPTER 7. COMPUTER SECURITY\n7.1.3 Topic Goals\nUpon completing this section, you should be able to do the following:\n1. Be able to explain what computer security is and why it is important.\n2. Be able to explain some of the important issues in computer security.\n3. Beabletoexplain the basics ofcryptography, andsolve(notextremelycomplicated)\nencryption and decryption problems.\n4. Beabletoexplainthebasicsofpublickeyencryption: howitworks(onahighlevel),\nwhat its advantages and disadvantages are, and what types of attacks it protects\nagainst.\n7.1.4 How These Topics Relate to Mathematics\nMathematics provides many underpinnings of encoding and decoding messages securely.\nThis is particularly true for strong encryption and decryption techniques, the types used\nin e-commerce or by the military. (As an example, see the section on public key encryp-\ntion.) However, it is also true on a simpler level for less secure encryption or decryption\ntechniques, such as those used in recreational puzzles.\n7.1.5 How These Topics Relate to Society and Technology\nComputer security is obviously an important topic for society. A need for security under-\nlies individual computer use: we do not want unauthorized people accessing our personal\ncomputing devices, for example. It underlies business use of computers: businesses need\nto protect their transactions, data, etc. Without sufficient security, e-commerce would not\nexist. It underlies many \u201ccritical industries,\u201d for example computers play a role in areas\nsuch as telecommunications, manufacturing, and energy. These industries obviously have\nstrong reasons to keep their systems and facilities secure. And it underlies government\nfunctions, not only in areas like national security and the military, but also in areas such\nas government-run medical programs, tax records and collection, and law enforcement.\n7.2 Some Computer Security Principles\nWe\u2019ll start by making some \u201cbig picture\u201d observations about computer security.\n1. Cryptography is a part, but not the entirety, of computer security. Sometimes com-\nputer security is simplified to \u201cencrypt your data and your communications.\u201d While\nencryption is part of computer security, it is not the whole of it; there are many,\nmany important aspects of computer security other than encryption. 7.2. SOME COMPUTER SECURITY PRINCIPLES 125\n2. There are a variety of computer security attacks. For example, some attacks target\ndata, some transmission of data, some computer systems. Some attacks target in-\ndividuals\u2019 personal computers. Some target business or government systems. Some\nattacks attempt to \u201csteal data\u201d but not to otherwise compromise a system. Some\nattempt to damage the system or render it ineffective for a period of time.\n3. Computer security has both technical and social aspects. Computer security guide-\nlines often focus on technical aspects: make sure your anti-malware software is up\nto date, use encryption on sensitive data, use sufficiently long passwords, etc. How-\never, there are non-technical attacks as well. For example, one social engineering\nattack against a business involves a malicious hacker calling an employee and imper-\nsonating someone of importance within the business; for instance the hacker might\npretend to be a technically inept boss with urgent need for a certain file.\n4. Computer security is not restricted to preventing unauthorized access by \u201coutsiders.\u201d\nWhile this is one type of threat, a large number of security incidents involve insiders.\nThat is why a good organizational security plan involves items such as background\nchecks for prospective employees, training about security practices and rules, re-\nstricting access to systems and data to only certain employees, logs of all activity\non critical systems, etc.\n5. If you work for an organization that deals with sensitive data, there are probably\ndeveloped practices and procedures you will need to follow. For example, there are\nfederal laws such as FERPA (that deals with educational data) and HIPAA (that\ndeals with medical data) that employees must know and follow. Moreover, many\norganizations have their own internal security practices and rules.\n6. \u201cSecurity is a process, not a product.\u201d This principle, attributed to computer secu-\nrity expert Bruce Schneier, highlights that security isn\u2019t something you can get or\nbuy and then be done with. For example, as important as anti-malware software\nis, it is only part of a good security plan. Additionally, new security threats are\nemerging on a weekly basis. What works today might not work tomorrow.\n7. It is useful to know some of the common types of attacks, and to know the basics\nof what individuals should do to protect themselves. This includes being able to\nrecognize some of the most common types of attacks (e.g., emails or phone calls\nthat ask you to provide your password), and being familiar with some of the most\ncommon countermeasures (such as anti-malware software).\n8. There are a number of topics such as privacy that are related to security, but are not\nidentical. For example, sometimes security and privacy go hand-in-hand: an illegal\naccess to a medical database is both a security and a privacy breach. Sometimes,\nthough, more security means less privacy. For example, companies or agencies that\nworkwithcriticalsystemsoftendoextensivebackgroundchecksontheirprospective 126 CHAPTER 7. COMPUTER SECURITY\nemployees; the result is more security for the company or agency, but less privacy\nfor the prospective employee.\n9. Computer security is an issue of strong current concern. In general, our computer\nsystems are not as secure as they should be. However, making systems more secure\nis difficult for a number of reasons. These include that there are a number of\ndifferent types of attacks; that many systems were developed before security became\na concern, and it is difficult to add security to existing systems; that security has\nboth technical and non-technical aspects; and that good security is costly.\n7.3 Introduction to Cryptography\nWhen you log into a computer system remotely, you don\u2019t want your password to be\ntransmitted over a computer network in its usual form: it is too easy for someone to snoop\non Internet traffic and discover your password. Instead, you want it to be encrypted, and\nany reasonable computer system encrypts passwords. Similarly, you don\u2019t want to send\nyour credit card information unencrypted over the Internet, you don\u2019t want your bank\ndoing financial transactions insecurely, and you don\u2019t want sensitive medical information\nstored where anyone can access it. For example, suppose a medical worker has a laptop\ncontaining medical records. Laptops are often stolen or lost, so extremely sensitive data\nshould not be stored on them. But if it is, then it should be encrypted to make it more\ndifficult for a thief to use it maliciously.\nIn this course we\u2019ll look in particular at encryption\/decryption. This is not because\nthis is the only important subarea of computer security; as the last section mentioned, it\nis only one of many. But it is an important subarea, and has a nice connection to the\nmathematical requirements of our course.\nCryptography, the science and practice of encrypting information,2 is a complicated\narea. Large financial transactions, military communications, etc. use extremely sophisti-\ncated encryption techniques, which are beyond the scope of this chapter. So here we will\nfocus on some of the basics.\nSupposeBobwantstosendamessagetoAlice. However, BobandAlice\u2019sarchnemesis,\nCharlie, wants to intercept this message. How can Bob send Alice a message securely?\nThis involves a number of steps if Bob and Alice use encryption:\n1. Bob must take the original message, called the plaintext, then encrypt it using an\nencryption key or cipher. The result is called ciphertext.\n2. Bob then sends the ciphertext to Alice.\n2There is a large amount of special terminology in the area of computer security. Since this is an\nintroductoryclasswewill,forthemostpart,avoidmuchoftheterminology. However,ifyouareinterested,\nthere are a number of online glossaries. 7.3. INTRODUCTION TO CRYPTOGRAPHY 127\n3. Alice receives the message, then applies a decryption key to the ciphertext to recover\nthe original plaintext.\nFor this to work, Alice must have a decryption key that reverses what Bob\u2019s encryption\nkey does. For example, if Bob\u2019s key advances each letter three places forward in the\nalphabet, then Alice\u2019s key would move each letter back three places.3 Or if Bob\u2019s key is\nan alphabetic substitution cipher and it takes \u2018A\u2019 to \u2018K\u2019, then the decryption key would\ntake \u2018K\u2019 to \u2018A\u2019.\nThis presents a problem, however: how does Bob let Alice know what the key is\nwithout letting Charlie also know? If Bob and Alice are in different locations, having\nBob send the key introduces the same problem as sending the original plaintext without\nencrypting it: Charlie might intercept the message. This is a problem with traditional\ncryptography: how to get the key securely to the receiver?\nNote Charlie\u2019s aim is likely to discover what message Bob is sending to Alice. But this\nisnottheonlypossibility. HemightpreventthemessagefromgettingtoAlicebystopping\nthe transmission somehow. He might change the message to say something different, for\nexample, instead of \u201cBid up to $2,000,000 for the rare manuscript\u201d he might change it to\n\u201cBid up to $20,000,000 for the rare manuscript.\u201d\nYou have probably played games similar to the introductory problem in this chapter.\nThese games might involve simple encryption techniques such as transposing pairs of\nadjacent letters, or advancing letters forward in the alphabet a set number of places. For\nexample, suppose you have the message ARRIVE IN DUBLIN and move each letter forward\n13 places in the alphabet (wrapping around if you go beyond the end). Just encrypt the\nletters; leave the spaces as they are.4 What do you get? The answer is at the end of the\nnext paragraph.\nThis method takes \u2018A\u2019 to \u2018N\u2019, \u2018R\u2019 to \u2018E\u2019, etc. This is an example of an alphabetic\nrotation cipher. This particular one, advancing every character 13 places, is called ROT-\n13. It is often used in non-secure settings, for example, to encrypt a \u201cspoiler\u201d comment\nin an online discussion of books or movies. Note that to decrypt ROT-13 ciphertext we\nmerely shift all characters back 13 characters. However, also note we can advance them\n13 characters; that is, since our alphabet has 26 characters, the ROT-13 encryption key\nis identical to the ROT-13 decryption key. (The answer to the problem above is NEEVIR\nVA QHOYVA. )\nProblem 1: Suppose you know the ciphertext SWPAN WJZ NQOP was obtained through an\nalphabetic rotation technique, but don\u2019t know how many places each letter was advanced.\nWhat is the maximum number of possible rotations you\u2019d need to try, and what is the\nplaintext?\nThe problem at the start of this chapter uses alphabetic substitution. Although sig-\nnificantly more complicated than alphabetic rotation, substitution is still not secure. Is\n3This extremely simple technique is called the Caesar cipher.\n4In serious encryption all characters including spaces and punctuation are encrypted so they do not\nprovide clues to word length, sentence structure, etc. 128 CHAPTER 7. COMPUTER SECURITY\nthis because alphabetic substitution does not provide enough possibilities? There are\n26 \u00d7 25 \u00d7 24 \u00d7 \u00b7\u00b7\u00b7 \u00d7 3 \u00d7 2 \u00d7 1 different alphabetic substitution options. This is a very\nlarge number. The problem is not that there are so few possibilities that the computer\ncan check all of them. Instead, the problem is that the computer can use other informa-\ntion. For example, certain letters appear more frequently than others. If you are familiar\nwith the board game Scrabble, think about the low scoring letters such as \u2018E\u2019,\u2018N\u2019, and\n\u2018S\u2019. These letters appear much more frequently than the high-scoring letters such as \u2018Z\u2019,\n\u2018Q\u2019, and \u2018J\u2019. This frequency information suggests some likely correspondences, which an\nanalyst can use to decrypt ciphertext obtained through alphabetical substitution.\nIn summary, alphabetic substitution and other simple techniques are not secure.\n7.4 Public Key Encryption\nOne problem mentioned above is the \u201ckey distribution\u201d problem: how does Bob securely\nsend Alice a key so that she can decrypt messages that he sends? There is an ingenious\ntechnique called public key encryption that avoids the key distribution problem.\nPublic key encryption relies on the idea of irreversible (or, more accurately, difficult\nto reverse) processes. Some things are much easier to do than undo. In particular, it\nis easier to do mathematical operations such as multiplying two large numbers than the\nreverse operation: given a large number, factor it.\nPublic key encryption relies on this in producing public key\/private key pairs. If Bob\nand Alice plan to use public key encryption, then Alice would first need to use a program\nto generate a public and a private key. She can \u201cpublish\u201d the public key, so Bob can get\nit. However, only she should know the private key. Bob and Alice then do the following\nsteps:\n1. Bob encrypts the message using Alice\u2019s public key.\n2. Bob send the ciphertext to Alice.\n3. Alice decrypts the message using her private key.\nNotethatanyone(includingBob)cansendAliceamessageusingherpublickey. However,\nonly she should be able to decrypt those messages.\nAs an alternative, sometimes public key encryption is used to send another key. This\nstill avoids the key distribution problem, but allows using a less computationally intensive\nkey for encrypting and decrypting long messages. So in this case there are two sets of\nencryption and decryption keys \u2014 the public key encryption and decryption keys, and\nthe \u201cregular\u201d encryption and decryption keys. The steps are then as follows:\n1. Bob encrypts the regular decryption key using Alice\u2019s public key.\n2. Bob sends the ciphertext version of the regular decryption key to Alice. 7.4. PUBLIC KEY ENCRYPTION 129\n3. Alice decrypts the regular decryption key using her private key.\n4. Bob encrypts a message using the regular encryption key.\n5. Bob send the ciphertext version of the message to Alice.\n6. Alice decrypts the message using the regular decryption key.\nProblem 2: Is public key encryption foolproof? Does it defend against all types of\nattacks?\nHere is a further explanation of how public key encryption works, using a type called\nRSA encryption. It relies on a number of mathematical concepts:\n\u2022 Prime numbers: Prime numbers are positive integers that are greater than 1, and\nthat are evenly divisible only by 1 and themselves. So, for example, 7 is prime since\nit has no divisors other than 1 and itself. However, 6 is composite (i.e., not prime)\nsince it is also divisible by 2 and 3.\n\u2022 Greatest common divisors: The greatest common divisor of two positive integers\nis the largest integer that evenly divides both. For example, the greatest common\ndivisor of 30 and 36 is 6, since 6 divides both, and no larger integer does. The\ngreatest common divisor is often abbreviated as gcd. For example, gcd(10,15) = 5.\n\u2022 Relative primeness: Two positive integers are said to be relatively prime if their\ngreatest common divisor is 1, i.e., if no positive integer greater than 1 divides both\nevenly. For example, 9 and 14 are relatively prime, but 10 and 28 are not since 2\ndivides both.\n\u2022 Modular arithmetic: Theprocessbelowusesmodulararithmetic, thatis, theremain-\nder operator. Specifically, a mod b is the remainder when you divide the integer a\nby the integer b. For example 22 mod 10 is 2.\n\u2022 Exponentiation: The RSA process uses exponentiation extensively.\nHere is an example. It is not important to follow all the details and arithmetic in\nthe example. But you should get a feeling for the amount of computation involved, and\nhow the mathematical items mentioned above play a role. This example illustrates the\nunderlying mathematics; but in practice these steps are actually done by computer. So\nthis is an illustrative example rather than what people actually do when using public key\ncryptography.\n1. To generate a public\/private key pair I take any two relatively large primes p and q\n(we\u2019ll use 1063 and 8501 for this example, although primes actually used are much\nlarger) and multiply them together to get n = pq: 9036563. 130 CHAPTER 7. COMPUTER SECURITY\n2. I next take any number e with the property that gcd(e,(p \u2212 1)(q \u2212 1)) = 1 (e.g.,\ne = 43 works since gcd(43,(1063\u22121)\u00d7(8501\u22121)) = 1).\n3. I send you e and n.\n4. To send me an encrypted message you take your message, and first assign numerical\nequivalents to each character. There are many possible ways to do this; let\u2019s use\nthe simple technique of assigning each letter its place in the alphabet: \u2018A\u2019 is 01, \u2018B\u2019\nis 02, etc. Then group the digits into blocks of a certain size, say of length 4. Let\nM indicate a block of 4 digits. You then encrypt M by computing C = Me mod n.\nYou do this for each block, and send me the results. For example, if your original\nmessage is STOP, you\u2019d have the following:\noriginal message: S T O P\nnumerical equivalents: 18 19 14 15\nyou compute and send:\n1819 raised to the 43rd power mod 9036563 = 7757145\n1415 raised to the 43rd power mod 9036563 = 8393137\n5. I know p and q (but n is, in practice, large enough that p and q cannot be found by\nother people). From these I find a number d such that de = 1 mod (p\u22121)(q\u22121), or\nde = 1 mod 9027000. (d = 6297907 works, we\u2019ll skip the mathematics involved in\nhow to find d.) Apply this to C : Cd mod n = (Me)d mod n = M(de) mod n. Now\nby a little mathematical \u201cmagic\u201d this equals M mod n, and so I recover the original\nM by taking each block of what you sent me, and raising it to the d power mod n.\nComments:\n\u2022 Note I can give you (and everyone else) the encryption key (e and n) as long as n\nis difficult to factor.\n\u2022 Note how prime numbers and the other mathematics mentioned above are involved\nin the encryption and decryption.\n\u2022 The important thing with this example is not that you understand all the details,\nbut that you understand the important points:\n\u2013 The motivation for public key encryption, as well as what problems it solves\nand what problems it doesn\u2019t.\n\u2013 How it works on a high level.\n\u2013 The reliance of public key encryption on mathematics.\n\u2013 The need for computers in doing the many computations involved in public\nkey encryption. 7.5. ADDITIONAL PROBLEMS 131\n7.5 Additional Problems\nHere are some additional problems on this topic.\nProblem 3: Do the following encryption\/decryption problems manually (i.e., without\nrelying on a computer). You need only encrypt the alphabetic characters \u2014 leave any\npunctuation as is.\n(a) Encrypt the following Alice in Wonderland quote using ROT-13:\nWHY IS A RAVEN LIKE A WRITING DESK?\n(b) Decrypt the following message, which was encrypted using rotation-based encryption:\nIJ RDNZ ADNC RJPGY BJ VITRCZMZ RDOCJPO V KJMKJDNZ\n(c) Decrypt the following message, which was generated with substitution-based encryp-\ntion:\nMU BERZ, NEZE GE MVYW ZVP RY KRYW RY GE ARP IVYW WC YWRU XP THRAE.\nRPB XK UCV GXYN WC LC RPUGNEZE UCV MVYW ZVP WGXAE RY KRYW RY WNRW.\nProblem 4: Algorithms such as public key encryption rely on being able to do \u201cexpmod\u201d\noperations quickly for large numbers. That is, for given positive integers b,n,m they need\nto compute bn mod m. Remember the mod m operations gives the remainder for division\nby m.\nComputing bn mod m by first computing bn and then finding the remainder has two\nshortcomings. First, since b,n, and m are very large numbers, bn is very, very large. And\nwhile computers can deal with very large numbers, it takes special efforts for them to do\nso. Second, this approach is rather time consuming.\nHere is a much more efficient algorithm:\nInput: Three positive integers b,n,m.\nOutput: bn mod m.\n1 Find the binary representation of n; call the bits in it a a ...a a\nk k\u22121 2 1\n2 Set x = 1\n3 Set power = b mod m\n4 For i = 1 to k\n5 If a equals 1\ni\n6 Set x = (x\u00b7power) mod m\n7 Set power = (power\u00b7power) mod m\n8 Print x\n9 Stop\n(a) Trace through this algorithm for b = 7, n = 17, m = 13. Specifically, state (i) the\nbinary representation of n, (ii) the values of x and power right after Line 3 is executed, 132 CHAPTER 7. COMPUTER SECURITY\n(iii) the values of i, x, and power right after each time Line 7 is executed, and (iv) what\nvalue is printed.\n(b) Trace through this algorithm for b = 5, n = 23, m = 11. Specifically, state (i) the\nbinary representation of n, (ii) the values of x and power right after Line 3 is executed,\n(iii) the values of i, x and power right after each time Line 7 is executed, and (iv) what\nvalue is printed.\nProblem 5: Let\u2019s use another technique to encrypt (a shortened version of) the Alice in\nWonderland quote from the problem above:\nWHY A RAVEN?\n(a) First, change each character, including the spaces and the question mark, into its\ndecimal ASCII equivalent. Write all the decimal numbers together from left to right to\nform a single number.\n(b) Take your answer from part (a) and transpose each pair of digits. So, for example, if\nyour answer in part (a) was 12345678, you\u2019d transpose the 1 and the 2, then the 3 and\nthe 4, then the 5 and the 6, then the 7 and the 8, to get 21436587. (Your actual answer\nfrom part (a) should be longer than the 8-digit example used here.)\n(c) Now move the last digit to the front of the number. Then taking two digits at a time,\nfrom left to right, turn each two-digit pair into the corresponding ASCII equivalent. So,\nfor example, if you have 21436587 from part (b), moving the last digit to the front would\ngive 72143658. Then 72 is an H, 14 is the non-printing SO (shift out) character, 36 is a\ndollar sign $, and 58 is a colon : . In writing your final answer, enclose any non-printing\ncharacters in parentheses. So the encrypted message would be H(shift out)$:\n(d) Does this encryption result in a substitution key? That is, each time a specific\ncharacter occurs in the plaintext is it encrypted as the same character in the ciphertext?\nProblem 6: Are substitution-based ciphers secure? Briefly explain why or why not.\n7.6 Problem Solutions\nIntroductory Problem: The saying is \u201cALL\u2019S WELL THAT ENDS WELL.\u201d\nProblem 1: There are 25 possible rotations to try (we don\u2019t count the 26th possibility, of\nadvancing each letter 26 places, since it just replaces each letter with itself). The original\nmessage is WATER AND RUST.\nProblem 2: It is not foolproof. For example, someone could pretend to be Bob and send\na fake message to Alice.\nProblem 3 (a) JUL VF N ENIRA YVXR N JEVGVAT QRFX?\n(b) NO WISE FISH WOULD GO ANYWHERE WITHOUT A PORPOISE 7.6. PROBLEM SOLUTIONS 133\n(c) MY DEAR, HERE WE MUST RUN AS FAST AS WE CAN JUST TO STAY IN\nPLACE. AND IF YOU WISH TO GO ANYWHERE YOU MUST RUN TWICE AS\nFAST AS THAT.\nProblem 4\n(a)\n(i) 10001\n(ii) x: 1 power: 7\n(iii) i x power\n--- --- -----\n1 7 10\n2 7 9\n3 7 3\n4 7 9\n5 11 3\n(iv) 11\n(b)\n(i) 10111\n(ii) x: 1 power: 5\n(iii) i x power\n--- --- -----\n1 5 3\n2 4 9\n3 3 4\n4 3 5\n5 4 3\n(iv) 4\nProblem 5\n(a) 877289326532826586697863\n(b) 782798235623285668968736 134 CHAPTER 7. COMPUTER SECURITY\n(c) Moving the last digit to the front gives 678279823562328566896873, which translates\nto CROR#>(space)UBYDI\n(d) It isn\u2019t. For example, the fifth and eighth characters in the plaintext are the same \u2014\nboth A\u2019s \u2014 but the fifth and eighth characters in the ciphertext are not.\nProblem 6: Substitution ciphers are not secure. This is because \u2014 even though there\nare an extremely large number of them \u2014 they can still be cracked by using techniques\nsuch as analyzing letter frequency and letter combination frequency.\n7.7 Questions\nHere are some questions to think about:\n1. Suppose someone asked you for advice on personal computer security. List three\ntips you would give them.\n2. There were security threats prior to computers. How have computers changed indi-\nvidual, organizational, and national security?\n3. List some types of data that require strong security, and some types that require\nminimal, if any, security.\n4. The issue of privacy is related to, but not identical to, security. How are computers\nchanging the privacy landscape? List some ways or give some examples.\n7.8 Additional Resources\nHere are some additional, online resources:\n\u2022 http:\/\/computer.howstuffworks.com\/encryption.htm: thehowstuffworks\u201cHow\nEncryption Works\u201d page. This page covers many of the basics mentioned in class,\nas well as providing additional details for those who are interested.\n\u2022 http:\/\/en.wikipedia.org\/wiki\/ROT13: the Wikipedia ROT-13 page. This page\nexplains ROT-13 and related schemes in some detail, and provides some examples.\n\u2022 http:\/\/www.thegeekstuff.com\/2012\/07\/cryptography-basics\/: Introductionto\nCryptography Basic Principles. This page from The Geek Stuff website gives an\noverview of some of the techniques and uses of cryptography.\n\u2022 http:\/\/www.oit.umn.edu\/safe-computing: the U of M Safe Computing website.\n\u2022 http:\/\/www.youtube.com\/watch?v=Wc1dOw4j3J8: Explaining Computer Security.\nA YouTube video containing practical, general advice about personal computer\nsecurity. 7.8. ADDITIONAL RESOURCES 135\n\u2022 http:\/\/www.dhs.gov\/topic\/cybersecurity: The U.S. Department of Homeland\nSecurity cybersecurity page. This page contains a wealth of information on cyber-\nsecurity and related topics.\n\u2022 http:\/\/www.dhs.gov\/critical-infrastructure-sectors: TheU.S.Department\nofHomelandSecuritycriticalinfrastructurepage. Thispagelistsanumberofsectors\nincluding not only information technology, but also others such as communications,\nenergy, and financial services.\n\u2022 http:\/\/www.schneier.com\/: Bruce Schneier Website. Schneier is an expert on\nsecurity and related topics such as privacy. He writes both advanced works for\nexperts as well as more accessible articles for popular audiences. The material here\nisn\u2019t necessarily closely related to what we covered in class, and you might not\nagree with everything Schneier writes, but this site provides interesting additional\nmaterial for anyone interested in learning more about this area. 136 CHAPTER 7. COMPUTER SECURITY Chapter 8\nComputer Science, Numbers, and\nCounting\nIn computer science numbers matter, including very small and very large ones.\n8.1 Introduction\n8.1.1 Introductory Problem\nA large part of computer graphics is modeling, for instance modeling a character in a\ncomputer-generated film, modeling a scene in an architectural simulation, or modeling a\nmechanical part of an automobile. One conmonly-used technique models the surface of\na solid object as a triangular mesh. That is, the object surface is represented as a large\nnumber of connected triangles.1\nGraphics scenes can be complicated. They might contain many objects. Moreover,\nthe triangular mesh for each object might contain many triangles in order to represent\nthe surface reasonably accurately. Therefore, the size of the files containing scenes can be\na concern. Consider the following problem.2\nSuppose you are composing a computer graphics scene consisting of 100 objects. Each\nobject is modeled as a triangular mesh consisting of an average of 100 triangles. Each\ntriangle has three vertices, each of which has an x, y, and z coordinate. And each\ncoordinate is stored as a 32-bit number. Roughly how much space would it take to store\nthis scene if you stored every coordinate of every triangle?\nComputer practitioners often find themselves doing problems like this. Here are addi-\ntional examples:\n1Sometimes quadrilaterals (four-sided shapes) or more generally polygons (many-sided shapes) are\nused instead of, or in addition to, triangles. The mesh is then called a quadrilateral or polygonal mesh.\n2A solution is in Section 8.4 below.\n137 138 CHAPTER 8. COMPUTER SCIENCE, NUMBERS, AND COUNTING\n1. Suppose you have a 4GB file. How long will it take to download if your average\ndownload rate is 1Mbps?\n2. Suppose a computer system allows passwords that are (exactly) eight characters\nlong, with each character being an upper-case or lower-case alphabetic character or\na digit 0 \u2013 9. How many possible passwords are there? And if a malicious hacker\nwrites a program that can check one thousand passwords per second, what is the\nchance that he or she will be able to access your account within five minutes?\n3. Suppose you are managing a programming project. You must choose a three-person\nteam from a group of five people. How many possible teams are there?\n8.1.2 Overview\nQuestion 1: What comes to mind when you think about \u201cnumbers and computer sci-\nence?\u201d Write a paragraph, make a list, sketch a diagram, etc.\nWhat comes to mind? One common image is the computer as a \u201cbig calculator.\u201d\nViewing computers as massive calculators is one historical perspective on computing, as\nthe following examples show:\n\u2022 The term \u201ccomputer\u201d used to refer to humans who did calculations.\n\u2022 One group of \u201cancestors\u201d of computers were business machines made by companies\nsuch as Burroughs and IBM, that often did numerical business computations.3\n\u2022 Some early pre-computers and early computers were built to do extensive numerical\ncomputations, such as ballistics computations during WWII.\n\u2022 In general, both historically and currently, there are many important scientific,\nengineering and other applications that rely on computers\u2019 abilities to do many,\nmany arithmetic operations very rapidly.\nHowever, there are also many other connections between computer science and numbers.\nOne area that we\u2019ll examine in some detail in this chapter is counting problems: what\nthey are, why they are important, what some examples are, what background information\nis useful to know about them, and what tips or techniques are useful in solving them.\nThe main theme of this chapter is that in computer science numbers matter, including\nvery large and very small ones.\n3Photographs of such computing machines are available on the web, for example see the photograph\narchive at the Charles Babbage Institute http:\/\/www.cbi.umn.edu 8.1. INTRODUCTION 139\n8.1.3 What Are Counting Problems and Why Are They Impor-\ntant?\nCounting problems consist of arithmetic computations to answer fundamental problems\nsuch as \u201chow many?\u201d or \u201chow long?\u201d How large is a certain file likely to be? How many\nservers does a company need to meet peak customer demand? How long will it take for a\nperson to download a file? How many different files names are there of a certain type?\nQuestion 2: Give an example of a computer science counting problem that you can think\nof, and that is different from those mentioned above.\nQuestion 3: Give an example of a counting problem that you can think of from an area\nother than computer science.\nCounting problems arise frequently in many areas of computer science. They are\nimportant not only to individuals who might want to figure out items such as how many\nsong files can fit on their computer\u2019s hard disk, or how long it might take to download a\nlarge file over a slow connection, but also to computer practitioners and researchers, to\nbusinesses, and to government organizations.\nCounting problems are a sufficiently important topic that they are usually part of a\ncomputer science curriculum. For example, at the University of Minnesota-Twin Cities,\ncounting problems are a prominent topic in CSci 2011, Discrete Structures of Computer\nScience, which is a required class for computer science and computer engineering majors.\nCountingproblemsareusuallynotdeepproblems: tosolvethemofteninvolvesjustthe\nusual arithmetic operations of multiplication, division, addition, subtraction, and expo-\nnentiation. However, there are a few challenges associated with the problems. Sometimes\n\u2014asinthegraphicsproblembeginningthischapter\u2014therearemanyquantitiesinvolved;\nsometimes it is not always obvious how to combine the different quantities; sometimes\nthere are extra conversions (for example, memory sizes are usually given in bytes but\ndownload rates in bits per second); sometimes the problems involve very large or very\nsmall numbers; and sometimes problems use unfamiliar terminology such as \u201cpetabytes\u201d\nor \u201cnanoseconds.\u201d Moreover, there are a variety of different types of counting problems.\nSo there is not a \u201cone size fits all\u201d formula or technique to apply in all situations.\n8.1.4 The Liberal Education Requirements\nHow do counting problems relate to the liberal education themes of CSci 1001? The link\nto the mathematical thinking core theme is obvious \u2014 counting and arithmetic is one\nbranch of mathematics.4\nHow, if at all, is counting related to the technology and society theme?\nConsider the general problem of downloading files. Customers who wish to download\ncontent online are willing to wait a certain amount of time, but not too long. Nowadays\nwe take services such as iTunes and Netflix for granted, but it was not always the case\n4Infact,whenpeoplethinkofmathematicstheyoftenthinkofarithmetic. However,justascomputer\nscience is much broader than computer programming, mathematics is much broader than arithmetic. 140 CHAPTER 8. COMPUTER SCIENCE, NUMBERS, AND COUNTING\nthat downloading a song file or downloading a movie was feasible. Companies such as\nApple and Netflix needed to do a number of calculations involving download times to\nguarantee that their services would have a large enough set of potential customers.\nConsider buying an audio file of a song over the Internet from iTunes or from a similar\nservice. A typical song file is about 4MB in size (the size will of course vary depending, for\nexample, on the song duration). Back when the most common connection was a 56Kbps\n(kilobits per second) download connection, the download time would be\n(4 megabytes)((about) 1000000 bytes\/megabyte)(8 bits\/byte)\n\u2248 570 sec\n(56 kilobits\/sec)((about) 1000 bits\/kilobit)\nor about nine and a half minutes.5 While this is not an outrageous amount of time, not\nmany people are willing to wait that long for one song file.\nHowever, Internet connection speeds have been continually increasing. If a person has\na 1 Mbps (megabit per second) average download rate, then the download time decreases\nto approximately 32 seconds, a much more acceptable download time.\nWhen Apple was setting up iTunes, the company needed to do a number of download\ncomputations on how long it would take potential customers with various download rates\nto download a typical song or a typical album. Apple calculated that the durations would\nprovide enough potential customers that iTunes would be feasible in terms of acceptable\ndownload times.\nThis business planning problem is just one example of how counting problems relate to\nthe technology and society theme. More generally, counting problems can be important\nto individuals, businesses, and governments because they answer questions of feasibility,\nplanning, likelihood of occurrence, need for resources, etc.\n8.1.5 Goals\nHere is what you should be able to do once we finish this topic:\n1. Given a counting problem, be able to solve it, and explain how you obtained your\nanswer.\n2. Be able to use counting problems to answer questions related to what computer\ncapabilities are feasible now or in the future.\n3. Know and be able to use terminology such as \u201cgigabytes\u201d, \u201cnanoseconds\u201d, etc. that\noften arise in computer-related counting problems.\n5Noticethatgettinganexactanswerforaproblemofthistypeisneitherimportantnorevenpossible:\nthe 4MB file size is just a rough size since typical song files are rarely exactly 4MB in size. And there\nare a number of factors that affect actual download rates as well. More generally, while there are some\ntypesofcountingproblemswhereanexactanswerisimportant,inmanywewilljustlookforareasonable\nrough approximation. 8.2. SOLVING COUNTING PROBLEMS 141\n8.2 Solving Counting Problems\nThere are a variety of techniques for solving counting problems. In this section we\u2019ll look\nat further examples of counting problems, as well as tips and techniques for solving them.\n8.2.1 Some General Tips\nConsider the following counting problems, some of which are similar to examples you\u2019ve\nseen before, and some of which are not:\n1. How long does it take to download a 3.6GB file over a 500Kbps network connection?\n2. How much storage (in KB or MB) does it take to store a 1000 x 1000 pixel image,\nwhere each pixel uses 24 bit color, and the image is compressed 30:1?\n3. Howmanypossiblepasswordsaretherewherethepasswordmustbe8or9characters\nlong, start with a lower case alphabetic character, and have as remaining characters\nany of 94 characters that consist of lower case alphabetic characters, upper case\nalphabetic characters, digits 0 \u2013 9, or any of 32 punctuation characters?\nCounting problems usually do not involve very complicated mathematics, but can\nnonetheless be challenging. For example, they often involve many quantities and compu-\ntations, might involve very large or very small numbers, and might require you to know\ncomputer terminology. This section contains some hints on doing these types of problems:\n\u2022 Read the problem carefully. Make sure you understand what the problem is asking,\nand understand all the items in the problem statement.\n\u2022 Combine quantities correctly. For example, in the first problem above, you are given\na file size and a download speed. To get the desired outcome, a duration, you need\nto divide the file size by the download speed.\n\u2022 Keep track of units. This is not only good general strategy, but also helps ensure\nthatyoudon\u2019tmissanyconversionsnotexplicitlystatedintheproblem(suchasbits\nto bytes, or bytes to megabytes). It also furnishes a partial check on your answer\n(e.g., if you get an answer of 2KB for a download time, something is wrong since\nthe answer should be an amount of time, not a memory size).\nBe particularly careful of bits and bytes. File sizes are usually given in term of\nbytes, while transmission speeds are usually given in terms of bits per second. For\nexample, in the first problem above, the file size is in gigabytes, and the download\nspeed is in kilobits per second. So the answer will require converting bits to bytes,\nor bytes to bits. 142 CHAPTER 8. COMPUTER SCIENCE, NUMBERS, AND COUNTING\n\u2022 Be familiar with the prefixes such as mega-, giga-, etc.. Many computer counting\nproblems involve gigabytes, kilobits, nanoseconds, etc. Remember, for instance\nthat a gigabyte is approximately a billion bytes. And a kilobit is approximately a\nthousand bits.\n\u2022 Be familiar with exponentiation. Computer science counting problems usually use\nextensive addition, multiplication, subtraction, and\/or division, which you should\nbe comfortable with. However, often the problems will also use exponentiation. If\nyou haven\u2019t used exponentiation recently, find an online tutorial (such as the one at\nlisted at the end of this chapter) and review the rules on how it works.\n\u2022 Be familiar with scientific notation. Computer science problems often involve very\nlarge numbers or very small numbers. These are often represented in scientific\nrepresentation format. For example the number 1.06 \u00d7 106, which has a mantissa\n1.06, andanexponent6, isanefficientwayofrepresenting1,060,000. Or\u22121.2\u00d710\u22126\nis a way of representing \u2212.0000012. If you are not familiar with scientific notation,\nlearn about it using an online resource such as the one listed at the end of this\nchapter.\n\u2022 Know when to do which types of operations (e.g., add vs. multiply). Noteinthethird\nproblem above you need to add together the number of passwords of each different\npossible length. However, the first two problems just require multiplication and\/or\ndivision.\n\u2022 Be familiar with different types of counting problems and the principles involved to\nsolve them. Some counting problems involve powers of two. Some involve ordered\nelements. Some involve unordered collections. Some allow items to be repeated.\nSome do not. Be familiar enough with the different types of problems that you\nknow which counting technique or techniques to apply to solve a problem.\n8.2.2 Example of Solving a Problem\nLet\u2019s solve the third problem above keeping these tips in mind. Here is the problem\nstatement again:\nHow many possible passwords are there where the password must be 8 or 9 characters\nlong, start with a lower case alphabetic character, and have as remaining characters any\nof 94 characters that consist of lower case alphabetic characters, upper case alphabetic\ncharacters, digits 0 \u2013 9, or any of 32 punctuation characters?\nMake sure you understand what the problem is asking. Think about what type of\nproblem this is, and what type of operations you will need to use to solve it. Note\nthat you can break the problem up into two subproblems \u2014 the number of 8 character\npasswords and the number of 9 character passwords. Does this help? Take a moment and\ndescribe what steps you would do to solve this problem before reading further. 8.2. SOLVING COUNTING PROBLEMS 143\nBreaking the count into an 8-character count and a 9-character count is useful. Specif-\nically, if you can calculate these two quantities, then we add them to get a solution. So\nfirst let\u2019s consider the number of passwords that are 8 characters long. One way to think\nof this problem is as a \u201cfill in the slots\u201d type of problem: there are 8 slots; the first must\nbe filled with any of the 26 lower case characters, and each remaining slot can be filled\nwith any of 94 characters. So the answer is 26\u00d794\u00d794\u00d7\u00b7\u00b7\u00b7\u00d794 = 26\u00d7947.\nSimilarly, the number of passwords that are 9 characters long is 26 \u00d7 948. So the\noverall answer is 26\u00d7(947 +948). This is a large number, about 1.6\u00d71017.\nBefore going on, let\u2019s consider the size of that number. Recall a billion is 109, a trillion\nis 1012, and a quadrillion is 1015. So the number of passwords in this problem is about\n160 quadrillion. This is good in this context \u2014 you want there to be a large number of\npasswords so that a malicious hacker trying random passwords or a \u201cbrute force\u201d\u2019 attack\ncannot discover your (or anyone else\u2019s) password.\nThere are other examples where the large numbers that result from counting problems\nare also useful. For example, how many different possible images are there are a certain\nsize? We don\u2019t want to \u201crun out\u201d of distinct icons to represent items, for instance. Or\nhow many different ways are there to combine musical notes to get a melody? Again, we\ndon\u2019t want to \u201crun out.\u201d\nBut there are also examples where the large number of possibilities is problematic. If\nwe need to do a task that processes every possibility, then we might need to perform a\nvery, very large number of calculations \u2014 perhaps so many that the task is not feasible,\nat least not using a brute force approach. For instance, suppose we are trying to decrypt\nmessages as part of a criminal investigation. Using a brute force approach on any mini-\nmally sophisticated type of encryption will not work in any reasonable amount of time.\nNext, let\u2019s return to the problem and look at two important variants:\na. Suppose (i) there is no restriction on the first character, and (ii) that characters\ncannot be repeated in the password.\nb. Suppose you want to count the number of ways to choose any 8 characters out of the\npossible 94. That is, (i) there is no restriction on the first character; (ii) characters\ncannot be repeated; (iii) order does not matter, for example \u2018ABCDEFGH\u2019 is the\nsame as \u2018HGFEDCBA\u2019.\nThese two variants illustrate common types of counting problems. Specifically, sometimes\nitems can be repeated and sometimes they cannot. And sometimes order matters and\nsometimes it does not. So two questions to ask yourself when solving counting problems\nare \u201cis repetition allowed?\u201d and \u201cdoes order matter?\u201d\nTo solve part (a), note it is still a \u201cfill in the slots\u201d problem. There are 8 slots, and 94\npossible choices for the first position. Once this position is filled, there are 93 remaining\nchoices for the second position, then 92 for the third, and so on. So the solution is\n94\u00d793\u00d792\u00d7\u00b7\u00b7\u00b787, or around 4.5\u00d71015. 144 CHAPTER 8. COMPUTER SCIENCE, NUMBERS, AND COUNTING\nPart (b) is a combination problem. The number of ways of choosing k distinct items\nfrom a group of n distinct items, when order does not matter, is n!\/(k!(n\u2212k)!). (Recall\nn! = n\u00d7(n\u22121)\u00d7(n\u22122)\u00d7\u00b7\u00b7\u00b7\u00d72\u00d71.) Some books use the shortened notation C(n,k)\nor (n) for this number. For this particular problem we are choosing 8 of 94 items, so the\nk\nanswer is 94!\/((8!)(86!)), which is about 1.1\u00d71011.\n8.2.3 Important Quantities\nIn previous chapters, such as in the data representation and the machine organization\nchapters, you saw some important terminology related to amounts of memory and to\nfractions of a second. For example, a GFLOP or gigaflop is 230, or roughly one billion,\nfloating point operations per second. Here are two tables you have seen previously. Figure\n8.1 lists important amounts of memory, and Figure 8.2 lists important fractions of a\nsecond.\nFigure 8.1: Some Important Memory Amounts\nAmount Power of Two Approximation\n1 kilobyte (KB) 210 bytes thousand bytes\n1 megabyte (MB) 220 bytes million bytes\n1 gigabyte (GB) 230 bytes billion bytes\n1 terabyte (TB) 240 bytes trillion bytes\n1 petabyte (PB) 250 bytes quadrillion bytes\n1 exabyte (EB) 260 bytes quintillion bytes\nFigure 8.2: Some Important Fractional Time Durations\nName Duration Duration (in words)\n1 millisecond (ms) 10\u22123 seconds one-thousandth of a second\n1 microsecond (\u00b5s) 10\u22126 seconds one-millionth of a second\n1 nanosecond (ns) 10\u22129 seconds one-billionth of a second\n1 picosecond (ps) 10\u221212 seconds one-trillionth of a second\n1 femtosecond (fs) 10\u221215 seconds one-quadrillionth second\nThere are still larger or smaller quantities of these types. For example, you can search\nonline for names of even larger memory sizes. 8.2. SOLVING COUNTING PROBLEMS 145\n8.2.4 A Useful Formula\nSuppose you are organizing a sports league that will have \u201cround robin\u201d play, that is,\nevery team will play every other team once. How many total games will there be if there\nare 10 teams in the league?\nOne way to solve this problem is to note the first team must play each of the other\nnine teams. The second team similarly also has to play each of the other nine teams, but\nyou\u2019ve already counted the game between the first team and second team. So there are\neight additional games involving the second team. Similarly there are seven additional\ngames involving the third team, and so on. The answer is therefore\n9+8+7+\u00b7\u00b7\u00b7+2+1 = 45.\nNext suppose that the following season the league expands to 12 teams. Now the\nnumber of games becomes\n11+10+9+\u00b7\u00b7\u00b7+2+1 = 66.\nThen suppose it expands to 16 teams, then to 18, etc. It would be useful to have a\ngeneral formula rather than having to add many numbers each time. In fact, there is such\na formula. Suppose you have n items, and want to count the number of different sets of\ntwo items. The formula is\nn\u22121\n(cid:88)\ni = (n\u22121)n\/2.\ni=1\nThe notation on the left means we are taking the sum of all i-values as i ranges between\n1 and n \u2212 1. So the formula states that the sum of the numbers between 1 and n \u2212 1,\ninclusive, equals (n\u22121)n\/2. In the original example above n = 10, and the formula yields\n(9\u00d710)\/2 = 45, which is the same number as obtained above. When n = 12 the formula\nyields (11 \u00d7 12)\/2 = 66, which again agrees with what we obtained above. And when\nn = 16 and then 18, we get (15\u00d716)\/2 = 120 and (17\u00d718)\/2 = 153, respectively.\nThis is a useful formula to remember since it comes up often in computer science\nand elsewhere: suppose you have n computers, each of which is connected to each other\ncomputer. How many connections are there? Suppose you have to check each item in a\nlist with each other item in a list to see if there are any duplicates. How many item-item\nchecks will you need to do? Suppose you want each person at a party to talk for at least\na minute with each other person. How many such conversations are there?6\n6One caution: note the sum is between 1 and n\u22121. If you are summing the first n integers \u2014 for\nexample, if you are counting connections between computers, but a computer can also be connected to\nitself \u2014 then you need to use the related formula\nn\n(cid:88)\ni=n(n+1)\/2.\ni=1 146 CHAPTER 8. COMPUTER SCIENCE, NUMBERS, AND COUNTING\n8.3 Example Problems\nThis section contains example problems.\nProblem 1: How many filenames are there that are six characters long, where the first\ncharactercanbeanyofthe52upperorlowercaseletters,andtheremainingfivecharacters\ncan be any upper case letter, lower case letter, or digit 0 \u2013 9?\nProblem 2: Suppose you have a 1000\u00d71000 image, with each pixel in the image repre-\nsented as a 24-bit color. The image is compressed 30:1.\n(a) Approximately how much memory does it take to store this image?\n(b) How long would it take to transmit this image over a 1Mpbs channel?\n(c) Suppose you had an algorithm that analyzed the image, using 9 floating point opera-\ntions for each pixel (in the uncompressed image). Suppose further that you are working\non a 2 GFLOPS computer. Approximately how long will it take the computer to do these\noperations?\nProblem 3: For each part below, set up the calculations, and then find the answer as a\nspecificnumber. Youmaygivelargenumbersasapproximationsratherthanastheirexact\nvalue. Additionally, classify the size of each numeric answer according to the following:\n\u2022 \u201csome\u201d: numbers less than one hundred.\n\u2022 \u201clarge\u201d: numbers greater than or equal to one hundred, but less than a million.\n\u2022 \u201ccolossal\u201d: numbers greater than or equal to a million, but less than a billion.\n\u2022 \u201cmammoth\u201d: numbers greater than or equal to a billion, but less than a trillion.\n\u2022 \u201cgargantuan\u201d: numbers greater than or equal to a trillion.\nSuppose you are investigating a computer crime. You have partial information, but\nare working on establishing a communication timeline for the suspect. You know the\nsuspect sent out 12 email messages during the time period you are investigating. Each\nemail message went to a single person (so no cc\u2019ing, etc.). However, because the suspect\nand his associates used anonymity tools you do not know which email messages were sent\nto whom when. Answer the following questions. Remember to classify your answers as\nmentioned above.\n(a) Suppose the suspect had 20 known associates, and each email message went to one of\nthese associates. How many ways are there to select 12 associates out of this group of 20\nif order matters and no associate received more than one email message?\n(b) How many ways are there in problem (a) if order does not matter and no associate\nreceived more than one email message? 8.4. PROBLEM SOLUTIONS 147\n(c) How many ways are there in problem (a) if order matters, but associates might have\nreceived more than one of the 12 email messages? (For example, it\u2019s possible all 12 went\nto a single associate.)\n(d) Suppose that due to new evidence you limit the suspect\u2019s list of associates to 15\npeople. Now how many possibilities are there if order matters and each email message\nwent to a different person?\n(e) Suppose you get still further new evidence: the first email went to associate X or\nassociate Y. The next 4 emails went to people from a group of 5 associates, but some\npeople in this group might have received more than one email message. The last 7 emails\nwent to 7 distinct people from a group of 10 associates. Assume order matters. How many\ndifferent possibilities are there?\n8.4 Problem Solutions\nSolution to Introductory Problem: Since there are 100 objects, each containing an\naverage of 100 triangles, each of which has 3 vertices, each of which has 3 coordinates,\neach of which takes 32 bits (which equals 4 bytes) to store, we get a total of\ntriangles vertices coordinates bytes\n100 objects \u00d7 100 \u00d73 \u00d7 3 \u00d74 .\nobject triangle vertex coordinate\nThis is 360,000 bytes, or approximately 360KB.\nSolution to Problem 1: Think of this as filling in six slots. There are 52 possibilities\nfor the first slot. Then there are 26+26+10 = 62 possibilities for the second, another\n62 possibilities for the third, another 62 for the fourth, etc. So there are 52\u00d762\u00d762\u00d7\n62\u00d762\u00d762 possibilities total. This equals 47,638,907,264, or about 47 billion.\nSolution to Problem 2:\n(a) The image size is\n(1000\u00d71000) pixels\u00d724 bits\/pixel\u00d7(1\/30)\/(8 bits\/byte) = 100,000 bytes\nor about 100KB.\n(b)Theansweris100,000 bytes\u00d7(8 bits\/byte)\/1,000,000 bps \u2248 .8 seconds.(Don\u2019tforget\nthe bytes to bits conversion.)\n(c) The image contains 1000\u00d71000 = 1 million pixels. So the answer is (1 million pixels\n\u00d7 9 floating point operations\/pixel)\/2 billion floating point operations per second. This\nsimplifies to 9\/2000 = .0045 seconds, or 4.5 milliseconds. 148 CHAPTER 8. COMPUTER SCIENCE, NUMBERS, AND COUNTING\nSolution to Problem 3:\n(a) 20\u00d719\u00d718\u00d7...9 or about 6 trillion (6\u00d71012). This is a gargantuan number.\n(b) This is a combination problem. The answer is C(20,12) = 20!\/(12!8!) = 125,970.\nThis is a large number.\n(c) This is 2012, which is about 4 quadrillion (4\u00d71015). This is a gargantuan number.\n(d) 15\u00d714\u00d713\u00d7...\u00d74, or about 220 billion (2.2\u00d71011). This is a mammoth number.\n(e) There are 2 possibilities for the first email, 54 for the next four, and 10\u00d79\u00d78\u00d7...\u00d74\nfor the last seven. Multiply all these together to get an answer of 756 million (7.56\u00d7108).\nThis is a colossal number.\n8.5 Additional Questions to Think About\nHere are questions to think about. We will explore some of these further in class.\n1. What does this topic tell us about the nature of computer science, and about what\ncomputer scientists and computer practitioners do?\n2. Whatdoesthistopictellusaboutmathematics: whatdoesitshowabouthowmath-\nematics is used in computer science, and what does it illustrate about mathematics\nitself?\n3. What does this topic tell us about society and technology: what does it tell us about\nboth computers and society, as well as about technology and society in general?\n4. Subsection8.1.4gaveoneexampleofhowcountingproblemsrelatetothetechnology\nand society theme in this class: that they are often used by businesses to figure out\nwhat is (or soon will be) feasible with computers. What other ways can you think\nof that counting problems relate to the technology and society theme?\n8.5.1 Some Further, Related Problems\nLet\u2019s use the introductory storage size problem to explore other related problems. You\nare invited to solve these problems on your own. No solutions are given here, so work\ncarefully and think about how to check if your answer is likely to be correct.\n1. Consider the following alternative storage scheme: suppose each object possessed\nabout 150 distinct triangle vertices. (Note multiple triangles can share a vertex,\nso the number of vertices is often significantly less than three times the number of\ntriangles.) The scheme consists of two tables. The first table has a row for each\nvertex, with the row having three columns: one for each coordinate. The second\ntable has a row for each triangle, with each row having three columns which hold\nthe indices of the triangle\u2019s vertices in the first table. An example mesh is shown in\nFigure 8.3, with the first table shown in Figure 8.4 and the second in Figure 8.5. 8.5. ADDITIONAL QUESTIONS TO THINK ABOUT 149\nFigure 8.3: A simple triangular mesh\nVertex 4 Vertex 5\n(0,100,0) (200,100,0)\n(cid:64) (cid:0)\n(cid:64) (cid:0)\n(cid:64) (cid:0)\n(cid:64) Triangle 2 (cid:0)\n(cid:64) (cid:0)\n(cid:64) (cid:0)\n(cid:64) (cid:0)\nTriangle 1 (cid:64) (cid:0) Triangle 3\n(cid:64) (cid:0)\n(cid:64)(cid:0)\nVertex 1 Vertex 2 Vertex 3\n(0,0,0) (100,0,0) (200,0,0)\nFigure 8.4: The Vertex Coordinate Table\nVertex Number x y z\n1 0.0 0.0 0.0\n2 100.0 0.0 0.0\n3 200.0 0.0 0.0\n4 0.0 100.0 0.0\n5 200.0 100.0 0.0\nFigure 8.5: The Triangle and Vertex Number Table\nTriangle Number First Vertex Index Second Vertex Index Third Vertex Index\n1 1 2 4\n2 2 5 4\n3 2 3 5 150 CHAPTER 8. COMPUTER SCIENCE, NUMBERS, AND COUNTING\n(a) How much less space does this file take than the original storage scheme?\n(b) How much space this alternative scheme saves is dependent on the quantities\nin the problem, for example, the number of triangles and number of distinct\nvertices. When is this alternative scheme likely to result in significant savings?\nWhen is it likely to result in only small savings?\n2. What other reasons \u2014 beyond storage space \u2014 might make one storage scheme\npreferable to the other?7\n8.6 Additional Resources\nHere are a few additional resources that might be useful:\n\u2022 http:\/\/www.mathsisfun.com\/index-notation-powers.html\u2014Math is Funpage\non scientific notation.\n\u2022 http:\/\/www.mathsisfun.com\/algebra\/exponent-laws.html\u2014Math is Funpage\non laws of exponentiation.\n7For a complicated problem there will be often be different ways to structure and store the data, and\neachwillhaveadvantagesanddisadvantages. Socomputerpractitionerswillneedtoweighthetrade-offs\nof each approach when deciding which to use. Chapter 9\nAlgorithmic Complexity\nDoes it scale?\n9.1 Introduction\n9.1.1 Introductory Problem\nSuppose you have a computer animation involving 100 different objects. As the animation\nprogresses the objects move, and for each frame in the animation the computer needs to\ndetect if any objects have collided. Assume further you have a check that computes if\ntwo given objects are colliding at the present time.1\nQuestions:2\n1. How many times will the computer need to perform this check for a frame in the\nanimation if you want to check each pair of objects?\n2. Suppose that you want a more complicated animation, so you create additional\nobjects and have 200 objects in your animation. Now how many times does the\ncomputer need to run the check?\n3. What is the ratio of the number of times in Question 1 to that in Question 2? For\nexample, does the number of times double?\n4. In general, suppose you have n objects in the scene. (a) What is the number of\ntimes you\u2019ll need to run the collision detection check? (b) How does this increase\nas n increases? For example, if n doubles, does the number of times double?\n1Whether any two given objects are colliding is itself a very interesting and complicated problem.\nFor example, if the objects are modeled as collections of triangles, then a straightforward approach is to\nintersect each triangle from the first object with each from the second. This can get complicated very\nquickly, and so computer animations often use a variety of clever techniques to make collision detection\nalgorithms more efficient.\n2Solutions are in Section 9.8.1 below.\n151 152 CHAPTER 9. ALGORITHMIC COMPLEXITY\n9.1.2 Overview and Motivation\nThere is more data being acquired, stored, and analyzed than ever before in human\nhistory. Astronomy data collected by telescopes, space probes, etc. tells us about the\nnature of the universe we inhabit. Government census data tells the government about\nits populace\u2019s characteristics: how many people live in the various states, counties, and\ncities? What are their occupations? What do age demographics look like? Business data\ntells companies who buys their products, whether there are seasonal fluctuation in certain\nproduct purchases, etc.\nOne key question in analyzing large data sets is \u201chow long will the operations take\nif the data set size increases?\u201d For example, suppose a company has a boom year, and\nits sales and number of customers both increase significantly, meaning their databases\nall become twice as large. Will the company be able to handle these larger databases\nwith their current resources \u2014 their database programs, number of computers, network\nconnections, etc.? And will the various database operations that the company does still\nbe doable in a reasonable amount of time?\nThe question \u201cDoes it scale?\u201d is therefore an important one. It is important in other\nareas of science and engineering (for example, chemical engineers take chemical reactions\nthatcanbedoneinalaboratory, andtrytoturnthemintofeasibleandefficientindustrial-\nscaleprocesses). Anditisimportanttocomputerscientistswhentheyanalyzealgorithms.\nA computational process that can be done for a small problem might or might not be\nfeasible for a large problem.\nThis chapter therefore explores algorithmic or computational complexity: how does\nthe number of operations an algorithm must perform grow as the problem size increases?\nSpecifically, this chapter explains how computer scientists measure algorithmic complex-\nity, looks further at why this is important, and provides examples of some of the types of\nproblems you should be able to do related to this topic.\n9.1.3 Further Explanation of Algorithmic Complexity\nAlgorithmic complexity is one way, indeed the primary way, that computer scientists\nmeasure algorithmic efficiency.3 Algorithmic complexity is not an exact measure of how\nlong an algorithm will take to run. In fact, there are many factors that make an exact\nrunning time difficult or impossible to measure. For example, the duration an algorithm\ntakes to solve a problem is affected by factors such as\n\u2022 how fast the computer running the program is;\n\u2022 how efficient the computer language used to implement the algorithm is;\n3Byalgorithmicorcomputationalcomplexitywemeantimecomplexity. Thereisanassociatedconcept\nofspace complexity,orhowtheamountofcomputermemoryanalgorithmusesgrowsastheproblemsize\nincreases. Spacecomplexitycanbeimportant,especiallyforalgorithmsworkingwithverylargeamounts\nof data. However, computer scientists are usually more concerned with time complexity, and so we will\nrestrict our attention to time complexity in this class. 9.1. INTRODUCTION 153\n\u2022 whether the computer is doing any other tasks at the same time it is running the\nalgorithm (e.g., is it also streaming music?);\n\u2022 the size of the input to the algorithm.\nOccasionally computer scientists or engineers will do \u201cbenchmark tests\u201d that check the\nraw time an implementation of an algorithm takes on specific test input under controlled\nconditions. However, more often they measure algorithm efficiency theoretically by study-\ning how the running time of the algorithm increases as the problem size increases. For\nexample, if the size of an input data set doubles, will the approximate time an algorithm\ntakes also double? Or will it increase by a factor of four? Or maybe eight? Or maybe\nmore?\nThere is a mathematical definition of algorithmic complexity. You are welcome to look\nit up if you are curious. Basically what it says is that for a sufficiently large problem size\nwe can get an upper bound (or \u201cbig-O\u201d complexity (pronounced \u201cbig-Oh\u201d)) or an upper\nand a lower bound (or \u201cbig-\u0398\u201d (pronounced \u201cbig Theta\u201d)) on the growth of the number\nof operations the algorithm takes. However, for the purposes of this class an intuitive\nunderstanding of what algorithmic complexity is and is not is sufficient.\nBefore looking at an intuitive description of complexity, let\u2019s consider three other fun-\ndamental questions: Why are computer scientists interested in growth for large problem\nsizes? What do we mean by a problem\u2019s \u201csize?\u201d And what does \u201csufficiently large\u201d mean\nanyway \u2014 is it 100? 1,000? 1,000,000?\nComputer scientists are interested in growth for large problem sizes for a few reasons,\nincluding:\n\u2022 Computers and algorithms are sufficiently fast that most small problems can be\nsolvedveryquickly, andsotherunningtimeforsmallproblemsoftendoesn\u2019tmatter.\n\u2022 For some problems, the amount of work done required increases dramatically as the\nproblem size increases. So even if these problems can be solved quickly for small\nproblem sizes, they might not be solvable in a reasonable amount of time for larger\nproblem sizes.\n\u2022 There are some truly large problems, and the amount of data scientists and others\nare gathering for these problems is increasing. Whether algorithms can handle\nthese large and growing data sets in a reasonable amount of time depends on the\nalgorithm\u2019s complexity.\n\u2022 Many cutting-edge applications nowadays work with large problem sizes.\n\u201cProblem size\u201d usually means the number of items in an algorithm\u2019s input. If you\nare measuring a sorting algorithm, the problem size is usually the number of items to be\nsorted.4 If you are calculating pay amounts and printing paychecks for all your employees,\n4Theword\u201cusually\u201disusedherebecausesometimestheproblemsizedependsonothercharacteristics\nof the data. For example, some sorting algorithms also depend on the maximum number of digits or\ncharacters in the items to sort. 154 CHAPTER 9. ALGORITHMIC COMPLEXITY\nit is usually the number of employees. If you are checking collisions between each pair of\nobjects in a graphics scene, it is usually the number of objects.\nWhat constitutes \u201csufficiently large\u201d varies from problem to problem. However, this\nturns out not to be a major concern for some of the same reasons as were just mentioned.\nFor example, as more and more data is gathered problem sizes grow, and so if a data set\nis not \u201csufficiently large\u201d now, it might be soon.\nIntuitively, computational or algorithmic complexity measures how the number of\noperations an algorithm performs grows as the problem size grows. And since the time\nan algorithm takes is closely related to the number of operations the algorithm performs,\nit is also a measure of how the time increases as the problem size does. For example, if\nan algorithm has \u201clinear\u201d complexity (see below) then if the problem size doubles, the\namount of time approximately doubles; if the problem size triples, the amount of time\napproximately triples; if the problem size increases by a factor of 10, then the amount of\ntime increases by about a factor of 10.\nIn addition to knowing what algorithmic complexity is, it is important to remember\nwhat it is not. It is not\n\u2022 an exact count of the running time or number of operations of an algorithm;\n\u2022 a measure of how the algorithm performs for small problem sizes;\n\u2022 a means of comparing two algorithms\u2019 running times on small data sets.\nWe\u2019ll explore examples of computing the algorithmic complexity of specific algorithms\nafter a few more preliminaries.\n9.1.4 Topic Goals\nAfter completing this section you should be able to do the following:\n1. Be able to explain what algorithmic complexity is, and why it is an important topic\nin computer science.\n2. Be able to explain how computer scientists measure algorithmic complexity. And\nbe able to explain what these techniques do and do not measure.\n3. Given a description of an algorithm, be able to calculate its complexity.\n9.1.5 Algorithmic Complexity and Mathematics\nAlgorithmic complexity is related to counting problems. Calculating the complexity often\nrequires counting operations. However, unlike many counting problems where the answer\nis a specific number, in complexity the answer is a function. In particular, the answer is a\nfunction of the problem size. Once you have found this function, algorithmic complexity 9.2. HOW TO MEASURE ALGORITHMIC COMPLEXITY? 155\nasks how quickly the functions grows. So algorithmic complexity, at least in its funda-\nmental form, involves two subareas of mathematics: counting problems and analyzing\nfunction behavior.\n9.1.6 Algorithmic Complexity and Technology and Society\nAs mentioned above, humans are gathering more data than ever before in human history.\nWhat we can do with these increasing amounts of data is dependent on how algorithms\nscale. If you increase a dataset size by a factor of 10 and a computational task goes from\ntaking one hour to ten hours, then it is probably still doable \u2014 you just need to wait\nlonger for the result (or get a faster computer, etc.). If the task goes from taking one hour\nto one thousand hours, then you might or might not have the time and other resources\nneeded. If a task goes from one hour to one trillion hours, then you probably will not get\nan answer in your lifetime.\nMany of the most interesting problems in computer science, in science and engineer-\ning, in biology and medicine, and elsewhere involve large amounts of data. Organizations\nthat are dealing with these issues are not only bodies such as NASA working with space\nexploration data, but also many companies, government bodies, and other organizations\nworking with business, social, or other data. For example, two computer-related com-\npanies for whom issues of scale are a constant concern are Google and Facebook, both\nof which store, process, and transmit massive amount of data for truly large numbers of\nusers.\n9.2 How To Measure Algorithmic Complexity?\n9.2.1 Big-O and Big-\u0398\nComputer scientists often use big-O or big-\u0398 notation to indicate an algorithm\u2019s com-\nplexity. Big-O provides an upper bound on growth. If an algorithm is O(n2) (pronounced\n\u201cbig Oh of n squared\u201d), the algorithm\u2019s time will, when a sufficiently large problem size\nis doubled, take at most about four times as long. Note this provides an upper bound \u2014\nthat is, an at most bound. It\u2019s possible, for example, that the algorithm might only take\ntwice as long.\nBig-\u0398 is more precise, and provides both an upper and a lower bound. If a sufficiently\nlargeproblemsizeisdoubled, a\u0398(n2)algorithmwilltakeaboutfourtimesaslong. Thisis\npronounced as \u201cbig Theta of n squared\u201d and is also called \u201corder n squared\u201d or quadratic\ncomplexity.\nTo complicate matters further, computer scientists sometimes distinguish between best\ncase, average case, and worst case complexity. Suppose you are searching for a specific\nemployeeaddressinalistofnaddresses. Itmightbethefirstaddress, inwhichcaseyou\u2019re\ndone once you checked the first item. So in this case you checked a constant number of\nitems, and the best case complexity is \u0398(1). It might be the last item, in which case 156 CHAPTER 9. ALGORITHMIC COMPLEXITY\nyou\u2019ve checked all n items. So the worst case complexity is \u0398(n). The average complexity\nis more difficult. Let\u2019s assume the desired address is equally likely to be at any position\nin the list. So the chance of it being in any particular place is 1\/n. The number of items\nchecked will be 1 if the item is in the first location, or 2 if it is in the second location, and\nso on. So the average number of comparisons is (1\u00d71\/n)+(2\u00d71\/n)+...+(n\u00d71\/n).\nThis sum turns out to be (n+1)\/2. Note that although the number of checks is about\nhalf as many as in the worst case, the number of operations still grows proportional to n,\nand so is still \u0398(n). (See the subsection below for why computer scientists write this as\n\u0398(n) rather than as \u0398((n+1)\/2).)\nFor many problems we look at in this class the best case, worst case, and average case\ncomplexity will all be the same. For those problems where they are not, assume \u2014 unless\notherwise specified \u2014 that we are interested in worst case complexity.\nThe list below explains common orders of growth. Many of the functions involved also\nappear in Table 9.1. The columns in that table represent different functions, the rows\ndifferent problem sizes. Note the problem sizes double, from 10 to 20, then to 40, then to\n80.\nFigure 9.1: The growth of some functions\n1 lg(n) n nlg(n) n2 n3 2n n!\nn = 10 1 3.3 10 33 100 1000 1024 3.6\u00d7106\nn = 20 1 4.3 20 86 400 8000 1.0\u00d7106 2.4\u00d71018\nn = 40 1 5.3 40 213 1600 64000 1.1\u00d71012 18.2\u00d71047\nn = 80 1 6.3 80 506 6400 512000 1.2\u00d71024 7.2\u00d710118\n\u2022 \u0398(1) or constant complexity: the algorithm time is roughly the same regardless of\nproblem size. This is very nice, but also very rare.\n\u2022 \u0398(lg n) or logarithmic complexity: the algorithm time grows a constant amount\nif the problem size doubles. This is a very slow rate of growth. An example of a\nlogarithmic complexity algorithm is binary search, which is an efficient searching\nalgorithm. (See the section below on logarithms for more information on the lg\nfunction.)\n\u2022 \u0398(n) or linear complexity: the algorithm time grows proportional to the growth\nin the problem size. For example, if the problem size doubles the algorithm takes\nroughly two times as long, if it triples the algorithm takes roughly three times as\nlong. If it increases by a factor of ten the algorithm takes roughly ten times as long.\n\u2022 \u0398(n lg n) complexity: the algorithm time grows slightly more than linearly. So if\nthe problem size doubles, the algorithm takes slightly more than twice as long. An\nexample of an order n lg n algorithm is an efficient sort such as mergesort. 9.2. HOW TO MEASURE ALGORITHMIC COMPLEXITY? 157\n\u2022 \u0398(n2) or quadratic complexity: the algorithm time grows proportional to the square\nof the growth in the problem size; if the problem size doubles the algorithm takes\nroughly 22 = 4 times as long. If the problem size increases by a factor of 10 then\nthe algorithm takes roughly 102 = 100 times as long. A less efficient sort such as\nbubble sort has quadratic complexity.\n\u2022 \u0398(n3) or cubic complexity: the algorithm time grows proportional to the cube of\nthe growth in the problem size; if the problem size doubles the algorithm takes\nroughly 23 = 8 times as long. If the problem size increases tenfold the algorithm\ntakes roughly 103 = 1000 times as long.\n\u2022 \u0398(2n)orexponentialcomplexity: thealgorithmtimegrowsbyafactorofroughly2if\nproblem size increases by one. It is impossible to solve large exponential complexity\nproblems exactly in a reasonable amount of time.\n\u2022 \u0398(n!) or factorial complexity: the algorithm time grows by a factor of n as the\nproblem size increases from n\u22121 to n. An example of a factorial time complexity\nproblem is the traveling salesman problem described below. Factorial complexity\nproblems grow even more quickly than exponential complexity problems, and so\nthey are also impossible to solve exactly in a reasonable amount of time.\n9.2.2 Simplifying Big-O and Big-\u0398 notation\nSuppose you are working for a company that is having you cross-check customer accounts.\nYou compute the complexity of the cross-checking algorithm and find that for an input\nlist of n accounts the algorithm performs n3+5n+2 operations. Should you say that the\nalgorithm has \u0398(n3 +5n+2) time complexity?\nIf you said that to a computer scientist, he or she would say you were correct, but\nwere using the terminology oddly. To see why this is so, let\u2019s examine what happens\nas the function f(n) = n3 + 5n + 2 grows. For example, let\u2019s compare the value of\nf(100) with the value of f(200). When n = 100, the value of f is 1003 + 5(100) + 2 =\n1,000,502. Notice this is not far from 1003 = 1,000,000. When n = 200, the value\nof f is 2003 + 5(200) + 2 = 8,001,002. Notice this is not far from 2003 = 8,000,000.\nMoreover, notice the ratio f(200)\/f(100) = 7.9969... is approximately 8. That is, when\nthe problem size doubles from 100 to 200, the number of operations increases by a factor\nof almost 8, which is characteristic of \u0398(n3) complexity.\nThis analysis is a strong indication (although not a rigorous proof) that n3 +5n+2\nis \u0398(n3). And in fact, when working with polynomials, we can drop the \u201clower order\nterms\u201d \u2014 that is, all terms other than the one with the highest exponent. So n3+5n+2\nis indeed \u0398(n3). As another example, n5+6n4\u221212n2+23 is \u0398(n5). The reason for this\nsimplification is that as n increases the highest order term \u2014 the term with the highest\nexponent \u2014 affects the function the most. 158 CHAPTER 9. ALGORITHMIC COMPLEXITY\nIn summary, rather than saying that an algorithm that takes n3 +5n+2 operations\nhas \u0398(n3 +5n+2) complexity, a computer scientist would say it has \u0398(n3) complexity.\nThis focuses on what part of the function is dominating the growth as n gets large.\nThere is one more simplification when working with big-O and big-\u0398 notation. Con-\nsider the function 7n3 +5n+2. We\u2019ve already seen that we wouldn\u2019t include the 5n+2\nwhen reporting the complexity. So would we say this function is \u0398(7n3)? Again, com-\nputer scientists would simplify this: the lead constant 7 does not affect the growth, so\nthe complexity is \u0398(n3). Again, \u0398(7n3) is not, strictly speaking, incorrect, but it doesn\u2019t\nfocus on the fact that n3 is driving the function growth, and that the constant 7 is a\n\u201cbystander.\u201d\nTo explore this further, evaluate 7n3 at n = 100 to get 7,000,000. Next, evaluate 7n3\nat n = 200. This gives 56,000,000, or 8 times as much. This is exactly the same ratio\nthat we get when we take the ratio 2003\/1003. Or let\u2019s derive the ratio in another way:\n7(2003) 2003 8000000\n= = = 8.\n7(1003) 1003 1000000\nIn particular, notice that the 7\u2019s cancel, and so they do not affect the growth.\nAs a summary example, suppose we found an algorithm took 5n4 +16n3 \u22122n2 +42\noperations. We\u2019d simplify this by dropping the lower order terms. This would leave the\nhighest order term, 5n4. We would then drop the constant 5, and would say the algorithm\nhas \u0398(n4) complexity.\n9.3 Logarithms\nLogarithms are mathematical functions that are very important in a number of fields,\nincluding computer science. One way to understand logarithms is as inverses of expo-\nnentiation. Recall that Moore\u2019s Law involves transistor density doubling every two years.\nThis leads to exponential growth. To \u201cundo\u201d exponential growth you use logarithms.\nHere\u2019s a quick example. Suppose you had a database whose size doubled every year.\nSuppose it started at 3MB in size, and you wanted to know how large it was after four\nyears. Then you would double 3MB, then double the result, then double that result, and\ndouble that result. Equivalently, you could compute 3\u00d724 = 3\u00d716 = 48MB.\nNow consider a related problem. Suppose you start with a 3MB database, and know\nit doubles in size every year. How many years does it take until it is 48MB in size?\nForget for the moment that you know, from the previous paragraph, that the answer is\nfour years. To solve this problem you could count the number of doublings needed to get\n48MB: the first doubling gives 6MB, the second 12MB, the third 24MB, and the fourth\n48MB.\nEquivalently, you could write the equation 3 \u00d7 2t = 48 where t is the number of\ndoublings needed. Note this is not the type of equation we are used to solving since the\nunknown t is an exponent. To transform this into an easier-to-work-with form, you can 9.3. LOGARITHMS 159\ntake the logarithm of both sides. You might recall there are different type of logarithms,\nsuchascommonlogarithms(base10)andnaturallogarithms(basee,whichis2.71828...).\nComputer scientists most often use logarithms base 2, which is written as lg. Specifically,\nthe function lgx is the number that 2 needs to be raised to in order to get x. This can\nbe a somewhat confusing definition, but it is useful to consider logarithms of powers of\n2: since 20 = 1, we have lg1 = 0. Since 21 = 2, we have lg2 = 1. Since 22 = 4, we have\nlg4 = 2. And in general lg2n = n.\nBefore we proceed further, let us examine the lg function\u2019s characteristics. The lg\nfunction grows very slowly: see Table 9.2 for some representative values. There are also\nFigure 9.2: The lg function\nn lg n (approx.)\n10 3.32\n100 6.64\n1,000 9.97\n10,000 13.28\n100,000 16.61\n1,000,000 19.93\nsome properties that are useful when manipulating logarithms:\nlg2x = x\nlgax = xlga\nlg(ab) = (lga)+(lgb)\nlg(a\/b) = (lga)\u2212(lgb)\nSo let\u2019s return to the problem. We now take the equation 3\u00d72t = 48. We then take\nthe lg of each side, and use the properties of logarithms:\nlg(3\u00d72t) = lg48\nlg3+lg2t = lg48\nlg2t = lg48\u2212log3\nt lg2 = lg(48\/3)\nt = lg16\nt = lg24\nt = 4.\nOf course not all problems will turn out so neatly. Sometimes you\u2019ll need to work with a\nquantity such as, say, lg73. To compute this you can use a calculator. If you can\u2019t find a 160 CHAPTER 9. ALGORITHMIC COMPLEXITY\ncalculator with a lg function, you can use the following identity where log is the common\nlog, i.e., log base 10:\nlgx = logx\/log2 \u2248 logx\/.301.\n(The \u2248 sign here means \u201capproximately equal to.\u201d) However, another very useful skill is\nbeing able to estimate lg values without using a calculator. This is where knowing powers\nof 2 is useful. What power(s) of 2 is 73 close to? It is between 26 = 64 and 27 = 128, and\ncloser to the former than the latter. So lg73 is slightly more than 6.\nLogarithms are useful not only in some computations, but also in the rate of growth\nof algorithms. For example, one famous search algorithm is binary search, whose rate\nof growth is \u0398(lgn). And some sorting algorithms are \u0398(nlgn). As n gets at all large,\nthese algorithms grow significantly more slowly than alternative \u0398(n) search and \u0398(n2)\nsort algorithms. See Table 9.3, and note that the contrasts apparent there become more\npronounced as n gets even larger.\nFigure 9.3: Comparison of some rates of growth\nlg n n n lg n n2\n1 2 2 4\n2 4 8 16\n3 8 24 64\n4 16 64 256\n5 32 160 1024\n6 64 384 4096\n7 128 896 16384\n9.4 Calculating Complexities\nOne useful skill for computer scientists and software developers is to be able to analyze\na given algorithm\u2019s complexity. Computing the complexity of complicated algorithms\ncan be difficult. However, calculating the complexity of simpler algorithms is a task you\nshould be able to do. This section contains a few simple algorithms along with derivations\nof their complexity.\nExample 1\n1 Set sum = 0\n2 For i = 1 to n\n3 For j = 1 to n\n4 Set sum = sum + a[i,j]\n5 Print sum\n6 Stop 9.4. CALCULATING COMPLEXITIES 161\nNotice that this algorithm contains a double loop. How often is the Set sum operation\ndone? Note that the i loop is executed n times, once for each of the values between 1 and\nn, and each time the i loop is executed the j loop is executed n times. So the total number\nof times is n \u00d7 n = n2. Notice this is the most performed operation in the algorithm.\nSetting sum to 0 is done only once, as is printing the sum. (In the subsequent examples\nbelow we won\u2019t mention operations like these that are performed so few times they do\nnot affect the final complexity.) So the dominant term in the operation count is n2, and\nthis is a \u0398(n2) algorithm.\nExample 2\n1 Set sum = 0\n2 For i = 1 to n\n3 For j = 1 to n\n4 For k = 1 to n\n5 Set sum = sum + a[i,j,k]\n6 For i = 1 to n\n7 For j = 1 to 10\n8 Set sum = sum + b[i,j]\n9 Print sum\n10 Stop\nHere the outer loop starting at line 2 is executed n times, the middle loop starting at\nline 3 is executed n times, and the inner loop starting at line 4 is executed n times. So\nthis triple loop updates sum in line 5 a total of n\u00d7n\u00d7n, or n3 times. Then the outer loop\nstarting at line 6 is executed n times and the inner loop starting at line 7 is executed 10\ntimes, and so sum is updated n\u00d710, or 10n times in line 8. The total number of updates\nis therefore n3 +10n. Since as n gets large n3 dominates 10n, this is written as \u0398(n3).\nExample 3\n1 Set sum = 0\n2 Set i = 1\n3 While i <= n\n4 Set sum = sum + i\n5 Set i = i * 2\n6 Print sum\n7 Stop\nThis one is more difficult. Let\u2019s look at a particular value of n. Suppose n is 77. Then\nwhat values does i assume? It starts at 1, then goes to 2, then to 4, then to 8, 16, 32,\n64, and finally 128. For a general n, the loop will be executed until the doubling process\nproduces an i-value greater than n. Let k be the number of times i is doubled until it\nis greater than n. So k is the least integer such that 2k > n. This number is essentially\nlgn: recall lg is the logarithm base two, and lgx is the exponent you need to raise 2 to\nin order to get x. So the algorithm\u2019s complexity is \u0398(lgn). 162 CHAPTER 9. ALGORITHMIC COMPLEXITY\n9.5 Additional Example Problems\nHere are a number of additional example problems involving complexity. Solutions are in\nthe problem answer section below.\nExample Problem 1\nSuppose you are searching through an n-row, n-column, n-depth set of geological data.\nGive a big-\u0398 time complexity for each of the following algorithms. Assume op1, op2, and\nop3 all take constant time.\nRemember to show your work or explain your answers. Also, write your big-\u0398 answer as\nsimply as possible. For example, instead of writing \u0398(2n2 +4n) write \u0398(n2) since big-\u0398\nestimates are irregardless of lower order terms (so the 4n is not needed), and multiplying\nfactors (so the 2 in 2n2 is not needed).\n(a)\n1 for row = 1 to n\n2 for col = 1 to n\n3 for depth = 1 to n\n4 do op1\n5 for row = 1 to n\n6 for col = 1 to n\n7 do op2\n8 stop\n(b)\n1 for row = 1 to n\n2 for col = 1 to 3\n3 for depth = 1 to 3\n4 do op1\n5 for row = 1 to n\n6 for col = 1 to n\n7 do op2\n8 stop 9.5. ADDITIONAL EXAMPLE PROBLEMS 163\n(c)\n1 for row = 1 to n\n2 for col = 1 to 3\n3 for depth = 1 to n\n4 do op1\n5 for row = 1 to n\n6 for col = 1 to n\n7 do op2\n8 for row = 1 to n\n9 for col = 1 to n\n10 do op3\n11 stop\n(d)\n1 for row = 1 to n\n2 for col = 1 to n\n3 depth = 1\n4 while depth <= n\n5 do op1\n6 depth = depth * 2\n7 for row = 1 to n\n8 for col = 1 to n\n9 do op2\n10 stop\nExample Problem 2\n(a) Suppose you are doing public health research studying diabetes. You have a database\nconsisting of 10,000 records, and have a \u0398(n2) program (where n is the number of records)\nlooking for correlations in the data. Suppose that when you run the program on your\ncomputer it takes about 7 minutes to finish.\n(a) Suppose that you get additional records so that the database size becomes 20,000\nrecords. Now about how long will it take to run the program?\n(b) Suppose a colleague asks you to run your program for a database she has that has\n100,000 records. Now about how long will it take to run the program?\n(c) Suppose you have 20 databases, each of 10,000 records. You run the program on the\nfirst of these, then immediately after it is done you run it on the second, and so forth\nuntil the program has been run on all 20 databases. About how long will this take?\n(d) Which takes less time: running the program on 20 databases each with 10,000 records,\nor running it on a single database with 100,000 records?\n(e)Supposeacoworkerwithprogrammingandalgorithmexperienceclaimshecanimprove\nyour algorithm. You run the program on your 10,000 record database and it now takes 9 164 CHAPTER 9. ALGORITHMIC COMPLEXITY\nminutes. Moreover, due to a mistake the coworker made, the program now is \u0398(n3). Now\nabout how long will it take if you run the algorithm on the 100,000 record database?\n(f) Going back to the \u0398(n2) algorithm that takes 7 minutes on a database of 10,000\nrecords: suppose you increase the database size by a factor of 5, so you have a database\nof 50,000 records. But you also get a computer that is 5 times as fast. How long will it\ntake your program to run using the new computer on the 50,000 record database?\nExample Problem 3:\nAbrupt changes in adjacent data values often indicate something significant in the data.\nFor example, in MRI data a large difference might indicate a transition between different\ntissue types, say bone and muscle. Or in a geologic data set a large difference might\nindicate the transition from one rock formation to another.\nThe following algorithm goes through an n-row, n-column, n-depth data set, and checks\nif there is a large difference between a data value and the next data value in the same\ncolumn and at the same depth (so it is checking for differences in one direction, but not\nall directions). In the pseudocode below abs refers to the absolute value function. So, for\nexample abs(-5) returns 5.\nInput: an n-row, n-column, n-depth data set of numbers, along with a positive number\nthreshold.\nOutput: a message \u201cLarge difference found\u201d if any value differs from the next value in the\nsame column and same depth by more than threshold, and a message \u201cNo large difference\nfound\u201d otherwise.\n1 Get threshold, the size n, and the data set\n2 Set i = 1\n3 Set sigDiffFound = false\n4 While i < n and sigDiffFound equals false\n5 Set j = 1\n6 While j <= n and sigDiffFound equals false\n7 Set k = 1\n8 While k <= n and sigDiffFound equals false\n9 If abs(a[i,j,k] - a[i+1,j,k]) > threshold\n10 Set sigDiffFound = true\n11 Set k = k + 1\n12 Set j = j + 1\n13 Set i = i + 1\n14 If sigDiffFound equals true\n15 Print \u2018Large difference found\u2019\n16 Else\n17 Print \u2018No large difference found\u2019\n18 Stop 9.6. THE TRAVELING SALESMAN PROBLEM 165\nNow answer the following questions. In each part do not make any assumptions on\nthe value of n, so your answer might be a function of n. However, write your answer as\na number or as a function of n and not, for example, as a big-\u0398 estimate.\n(a) What is the fewest number of times Line 9 is executed?\n(b) What is the largest number of times Line 9 is executed?\n(c) Suppose the number of rows, column, and depths all increased from n to 2n. What is\nthe ratio of the fewest number of times Line 9 is executed in this case to the number of\ntimes in your answer for part (a)?\n(d) Suppose the number of rows, column, and depths all increased from n to 2n. What\nis the ratio of the largest number of times Line 9 is executed in this case to the number\nof times in your answer for part (b)?\n9.6 The Traveling Salesman Problem\nAretherereallyproblemsthatgrowextremelyrapidly, sorapidlythattheycan\u2019tbesolved\nin a reasonable amount of time? The answer is emphatically yes.\nIn some cases a problem takes a large amount of time because the underlying data set\nis so large. For example a wind tunnel simulation in aerospace research might involve a\nlarge number of variables at a large number of points over a large number of time steps.\nOr a genomic research problem might involve searching millions of DNA sequences. On\nthe other hand, some problems are difficult because the number of computations needed\ngrows very quickly, even if the data set involved is small. The traveling salesman problem\nis a canonical example of a problem whose complexity grows so quickly it cannot be solved\nfor large n.\nIn the traveling salesman problem, a salesman needs to visit n cities, visiting each city\nexactly once. The salesman can choose which city to start with, then which of the other\ncities to visit next, then which of the remaining cities to visit after that, and so on until\nhe or she visits all the cities. In addition to the set of cities, the problem also specifies\nthe distance5 between each pair of cities. The traveling salesman problem is to find which\norder of visiting the cities will result in a path of least total distance.\nBecause there are n choices for the starting city, then n\u22121 for the next city to visit,\nand so on, the number of possibilities is n\u00d7(n\u22121)\u00d7(n\u22122)\u00d7...\u00d73\u00d72\u00d71 = n!. Recall\nn! grows very quickly \u2014 for example 10! is over 3 million. And so checking all possible\npaths to compute an exact solution to the traveling salesman problem is impractical when\nn is at all large.\nThe traveling salesman problem is not an isolated problem. There are many other\nproblems that share the traveling salesman problem\u2019s rapid growth.\n5Variants of the problem replace distance with travel time, or cost, or some other quantity. The key\npoint is that there is some positive number associated with each pair of cities. 166 CHAPTER 9. ALGORITHMIC COMPLEXITY\n9.7 What If a Problem Takes Too Long To Solve?\nSuppose you have a computational problem that takes too long for a single computer to\nsolve. However, it is an important enough problem that you really, really would like an\nanswer. How can you solve it? There are a variety of different techniques that might help.\nOne possibility is to run the problem on a faster computer, assuming you have access\nto one. This approach will only work to some extent. For example, if a problem scales\nlinearly then \u2014 if all other things are equal \u2014 a computer that is twice as fast will allow\nyou to solve a problem in half the time. However, if a problem scales exponentially then\na computer that is twice as fast will not be much help.\nAnother possibility is to use a computer that can do many operations simultaneously.\nSome computers have many processors that can work in parallel. For instance, supercom-\nputers used to perform large science and engineering simulations might have thousands\nof processors. Lately even personal computers have gone to multiple processors, such as\n\u201cquadcore\u201d or four-processor computers.\nHowever, not all problems can be distributed efficiently among multiple processors.\nMoreover, even if a problem is amenable to a parallel approach the speed-up still might\nnot be enough to solve the problem.\nStill another approach is distributed computing. Instead of distributing a problem\nover different processors on a single computer, the problem is distributed over different\ncomputers. For example, a company such as Pixar that makes computer-animated films\nuses hundreds of computers to do the computations needed to produce a film such as Toy\nStoryorBrave. Asanotherexample,thecomputationsforprogramssuchasSETI@home6\n(search for extraterrestrial intelligence) is distributed to many computers, including many\nvolunteers\u2019 personal computers. Like the previous approaches, distributed computing\nworks for some problems, but not all.\nStillanotherpossibilityistouseanotheralgorithm. Onetasksomecomputerscientists\ndo is to devise efficient algorithms to solve new problems, or to try to devise better\nalgorithms (or improve known algorithms) to solve existing problems. However, it might\nbe the case there isn\u2019t a more efficient algorithm.\nIn summary, there are a number of techniques that can be used to try to solve time-\nconsuming problems. Often additional computational power, additional computers, or a\nbetter algorithm (if one exists) can solve the problem. But not always. There are some\nproblems, such as the traveling salesman problem, that by their very nature cannot be\nsolved exactly for large values of n in a reasonable amount of time.7\n6See http:\/\/setiathome.berkeley.edu\/\n7Still another approach is to obtain an approximate, rather than exact, solution. There are some\nproblems that are impossible to solve exactly in a reasonable amount of time, but which have efficient\nalgorithms that will provide an approximate answer (or an answer that is likely, but not guaranteed, to\nbe correct or close to correct). 9.8. PROBLEM SOLUTIONS 167\n9.8 Problem Solutions\n9.8.1 Introductory Problem Solutions\nHere are model solutions to the questions at the start of this chapter.\n1. Each item must be checked against each other item. So the first object would be\nchecked against 99 others (note each object does not need to be checked against\nitself), the second against 98 others (since it\u2019s already been checked against the\nfirst), the third against 97 others, and so on until we have the sum\n99\n(cid:88)\n99+98+97+96+...+3+2+1 = i.\ni=1\nNote this is a type of sum discussed in the last chapter on counting. In particular,\nusing the formula (cid:80)n\u22121i = (n\u22121)n\/2 gives 99(100)\/2 = 4950.\ni=1\n2. Thisissimilartothepreviousquestionexceptthesumisnow(cid:80)199 i = 199(200)\/2 =\ni=1\n19,900.\n3. The ratio is 19900\/4950, or roughly 4.\n4. (a) Analogous to the explanation in Problem 1, the answer is\nn\u22121\n(cid:88)\n(n\u22121)+(n\u22122)+(n\u22123)+...+3+2+1 = i = (n\u22121)n\/2.\ni=1\n(b) If you double n, the number of times is (2n\u22121)(2n)\/2 (just substitute 2n for n\nin the part (a) answer). So the ratio is\n(2n\u22121)(2n)\/2 (2n\u22121)(2)\n= .\n(n\u22121)n\/2 n\u22121\nNotice that this is roughly 4.\nHere are two additional problems to think about:\n\u2022 Suppose that in Problem 4b that n triples instead of doubles. What would the\nanswer be then? How about if it increases by a factor of 10?\n\u2022 Explain in Problems 3 and 4 why computer scientists would be more interested in\nthe approximate answer (\u201croughly 4\u201d) rather than the exact answer. 168 CHAPTER 9. ALGORITHMIC COMPLEXITY\n9.8.2 Example Problem Solutions\nHere are solutions to the example problems from Section 9.5.\n1. (a) In lines 1 \u2013 4 the outer loop is executed n times, as is the middle loop and the\ninner loop. Since these loops are nested, the number of operations is n3. In lines\n5 \u2013 7 both the outer loop and inner loop are executed n times, for a total of n2\noperations. Since the loops in lines 5 \u2013 7 are executed after the loops in lines 1 \u2013\n4 are completed, the total number of operations is n3 + n2. Since n3 grows more\nquickly than n2, this is written as \u0398(n3).\n(b) In lines 1 \u2013 4 the outer loop is executed n times, and the middle loop and the\ninner loop are each executed 3 times. Since these loops are nested, the number of\noperations is 9n. In lines 5 \u2013 7 both the outer loop and inner loop are executed n\ntimes, for a total of n2 operations. Since the loops in lines 5 \u2013 7 are executed after\nthe loops in lines 1 \u2013 4 are completed, the total number of operations is 9n + n2.\nSince n2 grows more quickly than 9n, this is written as \u0398(n2).\n(c) In lines 1 \u2013 4 the outer and inner loops are executed n times, and the middle\nloop is executed 3 times. Since these loops are nested, the number of operations\nis 3n2. In lines 5 \u2013 7 both the outer loop and inner loop are executed n times, for\na total of n2 operations. In lines 8 \u2013 10 the outer and inner loops are also both\nexecuted n times each, for a total of n2 operations. Since the loops in lines 1 \u2013 4\nare executed first, then the loops in lines 5 \u2013 7 are executed, then the loops in lines\n8 \u2013 10 are executed, the total number of operations is 3n2 +n2 +n2 = 5n2. This is\nwritten as \u0398(n2).\n(d) In lines 1 \u2013 6 the outer loop and middle loop are each executed n times. As\ndiscussed in Section 9.4, the inner loop is executed lgn times. Since these loops are\nnested, the number of operations is n2lgn. In lines 7 \u2013 9 both the outer loop and\ninner loop are executed n times, for a total of n2 operations. Since the loops in lines\n7 \u2013 9 are executed after the loops in lines 1 \u2013 6 are completed, the total number of\noperations is n2lgn+n2. Since n2lgn grows more quickly than n2, this is written\nas \u0398(n2lgn).\n2. (a) Since the algorithm is \u0398(n2), when the problem size doubles the time needed will\nincrease by a factor of roughly 22 = 4. So the program would take about 4\u00d77 = 28\nminutes to run.\n(b) When the problem size increases tenfold, the time needed increases by a factor\nof roughly 102 = 100. So the program would take about 100\u00d77 = 700 minutes to\nrun.\n(c) Note here the problem size for each database is not increasing. Instead you are\nrunning the program on 20 same size databases. So the total time is 20\u00d77 = 140 9.9. SOME FURTHER QUESTIONS 169\nminutes. (Make sure you can explain why the answer is 20\u00d77 = 140 minutes rather\nthan 202 \u00d77 = 2800 minutes.)\n(d) Running the program on 20 databases each of 10,000 records takes considerably\nless time.\n(e) The original time is 9 minutes and the problem size has increased tenfold. Since\nthe algorithm is now \u0398(n3), a tenfold increase in problem size means roughly a\n103 = 1000 increase in time. So the total time is roughly 9000 minutes, which is six\nand a quarter days.\n(f) The problem size increases by a factor of 5, so the time would increase by 52 = 25\ndue to this. However, the computer speed increase would decrease the time by a\nfactor of 5. So the total time would be roughly (52 \u00d7 7)\/5 = 35 minutes. (Make\nsure you can explain why the time is 35 minutes rather than 7 minutes.)\n3. (a) In the case where a large difference is found between a[1,1,1] and a[2,1,1], Line\n9 is executed only once.\n(b) It is possible for the algorithm to run all the way through the triple loops. This\nwill happen if no large difference is found, or if a large difference is found on the\nfinal comparison. In either case, the outer loop is executed n\u22121 times (note that\nloop goes from 1 to n\u22121 because of the i+1 in Line 9), the middle loop n times,\nand the inner loop n times. So the total is (n\u22121)(n)(n) = n3 \u2212n2.\n(c) The fewest number of times is still 1, so the ratio is 1\/1 = 1.\n(d) Now the outer loop is executed 2n \u2212 1 times, the middle loop 2n times, and\nthe inner loop also 2n times. So the total number of times is (2n \u2212 1)(2n)(2n) =\n8n3 \u22124n2. The ratio is therefore (8n3 \u22124n2)\/(n3 \u2212n2), or roughly 8.\n9.9 Some Further Questions\nHere are some further questions to think about:\n1. What does the topic of algorithmic complexity tell us about computer science as a\nfield? About how computer scientists think, and about how they solve problems?\n2. The function f(n) = n! grows very quickly. Suppose someone says g(n) = n! + 1\ngrows even more quickly. Are they correct? How about g(n) = 2\u00d7n! ?\n3. Do you think there is a function that grows more quickly than all other functions?\nWhy or why not?\n4. Suppose someone says that as computers get faster and faster all computational\nproblems will be solvable in a very short amount of time. Do you agree or disagree? 170 CHAPTER 9. ALGORITHMIC COMPLEXITY\n5. Give examples, other than those given in this chapter, where the issue of how pro-\ncesses scale is important. If possible, give examples from areas that you are inter-\nested in outside of computer science.\n6. Give examples, other than those given in this chapter, where there are massive\namounts of data being gathered or generated. If possible, give examples from areas\nthat you are interested in outside of computer science. Chapter 10\nWhat is Computer Science?\nComputer science (cid:54)= computer programming.\n10.1 Introduction\n10.1.1 Introductory Problem\nSuppose someone claims \u201csoftware engineering\u201d is the same as \u201ccomputer science.\u201d Do\nyou agree or disagree, and why?\n10.1.2 Overview\nWhat is computer science? If you ask this to a number of people, you will get a variety of\nanswers. When some people think of computer science, they often think of computer pro-\ngramming. And while computer programming is an important part of computer science,\nit is not the same as computer science. For instance, there are many computer scientists\nwho do not do program. They might be theoreticians, analysts, or administrators. In this\nchapter we\u2019ll examine three related questions:\n\u2022 What is computer science?\n\u2022 What is the difference between computer science and computer programming?\n\u2022 How is computer science similar to, and different from, related fields such as com-\nputer engineering?\nThe purpose of this chapter is therefore to clarify what computer science is and what\nits relation to similar fields is. The discussion in this chapter leads into the material in the\nnext two chapters, where we\u2019ll look at the software development side of computer science\nin more detail, and we\u2019ll see the basics of a specific programming language, Python.\n171 172 CHAPTER 10. WHAT IS COMPUTER SCIENCE?\n10.1.3 Motivation\nTounderstandcomputerprogrammingandcomputerscienceitisimportanttoknowwhat\nthey are, to clarify some common misperceptions, and to understand their similarities to\nand differences from related areas.\n10.1.4 Goals\nUpon completing this material, you should be able to do the following:\n1. Be able to explain, in your own words, what computer science is.\n2. Be able to explain what fields such as computer engineering are, and how they are\nrelated to, but different from, computer science.\n3. Be able to explain how computer science differs from computer programming.\n10.1.5 Connection with Mathematics, and with Technology and\nSociety\nThis chapter does not have a direct tie to mathematics or to technology and society.\nHowever, it will be useful background information for when we look at topics such as\nsoftware development and computer programming, where there is a stronger connection\nto the liberal education requirements.\n10.2 What is Computer Science?\nThroughout this class we have been exploring different aspects of computer science such\nas the role of algorithms, and how computers represent and operate on different types of\ndata. From this material you should have gotten a good amount of exposure to computer\nscience. And so it might seem odd to raise the question \u201cWhat is Computer Science?\u201d\nat this point. However, now that we are looking at the areas of computer programming\nand software development in this class, it is a good time to explore more precisely what\ncomputer science is, especially with respect to related fields.\nIf you look up definitions of \u201ccomputer science,\u201d you will find a number of different\npossibilities:\n\u2022 Merriam-WebsterOnlineDictionary: \u201cabranchofsciencethatdealswiththetheory\nof computation or the design of computers.\u201d1\n1From http:\/\/www.merriam-webster.com\/dictionary\/computer%20science; accessed Dec. 31,\n2013. 10.2. WHAT IS COMPUTER SCIENCE? 173\n\u2022 Cambridge Dictionaries Online: \u201c the study of computers, how they work, and how\nto make use of them ...\u201d.2\n\u2022 Webopedia: \u201cThe study of computers, including both hardware and software design\n...\u201d.3\n\u2022 Wikipedia: \u201cComputer science (abbreviated CS or CompSci) is the scientific and\npractical approach to computation and its applications. It is the systematic study of\nthe feasibility, structure, expression, and mechanization of the methodical processes\n(or algorithms) that underlie the acquisition, representation, processing, storage,\ncommunication of, and access to information ...\u201d.4\nAs the differences among these examples indicate, there are difficulties in defining\nprecisely what computer science is. The remainder of this section will discuss in more\ndetail some of these difficulties.\nOne challenge is that computer science consists of a number of subfields or subparts.\nThe definitions above mention the theory of computation, computer design, how comput-\ners work, how to use computers, hardware and software design, applications, and other\nsubparts. Each of these is important. However, one mistake people often make is to\nequate computer science with just one subpart. For example, computer programming is\nan important part of computer science, but it is not all of computer science. Similarly,\ncomputer use, such as using databases, spreadsheets, webpage design tools, etc. is often\nsomething computer scientists do, but is only a small part of computer science.\nThere are various ways to subdivide computer science. One possible distinction is\nbetween hardware and software. Another is between theoretical computer science and ap-\nplied computer science. Still other subpart classifications are more detailed and\/or divide\nthe subparts even further. For example, software design can be broken into system soft-\nware such as operating systems and compilers, and application software such as graphics\nor database software. Still other classifications provide additional subareas; for example\nhere is a subarea list that contains some areas already mentioned and some additional\nones:5\n\u2022 systems\n\u2022 theory\n\u2022 artificial intelligence\/robotics\n\u2022 software engineering\/programming languages\n2Fromhttp:\/\/dictionary.cambridge.org\/us\/dictionary\/business-english\/computer-science?\nq=computer+science; accessed Dec. 31, 2013.\n3From http:\/\/www.webopedia.com\/TERM\/C\/computer science.html; accessed Dec. 31, 2013.\n4From http:\/\/en.wikipedia.org\/wiki\/Computer science; accessed Dec. 31, 2013.\n5These are the upper division elective \u201ctracks\u201d that University of Minnesota-Twin Cities Computer\nScience B.S. students can choose from to fulfill their degree requirements. 174 CHAPTER 10. WHAT IS COMPUTER SCIENCE?\n\u2022 computational science\n\u2022 graphics and visualization\n\u2022 architecture and hardware systems\n\u2022 bioinformatics and computational biology\n\u2022 databases\n\u2022 graphical information systems\n\u2022 human computer interaction\n\u2022 security\n\u2022 networks\n\u2022 software and data systems development\n\u2022 big data\nA second challenge is that many subfields of computer science are interdisciplinary.\nFor example, robotics draws not only on computer science, but also on other fields such as\nelectrical engineering and mechanical engineering. Artificial intelligence overlaps with the\nfields such as psychology and linguistics. Computer hardware research overlaps heavily\nwith electrical engineering and material science. Computer graphics overlaps with a va-\nriety of areas including optics, image processing, perception, and medical imaging; these\nin turn are subareas of other fields such as physics, psychology, and medical research. In\nshort, many subfields of computer science overlap with, draw upon, and contribute to\nother fields.\nA third challenge is that computer science is closely related to other fields such as\nsoftware engineering or computer engineering. Sometimes these other fields are seen\nas subfields of computer science, sometimes as distinct, but closely related fields. The\nsimilarities and differences are important enough that we will discuss this point further\nin the next section.\nA final challenge is that computer science is a rapidly evolving area, and so what\nconstitutes computer science continues to change. In the early days of computing topics\nsuch as numerical computation and language specification were prominent; topics such as\nnetworking or \u201cbig data\u201d were non-existent or not as important.\n10.3 Closely Related Fields\nAs the last section mentioned, computer science is closely related to fields such as software\nengineering and computer engineering. And sometime these fields are seen as subfields 10.3. CLOSELY RELATED FIELDS 175\nof computer science, and sometime they are seen as closely related fields. For example,\nsome universities have separate programs in computer science, computer engineering, and\nsoftware engineering; others might have just a single degree (usually computer science)\nbut might have computer engineering and\/or software engineering as emphases within\nthat computer science degree.\nHere is a commonly used diagram, which is explained further below, showing the\nrelation between computer science and five related fields.\nEE ---- CompE ---- CS ---- SE ---- IT --- IS\n\u2018CS\u2019 stands for computer science. Here is a brief explanation of the five other fields:\n\u2022 EE, or electrical engineering is the study and practice of working with electricity,\nelectronics, electromagnetism, and electrical systems. It consists of a number of\nsubfields, someofwhich, suchaspowersystems, arelessdirectlyrelatedtocomputer\nscience, and others, such as circuit design, that are more closely related. Most large\nuniversities (and many smaller ones) have an electrical engineering department.\n\u2022 CompE, or computer engineering is the study and practice of designing, creating,\nandmanufacturingcomputerhardwareandcomponents, especiallymicroprocessors.\nComputer engineering is therefore closely related to both electrical engineering and\ncomputer science. Not all universities have a computer engineering degree. Some\nthat do have it as a standalone program; however, often it is housed in the electrical\nengineering or computer science department.6\nComputer engineering students take many of the same introductory classes as com-\nputer science students and electrical engineering students \u2014 beginning program-\nming, introductory computer science theory, circuits, microcontrollers, etc. \u2014 and\nthen take advanced courses in areas such as computer architecture and systems\nprogramming.\n\u2022 SE, or software engineering is the study and practice of developing software. Soft-\nware engineering is different from computer science because of its narrowed but\ndeeper focus. For example, a student getting a software engineering degree would\ntake many of the same classes as a computer science student, including program-\nming, theory, and applications classes, but would take numerous advanced classes\nin software development. (The software development process is described in more\ndetail in the next chapter.)\nSome universities have separate software engineering programs. For most universi-\nties however, students wishing to get a software engineering background would get\n6Or both. For example at the University of Minnesota-Twin Cities, Computer Engineering is a joint\nprogram of both the Electrical and Computer Engineering Department and the Computer Science and\nEngineering Department. 176 CHAPTER 10. WHAT IS COMPUTER SCIENCE?\na computer science degree with a software engineering emphasis.7\n\u2022 ITorinformation technology: TheACM 2008 Curricular Guidelines for Information\nTechnology 8 defines IT as the \u201cthe computer technology needs of business, govern-\nment, healthcare, schools, and other kinds of organizations.\u201d It further describes\nthe field as follows:\n\u201cits emphasis is on the technology itself more than on the information it\nconveys. IT is a new and rapidly growing field that started as a grassroots\nresponse to the practical, everyday needs of business and other organiza-\ntions. Today, organizations of every kind are dependent on information\ntechnology. They need to have appropriate systems in place. These sys-\ntems must work properly, be secure, and be upgraded, maintained, and\nreplaced as appropriate. Employees throughout an organization require\nsupport from IT staff who understand computer systems and their soft-\nware and are committed to solving whatever computer-related problems\nthey might have. Graduates of Information Technology programs address\nthese needs.\u201d\nThe University of Minnesota College of Continuing Education has a degree in Infor-\nmation Technology Infrastructure (ITI). Students in this program take many com-\nputer science classes, some business classes, and electives that focus on technology\ninfrastructure; these include advanced network, computer systems, and database\nclasses among others.9\n\u2022 IS or information systems, is more concerned with the business side of information\ntechnology. For example, questions such as \u201chow could a new computer system\nmake a business\u2019s practices more efficient?\u201d and \u201cwhat type of computer system\ndoesabusinessneedtomanageitsdata?\u201d,whiletheyhavecomputerscienceaspects,\nbelong more to the field of information systems.10 A student getting a degree in\n7At the University of Minnesota-Twin Cities there is not a separate bachelor\u2019s degree in software\nengineering. However,thereisaMastersofScienceinSoftwareEngineering(MSSE).Thisisaprofessional\ndegree for people who work in the local software industry.\n8Available online at http:\/\/www.acm.org\/\/education\/curricula\/IT2008%20Curriculum.pdf; ac-\ncessed Jan. 9, 2014.\n9MoreinformationontheITIdegreeisonlineathttp:\/\/cce.umn.edu\/BAS%2DIT%2DInfrastructure\/.\n10The ACM 2010 Curricular Recommendations for Information Systems, available online at\nhttp:\/\/www.acm.org\/education\/curricula\/IS%202010%20ACM%20final.pdf, provides a more formal\nand detailed description of this field:\n\u201cInformation Systems as a field of academic study encompasses the concepts, principles, and\nprocesses for two broad areas of activity within organizations: 1) acquisition, deployment,\nmanagement, and strategy for information technology resources and services (the informa-\ntionsystemsfunction;ISstrategy,management,andacquisition;ITinfrastructure;enterprise\narchitecture; data and information) and 2) packaged system acquisition or system develop-\nment, operation, and evolution of infrastructure and systems for use in organizational pro- 10.3. CLOSELY RELATED FIELDS 177\ninformation systems would take many business classes such as project management\nand information system acquisition. They would also take classes in areas such\nas beginning programming, databases, and other applications that are critical to\nbusiness systems and operations. In addition, they would take classes in areas such\nas information security, information system architecture and infrastructure, and e-\ncommerce that involve both computer science and business. Information systems\nprograms are usually housed within the business school.11\nThe Association for Computing Machinery, one of the major computer professional\ngroups, has curricular recommendation reports for five of the six fields mentioned above\n(all except electrical engineering). These detailed reports, whose intended audience in-\ncludes educators, accreditors, and professionals from related industries, are available on-\nline at http:\/\/www.acm.org\/education\/curricula-recommendations.\nThe list above is not comprehensive. There are other fields such as mathematics that\nhave contributed to, overlap with, and are influenced by computer science.12 There are\nalso other specialized fields that are closely related to computer science. For example\nsome colleges or universities have degrees in computer forensics.\nIn general, computer science is very broad in terms of what types of jobs a student\nwith a computer science degree might go into. Many computer science students do go\ninto programming or software development positions. Others work in application areas\nsuch as databases or artificial intelligence. Others might work in areas such as systems\nadministrationornetworking. Stillotherswillworkinothersubareasofcomputerscience.\nComputer science and the related degrees are also very fluid. Many computer profes-\nsionals come from backgrounds in electrical engineering, mathematics, or other related\nareas, or even unrelated ones. In part this is because of the dynamic nature of computer\nscience, and in part because computer science both relies on and contributes to so many\nother fields.\ncesses (project management, system acquisition, system development, system operation, and\nsystem maintenance). The systems that deliver information and communications services in\nan organization combine both technical components and human operators and users. They\ncapture, store, process, and communicate data, information, and knowledge.\u201d\n11At the University of Minnesota-Twin Cities, the the Carlson School of Management has a bachelors\ndegree in Management of Information Systems (MIS). The University catalog describes the program:\n\u201cThe management information systems (MIS) major prepares students to be leaders in con-\nceptualizing,prescribing,developing,anddeliveringleading-edgeinformationsystemapplica-\ntionsthatsupportbusinessprocessesandmanagementdecisionmaking. Itprovidesstudents\nwith an understanding of the functions of information systems in organizations and detailed\nknowledge of information system analysis, design, and operation.\n12In fact many smaller schools house mathematics and computer science programs in the same depart-\nment. 178 CHAPTER 10. WHAT IS COMPUTER SCIENCE? Chapter 11\nSoftware Development\nProgramming \u201cin the small\u201d (cid:54)= programming \u201cin the large.\u201d\n11.1 Introduction\n11.1.1 Introductory Problem\nMark each of the following as \u201ctrue\u201d or \u201cfalse\u201d and briefly justify your answer.\n1. The largest software systems consist of hundreds of thousands of lines of code.\n2. Although computer errors have led to significant negative effects, such as billions of\ndollars of business losses and mission failure for interplanetary space probes, they\nhave never been a major contributing factor in a human fatality.\n3. Althoughithasnotalwaysbeenthecase, mostlargesoftwareprojectsarecompleted\non time and under or at budget.\n11.1.2 Overview\nComputer systems play an important part in our everyday life. But what do we know\nabout those systems? How big are they? How reliable are they? How are they con-\nstructed? Are most attempted software projects successful? The aim of this chapter is\nto examine these and other aspects of computer software and computer programming. In\nparticular, this chapter provides a \u201cbig picture\u201d discussion of software development and\ncomputer programming.\n11.1.3 Motivation\nIn 1990 the Mars Climate Orbiter entered the Martian atmosphere at the wrong angle,\nresulting in a catastrophic failure. The cause was traced to a software miscommunication:\n179 180 CHAPTER 11. SOFTWARE DEVELOPMENT\none group working on the software was using metric units of thrust, another was using\nEnglish units.\nLarge software systems are important in many aspects of society. Here are a few\nexamples:\n\u2022 As the introductory example shows, software systems are an important (and some-\ntimes faulty) part of space exploration.\n\u2022 Telecommunications software is an important part of the mobile phone infrastruc-\nture.\n\u2022 Office productivity software such as word processors, spreadsheets, and database\nsoftware are large programs used by many individuals and businesses.\n\u2022 Businesses also rely on a number of software systems such as payroll and inventory\nsystems.\n\u2022 As was briefly discussed in a previous chapter, system software such as operating\nsystemsandcompilersareprogramsthatallowcomputerstodosystem-relatedtasks\nsuch as translating high level programming code to machine instructions.\n\u2022 Computer games are rarely simple programs, but are often complicated systems\ninvolving graphics; user interaction; a rich database of plots, characters, and game\nobjects; ability to play over a network with multiple players; etc.\nIn summary, software systems play an important role in many, many important ar-\neas of society whether the areas are scientific, business-related, industrial, governmen-\ntal, communications-related, recreational, or personal. These systems allow individuals,\nbusinesses, government agencies, and other organizations to perform tasks that would\notherwise be impossible or difficult. But the systems can also create problems if they\nmalfunction. To better understand the role of software it is important to know some\nfundamentals about software and its development.\n11.1.4 Goals\nUpon completing this chapter, you should be able to do the following:\n1. Be able to explain some of the key differences between writing a small computer\nprogram and a large one.\n2. Be able to state some fundamental facts about software, software projects, and the\nsoftware development process.\n3. Be able to explain the main steps in the software development process. 11.2. PROGRAMMING \u201cIN THE LARGE\u201d VERSUS \u201cIN THE SMALL\u201d 181\n11.1.5 Connection with Mathematics, and with Technology and\nSociety\nSoftware development has a number of important connections with mathematics. On\none hand, programming has a strong connection with mathematics as much of it involves\ncomputations in some way, shape, or form. On the other hand there are deep and im-\nportant connections between software development and mathematics. However, many of\nthese connections are advanced.1 So \u2014 other than looking below at a problem involving\ncounting and software testing \u2014 we will not explore the connection between software\ndevelopment and mathematics further.\nThe connection between software systems and technology and society is more evident.\nAs discussed in the motivation subsection above, software systems play a role in many\nimportant areas of society.\n11.2 Programming \u201cIn the Large\u201d Versus \u201cIn the\nSmall\u201d\nOne common view of computer programming is similar to a common view of how writers\nwork: they work solo at their keyboard for many hours and finally create a significant\nwork. The writer might create a book, and the programmer an important computer\nprogram.\nWhile this view is sometimes correct, it does not reflect the reality of most program-\nmers. Why not? There are a number of reasons, including the following:\n\u2022 Most programmers work on multiperson projects rather than working alone.\n\u2022 While programming sometimes consists of writing new code, it also involves correct-\ning, updating, etc. old code, probably code that other programmers have written.\n\u2022 There is more to creating computer software than coding. For example, it is often\nnot clear exactly what the program needs to do, so part of the software development\nprocess is clarifying what the requirements for the software are.\n\u2022 Aprogramisoftennot\u201cstandalone;\u201d itmightitselfbepartofanevenlargecomputer\nprogram, which in turn might need to interact with still other computer programs.\nThe view of a single programmer working on a well-defined project and producing an\nentire program is an example of what is called \u201cprogramming in the small.\u201d However,\nlarge important systems are the work of many people working in many places over a\nlong time span. Much of the software we rely on, whether it be office productivity soft-\nware such as spreadsheets and word processors; web browser software; operating systems;\n1For example, one use of formal methods is to try to prove mathematically that a code section is\ncorrect. 182 CHAPTER 11. SOFTWARE DEVELOPMENT\nbusiness software systems that track and analyze inventory, orders, and cost; software\nfor telecommunication systems; etc. are large pieces of software. For example operating\nsystems such as Linux\/Unix, Windows, and MacOS consist of millions of lines of code.\nWorkingonalargemultipersonsystemissignificantlydifferentfromwritingaprogram\nthat might be used only by a handful of people, perhaps only the programmer himself or\nherself. Large systems will have many users, might go through many versions, and might\ninvolve special safety, security, accuracy, or other features.\n11.3 Parts of the Software Development Process\nSoftwaredevelopmentrequiresmorethanonlyprogrammingorcoding. Asthelastsection\nmentioned, software development often involves additional, related steps:\n\u2022 Requirements Engineering: It might seem odd that in most large systems the first\nchallenge is defining, and defining precisely, what the system is to do. Why does\nthis challenge even exist? Isn\u2019t there is usually a well-defined problem or set of\ntasks, and what we are looking for is a computer program to solve that problem or\ndo those tasks?\nHowever, for large systems it is rarely if ever the case that the problem or task\nis completely and precisely defined. Let\u2019s look at a very simple example: suppose\nsomeone asks you to write a computer program to sort a list. What does this mean?\nSort in ascending or descending order, or allow the user to choose either? Sort\na list of numbers? Names? Addresses? Any type of list involving alphabetical\nor numeric data? If the list involves both alphabetical and numeric data should\nnumbers appear before characters or vice versa? How about sorting upper case vs.\nlower case? And are there any restrictions or special requirements? For example, is\nthere any restriction on the list size or the number of characters in each list item?\nShould there be a check for obviously bad data? If so, how should it be handled?\nWhat type of a device should the program run on? Should the program be able to\nbe called by other programs? If so, what form should the list be in to ensure both\nprograms can work with it? Would the sorted list overwrite the original list (so the\noriginal list would no longer be around), or would that be a problem?\nSo even for this very simple task there are numerous clarifying questions we need\nto ask before writing the program. Defining the \u201crequirements,\u201d or precisely what\na system is to do, is difficult for a number of other reasons as well. These include\nthe following:\n\u2013 Large systems are complicated and it is difficult to specify all the requirements\naccurately and clearly.\n\u2013 Clients often don\u2019t know exactly what they want. They might have a high-level\nidea, but are unsure about the details. They might not know what is possible. 11.3. PARTS OF THE SOFTWARE DEVELOPMENT PROCESS 183\nOr they might have multiple divisions within their organization, and not know\nwhat all the different users want out of the system.\n\u2013 There are often tradeoffs involved in software systems. For example, a more\ncomplicated system might have more features and capabilities, but take longer\nto develop. A more secure system might be harder for people to use. A\nnonessential feature might be desirable but also costly. A new user interface\nmight be more efficient than the interface of an old system, but it will take\nadditional time for users to learn.\n\u2013 Changing landscapes. The requirements might (in fact, for a large project,\nwill) change over time. An organization\u2019s needs, processes, or infrastructure\nmight change. For example, suppose a company wanted some software that\nneeded to communicate with the company\u2019s existing databases, and that the\ncompany had multiple locations, each with its own database. However, due\nto company restructuring as well as falling telecommunications costs and in-\ncreasing telecommunications abilities the company decides to consolidate all\nits databases into a single location. Then the software would only need to\ncommunicate with this single database rather than with multiple ones.\n\u2022 Design: Suppose you are building a house. You don\u2019t begin by actually starting\nthe construction. Instead there is a planning and design phase first. Similarly,\nlarge software systems need careful design: What is the system\u2019s \u201carchitecture,\u201d for\nexample what are its main parts and how are they related? What are the subparts\nof the main parts? How does the system interact with any related systems it must\ncommunicate with? Etc.\n\u2022 Coding: This is the part of the development process that most people think of when\nthey think of software development: it is the part consisting of actually writing the\ncode. If the requirements are well-specified and stable, and if there is a good, infor-\nmative design, then coding should actually be the easiest part of the development\nprocess.\n\u2022 Testing: No people, not even the best programmers, write substantial amounts of\ncode error-free the first time. A part of a programmer\u2019s job is to test the code he or\nshe writes. However, testing is complicated enough and important enough that it\nconstitutes a separate part of the development process. In fact, many development\ncompanies have different people test the software than write it (think about why\nthis is useful). Some large development companies have an entire group whose job\nis testing.\nWhy is testing nontrivial? Here are a few of many reasons:\n\u2013 It is usually impossible to check all possible cases. For example, suppose a\nprogram asks a user to input a text string of 20 characters or fewer. There 184 CHAPTER 11. SOFTWARE DEVELOPMENT\nare so many possible names that it is impossible to check all of them in any\nreasonable amount of time. (See the next section for a related problem.)\n\u2013 Programs must guard against erroneous and unexpected events. Suppose a\nprogram asks a user to input a temperature. What happens if they mistype\n98.6 as 98,6 or as @iu.t@? Tasks such as checking input add complexity to\nprograms, and are often difficult to do rigorously.\n\u2013 Many program errors are not within a piece of code itself, but in how the piece\nof code interacts with other pieces of code in a larger system.\n\u2022 Maintenance: The word \u201cmaintenance\u201d lacks glamor. Would you really want main-\ntenancetobeasignificantpartofasuccessfulsoftwareproject? Actuallyyouwould.\nPart of maintenance is adding additional features to a successful piece of software.\nPart of it is fixing obscure defects or security issues that wouldn\u2019t have been found\nwithout a large user base. Part of it is updating successful software from an older\nversion to a newer version. Part of it is modifying the software so it is useful on a\nvariety of devices (e.g., perhaps on tablet computers or smartphones).\nIn short, think of software maintenance like you think about automobile mainte-\nnance or house maintenance. You do not want to spend too much time or money\non maintenance. However, if you have a car or house you really like you do preven-\ntive maintenance to keep it in good shape, and fix occasional problems that occur.\nAnd occasionally you do major \u201cmaintenance\u201d such as adding a room to a house.\nSimilarly, a reasonable and long-term commitment to maintenance is a sign of a\nsuccessful software product, not an unsuccessful one.\nA more comprehensive discussion of software development would discuss the above\nitems in more detail, as well as identifying other parts of software development. However,\nthe items explained above illustrate the key point that software development is more\nthan just coding, and that developing large software systems is different than developing\nsmaller systems or writing a single short program.\nThe steps above (sometimes with additional steps included) are sometimes put in a\nsequenceandpresentedasthe\u201cwaterfall\u201dmodelofsoftwaredevelopment: firstyouspecify\nthe requirements, then you design the system, then you do the coding, then you test the\nsystem, and afterwards you do system maintenance. This is a useful model in that it\nidentifies these key parts of the development process. However, it should not be taken as a\nrepresentationof how development actually occurs in practice. For example, as mentioned\nabove, requirements sometimes change in the middle of the development process, and so\nonecannotspecifytherequirementsandassumethatstageisentirely finished. Asanother\nexample, often during the design or coding it becomes clear that certain requirements\nwere omitted, or incorrectly or ambiguously specified; or during the coding phase a better\ndesign of some subparts of the system might be discovered. Additionally, development\noften proceeds iteratively. For example, certain core requirements might be specified, and\nthe related part of the system designed, coded, and tested; then a second iteration would 11.4. SOFTWARE CHALLENGES AND RISKS 185\nspecify requirements for an additional portion of the system, and it in turn would be\ndesigned, etc.; and in general the system would be built though a number of iterations.\n11.4 Software Challenges and Risks\nThe inherent complexity of large software systems presents a number of challenges. Large\nsystems consist of many, many parts and many, many subparts. The largest systems\nconsist of millions of lines of code. It is impossible for any single person to understand\nthe entire system in depth, or even a substantial part of it.\nBecause of this, large systems are difficult to design, implement, and maintain. In\nfact, large systems do not have a large success rate. Although software development has\nimproved and is continuing to improve, large systems are more often than not delivered\nlate and\/or over budget.2\nMoreover, evendeliveredsoftwareisnoterror-free. Ratesof1or2errorsperthousands\nof delivered lines of code are common. And while this might not seem like a large error\nrate, in a system of hundreds of thousands if not millions of lines of code it results in\na large number of errors. Many of these errors are minor, but occasionally a \u201csmall\u201d\nerror can have serious or catastrophic results. Software errors have contributed to mission\nfailures such as in the Mars Climate Orbiter example, financial losses that yearly total in\nthe billions of dollars, or even human injury or loss of life, as in the Therac-25 incident\nwe\u2019ll (probably) explore in class.\nBecause certain systems such as space exploration software, medical software, military\nsoftware, or financial software have special requirements, they need extra care, know-how,\nand oversight in their development. Careful software processes can significantly decrease\nthe number of errors in software systems; however, this requires additional costs and\nknow-how.\n11.5 Some Example Problems\nProblem 1: Suppose a software system is 200,000 lines long and is estimated to contain\n2.8 errors per thousand lines of code. How many errors does this mean the code is likely\nto contain?\nProblem 2: Suppose a program requires a user to enter an 8-character string, where\neach character in the string can be a lower-case alphabetic character, and upper-case\nalphabetic character, or a digit 0\u20139. Characters can be repeated. Suppose further that\nyou wish to test the code by checking all possible bitstrings, and that your test code can\ncheck 10,000 bitstrings per second. How long will it take for your code to test all of the\npossible 8-character strings?\n2The Oct. 2013 ACA site failure is just one of many examples. 186 CHAPTER 11. SOFTWARE DEVELOPMENT\nProblem 3: In testing it is desirable (but not always easy or even possible) to test every\n\u201cpath\u201d through the code. Consider the following algorithm fragment. In the fragment\nthe \u201c...\u201d represent lines that are omitted but which might provide output or modify the\nvariable values, but do not include any if or else statements. How many different paths\nare there through the algorithm? For example if violinCount is 5, violaCount is 20,\nand celloCount is 10, then the algorithm will execute different statements than when\nviolinCount is 8, violaCount is 12, and celloCount is 4. So these two cases represent\ntwo different paths.\nif violinCount > 10\nif celloCount < 10\n...\nelse if celloCount < 20\n...\nelse\n...\nelse\n...\nif violaCount equals celloCount\n...\nelse\n...\nif bassCount < 10\nif doubleBassoonCount < 10\n...\nelse\n...\nProblem 4: Explain why software development is more than only doing computer pro-\ngramming.\n11.6 Problem Solutions\nIntroductory Problem\n(1) False; they are larger, consisting of millions or tens of millions of lines of code.\n(2)False; forexample, bothsoftware and hardwaremalfunctionswerecontributingfactors\nin the Therac-25 incidents (which will likely be discussed in class).\n(3) False; although the situation is improving, recent studies have shown only about one\nthird of large software projects are completed on time and don\u2019t exceed their budget. 11.6. PROBLEM SOLUTIONS 187\nProblem 1\nIf a program is 200,000 lines long and contains an average of 2.8 errors\/thousand lines of\ncode, then it contains 2.8\u00d7200 = 560 errors.\nProblem 2\nThe 8-character string has 62 possibilities for each character. Characters can be repeated\nand order matters, so there are 628 = 218,340,105,584,896, or about 218 trillion possible\nstrings. If 10,000 of these can be processed per second, then it will take the program\n218,340,105,584,896\/10,000, or approximately 21,834,010,558, seconds. This is about\n22 billion seconds, which is almost 7 centuries.\nProblem 3\nNotice that the program will first take one of the four paths through the first part of the\ncode:\nif violinCount > 10\nif celloCount < 10\n...\nelse if celloCount < 20\n...\nelse\n...\nelse\n...\nThen it will take one of two paths through the next part:\nif violaCount equals celloCount\n...\nelse\n...\nFinally, it will take one of three paths through the final part (note that in addition to the\ntwo paths indicated by the dots, there is a third path when bassCount < 10 is False):\nif bassCount < 10\nif doubleBassoonCount < 10\n...\nelse\n...\nSo there are a total of 4\u00d72\u00d73 = 24 different paths.\nProblem 4\nAnswers can vary. One possibility is mentioning that, in addition to computer program-\nming, software development involves requirements engineering, software design, testing,\nand maintenance. 188 CHAPTER 11. SOFTWARE DEVELOPMENT Chapter 12\nPython Reference\n\u201cAll programmers are playwrights and all computers are lousy actors.\u201d1\n12.1 Introduction\nThischapterisaquickintroductiontoPython. Itwillhaveadifferentstructurethanother\nchapters, presenting some Python along with examples. This chapter is not comprehen-\nsive: Python, like most computer languages, is extensive, and the Python programming\nlanguage has been the topic of many entire books. So the material in this chapter is only\nan introduction that will focus on the basics of Python you need for the class.\nThis material is meant to complement online references and the in-class presentation\nof Python. Why have a chapter on Python if there are other resources? It is often useful\nto have additional or alternative explanation of programming language concepts, as well\nas additional examples. The Python site http:\/\/www.python.org contains additional\nreference material, as well as an online tutorial. Plan on using that site extensively. The\nclass lectures will present additional examples, some of which will involve more compli-\ncated use of Python than in this introductory chapter. So in your study of Python you\nshould also attend those classes and study the additional examples.\nYou should be able to run any of the examples in this section on the Python inter-\npreter.2 Recall that on the lab machines used for this class you can run the interpreter\nsimple by logging in and typing python in a terminal window. More detailed instructions\nabout using the Python interpreter are below.\nAs a final note, the best way to learn about computer programming is to program. So\nrather than just reading this chapter on its own, you are encouraged to try the examples\nin this chapter in the Python interpreter, vary them and see what happens, make up your\nown examples, etc.3\n1From http:\/\/www.cs.cmu.edu\/\u223cpattis\/quotations.html; accessed Dec. 18, 2013.\n2The Python in this chapter uses version 2.7.\n3This chapter contains only a few problems; additional problems are in the next chapter.\n189 190 CHAPTER 12. PYTHON REFERENCE\n12.2 Getting Started with The Python Interpreter\nTo use Python on the CSE lab machines, you can type python after opening a terminal\nwindow. This should put you in the interpreter, and you should see a >>> prompt. (If\nthis doesn\u2019t work, see a TA.) At the Python prompt you can type in Python statements.\nHere is an example, including what happens if you make a syntax error:\n>>> snowDepth = 5\n>>> print snowDepth\n5\n>>> set beehiveCount = 2\nFile \"<stdin>\", line 1\nset beehiveCount = 2\n^\nSyntaxError: invalid syntax\n>>> beehiveCount = 2\n>>> print beehiveCount\n2\nTo exit the interpreter, type CNTL-d, that is, press the control and (lower case) d at the\nsame time.\nSection 12.16 below will explain some additional use of the interpreter.\n12.3 Basics: Data Types and Operations\nAn earlier chapter discussed data and data representation. How does Python deal with\ndata? As you might expect from the earlier discussion, Python has many data types. In\nthis section we\u2019ll cover a few of them that you\u2019ll use in this class.\n12.3.1 Numbers\nRecall from the chapter on data representation that computers distinguish between inte-\ngers and floating point numbers. This is reflected in many languages, including Python:\nwhen working with numbers we often need to specify if they are integers or floating point\nnumbers.\nDecimal integers are represented by strings of digits with negative numbers preceded\nby a minus sign: 42, 0, and -65536 are all integers. However, a few cautions: First, don\u2019t\ninclude commas in Python numbers. For example, the last number above was not written\nas -65,536. Here is the result from the Python interpreter if you do mistakenly use a\ncomma:\n>>> 2 * -65,536\n(-130, 536) 12.3. BASICS: DATA TYPES AND OPERATIONS 191\nWhatever is happening here, it is very likely not what we want. The second caution is\ndon\u2019t include leading zeros in decimal numbers. For example, even though 042 base 10 is,\nstrictly speaking, equivalent to 42 base 10, we likely wouldn\u2019t write the former. Python\ndoesn\u2019t like the 042 either.4 Third, don\u2019t include a trailing decimal point, such as writing\n42 as 42. When Python sees a number with a decimal point, it interprets it as a floating\npoint number:\n>>> 2 * 4.\n8.0\nIf you wish, you can represent integers in binary or hexadecimal. To represent a\nnumberinbinary, prefixitwithan0b. Forexample, 0b10isbinaryforthedecimalvalue2.\nPrefix hexadecimal numbers with an 0x. As an example, 0x1af is the hexadecimal for 431\n(since 431 = 1\u00d7256+10\u00d716+15\u00d71). Note that the leading zero in these representations\nis telling the Python interpreter to be prepared for a non-decimal representation.\nFloating point numbers differ from integers in two ways. First, floating point numbers\nhave a decimal point followed by zero or more digits, for example 0.0 or 3.14159. Second,\nfloating point numbers can be larger or smaller than integers. To accommodate this,\nPython allows floating point numbers to be written in scientific notation. This is done by\nputting an e between the mantissa and the exponent. For example, the Python floating-\npoint number 5.7e4 is the Python representation for the number 5.7\u00d7104, which in turn\nis the same as the Python floating-point number 57000.0. Much larger numbers, such as\n6.02e23, (in conventional scientific notation 6.02\u00d71023), very negative numbers, such as\n-2.0542e45, (\u22122.0542\u00d71045), andverysmallnumbers, suchas6.626e-34(6.626\u00d710\u221234)\nare also possible.\n12.3.2 Text\nWorking with text in Python is simpler than working with numbers. To indicate a string\nof text, simply enclose it in either single or double quotes. For example, \u2018King Canute\u2019\nand \"King Canute\" are both the same string. Notice you can include spaces within the\nstring.\nOne complication with text is that we sometimes want to include special characters in\na text string. For example, what if we want to have quotation marks within a string? A\nstring attempt such as \"He said, \"You did well.\"\" does not work: it causes a syntax\nerror in Python.\nWith quotation marks, you can include a single quote within a double-quote delimited\nstring, or vice versa. For example, \u2018He said, \"You did well.\"\u2019 does work. But what\nif you want both single and double quotes in the string? Or what if we want other special\ncharacters such as a tab or line break? A way to indicate special characters in Python\nis by prefixing them with a specially designated character, the backslash character \\, as\nshown:\n4Actually it doesn\u2019t object to it, but it interprets it as an octal or base 8 number. 192 CHAPTER 12. PYTHON REFERENCE\n>>> print \"A line with a \\t tab and a \\n line break\"\nA line with a tab and a\nline break\n>>> print \"A line with a single quote \\\u2019, double quote \\\", and backslash \\\\.\"\nA line with a single quote \u2019, double quote \", and backslash \\.\n12.3.3 Booleans\nBoolean variables are variables whose value can be True or False. They are often used\nto indicate the status of a condition, for example leftValveOpen = True. Remember to\ncapitalize the first letter in True and False.\n12.4 Variables\nWe have met variables before: they are items in algorithms or programs whose values\ncan change. Variables in Python can be of many types, including integer, floating point,\nboolean, and text.\n12.4.1 Variable Names\nThere are rules for what constitutes a valid variable name in Python. Variable names\nmust start with an uppercase alphabetic character, a lowercase alphabetic character, or\nan underscore. This first character can then be followed by zero or more uppercase\nalphabetic characters, lowercase characters, underscores, or digits. So, for example, dog,\nCat, zebra87, _mandrillCount, and platypus_count are all valid variable names, while\n5dog, Cat!, and octop@us are not.\nAs mentioned in an earlier chapter, it is better to have descriptive variable names,\nfor example baboonCount rather than just b. This makes programs easier to read and\nunderstand. Python allows multiword variable names; it is good practice to separate the\nwords by underscores (e.g., baboon_count) or use \u201ccamelCase,\u201d that is, capitalizing the\nfirst letter of each word (other than perhaps the first). However, including blank spaces\nwithin variable names is not allowed.\n12.4.2 Assignment and Use\nAPythonstatementsuchasthreadCount = 500assigns500tothevariablethreadCount.\nThe left side of the assignment statement is a variable name, which is followed by the as-\nsignment operator =. The right hand side can involve values, operators, and\/or variables.\nFor example, each of the following are valid Python assignment statements:\nmolluskCount = 12 + 8 + 4\nanimalCount = zebraCount 12.5. OPERATORS 193\nanimalCount = zebraCount + gnuCount + 2\nlobsterCount = lobsterCount + 1\n12.5 Operators\nPython, like every computer language, includes a variety of operators. This section pro-\nvides an overview of commonly used arithmetic, relational, and logical operators.\n12.5.1 Arithmetic Operations\nSuppose you are constructing a triangular garden plot. The triangular area measures 6\nfeet in one direction and 8 feet in the other. What is the square footage of the area? You\nremember the area of a triangle is one-half the length of the base times the height. You\nplug this into the Python interpreter and get the following:\n>>> b = 6\n>>> h = 8\n>>> (1\/2)*b*h\n0\nWhat went wrong?\nPythoncontainstheusualarithmeticoperationsofaddition, subtraction, division, and\nmultiplication. It also contains a variant of division (floor division) that always rounds\ndown, a remainder operation, and an exponent operation, as shown in the following table:\nOperation Symbol Example Value\nAdd + 3 + 5 8\nSubtract - 72 - 21 51\nMultiply * 7.2 * 4.5 32.4\nDivide \/ 7 \/ 3.5. 2.0\nRounded Down Divide \/\/ 7 \/ 3.2. 2\nRemainder % 7 % 3 1\nExponent ** 7 ** 3 343\nMostuseoftheseoperationsisstraightforward. However,astheexampleaboveillustrates,\nsome further explanation and cautions are needed:\n\u2022 There is an order of operations for doing arithmetic. For example, is the addition\ndone before the multiplication in 4 + 3 * 2, or is the multiplication done first?\nThe rule is \u2014 absent any parentheses \u2014 multiplication before addition. However,\nyou can avoid memorizing the order of operation rules by using parentheses. Use\nparentheses. It will save you from making some hard-to-find errors, and will make\nthe code easier for you and others to read and understand. 194 CHAPTER 12. PYTHON REFERENCE\n\u2022 Divisioncanbeconfusing. Specifically, whatshould7\/3be? Shoulditbe2.333333?\n2 1\/3? Should we round down to 2? Round up to 3? Note part of the problem\nhere is that 7 and 3 are integers; should the result be an integer or a floating point\nnumber? And what is the \/\/ division for? Here are a few examples along with\nexplanations:\n>>> 7\/3\n2\n>>> -7\/3\n-3\n>>> 7.0\/3\n2.3333333333333335\n>>> -7.0\/3.0\n-2.3333333333333335\n>>> 7\/\/3\n2\n>>> -7\/\/3\n-3\n>>> 7.0\/\/3\n2.0\n>>> -7.0\/\/3\n-3.0\nIn the first test here we are doing integer division, and the result is an integer. The\nresult is rounded down to the next lowest integer. The rounding is always down,\nregardless of whether any fractional part is greater than 1\/2 or not. For example,\n8\/3 is 2, not 3. Also \u201crounded down\u201d means what you expect when the result is\npositive: just drop any fractional part. However, as the second test shows, when\nthe result is negative, \u201crounded down\u201d means going more negative; so in the case\nof -7\/3 the result is -3, not -2.\nThe third and fourth tests show what happens when one or both numbers is a\nfloating point number: the result is a floating point number. The rule with usual\ndivision, i.e., withthe\/operator, isthattheresultisanintegeronlyifbothnumbers\nare integers, otherwise the result is a floating point number. This is true even if\nthe result of dividing two floating point numbers comes out evenly. For example,\n6.0\/3.0 yields 2.0; note this is represented as a floating point number rather than\nas the integer 2.\nThe last four tests show the difference between division using \/\/ and division using\n\/. When both numbers are integers, there is no difference: compare the fifth and\nsixth tests with the first two tests. However, when one or both of the two numbers\nis a floating point number, then \/\/ rounds down. Note the result is still represented\nas a floating point number, with a 0 to the right of the decimal point. 12.5. OPERATORS 195\n12.5.2 Relational Operators\nRelational operators compare two items. Most of the operators in the table below will\nbe familiar to you: greater than, greater than or equal to, etc. Note the result is a value\nTrue or False.\nOperation Symbol Example Value\nLess than < 4 < 4 False\nGreater than > 8 > 4 True\nLess-or-equal <= 4 <= 8 True\nGreater-or-equal >= 4 >= 8 False\nEquality == 4 == 5 False\nInequality != 4 != 5 True\nThree notes:\n\u2022 As with arithmetic operators, use parentheses to indicate the order of operations.\n\u2022 The symbol for equality is two equal signs. This is to distinguish it from the assign-\nment operator. A common mistake is to have a line such as the following, which\nresults in the shown error message:\n>>> if b = 6:\nif b = 6:\n^\nSyntaxError: invalid syntax\nThis error vanishes if you use ==.\n\u2022 You can also apply these operators to characters and strings. The ordering used is\nalphabetic order, but capitals are always less than lower case characters. Here are\na few examples:\n>>> print \"a\" < \"c\"\nTrue\n>>> print \"Z\" < \"w\"\nTrue\n>>> print \"aardvark\" == \"crustacean\"\nFalse\n12.5.3 Logical Operators\nPython includes the logical operators (which we saw in a previous chapter) and, or, and\nnot. These are usually combined with relational operations, for example 196 CHAPTER 12. PYTHON REFERENCE\n(4 < 5) or (8 <= 2)\nis True. Here is a more elaborate example:\n(areaA * 5 >= areaB ** 3) and (not(areaA <=areaB))\nNote this expression can be rewritten as an equivalent expression without a not:\n(areaA * 5 >= areaB ** 3) and (areaA > areaB)\n12.6 Lists and Indexing\nIn our everyday life, we often deal with groups of items. So, not surprisingly, computer\nlanguages include ways to work with such collections. One of these is Python\u2019s list struc-\nture.\nAlistinPythonisasequenceofvaluesorelementsthatshareacommonnameandcan\nbeprocessedasaunit, butwhereeachelementcanalsobeaccessedandprocessedindivid-\nually. To indicate a list in Python, use square brackets, [ and ], around comma separated\nelements; forexample, hereisalistofnumbers: [1066, 1492, 1776], andalistofcolors:\n[\"red\", \"green\", \"blue\", \"white\", \"black\", \"cyan\", \"magenta\", \"yellow\"].\nThe items in the list can be any Python type, and you are allowed to mix types. For\nexample, [3.2, \"red\", False], which contains different types of data (a floating point\nnumber, a string, and a boolean value) is a valid Python list. Moreover, you can have\nlists of lists: [[11, 12, 13], [21, 22, 23]] can be thought of as a table with two rows\nand three columns.\nTo access an individual element in a list, use the list name along with the element\nposition. Let\u2019s suppose we set up the following list:\n>>> pieFlavors = [\"apple\", \"pumpkin\", \"blueberry\", \"cherry\", \"pear\"]\nAnd suppose further you want to access the first and third elements in the list. You can\ndo so as follows:\n>>> print pieFlavors[0], pieFlavors[2]\napple blueberry\nNote the syntax: the list name followed by a position number enclosed in square brackets.\nHowever, there is an obvious discrepancy here: we want to print out the first and third\nelements in the list, but we are supplying position numbers 0 and 2. Why?\nPython, like many computer languages, starts list indexing at 0, not 1. There are\nhistorical and practical reasons for this, but it is admittedly very confusing. So the first\nelement in the list has index or position 0, the second has index 1, and in general the\nith element has index i\u22121. The last (i.e., rightmost) element has index equal to the list\nlength minus one. For example, the pieFlavors list has 5 elements, so the index of the\nlast one, \"pear\", is 4. 12.7. INPUT\/OUTPUT 197\nWhat happens if you use an index that is not in the list? For instance, what will\npieFlavors[10] return, since there are not enough elements in the list? In this case,\nPython returns an error message:\n>>> print pieFlavors[10]\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nIndexError: list index out of range\nThere are a number of other useful things we can do with lists, some of which are\nexplained below, and some of which will appear in class examples.\nAs a final note in this section, indexing also works with strings and allows you to\naccess individual characters within the string. Here is an example:\n>>> currentColor = \"slateGrey34\"\n>>> print currentColor[0], currentColor[4], currentColor[9]\ns e 3\nAgain, remember the indices start at 0.\n12.7 Input\/Output\nThe pseudocode in other chapters had a get command, a way for algorithms to get input\nfrom the user (or from a file) as the algorithm was running. Similarly, the pseudocode\nhad a way to output information. It is reasonable to expect Python to have similar\ncapabilities. And indeed it does.\nWe\u2019ve already seen the simplest way Python outputs information: by using print. So\nprint \"This is a test\" prints that text string. Or print theaterLightCount prints\nthe value of the variable theaterLightCount.\nInput, however, is a little more complicated. If you think about input, you want to\nget the input and store it somewhere. So you will need to use an assignment statement.\nHere is an example of a user input line:\napplicantName = raw_input(\"Please input your surname: \")\nThe Python term raw_input tells Python that it should get input from the user. The text\nstring within the raw_input parentheses is a prompt the computer will print to indicate\nto the user that input is needed. Once the user inputs their surname, the computer stores\nit in the variable applicantName.\nBut there\u2019s one further complication: what type will the input be? In the example\nabove the input is obviously a string. But what if a program is working with apartment\nnumbers? You can probably think of some cases where the program would want to treat\nan apartment number as a text string, and some where it\u2019d want to treat it as an integer\n(and perhaps even some where it would want to treat it as a floating point number). More 198 CHAPTER 12. PYTHON REFERENCE\ngenerally suppose, for example, the user inputs 42. Is this supposed to be a text string?\nAn integer? A floating point number?\nBy default, Python considers the input as a text string. But what if you wanted 42 to\nbe treated as an integer? How do we tell this to Python? Like most languages Python has\nconversionfunctions. Tochangeastringtoanintegeryouusetheconversionfunctionint.\nTo change a string to a floating point number you use the conversion function float.5\nHere are some examples that include some input:\n>>> llamaCount = int(raw_input(\"Enter the number of llamas: \"))\nEnter the number of llamas: 5\n>>> llamaCount = llamaCount * 2\n>>> print llamaCount\n10\n>>> payRate = float(raw_input(\"Enter the current pay rate: \"))\nEnter the current pay rate: 12.25\n>>> payRate = payRate + 0.27\n>>> print payRate\n12.52\nOne common mistake is to forget that input lines like those above need two closing\nparentheses at their end: one to close raw_input and the second to close int or float.\n12.8 Control Structures\nThe chapter on pseudocode mentioned \u201csequence, selection, and repetition.\u201d Recall that\nsequence means executing statements in order, one after another. Selection means exe-\ncuting a statement or block of statements only if a given condition is true. And repetition\nmeans executing a statement or block of statements multiple times. Python has a number\nof control structures implementing sequence, selection, and repetition.\nThe most basic control structure, sequence, is to do one thing after another. This\nis represented in Python by the order of statements in the program text. Selection and\nrepetition have special keywords, however.\nNot surprisingly, selection in Python uses if and its variants. Here are examples:\nif elephantFoodSupply < elephantFoodNeeds:\nprint \"Order more elephant food\"\nif applePieNumber > cherryPieNumber and applePieNumber > pecanPieNumber:\nprint \"There are more apple pies\"\napplePieNumber = applePieNumber - 1\n5There is also a conversion function str that converts a number to a string. For example, sup-\npose apartmentNumber holds an integer value. Then the Python statement apartmentString =\nstr(apartmentNumber) takes that value, turns it into a text string, and places the result in the variable\napartmentString. 12.8. CONTROL STRUCTURES 199\nThe if statement takes a condition that evaluates to True or False. (Note, as in the\nsecond if statement, this can be a compound expression.) The condition is followed by a\ncolon. This is followed by the body of the if: an indented statement or set of statements\nthat will be executed if the condition is True.\nProblem 1: List some common errors a programmer might make in writing the code\nabove.\nAs with pseudocode, there are if variants. These include if-else, if-elif, and\nif-elif-else. Here are examples, starting with if-else:\nif applePieNumber > quincePieNumber:\nprint \"There are more apple pies.\"\napplePieNumber = applePieNumber - 1\nelse:\nprint \"There are at least as many quince pies.\"\nquincePieNumber = quincePieNumber - 1\nDepending on the relative values of applePieNumber and quincePieNumber this code will\nexecute one or the other block of indented statements. Note the form of the else: its\nindentation is the same as the if, there is a colon after the else keyword, and the lines\nto be executed for the else are indented.\nHere is another if variant, if-elif:\nif applePieNumber > quincePieNumber:\napplePieNumber = applePieNumber - 1\nelif quincePieNumber > 10:\nquincePieNumber = quincePieNumber - 1\nNote elif is short for else if. The elif is indented the same amount as the if, has a\nconditionfollowedbyacolon,andhasalineorblockoflinesthatwillbeexecutedwhenthe\nif condition is False and the elif statement is True. With an if-elif it is possible for\nthe if block of indented statements to be executed, the elif block of indented statements\nto be executed, or neither block of indented statements to be executed (if neither the if\nnor elif conditions are True).\nIt is possible to have multiple elifs, and\/or to combine an if-elif with a else: 200 CHAPTER 12. PYTHON REFERENCE\nif cardValue == 1:\nprint \"Ace\"\nelif cardValue == 2:\nprint \"Deuce\"\nelif cardValue == 13:\nprint \"King\"\nelif cardValue == 12:\nprint \"Queen\"\nelif cardValue == 11:\nprint \"Jack\"\nelif cardValue == 10:\nprint \"Ten\"\nelse:\nprint \"Other card\"\nNext we consider repetition structures. Python includes both while and for loops.\nWe begin with while loops, which are very similar to our pseudocode form. Here is an\nexample:\ni = 1\ncount = 0\nwhile i <= 100:\nif i % 2 == 0 or i % 3 = 0:\ncount = count + 1\ni = i + 1\nprint count\nThis code fragment will repeatedly execute the body of the while statement as long as the\ncondition in the while line is true. Specifically, it executes it for i = 1, 2, ..., 100\nand counts the number of such i that are divisible by 2 or 3 (or by both). Note the\nform of the while loop: the while keyword, followed by a condition, followed by a colon\n(don\u2019t forget the colon). Then the body of the loop consists of one or more indented\nstatements. Note in the example the while loop body includes an if statement, and so\ncount = count + 1 is therefore indented even further. The first statement after the end\nof the while loop body is indented at the same level as the while line.\nThe for statement provides a way to step through a number of items. One elegant\nexample is stepping through each item in a list, as in the following example:\nfor a in [1, 3, 6, 10]:\nprint a, a*a\nThe indented body of the statement is executed repeatedly, with the variable a taking on\nsuccessive values in the list. The output of this loop is 12.9. FUNCTIONS 201\n1 1\n3 9\n6 36\n10 100\nYou could actually write the while example above using the built-in range function:\ncount = 0\nfor i in range(1, 101):\nif i % 2 == 0 or i % 3 = 0:\ncount = count + 1\ni = i + 1\nprint count\nNote that range(a, b) produces a list of consecutive integers starting with a and ending\nwith b-1, not b.\nAnother useful built-in function, both in general and for use with loops, is len, which\nreturns the length of a list or string. Here is an example:\nx = \"Vertical\"\nfor i in range(0, len(x)):\nprint x[i]\nwill print\nV\ne\nr\nt\ni\nc\na\nl\nThis example shows one reason why it is useful for range(a, b) to go up to but not\ninclude b: since the list elements are indexed from 0 to the length minus 1, you can just\nwrite range(0, len(x)) rather than needing to include a -1 somewhere in the range\nexpression.\n12.9 Functions\nComputer languages allow you not only to use built-in functions, such as range and\nlen, but also to define and use your own functions. This is a very useful capability.\nFor example, one function of a payroll program might be to print checks. The steps 202 CHAPTER 12. PYTHON REFERENCE\nfor printing different checks will be the same other than, for example, printing different\namounts and recipients. Rather than writing different code for each different check it\nmakes sense to have a single check printing function along with some way to indicate the\nvalues, such as the check amount, that can vary.\nSince you have seen some built-in functions in examples above, you already know\nsomething about function use. Specifically, to call a function you use the function name,\nfollowed by an opening parenthese, followed by one or more arguments, followed by a\nclosing parenthese. The rules for function names are the same as those for variables.\nFor example, the name can contain alphabetic characters, digits, and the underscore, but\nmust start with an alphabetic character or an underscore.\nWhen using a function, you need to know how many arguments it takes. For example,\nlen takes a single argument that is a string or list. However, there are some functions\nthat can have different numbers of arguments. For example, range can take one, two, or\nthree arguments as the following example shows:\n>>> print range(4)\n[0, 1, 2, 3]\n>>> print range(2,4)\n[2, 3]\n>>> print range(2, 12, 3)\n[2, 5, 8, 11]\nFunction calls may be used as part of expressions, can appear more than once in an\nexpression, and can take the results of other functions as arguments, as shown in the\nfollowing example:\n>>> a = len(range(1,101,2)) + len(range(1,101,3))\n>>> print a\n84\nDefiningyourownfunctionisnotdifficult, butthereareafewrulestoremember. Let\u2019s\ndefine a simple function that takes two numbers a and b, squares each (i.e., multiples each\nby itself) and then adds the two results. This operation occurs often in mathematics; for\nexample it is part of the distance formula, appears in statistics formulas, etc. Here is the\nexample:\ndef sumsq (a, b):\na2 = a * a\nb2 = b * b\nreturn a2 + b2\nHere are the parts of the definition:\n\u2022 The define line. This starts with the keyword def, then has the function name (in\nthis case we have chosen sumsq), followed by the function parameters a and b that 12.9. FUNCTIONS 203\nare separated by commas and enclosed in parentheses, and the end-of-the-line colon\n(don\u2019t forget the colon).\n(A quick terminology clarification: the terms argument and parameters are some-\ntimes used interchangeably. We will use the convention that arguments are the\nvalues passed to the function through the function call, while parameters are the\nvariables in the function definition. So if we execute the line print sumsq(2,4)\nthen 2 and 4 are arguments that get assigned to the parameters a and b, respec-\ntively.)\n\u2022 The function body, which is indented and occurs after the define line. This is just\na sequence of Python statements that will be executed when the function is called.\n\u2022 Areturnstatementthattellswhatvalueorvaluestoreturntothecallingstatement.\nThe function above returns the numerical value that is the sum of the values of a2\nand b2. It is possible for a function to have more than one return statement as\nlong as only one is reached; for example, a function with an if-else statement may\nhave a return at the end of the if body and another at the end of the else body.\nIt is also possible for a function not to have any return statement. For instance, the\nfunction might just print a message and then end, at which point execution of the\nprogram resumes after the calling statement:\ndef printHurray(n):\nfor i in range(0, n):\nprint \"Hurray!\"\nWhen our sumsq function is called, we must supply it with two arguments that are\nmatchedwiththeparametersaandb. Forinstance, inthestatementprint sumsq(3, 5)\nthe argument 3 is matched with the parameter a, and the argument 5 is matched with b.\nThe function then executes the lines in its function body, and returns the value 34 to the\nstatement print sumsq(3,5), which then prints that value.\nProblem 2: It is possible to write sumsq more efficiently. See if you can write it as a two\nline function.\nThere is a special kind of function called a method that has its own syntax since it\nis closely associated with a Python structure. In our study of Python we will see a few\nuseful methods. For example, there is an append method for lists, whose use is illustrated\nby the following example:\n>>> treeList = [\"elm\", \"oak\", \"maple\"]\n>>> print treeList\n[\u2018elm\u2019, \u2018oak\u2019, \u2018maple\u2019]\n>>> treeList.append(\"ash\")\n>>> print treeList\n[\u2018elm\u2019, \u2018oak\u2019, \u2018maple\u2019, \u2018ash\u2019] 204 CHAPTER 12. PYTHON REFERENCE\nNote the syntax: the variable name is followed by a dot, followed by the method name,\nfollowed by the argument in parentheses. Here is another example that inserts gingko at\nindex 2 (so as the third item) in the list. This uses the insert method for lists.\n>>> treeList = [\"elm\", \"oak\", \"maple\"]\n>>> treeList.insert(2, \"gingko\")\n>>> print treeList\n[\u2018elm\u2019, \u2018oak\u2019, \u2018gingko\u2019, \u2018maple\u2019]\nThe notion of scope is important in computer programs. Function parameters and\nvariables defined in an indented function body are not accessible outside of the function.\nIn computer parlance, their scope is local to the function definition. Here is an example:\n>>> def treeAdd(newTree):\n... standardTreeList = [\"oak\", \"maple\", \"elm\"]\n... standardTreeList.append(newTree)\n... return standardTreeList\n...\n>>> print treeAdd(\"gingko\")\n[\u2018oak\u2019, \u2018maple\u2019, \u2018elm\u2019, \u2018gingko\u2019]\n>>> print standardTreeList\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: name \u2018standardTreeList\u2019 is not defined\nLet\u2019s take a moment to examine this example. The first few lines are the definition of\nthe treeAdd function. Once that is complete, the print line outputs the result when the\nfunction is called with the argument \"gingko\". This works fine, it is just regular function\nusage. However, the next line causes an error. The problem is standardTreeList is\ndefined within the function treeAdd and so it cannot be accessed outside that function.\nAnother way of putting this is that the value of standardTreeList is being passed back\nfrom the function in the next-to-last line, but the variable itself (its name in particular)\nis not accessible outside the function.\nIt is actually possible to have different variables with the same name in different parts\nof a program as long as their scopes do not overlap. For example, a commonly used\nvariable name such as n might represent a maximum possible value in many different\nfunctions in a program, in each case being local in scope to the function. This is very\ndesirable for large projects: otherwise there would be both a profusion of awkward names,\nandtherewouldneedtobescrupulouscarethatthesamenameswerenotusedfordifferent\nvariables. 12.10. LIBRARIES 205\n12.10 Libraries\nMost computer languages also include libraries or modules of items that, while sometimes\nused, are not used frequently. For example, Python contains a math module of useful data\nand functions. Here is a quick example:\nimport math\nradius = 10.0\ncircumference = math.pi * radius\nedge1 = 14.0\nedge2 = 15.0\nprint math.sqrt(edge1 * edge1 + edge2 * edge2)\nNote two important points:\n\u2022 Before using data or a function in a module, you must let Python know you plan to\nuse it. You do this by having a line starting with the import keyword followed by\nthe module name.\n\u2022 To use a value or function defined in a module, Python needs to know the module\nthat defines the value, and the name of the value, separated by a period. In this\ncase, the math module provides a value named pi, as well as a function named sqrt.\n(Remember the discussion above about method syntax.)\nProblem 3: Rewrite the code fragment above using the sumsq function from earlier in\nthis chapter.\n12.11 Comments and Line Continuation\nComments, indicated by a pound character #, are used in programming to add notes\nfor humans to read.6 They are not part of the program execution, and do not alter the\nbehavior of the program; Python ignores them. The comment can span just part of a\nline (the last part, after the pound sign), or an entire line. If you have a long, multiline\ncomment start each line with a pound sign.\nAnother useful character in making programs more readable and understandable is\nthe line continuation character, which in Python is the backslash \\. The following two\nexamples are equivalent:\na = 10\nb = 20\nprint \"The first value is \", a * a, \" and the second is \", b * b\n6Comments are often presented as being for \u201cothers\u201d to read, but they are also useful for the code\u2019s\nauthor, as reflected in Eagleson\u2019s Law: \u201cAny code of your own that you haven\u2019t looked at for six or more\nmonths might as well have been written by someone else.\u201d 206 CHAPTER 12. PYTHON REFERENCE\nand\na = 10\nb = 20\nprint \"The first value is \", a * a, \\\n\" and the second is \", b * b\nPython ignores the backslash-newlines and combines the lines before printing them. So\nboth the above print:\nThe first value is 100 and the second is 400\nWhen a line has a long string in it, it is useful to split the string into two strings,\neach on different lines, rather than putting the continuation character in the middle of\na string. This allows indenting the continuation of the line, which is useful to make the\nprogram readable. Compare the three print statements:\n>>> print \"It was the best of times; it was the worst \\\n... of times\"\nIt was the best of times; it was the worst of times\n>>> print \"It was the best of times; it was the worst\",\\\n... \"of times.\"\nIt was the best of times; it was the worst of times.\n>>> print \"It was the best of times; it was the worst\", \\\n... \"of times.\"\nIt was the best of times; it was the worst of times.\n12.12 More About Lists\nBeing able to work with collections of data as a single entity, rather than as a number of\ndisparate elements, is a powerful feature of programming languages. This section contains\na few examples of helpful shortcuts for tasks such as initializing lists, scaling each item in\na list, etc.\nThe example below first initializes a list to contain 31 entries with value 0, asks the\nuser to input numbers, counts how many times certain numbers occur and updates the\nlist accordingly, and prints out the count in two different ways. Notice the use of the\nfollowing constructs:\n\u2022 Initializing a long list using range.\n\u2022 Accessing a list element using [ and ].\n\u2022 Usingasublist: hist[a:b]isthesublistofitemshist[a],hist[a+1],...,hist[b-1].\nNote it includes hist[b-1], but not hist[b]. 12.13. RANDOM NUMBERS 207\n\u2022 Getting a list length using len.\n\u2022 Stepping through a list using range and len.\n# Set up a list of 31 zeros.\nhist = [0 for i in range(0, 31)]\n# Count number of times each valid input value occurs.\np = int(raw_input(\"Enter a number\", \\\n\" between 0 and 30 (-1 to exit): \"))\nwhile (p != -1):\nif (p >= 0 and p <= 30):\n# Add 1 to the count for p\nhist[p] = hist[p] + 1;\np = int(raw_input(\"Enter a number\", \\\n\" between 0 and 30 (-1 to exit): \"))\n# Printout 1: counts, maximum of 10 per row.\nprint hist[0:10]\nprint hist[10:20]\nprint hist[20:30]\nprint hist[30:31]\n# Printout 2: 1 count per row along with index i\nfor i in range(0, len(hist)):\nprint i, hist[i]\n12.13 Random Numbers\nThe random module is another useful Python module. It can be used in simulating card\ngames, lines in a grocery store, traffic in a transportation simulation, the spread of a\ndisease in an epidemiological simulation, etc. Here is a short code fragment illustrating\nthreeimportantitemsforusingrandomnumbers: importingtherandommodule, usingthe\nrandom.randrange function to get a random number in a discrete range of possibilities,\nand using the random.random function for generating a random floating point number.\nimport random\nfourCount = 0\nfor i in range(0,100):\nif random.randrange(1,7) == 4:\nfourCount = fourCount + 1\nprint \"There were \", fourCount, \"4\u2019s in 100 dice rolls.\"\nr = random.random() * 180 + 32 208 CHAPTER 12. PYTHON REFERENCE\nThe random.randrange(a, b) functions generates an integer between a and b-1 inclu-\nsive, with each choice being equally likely. The random.random function generates a\nfloating point number between 0.0 and 1.0. Note the program above first scales this range\nto between 0.0 and 180.0, and then adds 32 so the final range is between 32.0 and 212.0.\nProblem 4: Write a Python expression to generate a random floating-point number in\nthe range [\u22125,5] and to store that number in the variable d.\n12.14 Examples\nHere are two complete examples, illustrating many of the constructs described above.\n# Example 1\ndef gcd(a, b):\n# The GCD of anything and 0 is 0\nif a == 0:\nreturn b\n# Compute the GCD of a and b\nwhile b != 0:\nif a > b:\na = a - b\nelse:\nb = b - a\nreturn a\n# Example 2\nimport random\nnumberOfHands = int(raw_input(\"How many hands to deal? \"))\nfor i in range(numberOfHands):\nfourCardHand = []\nfor j in range(4):\nfourCardHand.append(random.randrange(1, 14))\naceCount = 0\nfor j in fourCardHand:\nif j == 1:\naceCount = aceCount + 1\nprint \"There were \", aceCount, \" aces in the hand.\"\nprint \"All hands counted.\" 12.15. PROBLEM SOLUTIONS 209\n12.15 Problem Solutions\nProblem 1: Thereareanumberofpossibilitiesincludingforgettingthecolons, mistyping\nthe variable names, and using incorrect indentation.\nProblem 2: Here is a two line version:\ndef sumsq (a, b):\nreturn (a * a) + (b * b)\nProblem 3: Replace the last line with\nprint math.sqrt(sumsq(edge1, edge2))\nProblem 4: Here is one possibility:\nd = (random.random() * 10.0) - 5.0\n12.16 More About Using the Python Interpreter\nAs explained at the start of this chapter, to use Python on the CSE lab machines, you can\ntype python after opening a terminal window. This should put you in the interpreter, and\nyou should see a >>> prompt. (If this doesn\u2019t work, see a TA.) At the Python prompt\nyou can type in Python commands.\nIf you have a file consisting of one or more user-defined functions, you can use them\nin the interpreter by using the import command. Suppose you have a function called\ncoinFlip(n) which you wrote, which takes a positive integer as input, and which is in a\nfile ex01.py; then typing\n>>> import ex01\n>>> ex01.coinFlip(100)\nruns the function with n = 100.\nIf you have a complete program \u2014 not just a function or group of functions \u2014 and\nwish to run it from inside the interpreter, then you can use the import or execfile\ncommand. Here is an example of running a program helloWorld.py that prints \u201cHello,\nworld\u201d:\n>>> import helloWorld\nHello, World\nHere is an example that uses the execfile command:\n>>> execfile(\"helloWorld.py\")\nHello, World 210 CHAPTER 12. PYTHON REFERENCE\nRemember, to exit the interpreter type Control-d, i.e., hit the \u2018d\u2019 key while pressing\ndown the control key at the same time.\nIf you have a program that you know is correct, then you can also execute it directly\nfrom the operating system command line: you can type python programName at the\nterminal window prompt to run it. Here\u2019s an example with a program ex02.py that\nprompts a user for a room length:\n% python ex02.py\nPlease enter room length in inches:\n...\nYou can actually do this as you develop a program: edit the program in one window, save\nit when you have a round of edits done, then run it in another terminal window.\n12.17 Additional Resources\nThere are a vast number of online resources for Python. The beginner materials at the\nofficial Python website, http:\/\/www.python.org, are particularly recommended. "}