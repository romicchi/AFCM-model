{"text":"Modules_1- Introduction to Databases Systems & SQL\n1.1 Introduction and Background\nHow were things managed before technology became a major influence in our lives? Tracking\ninformation was difficult before the employment of databases. There was plenty of room for error with the pen\nand paper method. It was not until the 1960s when databases were used from a computer-based format.\nHowever, most computerized databases still use the principles and methods developed in the previous age.\nDatabases now are used everywhere to store information. Whether it be in a customer management\nsystem or tracking bank information, databases are utilized to store the necessary data for later use. Data is\nstructured in rows and columns featuring different fields for queries and stored in multiple tables to showcase\nthe relationship between them. According to Oracle.com, \u201cDatabases have evolved dramatically since their\ninception in the early 1960s\u201d (Oracle). In the beginning, only navigational databases, such as the hierarchical\nand network database, were employed. As time went on, new types of databases were created based on the\nneeds of organizations and the management of their data.\nSource: https:\/\/www.smartsheet.com\/database-management\nIn the graph shown above, a database is used in a database management system (DBMS) for short, is a\nform of software that allows an organization to access and manipulate data that will be showcased in a form\nthat is unable to be changed by other applications and users.\n1.2 Limitations of Conventional File Processing\nFiles are used to store specific data for future use and recollection. When computers first became\nmainstream, files were stored like paper, in the form of flat files. This information was collected in notepads\nseparated by spaces, commas, semicolons or other symbols. Organization of files was often based on their\ncategories, consisting of only related information with specific names. The downside to this is that you were\nunable to open the files without using a specific coding language to edit it. While it appeared convenient at the\ntime, it is easy to identify the many disadvantages to using this system. 1.3 Data Redundancy\nOne of the major problems with this system was data redundancy and inconsistency. Since the files and\nprograms jammed into files were created by several different programmers over a long period of time, the files\nwere certain to be in different formats, involving several different programming languages. Most of the\ninformation is also constantly duplicated due to how tedious it would be to access others\u2019 code and double\ncheck the information. For example, if a customer of a bank has two accounts, the data accompanied by these\naccounts would be stored in two separate files in order to satisfy both accounts as they are made. This leads to\ndata redundancy. This would lead to bigger storage sizes for the same information, increasing the cost.\n1.4 Data Accuracy\nThe countless copies of this data could also have discrepancies, making it impossible to know which\ninformation is accurate. Whenever a new value needs to be entered into the database, every single file with\nthis data has to be updated to prevent this. This would lead to tedious work that wasn\u2019t 100% accurate in the\nend. For example, a company could have stored customer data, including name, address, and city. There could\nbe a request in which the record of a customer who lives in a specific city is needed. In order to achieve this, a\nnew program would need to be written and executed, and the file containing the customer's city had to be\naccessed. Every single customer who belonged to this city would need to be specifically selected and taken\nout into this new program in order to organize the data. This is neither convenient nor reliable. These copies\nalso contributed to the difficulty involving the creation of new applications, as they may be unable to find the\nappropriate data. This also ensured atomicity didn\u2019t work. Atomicity is a sequence of database processes such\nthat either all occur, or nothing occurs. This could be used to prevent updates to a database occurring only\npartially; however, atomicity is unable to work unless it is able to read and write to every single file, which in\nthis structure, is extremely difficult.\nThere was also a difficulty in accessing data due to the \u201cspaghetti code\u201d structure of this system. If a\nspecific set of information is needed to be organized in a new way, unless it was anticipated prior to the initially\nbeing created, it was nearly impossible to achieve this. The application needed to display the information in\nthe requested way would not have existed. This system doesn\u2019t allow data to be retrieved in a convenient\nmanner, leading to different systems created down the line.\nIntegrity problems were also created due to the data values in a database needing to satisfy certain types\nof consistency constraints. Since most of the code involving these files is in different languages, it is almost\nimpossible to change them all to enforce new constraints. The file system also lacks concurrent access. In\nmodern systems, multiple users can update the data simultaneously. This is to ensure a faster response time\nand to improve the overall performance of the system. The involvement of multiple users may result in\ninconsistent data, which is normally prevented using supervision. However, in a file processing system, this\nsupervision is lackluster due to the several applications and various languages. It all leads to the same problems\nin the end.\n1.5 Data Security\nSecurity is also a major issue in this system. In a database, every user in the database system shouldn\u2019t\nbe able to access all the data. Each user should be delegated and only allowed to access specific data requiring\na password of sorts. In a file processing system since different programmers add their own application, there\nis either a universal password or so many passwords that the information is scrambled and the people requiring\nit can\u2019t access it. Since every new file is only added when needed, it is difficult to constantly change the\npermission for each individual file in order to ensure security standards.\nThese disadvantages would lead many to convert to a database approach rather than a file system. A\ndatabase corrected many of these errors reducing the development time and increasing the data integrity of every file. It is true that file processing systems were full of many errors, but they are known as a stepping\nstone towards more perfected systems of data storage.\n1.6 Advantages of Databases\nIn today\u2019s world, data is prevalent in every aspect of our lives as human beings. Data is constantly\nbeing created, organized, and stored. With all this data being transferred and exchanged around the world, it is\nimportant to have an efficient and organized method to storing this data. This is where databases come in.\nDatabases offer improved efficiency and versatility, they allow categorization and structuring of available data,\nand they allow multi-user access, creating an organized work environment and newer and better ways to\nmanage data.\nEfficiency comes into play specifically with businesses. Databases can handle large amounts of data as\nwell as multiple types of data. Businesses can use databases to have data easily accessible to make operational\ndecisions on a daily basis.\nVersatility is also important in terms of accessing data. Databases can be accessed via desktop, laptop,\ntablet and even mobile devices. This is incredibly helpful in a time where so much importance is placed on\naccessing things immediately, as data can be easily retrieved at any moment. This benefit is applicable to\nconsumers as well as businesses.\nCategorization and organization are both major advantages. They allow the structuring of information\nin ways that are easily understandable and accessed. Certain DBMS allow relationships between entities in\norder to simplify the organization of data.\nSource: Liz Parody (Databases for Front-End Developers;Medium.com)\nAccessing data in a multitude of ways by multiple different users is also a huge advantage that databases\nhave; this is called multi-access. Multi-access is what allows multiple authorized users to have access to the\nsame data. For example, a human resources manager at a company will have access to the same set of potential\nhires at a certain location as the general manager of that same location. The picture below visually describes\nthe relationship between this shared data and the users that have access to it. (WD, 2005) Source: https:\/\/www.workingdata.co.uk\/spreadsheets-vs-databases-round-1-multi-user\/\nDatabases offer businesses a smoother operating work situation. The implementation of a database\nmanagement language such as SQL (Structured Query Language) allows businesses to access and modify data\nthat is stored in a relational database.\nDatabases are constantly being used and accessed in new ways. With all the advantages that databases\noffer, uses will continue to grow. The accessibility, versatility and efficiency that a database can provide when\npaired with a DBMS is the reason why so many successful businesses are using them to this day.\n1.7 Costs and Risks of Database Approach\nThere are obviously many advantages that benefit those who implement a database approach.\nOrganization, efficiency and structure are all some positive elements that can be attributed to the database\napproach. However, there is always give and take, and there are some risks and costs involved with the database\napproach as well.\nFor example, when you decide to implement a database system, you now require personnel who know\nhow to implement and maintain this system. This will most definitely be a significant cost that will be directly\nattributed to the implementation of the system. There also lies the cost in training individuals who may be new\nto your system that has already been implemented, and this will not be cheap either. The graph below illustrates\nthe cost one may be dealing with personnel-wise on an annual basis when implementing a Database system. Source: https:\/\/education.oracle.com\/oracle-dba-salaries-guide\nAnother significant cost of the Database approach is the cost of installation and maintenance. When\nimplementing a new database system, it is costly to pay personnel to install and operate it, especially if it is a\nlarge and complex database. Installation isn\u2019t where the cost stops; maintenance is needed in order to keep that\nsystem running, and as you want to expand and maintain, over time, you will require additional hardware. The\nchart below displays the different costs of operating a given datacenter per month.\nSource: https:\/\/www.researchgate.net\/figure\/Monthly-costs-of-the-data-center_fig3_258385511 One must also account for the cost of migration: the cost to transfer the data and functionality of the\nprevious file system over to the new database system accurately and without loss. It may seem as though it is\na simple concept, but it is very difficult in a lot of cases and thus costs a substantial amount of money and time\nto execute.\nThere are also the costs and risks involved in needing specific backup and recovery systems. In a shared\ncorporate database, there will be large amounts of data being stored. However, there must be backup data in\ncase of software, hardware, or human error. If the data is not backed up, depending on the use of the database,\nthe results could be catastrophic.\nLastly, there is organizational conflict. When implementing a large database with large complexity, it\nis common for people within the organization to have opposing views on how the data should be stored and\nhow the system should be running. The costs and risks here lie in hiring strong leadership. In order to reach\nagreements on data definitions and how responsibilities are delegated for accurate data maintenance, the\nleadership must be strong and defined.\n1.8 Components of a Database Environment\nA database environment has 5 major components for functionality. The components necessary are:\npeople, hardware, software, data, and procedures (OwlGen, 2019).\nSource:http:\/\/cdn.wagmob.com\/subject\/G124\/html\/introduction00to00dbms_1.html When it comes to people, there are different roles needed to help build the overall database\nenvironment. These roles would include but are not limited to system and database administrators, database\ndesigners, programmers, analysts, and end users (OwlGen, 2019).\nThe system administrator is in charge of setting up and managing the system and server. They are\nneeded to make sure there are no server crashes or any missing information within the database (Gite, 2014).\nDatabase administrators ensure the physical database is working properly through monitoring the performance\nand also managing security access and other standards (\u201cWhat are the functions of a database administrator\u201d).\nDatabase designers and programmers code all queries, relationships, and data and make sure they are stored\nproperly within the database management system. Analysts review all the data the designers and programmers\nhave implemented. Finally, end users are the ones that utilize the database management system and make the\nsystem more usable for other users.\nHardware and software are the items that make the database environment come to life. Hardware\nincludes the actual computer itself and any sort of networking components needed. Software includes the\noperating system and any sort of programs needed to build and administer the database (OwlGen, 2019).\nFinally, data and procedures go hand in hand. Data includes things like the actual database needed to\nfunction in the environment as well as any business procedures and\/or rules that manage the system. The\nprocedures are implemented to structure the overall design on how the database should work and regulate all\nthe data that should be going in and coming out of the database (OwlGen, 2019).\n1.9 Database Systems Development Life Cycle\nThe database life cycle (DBLC) consists of\nsix phases. These phases include database primary\nstudy planning, analysis, detailed System design,\n(prototyping), implementation and loading, testing\nand evaluation, operation, maintenance and\nevolution.\nIn the database primary study, the researcher\nexamines the current systems operations in the\ncompany to determine how and why the current\nsystem isn\u2019t sustainable. The objective of this study\nis to analyze the company status, define problems\nand constraints, define purpose, and define the\nscope and boundaries. Each section can be broken\ndown in order to further understand the usefulness\nbehind creating this study.\nThe Database Life Cycle (DBLC) Analyzing the company Pertains to defining the general conditions within a company, including its\nsituation organization structure and its mission. In order to correctly do this, the\ndesigner must discover what the company\u2019s operation components are, the\nway they function, and how they interact.\nDefining Problems and Pertains to the discovery of issues within the company, formally and\nConstraints informally. These problems may appear unstructured; however, problems are\nusually connected, allowing the designer to overcome them by the end of the\nprocess.\nDefining Objectives Is a part of the new proposed database system showing that it is designed to\nsolve the major problems identified previously?\nDefining the Scope and Pertains to the engineer recognizing the existence of their limits: scope and\nBoundaries boundaries. The system\u2019s scope shows the extent of the design according to\nthe requirements. The system also is connected to limits known as boundaries\nwhich are external. These boundaries are set by the accompanying hardware\nand software.\nDatabase design is the second phase focusing on the design of the database\nthat supports company operations and objectives in the future. This can be\nviewed as the most critical DBLC phase.\nImplementation and Pertain to a series of instructions when dealing with the creation of tables,\nLoading attributes, etc. in the domain. In this phase, the design specifications are\ninstalled, creating the exact database required by the parent company. This\ncan be done in 3 phases.\nInstall the DBMS Installing a new instance of a DBMS in the system on a server.\nCreating the DBMS Creates the table spaces and file groups accompanied by the database.\nLoading and Converting After the database is created, the data must enter the new tables. This\nData requires them to be merged and imported from other databases or the ones\npreviously used in order to ensure the same data is relayed into the newer,\nbetter system.\nTesting and evaluation pertain to the decision made to ensure integrity,\nsecurity, performance, and recoverability of the database. Following the plans\nlaid out previously, this fine-tunes the database to ensure that it performs as\nexpected. This phase is also divided into three phases, making it easy to\nfollow and accurately test the functionality of the database.\nTest the Database During this step, the database is tested to ensure it has the integrity and\nsecurity required by the company. This is enforced through the proper use of\nprimary and foreign key rules.\nFine-Tune the Database This is the editing of the database with the results of the previous step in\nmind. If no fine-tuning is required, this step can be skipped.\nEvaluating the Database The database must be reviewed thoroughly to ensure that the data contained\nis protected against loss, promoting the use of a backup.\nOperation The second to last step identifying that the database is fully functional. At this\npoint, the database is complete, and the new system has space to evolve as\nneeded by the developers. Maintenance and Evolution The final step. This step is directed by the database administrator allowing\nthem to perform routine maintenance activities regarding the database. Some\nof these activities include Backup, Corrected Maintenance, Adaptive\nMaintenance and the Assignment of access permissions to welcome new\nusers and edit old users.\nAll together these steps make up the Database Life cycle and ensure that a fully functional database is\ncreated, allowing for around the clock maintenance within the company and promoting a highly efficient\nsystem the meets the guidelines presented at the beginning of the process.\n1.10 A Database and its Data Relationships\nDatabase tables are structured to store data, but a database is not complete unless it also shows the\nrelationships among the tables. To see why this is important, examine Figure 1-4 below (Kroenke, Auer,\nVandenberg, Yoder, 2018) the database includes all of the basic data shown together with a GRADE table.\nUnfortunately, the relationships among the data are missing.\nIn this format, the GRADE data are useless. It would be the equivalent to a sports commentator who\nsimply announced: \u201cNow for tonight\u2019s baseball scores: 2\u20133, 7\u20132, 1\u20130, and 4\u20135.\u201d The scores are useless without\nknowing the teams that earned them. Thus, a database contains both data and the relationships among the data.\nThis demonstrates is imperative characteristic of database processing. Each row in a table is distinctively\nidentified by a primary key, and the values of these keys are used to create the relationships between the tables.\nFor example, in the STUDENT table StudentNumber serves as the primary key. Each value of StudentNumber\nis unique and identifies a particular student. Thus, StudentNumber 1 identifies Sam Cooke. For example,\nClassNumber in the CLASS table identifies each class. If the numbers used in primary key columns such as\nStudentNumber and ClassNumber are repeatedly created and assigned in the database itself, then the key is also\ncalled a surrogate key (Kroenke, Auer, Vandenberg, Yoder, 2018).\nFigure 1-1: Sample Microsoft Access Student Record\nFigure 1-2 shows each row in a table in specifically known by a primary key, and value of those keys\nthat are used to create a relationship between the tables, such as student IDNumber (primary key). If the\nnumbers used StudentNumber and ClassNumber column and generate and assigned in the database, then the\nkey is also called a surrogate key.\nFigure 1-2 The Primary key and Surrogate key In the table below shows when more than one column in a table are merged to form of the primary key,\nis known as a composite key. In the GRADE column, StudentNumber and ClassNumber each now serve as a\nforeign key. A foreign key provides a relationship or link between two tables. Figure 1-3 shows a Microsoft\nAccess 2016 point of view of the tables and their relationships.\nStudentNumber Table\nClassNumber Table\nFigure 1-3: The Grade table with foreign keys \u2013 link to Student ClassNumber Table\nSingle-User and Multi-user Database Applications\nFigure 1-4 shows the greater database application, part of a customer relationship management\n(CRM) system, which manages customers and their contacts, purchases, support requests, and so forth. The\nCRM system uses software to support a larger company, which may include anywhere from 500 rows to 10\nmillion or more.\nAn enterprise resources planning (ERP) system is an information system that affects every\ndepartment in a company, including sales, inventory, planning purchasing and other business purposes. SAP\n(System, Applications & Products in Data Processing) is the vendor used with ERP applications for large\ncompanies. Figure 1-4 shows a larger database application\nWhat is Microsoft Access?\nMicrosoft Access is not just a database management system (DBMS) but is also a personal database\nsystem. Microsoft Access is a combination of the relational Microsoft Jet Database engine with a graphical\nuser interface (GUI) and software-development tools.\nMicrosoft Access is one of the office suites that is intended for individuals and small works groups such\nas interact with application through data entry process forms, generate reports, run the queries.\n1.11 - Concise Summary:\nDatabases are the foundation of structuring data. When they were first implemented in the 1960s, data\nbecame easier to manage and structure. A database is now necessary to hold and manage user data and other\npersonal information. Organizations utilize a database management system, or DBMS, for manipulating and\nstoring the data into the databases while also managing the relationships between the data itself.\nAs computers and other technology began to become introduced, it became much simpler to manage\ndata and store it in the DBMS. A database has many advantages, including efficiency, versatility,\ncategorization, and organization to name a few. However, there are associated costs and risks to databases.\nThe organization is now required to put funding towards training employees in managing and updating the\nDBMS as well as for general upkeep of the management system in order for it to remain stable. Various\ncomponents of the DBMS to enable this include the people, the hardware, the software, the data itself, and the\nprocedures needed to keep the database organized and well managed.\nFinally, the life cycle of the database can be defined by six main phases: database initial study, database\ndesign, implementation and loading, testing and evaluation, operation, and maintenance and evolution. It is\nimportant to consider what needs to be implemented in a database, but also what role it can play for based on\nthe needs of the organization "}