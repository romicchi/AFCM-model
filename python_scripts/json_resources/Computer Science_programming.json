{"text":"Contents\nCopyleft (Copyright) i\nDraft Notice iii\nPreface v\nAcknowledgements ix\n1. Introduction 1\n1.1. Problem Solving . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n1.2. Computing Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n1.3. Basic Program Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n1.4. Syntax Rules & Pseudocode . . . . . . . . . . . . . . . . . . . . . . . . . 12\n1.5. Documentation, Comments, and Coding Style . . . . . . . . . . . . . . . 14\n2. Basics 17\n2.1. Control Flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n2.1.1. Flowcharts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n2.2. Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n2.2.1. Naming Rules & Conventions . . . . . . . . . . . . . . . . . . . . 19\n2.2.2. Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\n2.2.3. Declaring Variables: Dynamic vs. Static Typing . . . . . . . . . . 31\n2.2.4. Scoping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n2.3. Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\n2.3.1. Assignment Operators . . . . . . . . . . . . . . . . . . . . . . . . 33\n2.3.2. Numerical Operators . . . . . . . . . . . . . . . . . . . . . . . . . 35\n2.3.3. String Concatenation . . . . . . . . . . . . . . . . . . . . . . . . . 37\n2.3.4. Order of Precedence . . . . . . . . . . . . . . . . . . . . . . . . . 38\n2.3.5. Common Numerical Errors . . . . . . . . . . . . . . . . . . . . . . 38\n2.3.6. Other Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . 40\n2.4. Basic Input\/Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41\n2.4.1. Standard Input & Output . . . . . . . . . . . . . . . . . . . . . . 42\n2.4.2. Graphical User Interfaces . . . . . . . . . . . . . . . . . . . . . . . 42\n2.4.3. Output Using printf()-style Formatting . . . . . . . . . . . . . 43\n2.4.4. Command Line Input . . . . . . . . . . . . . . . . . . . . . . . . . 44\nxi Contents\n2.5. Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46\n2.5.1. Types of Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46\n2.5.2. Strategies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49\n2.6. Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50\n2.6.1. Temperature Conversion . . . . . . . . . . . . . . . . . . . . . . . 50\n2.6.2. Quadratic Roots . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n2.7. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n3. Conditionals 65\n3.1. Logical Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n3.1.1. Comparison Operators . . . . . . . . . . . . . . . . . . . . . . . . 66\n3.1.2. Negation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68\n3.1.3. Logical And . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69\n3.1.4. Logical Or . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70\n3.1.5. Compound Statements . . . . . . . . . . . . . . . . . . . . . . . . 71\n3.1.6. Short Circuiting . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74\n3.2. The If Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75\n3.3. The If-Else Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76\n3.4. The If-Else-If Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . 78\n3.5. Ternary If-Else Operator . . . . . . . . . . . . . . . . . . . . . . . . . . . 82\n3.6. Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82\n3.6.1. Meal Discount . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82\n3.6.2. Look Before You Leap . . . . . . . . . . . . . . . . . . . . . . . . 83\n3.6.3. Comparing Elements . . . . . . . . . . . . . . . . . . . . . . . . . 84\n3.6.4. Life & Taxes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85\n3.7. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87\n4. Loops 95\n4.1. While Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97\n4.1.1. Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98\n4.2. For Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99\n4.2.1. Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100\n4.3. Do-While Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100\n4.4. Foreach Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102\n4.5. Other Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n4.5.1. Nested Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n4.5.2. Infinite Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n4.5.3. Common Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105\n4.5.4. Equivalency of Loops . . . . . . . . . . . . . . . . . . . . . . . . . 106\n4.6. Problem Solving With Loops . . . . . . . . . . . . . . . . . . . . . . . . . 106\n4.7. Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107\n4.7.1. For vs While Loop . . . . . . . . . . . . . . . . . . . . . . . . . . 107\n4.7.2. Primality Testing . . . . . . . . . . . . . . . . . . . . . . . . . . . 108\n4.7.3. Paying the Piper . . . . . . . . . . . . . . . . . . . . . . . . . . . 109\nxii Contents\n4.8. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111\n5. Functions 133\n5.1. Defining & Using Functions . . . . . . . . . . . . . . . . . . . . . . . . . 134\n5.1.1. Function Signatures . . . . . . . . . . . . . . . . . . . . . . . . . . 134\n5.1.2. Calling Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 136\n5.1.3. Organizing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137\n5.2. How Functions Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137\n5.2.1. Call By Value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140\n5.2.2. Call By Reference . . . . . . . . . . . . . . . . . . . . . . . . . . . 140\n5.3. Other Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142\n5.3.1. Functions as Entities . . . . . . . . . . . . . . . . . . . . . . . . . 142\n5.3.2. Function Overloading . . . . . . . . . . . . . . . . . . . . . . . . . 144\n5.3.3. Variable Argument Functions . . . . . . . . . . . . . . . . . . . . 145\n5.3.4. Optional Parameters & Default Values . . . . . . . . . . . . . . . 145\n5.4. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146\n6. Error Handling 151\n6.1. Error Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153\n6.2. Error Handling Strategies . . . . . . . . . . . . . . . . . . . . . . . . . . 153\n6.2.1. Defensive Programming . . . . . . . . . . . . . . . . . . . . . . . 153\n6.2.2. Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155\n6.3. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n7. Arrays, Collections & Dynamic Memory 159\n7.1. Basic Usage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160\n7.2. Static & Dynamic Memory . . . . . . . . . . . . . . . . . . . . . . . . . . 162\n7.2.1. Dynamic Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . 164\n7.2.2. Shallow vs. Deep Copies . . . . . . . . . . . . . . . . . . . . . . . 166\n7.3. Multidimensional Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . 166\n7.4. Other Collections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167\n7.5. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168\n8. Strings 177\n8.1. Basic Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177\n8.2. Comparisons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178\n8.3. Tokenizing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179\n8.4. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179\n9. File Input\/Output 183\n9.1. Processing Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183\n9.1.1. Paths . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184\n9.1.2. Error Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185\n9.1.3. Buffered and Unbuffered . . . . . . . . . . . . . . . . . . . . . . . 187\nxiii Contents\n9.1.4. Binary vs Text Files . . . . . . . . . . . . . . . . . . . . . . . . . 187\n9.2. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188\n10.Encapsulation & Objects 197\n10.1.Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198\n10.1.1. Defining . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198\n10.1.2. Creating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199\n10.1.3. Using Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200\n10.2.Design Principles & Best Practices . . . . . . . . . . . . . . . . . . . . . 200\n10.3.Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201\n11.Recursion 203\n11.1.Writing Recursive Functions . . . . . . . . . . . . . . . . . . . . . . . . . 204\n11.1.1. Tail Recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205\n11.2.Avoiding Recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206\n11.2.1. Memoization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208\n11.3.Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209\n12.Searching & Sorting 211\n12.1.Searching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211\n12.1.1. Linear Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212\n12.1.2. Binary Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213\n12.1.3. Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215\n12.2.Sorting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220\n12.2.1. Selection Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221\n12.2.2. Insertion Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224\n12.2.3. Quick Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227\n12.2.4. Merge Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232\n12.2.5. Other Sorts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237\n12.2.6. Comparison & Summary . . . . . . . . . . . . . . . . . . . . . . . 237\n12.3.Searching & Sorting In Practice . . . . . . . . . . . . . . . . . . . . . . . 238\n12.3.1. Using Libraries and Comparators . . . . . . . . . . . . . . . . . . 238\n12.3.2. Preventing Arithmetic Errors . . . . . . . . . . . . . . . . . . . . 239\n12.3.3. Avoiding the Difference Trick . . . . . . . . . . . . . . . . . . . . 241\n12.3.4. Importance of a Total Order . . . . . . . . . . . . . . . . . . . . . 242\n12.3.5. Artificial Ordering . . . . . . . . . . . . . . . . . . . . . . . . . . 242\n12.3.6. Sorting Stability . . . . . . . . . . . . . . . . . . . . . . . . . . . 243\n12.4.Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244\n13.Graphical User Interfaces & Event Driven Programming 247\n14.Introduction to Databases & Database Connectivity 249\nxiv Contents\nI. The C Programming Language 251\n15.Basics 253\n15.1.Getting Started: Hello World . . . . . . . . . . . . . . . . . . . . . . . . 253\n15.2.Basic Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254\n15.2.1. Basic Syntax Rules . . . . . . . . . . . . . . . . . . . . . . . . . . 255\n15.2.2. Preprocessor Directives . . . . . . . . . . . . . . . . . . . . . . . . 255\n15.2.3. Comments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258\n15.2.4. The main() Function . . . . . . . . . . . . . . . . . . . . . . . . 259\n15.3.Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260\n15.3.1. Declaration & Assignment . . . . . . . . . . . . . . . . . . . . . . 260\n15.4.Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262\n15.5.Basic I\/O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263\n15.6.Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 265\n15.6.1. Converting Units . . . . . . . . . . . . . . . . . . . . . . . . . . . 265\n15.6.2. Computing Quadratic Roots . . . . . . . . . . . . . . . . . . . . . 267\n16.Conditionals 271\n16.1.Logical Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271\n16.1.1. Order of Precedence . . . . . . . . . . . . . . . . . . . . . . . . . 273\n16.1.2. Comparing Strings and Characters . . . . . . . . . . . . . . . . . 273\n16.2.If, If-Else, If-Else-If Statements . . . . . . . . . . . . . . . . . . . . . . . 274\n16.3.Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 276\n16.3.1. Computing a Logarithm . . . . . . . . . . . . . . . . . . . . . . . 276\n16.3.2. Life & Taxes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277\n16.3.3. Quadratic Roots Revisited . . . . . . . . . . . . . . . . . . . . . . 279\n17.Loops 283\n17.1.While Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283\n17.2.For Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 285\n17.3.Do-While Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 285\n17.4.Other Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286\n17.5.Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287\n17.5.1. Normalizing a Number . . . . . . . . . . . . . . . . . . . . . . . . 287\n17.5.2. Summation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287\n17.5.3. Nested Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 288\n17.5.4. Paying the Piper . . . . . . . . . . . . . . . . . . . . . . . . . . . 288\n18.Functions 291\n18.1.Defining & Using Functions . . . . . . . . . . . . . . . . . . . . . . . . . 291\n18.1.1. Declaration: Prototypes . . . . . . . . . . . . . . . . . . . . . . . 291\n18.1.2. Void Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293\n18.1.3. Organizing Functions . . . . . . . . . . . . . . . . . . . . . . . . . 294\n18.1.4. Calling Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 294\nxv Contents\n18.2.Pointers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 295\n18.2.1. Passing By Reference . . . . . . . . . . . . . . . . . . . . . . . . . 297\n18.2.2. Function Pointers . . . . . . . . . . . . . . . . . . . . . . . . . . . 300\n18.3.Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301\n18.3.1. Generalized Rounding . . . . . . . . . . . . . . . . . . . . . . . . 301\n18.3.2. Quadratic Roots . . . . . . . . . . . . . . . . . . . . . . . . . . . 303\n19.Error Handling 305\n19.1.Language Supported Error Codes . . . . . . . . . . . . . . . . . . . . . . 305\n19.1.1. POSIX Error Codes . . . . . . . . . . . . . . . . . . . . . . . . . 306\n19.2.Error Handling By Design . . . . . . . . . . . . . . . . . . . . . . . . . . 308\n19.3.Enumerated Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309\n19.4.Using Enumerated Types for Error Codes . . . . . . . . . . . . . . . . . 310\n20.Arrays 313\n20.1.Basic Usage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313\n20.2.Dynamic Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 316\n20.3.Using Arrays with Functions . . . . . . . . . . . . . . . . . . . . . . . . . 318\n20.4.Multidimensional Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . 319\n20.4.1. Contiguous 2-D Arrays . . . . . . . . . . . . . . . . . . . . . . . . 322\n20.5.Dynamic Data Structures . . . . . . . . . . . . . . . . . . . . . . . . . . 324\n21.Strings 325\n21.1.Character Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325\n21.2.String Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327\n21.3.Arrays of Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330\n21.4.Comparisons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331\n21.5.Conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332\n21.6.Tokenizing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333\n22.File I\/O 335\n22.1.Opening Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 335\n22.2.Reading & Writing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336\n22.2.1. Plaintext Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336\n22.2.2. Binary Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 338\n22.3.Closing Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339\n23.Structures 341\n23.1.Defining Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 341\n23.1.1. Alternative Declarations . . . . . . . . . . . . . . . . . . . . . . . 342\n23.1.2. Nested Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . 343\n23.2.Usage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 344\n23.2.1. Declaration & Initialization . . . . . . . . . . . . . . . . . . . . . 344\n23.2.2. Selection Operators . . . . . . . . . . . . . . . . . . . . . . . . . . 346\nxvi Contents\n23.3.Arrays of Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 348\n23.4.Using Structures With Functions . . . . . . . . . . . . . . . . . . . . . . 351\n23.4.1. Factory Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 353\n23.4.2. To String Functions . . . . . . . . . . . . . . . . . . . . . . . . . . 354\n23.4.3. Passing Arrays of Structures . . . . . . . . . . . . . . . . . . . . . 355\n24.Recursion 357\n25.Searching & Sorting 361\n25.1.Comparator Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\n25.2.Function Pointers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 365\n25.3.Searching & Sorting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 372\n25.3.1. Searching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 372\n25.3.2. Sorting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 374\n25.3.3. Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 374\n25.4.Other Considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 377\n25.4.1. Sorting Pointers to Elements . . . . . . . . . . . . . . . . . . . . . 377\nII. The Java Programming Language 381\n26.Basics 383\n26.1.Getting Started: Hello World . . . . . . . . . . . . . . . . . . . . . . . . 384\n26.2.Basic Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 385\n26.2.1. Basic Syntax Rules . . . . . . . . . . . . . . . . . . . . . . . . . . 385\n26.2.2. Program Structure . . . . . . . . . . . . . . . . . . . . . . . . . . 386\n26.2.3. The main() Method . . . . . . . . . . . . . . . . . . . . . . . . . 389\n26.2.4. Comments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 389\n26.3.Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 390\n26.3.1. Declaration & Assignment . . . . . . . . . . . . . . . . . . . . . . 391\n26.4.Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393\n26.5.Basic I\/O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 395\n26.6.Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 396\n26.6.1. Converting Units . . . . . . . . . . . . . . . . . . . . . . . . . . . 396\n26.6.2. Computing Quadratic Roots . . . . . . . . . . . . . . . . . . . . . 400\n27.Conditionals 403\n27.1.Logical Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 403\n27.1.1. Order of Precedence . . . . . . . . . . . . . . . . . . . . . . . . . 405\n27.1.2. Comparing Strings and Characters . . . . . . . . . . . . . . . . . 406\n27.2.If, If-Else, If-Else-If Statements . . . . . . . . . . . . . . . . . . . . . . . 407\n27.3.Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 408\n27.3.1. Computing a Logarithm . . . . . . . . . . . . . . . . . . . . . . . 408\n27.3.2. Life & Taxes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 410\nxvii Contents\n27.3.3. Quadratic Roots Revisited . . . . . . . . . . . . . . . . . . . . . . 411\n28.Loops 415\n28.1.While Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 415\n28.2.For Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 417\n28.3.Do-While Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 417\n28.4.Enhanced For Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 418\n28.5.Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 419\n28.5.1. Normalizing a Number . . . . . . . . . . . . . . . . . . . . . . . . 419\n28.5.2. Summation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 419\n28.5.3. Nested Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 420\n28.5.4. Paying the Piper . . . . . . . . . . . . . . . . . . . . . . . . . . . 421\n29.Methods 423\n29.1.Defining Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 424\n29.1.1. Void Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 426\n29.1.2. Using Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . 426\n29.1.3. Passing By Reference . . . . . . . . . . . . . . . . . . . . . . . . . 427\n29.2.Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 428\n29.2.1. Generalized Rounding . . . . . . . . . . . . . . . . . . . . . . . . 428\n30.Error Handling & Exceptions 431\n30.1.Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 431\n30.1.1. Catching Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . 431\n30.1.2. Throwing Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . 433\n30.1.3. Creating Custom Exceptions . . . . . . . . . . . . . . . . . . . . . 433\n30.1.4. Checked Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . 434\n30.2.Enumerated Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436\n30.2.1. More Tricks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437\n31.Arrays 439\n31.1.Basic Usage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 439\n31.2.Dynamic Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 442\n31.3.Using Arrays with Methods . . . . . . . . . . . . . . . . . . . . . . . . . 442\n31.4.Multidimensional Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . 443\n31.5.Dynamic Data Structures . . . . . . . . . . . . . . . . . . . . . . . . . . 444\n32.Strings 449\n32.1.Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 449\n32.2.String Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 450\n32.3.Arrays of Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 452\n32.4.Comparisons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 453\n32.5.Tokenizing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 455\nxviii Contents\n33.File I\/O 457\n33.1.File Input . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 457\n33.2.File Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 459\n34.Objects 461\n34.1.Data Visibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 462\n34.2.Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 463\n34.2.1. Accessor & Mutator Methods . . . . . . . . . . . . . . . . . . . . 464\n34.3.Constructors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 467\n34.4.Usage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 469\n34.5.Common Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 469\n34.6.Composition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 472\n34.7.Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 474\n35.Recursion 479\n36.Searching & Sorting 483\n36.1.Comparators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 483\n36.2.Searching & Sorting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487\n36.2.1. Searching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487\n36.2.2. Sorting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 488\n36.3.Other Considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 488\n36.3.1. Sorted Collections . . . . . . . . . . . . . . . . . . . . . . . . . . . 488\n36.3.2. Handling null values . . . . . . . . . . . . . . . . . . . . . . . . 490\n36.3.3. Importance of equals() and hashCode() Methods . . . . . . . 491\n36.3.4. Java 8: Lambda Expressions . . . . . . . . . . . . . . . . . . . . . 493\nIII. The PHP Programming Language 495\n37.Basics 497\n37.1.Getting Started: Hello World . . . . . . . . . . . . . . . . . . . . . . . . 498\n37.2.Basic Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 499\n37.2.1. Basic Syntax Rules . . . . . . . . . . . . . . . . . . . . . . . . . . 499\n37.2.2. PHP Tags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 500\n37.2.3. Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 500\n37.2.4. Comments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 500\n37.2.5. Entry Point & Command Line Arguments . . . . . . . . . . . . . 502\n37.3.Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 502\n37.3.1. Using Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . 503\n37.4.Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 504\n37.4.1. Type Juggling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 505\n37.4.2. String Concatenation . . . . . . . . . . . . . . . . . . . . . . . . . 508\n37.5.Basic I\/O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 508\nxix Contents\n37.6.Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 509\n37.6.1. Converting Units . . . . . . . . . . . . . . . . . . . . . . . . . . . 509\n37.6.2. Computing Quadratic Roots . . . . . . . . . . . . . . . . . . . . . 512\n38.Conditionals 515\n38.1.Logical Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 515\n38.1.1. Order of Precedence . . . . . . . . . . . . . . . . . . . . . . . . . 517\n38.2.If, If-Else, If-Else-If Statements . . . . . . . . . . . . . . . . . . . . . . . 517\n38.3.Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 519\n38.3.1. Computing a Logarithm . . . . . . . . . . . . . . . . . . . . . . . 519\n38.3.2. Life & Taxes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 520\n38.3.3. Quadratic Roots Revisited . . . . . . . . . . . . . . . . . . . . . . 522\n39.Loops 527\n39.1.While Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 527\n39.2.For Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 528\n39.3.Do-While Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529\n39.4.Foreach Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529\n39.5.Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 530\n39.5.1. Normalizing a Number . . . . . . . . . . . . . . . . . . . . . . . . 530\n39.5.2. Summation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 530\n39.5.3. Nested Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 531\n39.5.4. Paying the Piper . . . . . . . . . . . . . . . . . . . . . . . . . . . 531\n40.Functions 535\n40.1.Defining & Using Functions . . . . . . . . . . . . . . . . . . . . . . . . . 535\n40.1.1. Declaring Functions . . . . . . . . . . . . . . . . . . . . . . . . . . 535\n40.1.2. Organizing Functions . . . . . . . . . . . . . . . . . . . . . . . . . 537\n40.1.3. Calling Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 537\n40.1.4. Passing By Reference . . . . . . . . . . . . . . . . . . . . . . . . . 538\n40.1.5. Optional & Default Parameters . . . . . . . . . . . . . . . . . . . 539\n40.1.6. Function Pointers . . . . . . . . . . . . . . . . . . . . . . . . . . . 540\n40.2.Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 540\n40.2.1. Generalized Rounding . . . . . . . . . . . . . . . . . . . . . . . . 540\n40.2.2. Quadratic Roots . . . . . . . . . . . . . . . . . . . . . . . . . . . 541\n41.Error Handling & Exceptions 543\n41.1.Throwing Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 543\n41.2.Catching Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 543\n41.3.Creating Custom Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . 544\n42.Arrays 547\n42.1.Creating Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 547\nxx Contents\n42.2.Indexing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 547\n42.2.1. Strings as Indices . . . . . . . . . . . . . . . . . . . . . . . . . . . 549\n42.2.2. Non-Contiguous Indices . . . . . . . . . . . . . . . . . . . . . . . 549\n42.2.3. Key-Value Initialization . . . . . . . . . . . . . . . . . . . . . . . 549\n42.3.Useful Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 550\n42.4.Iteration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 551\n42.5.Adding Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 552\n42.6.Removing Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 553\n42.7.Using Arrays in Functions . . . . . . . . . . . . . . . . . . . . . . . . . . 554\n42.8.Multidimensional Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . 555\n43.Strings 557\n43.1.Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 557\n43.2.String Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 558\n43.3.Arrays of Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 560\n43.4.Comparisons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 560\n43.5.Tokenizing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 561\n44.File I\/O 563\n44.1.Opening Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 563\n44.2.Reading & Writing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 564\n44.2.1. Using URLs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 565\n44.2.2. Closing Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 565\n45.Objects 567\n45.1.Data Visibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 568\n45.2.Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 568\n45.2.1. Accessor & Mutator Methods . . . . . . . . . . . . . . . . . . . . 570\n45.3.Constructors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 571\n45.4.Usage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 572\n45.5.Common Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 573\n45.6.Composition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 573\n45.7.Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 574\n46.Recursion 577\n47.Searching & Sorting 581\n47.1.Comparator Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 581\n47.1.1. Searching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 584\n47.1.2. Sorting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 584\nGlossary 587\nAcronyms 599\nxxi Contents\nIndex 610\nReferences 613\nxxii List of Algorithms\n1.1. An example of pseudocode: finding a minimum value . . . . . . . . . . . . 13\n2.1. Assignment Operator Demonstration . . . . . . . . . . . . . . . . . . . . . 34\n2.2. Addition and Subtraction Demonstration . . . . . . . . . . . . . . . . . . 35\n2.3. Multiplication and Division Demonstration . . . . . . . . . . . . . . . . . 36\n2.4. Temperature Conversion Program . . . . . . . . . . . . . . . . . . . . . . 50\n2.5. Quadratic Roots Program . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n3.1. An if-statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76\n3.2. An if-else Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79\n3.3. Example If-Else-If Statement . . . . . . . . . . . . . . . . . . . . . . . . . 79\n3.4. General If-Else-If Statement . . . . . . . . . . . . . . . . . . . . . . . . . . 81\n3.5. If-Else-If Statement With a Bug . . . . . . . . . . . . . . . . . . . . . . . 81\n3.6. A simple receipt program . . . . . . . . . . . . . . . . . . . . . . . . . . . 83\n3.7. Preventing Division By Zero Using an If Statement . . . . . . . . . . . . . 83\n3.8. Comparing Students by Name . . . . . . . . . . . . . . . . . . . . . . . . . 84\n3.9. Computing Tax Liability with If-Else-If . . . . . . . . . . . . . . . . . . . 86\n3.10.Computing Tax Credit with If-Else-If . . . . . . . . . . . . . . . . . . . . . 86\n4.1. Counter-Controlled While Loop . . . . . . . . . . . . . . . . . . . . . . . . 97\n4.2. Normalizing a Number With a While Loop . . . . . . . . . . . . . . . . . 99\n4.3. A General For Loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99\nxxiii LIST OF ALGORITHMS\n4.4. Counter-Controlled For Loop . . . . . . . . . . . . . . . . . . . . . . . . . 100\n4.5. Summation of Numbers in a For Loop . . . . . . . . . . . . . . . . . . . . 100\n4.6. Counter-Controlled Do-While Loop . . . . . . . . . . . . . . . . . . . . . . 101\n4.7. Flag-Controlled Do-While Loop . . . . . . . . . . . . . . . . . . . . . . . . 102\n4.8. Example Foreach Loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102\n4.9. Foreach Loop Computing Grades . . . . . . . . . . . . . . . . . . . . . . . 103\n4.10.Nested For Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n4.11.Infinite Loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104\n4.12.Computing the Geometric Series Using a For Loop . . . . . . . . . . . . . 107\n4.13.Computing the Geometric Series Using a While Loop . . . . . . . . . . . . 108\n4.14.Determining if a Number is Prime or Composite . . . . . . . . . . . . . . 109\n4.15.Counting the number of primes. . . . . . . . . . . . . . . . . . . . . . . . . 109\n4.16.Computing a loan amortization schedule . . . . . . . . . . . . . . . . . . . 111\n4.17.Scaling a Value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123\n5.1. A function in pseudocode . . . . . . . . . . . . . . . . . . . . . . . . . . . 135\n5.2. Using a function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137\n11.1.Recursive CountDown(n) Function . . . . . . . . . . . . . . . . . . . . . 203\n11.2.Recursive Fibonacci(n) Function . . . . . . . . . . . . . . . . . . . . . . 204\n11.3.Recursive Fibonacci(n) Function With Memoization . . . . . . . . . . . 208\n12.1.Linear Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212\n12.2.Recursive Binary Search Algorithm, BinarySearch(A,l,r,e ) . . . . . . 214\nk\n12.3.Iterative Binary Search Algorithm, BinarySearch(A,e ) . . . . . . . . . 215\nk\n12.4.Selection Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222\n12.5.Insertion Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225\n12.6.QuickSort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229\nxxiv LIST OF ALGORITHMS\n12.7.In-Place Partition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229\n12.8.MergeSort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233\n12.9.Merge . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234\nxxv  List of Code Samples\n1.1. A simple program in C . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n1.2. A simple program in C, compiled to assembly . . . . . . . . . . . . . . . 10\n1.3. A simple program in C, resulting machine code formatted in hexadecimal\n(partial) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n2.1. Example of variable scoping in C . . . . . . . . . . . . . . . . . . . . . . 32\n2.2. Compound Assignment Operators in C . . . . . . . . . . . . . . . . . . . 41\n2.3. printf() examples in C . . . . . . . . . . . . . . . . . . . . . . . . . . 45\n2.4. Output Result . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45\n4.1. Zune Bug . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105\n15.1.Hello World Program in C . . . . . . . . . . . . . . . . . . . . . . . . . . 254\n15.2.Fahrenheit-to-Celsius Conversion Program in C . . . . . . . . . . . . . . 268\n15.3.Quadratic Roots Program in C . . . . . . . . . . . . . . . . . . . . . . . 269\n16.1.Examples of Conditional Statements in C . . . . . . . . . . . . . . . . . . 275\n16.2.Logarithm Calculator Program in C . . . . . . . . . . . . . . . . . . . . . 280\n16.3.Tax Program in C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281\n16.4.Quadratic Roots Program in C With Error Checking . . . . . . . . . . . 282\n17.1.While Loop in C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283\n17.2.Flag-controlled While Loop in C . . . . . . . . . . . . . . . . . . . . . . . 284\n17.3.For Loop in C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 285\n17.4.Do-While Loop in C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286\n17.5.Normalizing a Number with a While Loop in C . . . . . . . . . . . . . . 287\n17.6.Summation of Numbers using a For Loop in C . . . . . . . . . . . . . . . 287\n17.7.Nested For Loops in C . . . . . . . . . . . . . . . . . . . . . . . . . . . . 288\n17.8.Loan Amortization Program in C . . . . . . . . . . . . . . . . . . . . . . 290\n19.1.Using the errno.h library . . . . . . . . . . . . . . . . . . . . . . . . . 307\n23.1.A Student structure declaration . . . . . . . . . . . . . . . . . . . . . . 344\n25.1.C Function Pointer Syntax Examples . . . . . . . . . . . . . . . . . . . . 371\n25.2.C Search Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375\n25.3.C Sort Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 376\n25.4.C Comparator Function for Strings . . . . . . . . . . . . . . . . . . . . . 377\nxxvii List of Code Samples\n25.5.Sorting Structures via Pointers . . . . . . . . . . . . . . . . . . . . . . . 378\n25.6.Handling Null Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379\n26.1.Hello World Program in Java . . . . . . . . . . . . . . . . . . . . . . . . 384\n26.2.Basic Input\/Output in Java . . . . . . . . . . . . . . . . . . . . . . . . . 396\n26.3.Fahrenheit-to-Celsius Conversion Program in Java . . . . . . . . . . . . . 399\n26.4.Quadratic Roots Program in Java . . . . . . . . . . . . . . . . . . . . . . 402\n27.1.Examples of Conditional Statements in Java . . . . . . . . . . . . . . . . 407\n27.2.Logarithm Calculator Program in Java . . . . . . . . . . . . . . . . . . . 412\n27.3.Tax Program in Java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 413\n27.4.Quadratic Roots Program in Java With Error Checking . . . . . . . . . . 414\n28.1.While Loop in Java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 415\n28.2.Flag-controlled While Loop in Java . . . . . . . . . . . . . . . . . . . . . 416\n28.3.For Loop in Java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 417\n28.4.Do-While Loop in Java . . . . . . . . . . . . . . . . . . . . . . . . . . . . 418\n28.5.Enhanced For Loops in Java Example 1 . . . . . . . . . . . . . . . . . . . 418\n28.6.Enhanced For Loops in Java Example 2 . . . . . . . . . . . . . . . . . . . 419\n28.7.Normalizing a Number with a While Loop in Java . . . . . . . . . . . . . 419\n28.8.Summation of Numbers using a For Loop in Java . . . . . . . . . . . . . 420\n28.9.Nested For Loops in Java . . . . . . . . . . . . . . . . . . . . . . . . . . . 420\n28.10.Loan Amortization Program in Java . . . . . . . . . . . . . . . . . . . . . 422\n34.1.The completed Java Student class. . . . . . . . . . . . . . . . . . . . . 477\n36.1.Java Search Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . 489\n36.2.Using Java Collection\u2019s Sort Method . . . . . . . . . . . . . . . . . . . . 490\n36.3.Handling Null Values in Java Comparators . . . . . . . . . . . . . . . . . 491\n37.1.Hello World Program in PHP . . . . . . . . . . . . . . . . . . . . . . . . 498\n37.2.Hello World Program in PHP with HTML . . . . . . . . . . . . . . . . . 498\n37.3.Type Juggling in PHP . . . . . . . . . . . . . . . . . . . . . . . . . . . . 506\n37.4.Fahrenheit-to-Celsius Conversion Program in PHP . . . . . . . . . . . . . 511\n37.5.Quadratic Roots Program in PHP . . . . . . . . . . . . . . . . . . . . . . 513\n38.1.Examples of Conditional Statements in PHP . . . . . . . . . . . . . . . . 518\n38.2.Logarithm Calculator Program in C . . . . . . . . . . . . . . . . . . . . . 523\n38.3.Tax Program in PHP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 524\n38.4.Quadratic Roots Program in PHP With Error Checking . . . . . . . . . 525\n39.1.While Loop in PHP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 527\n39.2.Flag-controlled While Loop in PHP . . . . . . . . . . . . . . . . . . . . . 528\n39.3.For Loop in PHP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529\n39.4.Do-While Loop in PHP . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529\n39.5.Normalizing a Number with a While Loop in PHP . . . . . . . . . . . . . 530\nxxviii List of Code Samples\n39.6.Summation of Numbers using a For Loop in PHP . . . . . . . . . . . . . 531\n39.7.Nested For Loops in PHP . . . . . . . . . . . . . . . . . . . . . . . . . . 531\n39.8.Loan Amortization Program in PHP . . . . . . . . . . . . . . . . . . . . 533\n44.1.Processing a file line-by-line in PHP . . . . . . . . . . . . . . . . . . . . . 564\n45.1.The completed PHP Student class. . . . . . . . . . . . . . . . . . . . . 576\n47.1.Using PHP\u2019s usort() Function . . . . . . . . . . . . . . . . . . . . . . . 585\nxxix  List of Figures\n1.1. Depiction of Computer Memory . . . . . . . . . . . . . . . . . . . . . . . 6\n1.2. A Compiling Process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8\n2.1. Types of Flowchart Nodes . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n2.2. Example of a flowchart for a simple ATM process . . . . . . . . . . . . . 19\n2.3. Elements of a printf() statement in C . . . . . . . . . . . . . . . . . . 44\n2.4. Intersection of two circles. . . . . . . . . . . . . . . . . . . . . . . . . . . 63\n3.1. Control flow diagrams for sequential control flow and an if-statement. . . 77\n3.2. An if-else Flow Chart . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78\n3.3. Control Flow for an If-Else-If Statement . . . . . . . . . . . . . . . . . . 80\n3.4. Quadrants of the Cartesian Plane . . . . . . . . . . . . . . . . . . . . . . 87\n3.5. Three types of triangles . . . . . . . . . . . . . . . . . . . . . . . . . . . 90\n3.6. Intersection of Two Rectangles . . . . . . . . . . . . . . . . . . . . . . . . 91\n3.7. Examples of Floor Tiling . . . . . . . . . . . . . . . . . . . . . . . . . . . 93\n4.1. A Typical Loop Flow Chart . . . . . . . . . . . . . . . . . . . . . . . . . 96\n4.2. A Do-While Loop Flow Chart. The continuation condition is checked after\nthe loop body. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101\n4.3. Plot of f(x) = sinx . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116\nx\n4.4. A rectangle for the interval [\u22125,5]. . . . . . . . . . . . . . . . . . . . . . 117\n4.5. Follow the bouncing ball . . . . . . . . . . . . . . . . . . . . . . . . . . . 118\n4.6. Sampling points in a circle . . . . . . . . . . . . . . . . . . . . . . . . . . 119\n4.7. Regular polygons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120\n4.8. A polygon and its centroid. Whoo! . . . . . . . . . . . . . . . . . . . . . 130\n5.1. A function declaration (prototype) in the C programming language with\nthe return type, identifier, and parameter list labeled. . . . . . . . . . . . 135\n5.2. Program Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139\n5.3. Demonstration of Pass By Value . . . . . . . . . . . . . . . . . . . . . . . 141\n5.4. Demonstration of Pass By Reference . . . . . . . . . . . . . . . . . . . . 143\n7.1. Example of an Array . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160\n7.2. Example returning a static array . . . . . . . . . . . . . . . . . . . . . . 163\n7.3. Pitfalls of Returning Static Arrays. . . . . . . . . . . . . . . . . . . . . . 174\n7.4. Depiction of Application Memory. . . . . . . . . . . . . . . . . . . . . . . 175\n7.5. Shallow vs. Deep Copies . . . . . . . . . . . . . . . . . . . . . . . . . . . 176\nxxxi List of Figures\n9.1. Linux Tree Directory Structure . . . . . . . . . . . . . . . . . . . . . . . 186\n9.2. An example polygon for n = 5 . . . . . . . . . . . . . . . . . . . . . . . . 188\n9.3. A Word Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189\n9.4. A solved Sudoku puzzle . . . . . . . . . . . . . . . . . . . . . . . . . . . 191\n9.5. A DNA Sequence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n9.6. Codon Table for RNA to Protein Translation . . . . . . . . . . . . . . . . 195\n11.1.Recursive Fibonacci Computation Tree . . . . . . . . . . . . . . . . . . . 207\n12.1.Array of Integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212\n12.2.A Sorted Array . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213\n12.3.Binary Search Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216\n12.4.Example of the benefit of ordered (indexed) elements in Windows 7 . . . 220\n12.5.Selection Sort Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223\n12.6.Insertion Sort Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226\n12.7.Partitioning Example 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230\n12.8.Partitioning Example 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230\n12.9.Partitioning Example 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231\n12.10.Merge Sort Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235\n12.11.Merge Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236\n12.12.Generalized Sorting with a Comparator . . . . . . . . . . . . . . . . . . . 240\n18.1.Pointer Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 298\n20.1.Dynamically Allocating Multidimensional Arrays . . . . . . . . . . . . . 321\n20.2.Contiguous Two Dimensional Array . . . . . . . . . . . . . . . . . . . . . 324\n21.1.Example of a character array (string) in C. . . . . . . . . . . . . . . . . . 325\n23.1.Contiguous Structure Array . . . . . . . . . . . . . . . . . . . . . . . . . 350\n23.2.Array of Structure Pointers . . . . . . . . . . . . . . . . . . . . . . . . . 350\n23.3.Hybrid Array of Structures . . . . . . . . . . . . . . . . . . . . . . . . . . 352\nxxxii 1. Introduction\nComputersareawesome. Thehumanracehasseenmoreadvancementsinthelast50years\nthan in the entire 10,000 years of human history. Technology has transformed the way we\nlive our daily lives, how we interact with each other, and has changed the course of our\nhistory. Today, everyone carries smart phones which have more computational power than\nsupercomputers from even 20 years ago. Computing has become ubiquitous, the \u201cinternet\nof things\u201d will soon become a reality in which every device will become interconnected\nand data will be collected and available even about the smallest of minutiae.\nHowever, computers are also dumb. Despite the most fantastical of depictions in science\nfiction and and hopes of Artificial Intelligence, computers can only do what they are told\nto do. The fundamental art of Computer Science is problem solving. Computers are\nnot good at problem solving; you are the problem solver. It is still up to you, the user,\nto approach a complex problem, study it, understand it, and develop a solution to it.\nComputers are only good at automating solutions once you have solved the problem.\nComputational sciences have become a fundamental tool of almost every discipline.\nScholars have used textual analysis and data mining techniques to analyze classical\nliterature and historic texts, providing new insights and opening new areas of study.\nAstrophysicists have used computational analysis to detect dozens of new exoplanets.\nComplex visualizations and models can predict astronomical collisions on a galactic scale.\nPhysicists have used big data analytics to push the boundaries of our understanding of\nmatter in the search for the Higgs boson and study of elementary particles. Chemists\nsimulate the interaction of millions of combinations of compounds without the need for\nexpensive and time consuming physical experiments. Biologists use massively distributed\ncomputingmodelstosimulateproteinfoldingandothercomplexprocesses. Meteorologists\ncan predict weather and climactic changes with ever greater accuracy.\nTechnology and data analytics have changed how political campaigns are run, how\nproducts are marketed and even delivered. Social networks can be data mined to track\nand predict the spread of flu epidemics. Computing and automation will only continue\nto grow. The time is soon coming where basic computational thinking and the ability\nto develop software will be considered a basic skill necessary to every discipline, a\nrequirement for many jobs and an essential skill akin to arithmetic.\nComputer Science is not programming. Programming is a necessary skill, but it is only\nthe beginning. This book is intended to get you started on your journey.\n1 1. Introduction\n1.1. Problem Solving\nAt its heart, Computer Science is about problem solving. That is not to say that only\nComputer Science is about problem solving. It would be hubris to think that Computer\nScience holds a monopoly on \u201cproblem solving.\u201d Indeed, it would be hard to find any\ndiscipline in which solving problems was not a substantial aspect or motivation if not\nintegral. Instead, Computer Science is the study of computers and computation. It\ninvolves studying and understanding computational processes and the development of\nalgorithms and techniques and how they apply to problems.\nProblem solving skills are not something that can be distilled down into a single step-\nby-step process. Each area and each problem comes with its own unique challenges and\nconsiderations. General problem solving techniques can be identified, studied and taught,\nbut problem solving skills are something that come with experience, hard work, and most\nimportantly, failure. Problem solving is part and parcel of the human experience.\nThat doesn\u2019t mean we can\u2019t identify techniques and strategies for approaching problems,\nin particular problems that lend themselves to computational solutions. A prerequisite\nto solving a problem is understanding it. What is the problem? Who or what entities\nare involved in the problem? How do those entities interact with each other? What are\nthe problems or deficiencies that need to be addressed? Answering these questions, we\nget an idea of where we are.\nUltimately, what is desired in a solution? What are the objectives that need to be\nachieved? What would an ideal solution look like or what would it do? Who would use\nthe solution and how would they use it? By answering these questions, we get an idea of\nwhere we want to be. Once we know where we are and where we want to be, the problem\nsolving process can begin: how do we get from point A to point B?\nOne of the first things a good engineer asks is: does a solution already exist? If a solution\nalready exists, then the problem is already solved! Ideally the solution is an \u201coff-the-shelf\u201d\nsolution: something that already exists and which may have been designed for a different\npurpose but that can be repurposed for our problem. However, there may be exceptions\nto this. The existing solution may be infeasible: it may be too resource intensive or\nexpensive. It may be too difficult or too expensive to adapt to our problem. It may solve\nmost of our problem, but may not work in some corner cases. It may need to be heavily\nmodified in order to work. Still, this basic question may save a lot of time and effort in\nmany cases.\nIn a very broad sense, the problem solving process is one that involves\n1. Design\n2. Implementation\n2 1.1. Problem Solving\n3. Testing\n4. Refinement\nAfter one has a good understanding of a problem, they can start designing a solution. A\ndesign is simply a plan on the construction of a solution. A design \u201con paper\u201d allows\nyou to see what the potential solution would look like before investing the resources in\nbuilding it. It also allows you to identify possible impediments or problems that were\nnot readily apparent. A design allows you to an opportunity to think through possible\nalternative solutions and weigh the advantages and disadvantages of each. Designing a\nsolution also allows you to understand the problem better. Design can involve gathering\nrequirements and developing use cases. How would an individual use the proposed\nsolution? What features would they need or want?\nImplementations can involve building prototype solutions to test the feasibility of the\ndesign. It can involve building individual components and integrating them together.\nTesting involves finding, designing, and developing test cases: actual instances of the\nproblem that can be used to test your solution. Ideally, the a test case instance involves\nnot only the \u201cinput\u201d of the problem, but also the \u201coutput\u201d of the problem: a feasible or\noptimal solution that is known to be correct via other means. Test cases allow us to test\nour solution to see if it gives correct and perhaps optimal solutions.\nRefinement is a process by which we can redesign, reimplement and retest our solution.\nWe may want to make the solution more efficient, cheaper, simpler or more elegant. We\nmay find there are components that are redundant or unnecessary and try to eliminate\nthem. We may find errors or bugs in our solution that fail to solve the problem for some\nor many instances. We may have misinterpreted requirements or there may have been\nmiscommunication, misunderstanding or differing expectations in the solution between\nthe designers and stakeholders. Situations may change or requirements may have been\nmodified or new requirements created and the solution needs to be adapted. Each of\nthese steps may need to be repeated many times until an ideal solution, or at least\nacceptable, solution is achieved.\nYet another phase of problem solving is maintenance. The solution we create may need\nto be maintained in order to remain functional and stay relevant. Design flaws or bugs\nmay become apparent that were missed in previous phases. The solution may need to be\nupdated to adapt to new technology or requirements.\nIn software design there are two general techniques for problem solving; top-down and\nbottom-up design. A top-down design strategy approaches a problem by breaking it\ndown into smaller and smaller problems until either a solution is obvious or trivial or a\npreexisting solution (the aforementioned \u201coff-the-shelf\u201d solution) exists. The solutions to\nthe subproblems are combined and interact to solve the overall problem.\nA bottom-up strategy attempts to first completely define the smallest components or\n3 1. Introduction\nentities that make up a system first. Once these have been defined and implemented,\nthey are combined and interactions between them are defined to produce a more complex\nsystem.\n1.2. Computing Basics\nEveryone has some level of familiarity with computers and computing devices just as\neveryone has familiarity with automotive basics. However, just because you drive a car\neveryday doesn\u2019t mean you can tell the difference between a crankshaft and a piston. To\nget started, let\u2019s familiarize ourselves with some basic concepts.\nA computer is a device, usually electronic, that stores, receives, processes, and outputs\ninformation. Modern computing devices include everything from simple sensors to mobile\ndevices, tablets, desktops, mainframes\/servers, supercomputers and huge grid clusters\nconsisting of multiple computers networked together.\nComputer hardware usually refers to the physical components in a computing system\nwhich includes input devices such as a mouse\/touchpad, keyboard, or touchscreen, output\ndevices such as monitors, storage devices such as hard disks and solid state drives, as\nwell as the electronic components such as graphics cards, main memory, motherboards\nand chips that make up the Central Processing Unit (CPU).\nComputer processors are complex electronic circuits (referred to as Very Large Scale Inte-\ngration (VLSI)) which contain thousands of microscopic electronic transistors\u2013electronic\n\u201cgates\u201d that can perform logical operations and complex instructions. In addition to\nthe CPU a processor may contain an Arithmetic and Logic Unit (ALU) that performs\narithmetic operations such as addition, multiplication, division, etc.\nComputer Software usually refers to the actual machine instructions that are run on a\nprocessor. Software is usually written in a high-level programming language such as C or\nJava and then converted to machine code that the processor can execute.\nComputers \u201cspeak\u201d in binary code. Binary is nothing more than a structured collection\nof 0s and 1s. A single 0 or 1 is referred to as a bit. Bits can be collected to form larger\nchunks of information: 8 bits form a byte, 1024 bytes is referred to as a kilobyte, etc.\nTable 1.1 contains a several more binary units. Each unit is in terms of a power of 2\ninstead of a power of 10. As humans, we are more familiar with decimal\u2013base-10 numbers\nand so units are usually expressed as powers of 10, kilo- refers to 103, mega- is 106, etc.\nHowever, since binary is base-2 (0 or 1), units are associated with the closest power\nof 2. Computers are binary machines because it is the most practical to implement in\nelectronic devices. 0s and 1s can be easily represented by low\/high voltage; low\/high\nfrequency; on-off; etc. It is much easier to design and implement systems that switch\nbetween only two states.\n4 1.3. Basic Program Structure\nUnit 2n Number of bytes\nKilobyte (KB) 210 1,024\nMegabyte (MB) 220 1,048,576\nGigabyte (GB) 230 1,073,741,824\nTerabyte (TB) 240 1,099,511,627,776\nPetabyte (PB) 250 1,125,899,906,842,624\nExabyte (EB) 260 1,152,921,504,606,846,976\nZettabyte (ZB) 270 1,180,591,620,717,411,303,424\nYottabyte (YB) 280 1,208,925,819,614,629,174,706,176\nTable 1.1.: Various units of digital information with respect to bytes. Memory is usually\nmeasured using powers of two.\nComputer memory can refer to secondary memory which are typically longterm storage\ndevices such as hard disks, flash drives, SD cards, optical disks (CDs, DVDs), etc. These\ngenerally have a large capacity but are slower (the time it takes to access a chunk of data\nis longer). Or, it can refer to main memory (or primary memory): data stored on chips\nthat is much faster but also more expensive and thus generally smaller.\nThe first hard disk (IBM 350) was developed in 1956 by IBM and had a capacity of\n3.75MB and cost $3,200 ($27,500 in 2015 dollars) per month to lease. For perspective,\nthe first commercially available TB hard drive was released in 2007. As of 2015, terabyte\nhard disks can be commonly purchased for $50\u2013$100.\nMain memory, sometimes referred to as Random Access Memory (RAM) consists of\na collection of addresses along with contents. An address usually refers to a single\nbyte of memory (called byte-addressing). The content, that is the byte of data that is\nstored at an address, can be anything. It can represent a number, a letter, etc. To the\ncomputer it is all just a bunch of 0s and 1s. For convenience, memory addresses are\nrepresented using hexadecimal, which is a base-16 counting system using the symbols\n0,1,...,9,a,b,c,d,e,f. Numbers are prefixed with a 0x to indicate they represent\nhexadecimal numbers. Figure 1.1 depicts memory and its address\/contents.\nSeparate computing devices can be connected to each other through a network. Networks\ncanbewiredwithelectricalsignalsorlightasinfiberopticswhichprovidelargebandwidth\n(the amount of data that can be sent at any one time), but can be expensive to build and\nmaintain. They can also be wireless, but provide shorter range and lower bandwidth.\n1.3. Basic Program Structure\nPrograms start out as source code, a collection of instructions usually written in a high-\nlevel programming language. A source file containing source code is nothing more than\n5 1. Introduction\nAddress Contents\n. .\n. .\n. .\n0x7fff58310b8f\n0x7fff58310b8b 0x32\n0x7fff58310b8a 0x3e\n0x7fff58310b89 0xcf\n0x7fff58310b88 0x23\n0x7fff58310b87 0x01\n0x7fff58310b86 0x32\n0x7fff58310b85 0x7c\n0x7fff58310b84 0xff\n0x7fff58310b83\n0x7fff58310b82\n0x7fff58310b81\n0x7fff58310b80\n0x7fff58310b7f\n0x7fff58310b7e\n0x7fff58310b7d\n0x7fff58310b7c 3.14159265359\n0x7fff58310b7b\n0x7fff58310b7a\n0x7fff58310b79\n0x7fff58310b78 32,321,231\n0x7fff58310b77\n0x7fff58310b76\n0x7fff58310b75\n0x7fff58310b74 1,458,321\n0x7fff58310b73 \\0\n0x7fff58310b72 o\n0x7fff58310b71 l\n0x7fff58310b70 l\n0x7fff58310b6f e\n0x7fff58310b6e H\n0x7fff58310b88 0xfa\n0x7fff58310b87 0xa8\n0x7fff58310b86 0xba\n. .\n. .\n. .\nFigure 1.1.: Depiction of Computer Memory. Each address refers to a byte, but different\ntypes of data (integers, floating-point numbers, characters) may require\ndifferentamountsofmemory. Memoryaddressesandsomedataisrepresented\nin hexadecimal.\n6 1.3. Basic Program Structure\na plain text file that can be edited by any text editor. However, many developers and\nprogrammers utilize modern Integrated Development Environment (IDE) that provide a\ntext editor with code highlighting: various elements are displayed in different colors to\nmake the code more readable and elements can be easily identified. Mistakes such as\nunclosed comments or curly brackets can be readily apparent with such editors. IDEs can\nalso provide automated compile\/build features and other tools that make the development\nprocess easier and faster.\nSome languages are compiled languages meaning that a source file must be translated\ninto machine code that a processor can understand and execute. This is actually a\nmultistep process. A compiler may first preprocess the source file(s) and perform some\npre-compiler operations. It may then transform the source code into another language\nsuch as an assembly language, a lower-level more machine-like language. Ultimately, the\ncompiler transforms the source code into object code, a binary format that the machine\ncan understand.\nTo produce an executable file that can actually be run, a linker may then take the object\ncode and link in any other necessary objects or precompiled library code necessary to\nproduce a final program. Finally, an executable file (still just a bunch of binary code) is\nproduced.\nOnce an executable file has been produced we can run the program. When a program is\nexecuted, a request is sent to the operating system to load and run the program. The\noperating system loads the executable file into memory and may setup additional memory\nfor its variables as well as its call stack (memory to enable the program to make function\ncalls). Once loaded and setup, the operating system begins executing the instructions at\nthe program\u2019s entry point.\nIn many languages, a program\u2019s entry point is defined by a main function or method.\nA program may contain many functions and pieces of code, but this special function is\ndefined as the one that gets invoked when a program starts. Without a main function,\nthe code may still be useful: libraries contain many useful functions and procedures so\nthat you don\u2019t have to write a program from scratch. However, these functions are not\nintended to be run by themselves. Instead, they are written so that other programs can\nuse them. A program becomes executable only when a main entry point is provided.\nThis compile-link-execute process is roughly depicted in Code Sample 1.2. An example of\na simple C program can be found in Code Sample 1.1 along with the resulting assembly\ncode produced by a compiler in Figure 1.2 and the final machine code represented in\nhexadecimal in Code Sample 1.3.\nIn contrast, some languages are interpreted, not compiled. The source code is contained\nin a file usually referred to as a script. Rather than being run directly by an operating\nsystem, the operating system loads and execute another program called an interpreter.\nThe interpreter then loads the script, parses, and execute its instructions. Interpreted\n7 1. Introduction\nText Editor\nSource File\nor IDE\nOther Object\nSyntax\nCompiler Files &\nError(s)\nLibraries\nsuccess\nObject File Linker\nInput\nExecutable Results &\nFile Output\nrun\nFigure 1.2.: A Compiling Process\n8 1.3. Basic Program Structure\n#include<stdlib.h>\n1\n#include<stdio.h>\n2\n#include<math.h>\n3\n4\nint main(int argc, char **argv) {\n5\n6\nif(argc != 2) {\n7\nfprintf(stderr, \"Usage: %s x\\n\", argv[0]);\n8\nexit(1);\n9\n}\n10\n11\ndouble x = atof(argv[1]);\n12\ndouble result = sqrt(x);\n13\n14\nif(x < 0) {\n15\nfprintf(stderr, \"Cannot handle complex roots\\n\");\n16\nexit(2);\n17\n}\n18\n19\nprintf(\"square root of %f = %f\\n\", x, result);\n20\n21\nreturn 0;\n22\n}\n23\nCode Sample 1.1.: A simple program in C\n9 1. Introduction\n.section __TEXT,__text,regular,pure_instructions\n.globl _main\n.align 4, 0x90\n_main: ## @main\n.cfi_startproc\n## BB#0:\npushq %rbp\nLtmp2:\n.cfi_def_cfa_offset 16\nLtmp3:\n.cfi_offset %rbp, -16\nmovq %rsp, %rbp\nLtmp4:\n.cfi_def_cfa_register %rbp\nsubq $48, %rsp\nmovl $0, -4(%rbp)\nmovl %edi, -8(%rbp)\nmovq %rsi, -16(%rbp)\ncmpl $2, -8(%rbp)\nje LBB0_2\n## BB#1:\nleaq L_.str(%rip), %rsi\nmovq ___stderrp@GOTPCREL(%rip), %rax\nmovq (%rax), %rdi\nmovq -16(%rbp), %rax\nmovq (%rax), %rdx\nmovb $0, %al\ncallq _fprintf\nmovl $1, %edi\nmovl %eax, -36(%rbp) ## 4-byte Spill\ncallq _exit\nLBB0_2:\nmovq -16(%rbp), %rax\nmovq 8(%rax), %rdi\ncallq _atof\nxorps %xmm1, %xmm1\nmovsd %xmm0, -24(%rbp)\nmovsd -24(%rbp), %xmm0\nsqrtsd %xmm0, %xmm0\nmovsd %xmm0, -32(%rbp)\nucomisd -24(%rbp), %xmm1\njbe LBB0_4\n## BB#3:\nleaq L_.str1(%rip), %rsi\nmovq ___stderrp@GOTPCREL(%rip), %rax\nmovq (%rax), %rdi\nmovb $0, %al\ncallq _fprintf\nmovl $2, %edi\nmovl %eax, -40(%rbp) ## 4-byte Spill\ncallq _exit\nLBB0_4:\nleaq L_.str2(%rip), %rdi\nmovsd -24(%rbp), %xmm0\nmovsd -32(%rbp), %xmm1\nmovb $2, %al\ncallq _printf\nmovl $0, %ecx\nmovl %eax, -44(%rbp) ## 4-byte Spill\nmovl %ecx, %eax\naddq $48, %rsp\npopq %rbp\nretq\n.cfi_endproc\n.section __TEXT,__cstring,cstring_literals\nL_.str: ## @.str\n.asciz \"Usage: %s x\\n\"\nL_.str1: ## @.str1\n.asciz \"Cannot handle complex roots\\n\"\nL_.str2: ## @.str2\n.asciz \"square root of %f = %f\\n\"\n.subsections_via_symbols\nCode Sample 1.2.: A simple program in C, compiled to assembly\n10 1.3. Basic Program Structure\n00000e40 55 48 89 e5 48 83 ec 30 c7 45 fc 00 00 00 00 89 |UH..H..0.E......|\n00000e50 7d f8 48 89 75 f0 81 7d f8 02 00 00 00 0f 84 2c |}.H.u..}.......,|\n00000e60 00 00 00 48 8d 35 f2 00 00 00 48 8b 05 9f 01 00 |...H.5....H.....|\n00000e70 00 48 8b 38 48 8b 45 f0 48 8b 10 b0 00 e8 94 00 |.H.8H.E.H.......|\n00000e80 00 00 bf 01 00 00 00 89 45 dc e8 81 00 00 00 48 |........E......H|\n00000e90 8b 45 f0 48 8b 78 08 e8 6e 00 00 00 0f 57 c9 f2 |.E.H.x..n....W..|\n00000ea0 0f 11 45 e8 f2 0f 10 45 e8 f2 0f 51 c0 f2 0f 11 |..E....E...Q....|\n00000eb0 45 e0 66 0f 2e 4d e8 0f 86 25 00 00 00 48 8d 35 |E.f..M...%...H.5|\n00000ec0 a5 00 00 00 48 8b 05 45 01 00 00 48 8b 38 b0 00 |....H..E...H.8..|\n00000ed0 e8 41 00 00 00 bf 02 00 00 00 89 45 d8 e8 2e 00 |.A.........E....|\n00000ee0 00 00 48 8d 3d 9d 00 00 00 f2 0f 10 45 e8 f2 0f |..H.=.......E...|\n00000ef0 10 4d e0 b0 02 e8 22 00 00 00 b9 00 00 00 00 89 |.M....\".........|\n00000f00 45 d4 89 c8 48 83 c4 30 5d c3 ff 25 08 01 00 00 |E...H..0]..%....|\n00000f10 ff 25 0a 01 00 00 ff 25 0c 01 00 00 ff 25 0e 01 |.%.....%.....%..|\n00000f20 00 00 00 00 4c 8d 1d dd 00 00 00 41 53 ff 25 cd |....L......AS.%.|\n00000f30 00 00 00 90 68 00 00 00 00 e9 e6 ff ff ff 68 0c |....h.........h.|\n00000f40 00 00 00 e9 dc ff ff ff 68 18 00 00 00 e9 d2 ff |........h.......|\n00000f50 ff ff 68 27 00 00 00 e9 c8 ff ff ff 55 73 61 67 |..h'........Usag|\n00000f60 65 3a 20 25 73 20 78 0a 00 43 61 6e 6e 6f 74 20 |e: %s x..Cannot |\n00000f70 68 61 6e 64 6c 65 20 63 6f 6d 70 6c 65 78 20 72 |handle complex r|\n00000f80 6f 6f 74 73 0a 00 73 71 75 61 72 65 20 72 6f 6f |oots..square roo|\n00000f90 74 20 6f 66 20 25 66 20 3d 20 25 66 0a 00 00 00 |t of %f = %f....|\n00000fa0 01 00 00 00 1c 00 00 00 00 00 00 00 1c 00 00 00 |................|\n00000fb0 00 00 00 00 1c 00 00 00 02 00 00 00 40 0e 00 00 |............@...|\n00000fc0 34 00 00 00 34 00 00 00 0b 0f 00 00 00 00 00 00 |4...4...........|\n00000fd0 34 00 00 00 03 00 00 00 0c 00 01 00 10 00 01 00 |4...............|\n00000fe0 00 00 00 00 00 00 00 01 14 00 00 00 00 00 00 00 |................|\n00000ff0 01 7a 52 00 01 78 10 01 10 0c 07 08 90 01 00 00 |.zR..x..........|\n00001000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|\n00001010 00 00 00 00 00 00 00 00 34 0f 00 00 01 00 00 00 |........4.......|\n00001020 3e 0f 00 00 01 00 00 00 48 0f 00 00 01 00 00 00 |>.......H.......|\n00001030 52 0f 00 00 01 00 00 00 00 00 00 00 00 00 00 00 |R...............|\n00001040 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|\n...(cut for room)...\n00002000 11 22 18 54 00 00 00 00 11 40 5f 5f 5f 73 74 64 |.\".T.....@___std|\n00002010 65 72 72 70 00 51 72 10 90 40 64 79 6c 64 5f 73 |errp.Qr..@dyld_s|\n00002020 74 75 62 5f 62 69 6e 64 65 72 00 80 e8 ff ff ff |tub_binder......|\n00002030 ff ff ff ff ff 01 90 00 72 18 11 40 5f 61 74 6f |........r..@_ato|\n00002040 66 00 90 00 72 20 11 40 5f 65 78 69 74 00 90 00 |f...r .@_exit...|\n00002050 72 28 11 40 5f 66 70 72 69 6e 74 66 00 90 00 72 |r(.@_fprintf...r|\n00002060 30 11 40 5f 70 72 69 6e 74 66 00 90 00 00 00 00 |0.@_printf......|\n00002070 00 01 5f 00 05 00 02 5f 6d 68 5f 65 78 65 63 75 |.._...._mh_execu|\n00002080 74 65 5f 68 65 61 64 65 72 00 21 6d 61 69 6e 00 |te_header.!main.|\n00002090 25 02 00 00 00 03 00 c0 1c 00 00 00 00 00 00 00 |%...............|\n000020a0 c0 1c 00 00 00 00 00 00 fa de 0c 05 00 00 00 14 |................|\n000020b0 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 00 |................|\n000020c0 02 00 00 00 0f 01 10 00 00 00 00 00 01 00 00 00 |................|\n000020d0 16 00 00 00 0f 01 00 00 40 0e 00 00 01 00 00 00 |........@.......|\n000020e0 1c 00 00 00 01 00 00 01 00 00 00 00 00 00 00 00 |................|\n000020f0 27 00 00 00 01 00 00 01 00 00 00 00 00 00 00 00 |'...............|\n00002100 2d 00 00 00 01 00 00 01 00 00 00 00 00 00 00 00 |-...............|\n00002110 33 00 00 00 01 00 00 01 00 00 00 00 00 00 00 00 |3...............|\n00002120 3c 00 00 00 01 00 00 01 00 00 00 00 00 00 00 00 |<...............|\n00002130 44 00 00 00 01 00 00 01 00 00 00 00 00 00 00 00 |D...............|\n00002140 03 00 00 00 04 00 00 00 05 00 00 00 06 00 00 00 |................|\n00002150 07 00 00 00 00 00 00 40 02 00 00 00 03 00 00 00 |.......@........|\n00002160 04 00 00 00 05 00 00 00 06 00 00 00 20 00 5f 5f |............ .__|\n00002170 6d 68 5f 65 78 65 63 75 74 65 5f 68 65 61 64 65 |mh_execute_heade|\n00002180 72 00 5f 6d 61 69 6e 00 5f 5f 5f 73 74 64 65 72 |r._main.___stder|\n00002190 72 70 00 5f 61 74 6f 66 00 5f 65 78 69 74 00 5f |rp._atof._exit._|\n000021a0 66 70 72 69 6e 74 66 00 5f 70 72 69 6e 74 66 00 |fprintf._printf.|\n000021b0 64 79 6c 64 5f 73 74 75 62 5f 62 69 6e 64 65 72 |dyld_stub_binder|\n000021c0 00 00 00 00 |....|\n000021c4\nCode Sample 1.3.: A simple program in C, resulting machine code formatted in hexadec-\nimal (partial)\n11 1. Introduction\nlanguages may still have a predefined main function, but in general, a script starts\nexecuting starting with the first instruction in the script file. Adhering to the syntax\nrules is still important, but since interpreted languages are not compiled, syntax errors\nbecome runtime errors. A program may run fine until its first syntax error at which\npoint it fails.\nThere are other ways of compiling and running programs. Java for example represents a\ncompromise between compiled and interpreted languages. Java source code is compiled\ninto Java bytecode which is not actually machine code that the operating system and\nhardware can run directly. Instead, it is compiled code for a Java Virtual Machine (JVM).\nThis allows a developer to write highly portable code, compile it once and it is runnable\non any JVM on any system (write-once, compile-once, run-anywhere).\nIn general, interpreted languages are slower than compiled languages because they are\nbeing run through another program (the interpreter) instead of being executed directly\nby the processor. Modern tools have been introduced to solve this problem. Just In Time\n(JIT) compilers have been developed that take scripts that are not usually compiled,\nand compile them to a native machine code format which has the potential to run much\nfaster than when interpreted. Modern web browsers typically do this for JavaScript code\n(Google Chrome\u2019s V8 JavaScript engine for example).\nAnother related technology are transpilers. Transpilers are source-to-source compilers.\nThey don\u2019t produce assembly or machine code, instead they translate code in one\nhigh-level programming language to another high-level programming language. This\nis sometimes done to ensure that scripting languages like JavaScript are backwards\ncompatible with previous versions of the language. Transpilers can also be used to\ntranslate one language into the same language but with different aspects (such as parallel\nor synchronized code) automatically added. They can also be used to translate older\nlanguages such as Pascal to more modern languages as a first step in updating a legacy\nsystem.\n1.4. Syntax Rules & Pseudocode\nProgramming languages are a lot like human languages in that they have syntax rules.\nThese rules dictate the appropriate arrangements of words, punctuation, and other\nsymbols that form valid statements in the language. For example, in many programming\nlanguages, commands or statements are terminated by semicolons (just as most sentences\nareendedwithaperiod). Thisisanexampleof\u201cpunctuation\u201dinaprogramminglanguage.\nIn English paragraphs are separated by lines, in programming languages blocks of code\nare separated by curly brackets. Variables are comparable to nouns and operations and\nfunctions are comparable to verbs. Complex documents often have footnotes that provide\nadditional explanations; code has comments that provide documentation and explanation\nfor important elements. English is read top-to-bottom, left-to-right. Programming\n12 1.4. Syntax Rules & Pseudocode\nlanguages are similar: individual executable commands are written one per line. When a\nprogram executes, each command executes one after the other, top-to-bottom. This is\nknown as sequential control flow.\nA block of code is a section of code that has been logically grouped together. Many\nlanguages allow you to define a block by enclosing the grouped code around opening and\nclosing curly brackets. Blocks can be nested within each other to form sub-blocks.\nMost languages also have reserved words and symbols that have special meaning. For\nexample, many languages assign special meaning to keywords such as for, if, while,\netc. that are used to define various control structures such as conditionals and loops.\nSpecial symbols include operators such as + and * for performing basic arithmetic.\nFailure to adhere to the syntax rules of a particular language will lead to bugs and\nprograms that fail to compile and\/or run. Natural languages such as English are very\nforgiving: we can generally discern what someone is trying to say even if they speak\nin broken English (to a point). However, a compiler or interpreter isn\u2019t as smart as a\nhuman. Even a small syntax error (an error in the source code that does not conform\nto the language\u2019s rules) will cause a compiler to completely fail to understand the code\nyou have written. Learning a programming language is a lot like learning a new spoken\nlanguage (but, fortunately a lot easier).\nIn subsequent parts of this book we focus on particular languages. However, in order\nto focus on concepts, we\u2019ll avoid specific syntax rules by using pseudocode, informal,\nhigh-level descriptions of algorithms and processes. Good pseudocode makes use of plain\nEnglish and mathematical notation, making it more readable and abstract. A small\nexample can be found in Algorithm 1.1.\nInput :A collection of numbers, A = {a ,a ,...,a }\n1 2 n\nOutput:The minimal element in A\nLet min be equal to a\n1 1\nforeach element a in A do\n2 i\nif a < min then\n3 i\na is less than the smallest element we\u2019ve found so far\n4 i\nUpdate min to be equal to a\n5 i\nend\n6\nend\n7\noutput min\n8\nAlgorithm 1.1: An example of pseudocode: finding a minimum value\n13 1. Introduction\n1.5. Documentation, Comments, and Coding Style\nGood code is not just functional, it is also beautiful. Good code is organized, easy to\nread, and well documented. Organization can be achieved by separating code into useful\nfunctions and collecting functions into modules or libraries. Good organization means\nthat at any one time, we only need to focus on a small part of a program.\nIt would be difficult to read an essay that contained random line breaks, paragraphs\nwere not indented, it contained different spacing or different fonts, etc. Likewise, code\nshould be legible. Well written code is consistent and makes good use of whitespace\nand indentation. Code within the same code block should be indented at the same level.\nNested blocks should be further indented just like the outline of an essay or table of\ncontents.\nCode should also be well documented. Each line or segment of code should be clear\nenough that it tells the user what the code does and how it does it. This is referred to as\n\u201cself-documenting\u201d code. A person familiar with the particular language should be able\nto read your code and immediately understand what it does. In addition, well-written\ncode should contain sufficient and clear comments. A comment in a program is intended\nfor a human user to read. A comment is ultimately ignored by the compiler\/interpreter\nand has no effect on the actual program. Good comments tell the user why the code was\nwritten or why it was written the way it was. Comments provide a high-level description\nof what a block of code, function, or program does. If the particular method or algorithm\nis of interest, it should also be documented.\nThere are typically two ways to write comments. Single line comments usually begin\nwith two forward slashes, \/\/.1 Everything after the slashes until the next line is ignored.\nMultiline comments begin with a \/* and end with a *\/; everything between them is\nignored even if it spans multiple lines. This syntax is shared among many languages\nincluding C, Java, PHP and others. Some examples:\ndouble x = sqrt(y); \/\/this is a single line comment\n1\n2\n\/*\n3\nThis is a multiline comment\n4\neach line is ignored, but allows\n5\nfor better formatting\n6\n*\/\n7\n8\n\/**\n9\n* This is a doc-style comment, usually placed in\n10\n1You can remember the difference between a forward slash \/ and a backslash \\ by thinking of a\nperson facing right and either leaning backwards (backslash) or forwards (forward slash).\n14 1.5. Documentation, Comments, and Coding Style\n* front of major portions of code such as a function\n11\n* to provide documentation\n12\n* It begins with a forward-slash-star-star\n13\n*\/\n14\nThe last example above is a doc-style comment. It originated with Java, but has since\nbeen adopted by many other programming languages. Syntactically it is a normal\nmultiline comment, but begins with a \/**. Asterisks are aligned together on each\nline. Certain commenting systems allow you to place other marked up data inside these\ncomments such as labeling parameters (@param x) or use HTML code to provide links\nand style. These doc-style comments are used to provide documentation for major parts\nof the code especially functions and data structures. Though not part of the language,\nother documentation tools can be used to gather the information in doc-style comments\nto produce formatted documentation such as web pages or Portable Document Format\n(PDF) documents.\nComments should not be trivial: they should not explain something that should be\nreadily apparent to an experienced user or programmer. For example, if a piece of code\nadds two numbers together and stores the result, there should not be a comment that\nexplains the process. It is a simple and common enough operation that is self-evident.\nHowever, if a function uses a particular process or algorithm such as a Fourier Transform\nto perform an operation, it would be appropriate to document it in a series of comments.\nComments can also detail how a function or piece of code should be used. This is\ntypically done when developing an Application Programmer Interface (API) for use\nby other programmers. The API\u2019s available functions should be well documented so\nthat users will know how and when to use a particular function. It can document the\nfunction\u2019s expectations and behavior such as how it handles bad input or error situations.\n15  2. Basics\n2.1. Control Flow\nThe flow of control (or simply control flow) is how a program processes its instructions.\nTypically,programsoperateinalinearorsequential flowofcontrol. Executablestatements\nor instructions in a program are performed one after another. In source code, the order\nthat instructions are written defines their order. Just like English, a program is \u201cread\u201d\ntop to bottom. Each statement may modify the state of a program. The state of a\nprogram is the value of all its variables and other information\/data stored in memory\nat a given moment during its execution. Further, an executable statement may instead\ninvoke (or call or execute) another procedure (also called subroutine, function, method,\netc.) which is another unit of code that has been encapsulated into one unit so that it\ncan be reused.\nThis type of control flow is usually associated with a procedural programming paradigm\n(which is closely related to imperative or structured programming paradigms). Though\nthistextwillmostlyfocusonlanguagesthatareprocedural(orthathavestrongprocedural\naspects), it is important to understand that there are other programming language\nparadigms. Functional programming languages such as Scheme and Haskell achieve\ncomputation through the evaluation of mathematical functions with as little or no (\u201cpure\u201d\nfunctional) state at all. Declarative languages such as those used in database languages\nlike SQL or in spreadsheets like Excel specify computation by expressing the logic of\ncomputation rather than explicitly specifying control flow. For a more formal introduction\nto programming language paradigms, a good resource is Seven Languages in Seven Weeks:\nA Pragmatic Guide to Learning Programming Languages by Tate [36].\n2.1.1. Flowcharts\nSometimes processes are described using diagrams called flowcharts. A flowchart is a\nvisual representation of an algorithm or process consisting of boxes or \u201cnodes\u201d connected\nby directed edges. Boxes can represent an individual step or a decision to be made. The\nedges establish an order of operations in the diagram.\nSome boxes represent decisions to be made which may have one or more alternate routes\n(more than one directed edge going out of the box) depending on the the result of the\n17 2. Basics\nDecision Control to Action to\nNode Perform Perform\n(a) Decision Node (b) Control Node (c) Action Node\nFigure 2.1.: Types of Flowchart Nodes. Control and action nodes are distinguished\nby color. Control nodes are automated steps while action nodes are steps\nperformed as part of the algorithm being depicted.\ndecision. Decision boxes are usually depicted with a diamond shaped box.\nOther boxes represent a process, operation, or action to be performed. Boxes representing\na process are usually rectangles. We will further distinguish two types of processes using\ntwo different colorings: we\u2019ll use green to represent boxes that are steps directly related\nto the algorithm being depicted. We\u2019ll use blue for actions that are necessary to the\ncontrol flow of the algorithm such as assigning a value to a variable or incrementing a\nvalue as part of a loop. Figure 2.1 depicts the three types of boxes we\u2019ll use. Figure 2.2\ndepicts a simple ATM (Automated Teller Machine) process as an example.\n2.2. Variables\nIn mathematics, variables are used as placeholders for values that aren\u2019t necessarily\nknown. For example, in the equation,\nx = 3y +5\nthe variables x and y represent numbers that can take on a number of different values.\nSimilarly, in a computer program, we also use variables to store values. A variable is\nessentially a memory location in which a value can be stored. Typically, a variable is\nreferred to by a name or identifier (like x,y,z in mathematics). In mathematics variables\nare usually used to hold numerical values. However, in programming, variables can\nusually hold different types of values such as numbers, strings (a collection of characters),\nBooleans (true or false values), or more complex types such as arrays or objects.\n18 2.2. Variables\nUserInput\namount\nIsPIN yes Get Sufficient yes Dispense\nInputPIN amountof\ncorrect? Funds? amount\nwithdraw\nno\nno\nEjectCard\nFigure 2.2.: Example of a flowchart for a simple ATM process\n2.2.1. Naming Rules & Conventions\nMost programming languages have very specific rules as to what you can use as variable\nidentifiers (names). For example, most programming languages do not allow you to use\nwhitespace characters (space, tab, etc.) in a variable\u2019s identifier. Allowing spaces would\nmake variable names ambiguous: where does the variable\u2019s name end and the rest of the\nprogram continue? How could you tell the difference between \u201caverage score\u201d and two\nseparate variables named \u201caverage\u201d and \u201cscore\u201d? Many programming languages also\nhave reserved words\u2013words or terms that are used by the programming language itself\nand have special meaning. Variable names cannot be the same as any reserved word as\nthe language wouldn\u2019t be able to distinguish between them.\nFor similar reasons, many programming languages do not allow you to start a variable\nname with a number as it would make it more difficult for a compiler or interpreter to\nparse a program\u2019s source code. Yet other languages require that variables begin with a\nspecific character (PHP for example requires that all variables begin with a dollar sign,\n$).\nIn general, most programming languages allow you to use a combination of uppercase\nA-Z and lowercase a-z letters as well as numbers, [0-9] and certain special characters\nsuch as underscores _ or dollar signs, $. Moreover, most programming languages (like\nEnglish) are case sensitive meaning that a variable name using lowercase letters is not\nthe same variable as one that uses uppercase letters. For example, the variables x and\nX are different; the variables average, Average and AVERAGE are all different as well.\nA few languages are case-insensitive meaning that they do not recognize differences in\nlower and uppercase letters when used in variable identifiers. Even in these languages,\n19 2. Basics\nhowever, using a mixture of lowercase and uppercase letters to refer to the same variable\nis discouraged: it is difficult to read, inconsistent, and just plain ugly.\nBeyond the naming rules that languages may enforce, most languages have established\nnaming conventions; a set of guidelines and best-practices for choosing identifier names\nfor variables (as well as functions, methods, and class names). Conventions may be\nwidely adopted on a per-language basis or may be established within a certain library,\nframework or by an organization that may have official style guides. Naming conventions\nare intended to give source code consistency which ultimately improves readability and\nmakes it easier to understand. Following a consistent convention can also greatly reduce\nthe chance for errors and mistakes. Good naming conventions also has an aesthetic\nappeal; code should be beautiful.\nThere are several general conventions when it comes to variables. An early convention,\nbut still in common use is underscore casing in which variable names consisting of more\nthan one word have words separated by underscore characters with all other characters\nbeing lowercase. For example:\naverage_score, number_of_students, miles_per_hour\nA variation on this convention is to use all uppercase letters such as MILES_PER_HOUR.\nA more modern convention is to use lower camel casing (or just camel casing) in which\nvariable names with multiple words are written as one long word with the first letter in\neach new word capitalized but with the first word\u2019s first letter lowercase. For example:\naverageScore, numberOfStudents, milesPerHour\nThe convention refers to the capitalized letters resembling the humps of a camel. One\nadvantage that camel casing has over underscore casing is that you\u2019re not always straining\nto type the underscore character. Yet another similar convention is upper camel casing,\nalso known as PascalCase1 which is like camel casing, but the first letter in the first word\nis also capitalized:\nAverageScore, NumberOfStudents, MilesPerHour\nEach of these conventions is used in various languages in different contexts which we\u2019ll\nexplore more fully in subsequent sections (usually underscore lowercasing and camel\ncasing are used to denote variables and functions, PascalCase is used to denote user\ndefined types such as classes or structures, and underscore uppercasing is used to denote\nstatic and constant variables). However, for our purposes, we\u2019ll use lower camel casing\nfor variables in our pseudocode.\n1Rarely, this is referred to as DromedaryCase; a Dromedary is an Arabian camel.\n20 2.2. Variables\nThereareexceptionsandspecialcasestoeachoftheseconventionssuchaswhenavariable\nname involves an acronym or a hyphenated word, etc. In such cases sensible extensions or\ncompromisesareemployed. Forexample, xmlString or priorityXMLParser (involving\nthe acronym Extensible Markup Language (XML)) may be used which keep all letters in\nthe acronym consistent (all lowercase or all uppercase).\nIn addition to these conventions, there are several best-practice principles when deciding\non identifiers.\n\u2022 Be descriptive, but not verbose \u2013 Use variable names that describe what the\nvariable represents. The examples above, averageScore, numberOfStudents,\nmilesPerHour clearly indicate what the variable is intended to represent. Using\ngood, descriptive names makes it your code self-documenting (a reader can make\nsense of it without having to read extensive supplemental documentation).\nAvoid meaningless variable names such as value, aVariable, or some cryptic\ncombination of v10 (its the 10th variable I\u2019ve used!). Ambiguous variables such\nas name should also be avoided unless the context makes its clear what you are\nreferring to (as when used inside of a Person object).\nSingle character variables are commonly used, but used in a context in which their\nmeaning is clearly understood. For example, variable names such as x, y are okay\nif they are used to refer to points in the Euclidean plane. Single character variables\nsuch as i, j are often used as index variables when iterating over arrays. In this\ncase, terseness is valued over descriptiveness as the context is very well understood.\nAs a general rule, the more a variable is used, the shorter it should be. For\nexample, the variable numStudents may be preferred over the full variable\nnumberOfStudents.\n\u2022 Avoid abbreviations (or at least use them sparingly) \u2013 You\u2019re not being charged by\nthe character in your code; you can afford to write out full words. Abbreviations can\nhelp to write shorter variable names, but not all abbreviations are the same. The\nword \u201cabbreviation\u201d itself could be abbreviated as \u201cabbr.\u201d, \u201cabbrv.\u201d or \u201cabbrev.\u201d\nfor example. Abbreviations are not always universally understood by all users,\nmay be ambiguous and non-standard. Moreover, modern IDEs provide automatic\ncode completion, relieving you of the need to type longer variable names. If the\nabbreviation is well-known or understood from context, then it may make sense to\nuse it.\n\u2022 Avoid acronyms (or at least use them sparingly) \u2013 Using acronyms in variable\nnames come with many of the same problems as abbreviations. However, if it makes\nsense in the context of your code and has little chance of being misunderstood or\nmistaken, then go for it. For example, in the context of a financial application,\nAPR (Annual Percentage Rate) would be a well-understood acronym in which case\n21 2. Basics\nthe variable apr may be preferred over the longer annualPercentageRate.\n\u2022 Avoid pluralizations, use singular forms \u2013 English is not a very consistent language\nwhen it comes to rules like pluralizations. For most cases you simply add \u201cs\u201d; for\nothers you add \u201ces\u201d or change the \u201cy\u201d to \u201ci\u201d and add \u201ces\u201d. Some words are the\nsame form for singular and plural such as \u201cglasses.\u201d2 Other words have completely\ndifferent forms (\u201cfocus\u201d becomes \u201cfoci\u201d). Still yet there are instances in which\nmultiple words are acceptable: the plural of \u201cperson\u201d can be \u201cpersons\u201d or \u201cpeople\u201d.\nAvoiding plural forms keeps things simple and consistent: you don\u2019t need to be\na grammarian in order easily read code. One potential exception to this is when\nusing a collection such as an array to hold more than one element or the variable\nrepresents a quantity that is pluralized (as with numberOfStudents above).\nThough the guidelines above provide a good framework from which to write good variable\nnames, reasonable people can and do disagree on best practice because at some point as\nyou go from generalities to specifics, conventions become more of a matter of personal\npreference and subjective aesthetics. Sometimes an organization may establish its own\ncoding standards or style guide that must be followed which of course trumps any of the\nguidelines above.\nIn the end, a good balance must be struck between readability and consistency. Rules\nand conventions should be followed, until they get in the way of good code that is.\n2.2.2. Types\nA variable\u2019s type (or data type) is the characterization of the data that it represents. As\nmentioned before, a computer only \u201cspeaks\u201d in 0s and 1s (binary). A variable is merely\na memory location in which a series of 0s and 1s is stored. That binary string could\nrepresent a number (either an integer or a floating point number), a single alphanumeric\ncharacter or series of characters (string), a Boolean type or some other, more complex\nuser-defined type.\nThe type of a variable is important because it affects how the raw binary data stored\nat a memory location is interpreted. Moreover, some types take a different amount of\nmemory to store. For example, an integer type could take 32 bits while a floating point\ntype could take 64 bits. Programming languages may support different types and may\ndo so in different ways. In the next few sections we\u2019ll describe some common types that\nare supported by many languages.\n2These are called plurale tantum (nouns with no singular form) and singular tantum (nouns with no\nplural form) for you grammarians. Words like \u201csheep\u201d are unchanging irregular plurals; words whose\nsingular and plural forms are the same.\n22 2.2. Variables\nNumeric Types\nAt their most basic, computers are number crunching machines. Thus, the most basic\ntype of variable that can be used in a computer program is a numeric type. There are\nseveral numeric types that are supported by various programming languages. The most\nsimple is an integer type which can represent whole numbers 0, 1, 2, etc. and their\nnegations, \u22121,\u22122,.... Floating point numeric types represent decimal numbers such\nas 0.5,3.14,4.0, etc. However, neither integer nor floating point numbers can represent\nevery possible number since they use a finite number of bits to represent the number. We\nwill examine this in detail below. For now, let\u2019s understand how a computer represents\nboth integers and floating point numbers in memory.\nAs humans, we \u201cthink\u201d in base-10 (decimal) because we have 10 fingers and 10 toes.\nWhen we write a number with multiple digits in base-10 we do so using \u201cplaces\u201d (ones\nplace, tens place, hundreds place, etc.). Mathematically, a number in base-10 can be\nbroken down into powers of ten; for example:\n3,201 = 3\u00d7103 +2\u00d7102 +0\u00d7101 +1\u00d7100\nIn general, any number in base-10 can be written as the summation of powers of 10\nmultiplied by numbers 0\u20139,\nc \u00d710k +c \u00d710k\u22121 +\u00b7\u00b7\u00b7c \u00b7101 +c\nk k\u22121 1 0\nIn binary, numbers are represented in the same way, but in base-2 in which we only have\n0 and 1 as symbols. To illustrate, let\u2019s consider counting from 0: in base-10, we would\ncount 0,1,2,...,9 at which point we \u201ccarry-over\u201d a 1 to the tens spot and start over at\n0 in the ones spot, giving us 10,11,12,...,19 and repeat the carry-over to 20.\nWith only two symbols, the carry-over occurs much more frequently, we count 0,1 and\nthen carry over and have 10. It is important to understand, this is not \u201cten\u201d: we are\ncounting in base-2, so 10 is actually equivalent to 2 in base-10. Continuing, we have 11\nand again carry over, but we carry it over twice giving us 100 (just like we\u2019d carry over\ntwice when going from 99 to 100 in base-10). A full count from 0 to 16 in binary can be\nfound in Table 2.1. In many programming languages, a prefix of 0b is used to denote a\nnumber represented in binary. We use this convention in the table.\nAs a fuller example, consider again the number 3,201. This can be represented in binary\n23 2. Basics\nas follows.\n0b110010000001 =1\u00d7211 +1\u00d7210 +0\u00d729 +0\u00d728+\n1\u00d727 +0\u00d726 +0\u00d725 +0\u00d724+\n0\u00d723 +0\u00d722 +0\u00d721 +1\u00d720\n=211 +210 +27 +20\n=2,048+1,024+128+1\n=3,201\nRepresenting negative numbers is a bit more com-\nplicated and is usually done using a scheme called Base-10 Binary\ntwo\u2019s complement. We omit the details, but essen-\n0 0b0\ntially the first bit in the representation serves as a\n1 0b1\nsign bit: zero indicates positive, while 1 indicates\n2 0b10\nnegative. Negative values are represented as a com-\n3 0b11\nplement with respect to 2n (a complement is where\n4 0b100\n0s and 1s are \u201cflipped\u201d to 1s and 0s).\n5 0b101\n6 0b110\nWhen represented using two\u2019s complement, binary\n7 0b111\nnumbers with n bits can represent numbers x in the\n8 0b1000\nrange\n\u22122n\u22121 \u2264 x \u2264 2n\u22121 \u22121 9 0b1001\n10 0b1010\nNote that the upper bound follows from the fact\n11 0b1011\nthat\n12 0b1100\nn\u22122\n0b11...011 = (cid:88) 2i = 2n\u22121 \u22121 13 0b1101\n14 0b1110\n(cid:124) (cid:123)(cid:122) (cid:125) i=0\nnbits 15 0b1111\nThe \u22121 captures the idea that we start at zero. The 16 0b10000\nexponent in the upper bound is n\u22121 since we need\nTable 2.1.: Counting in Binary\none bit to represent the sign. The lower bound\nrepresents the idea that we have 2n\u22121 possible values (n\u22121 since we need one bit for\nthe sign bit) and we don\u2019t need to start at zero, we can start at \u22121. Table 2.2 contains\nranges for common integer types using various number of bits.\nn (number of bits) minimum maximum\n8 -128 127\n16 -32,768 32,767\n32 -2,147,483,648 2,147,483,647\n64 -9,223,372,036,854,775,808 9,223,372,036,854,775,807\n128 \u2248 \u22123.4028\u00d71038 \u2248 3.4028\u00d71038\nTable 2.2.: Ranges for various signed integer types\n24 2.2. Variables\nSome programming languages allow you to define variables that are unsigned in which\nthe sign bit is not used to indicate positive\/negative. With the extra bit we can represent\nnumbers twice as big; using n bits we can represent numbers x in the range\n0 \u2264 x \u2264 2n \u22121\nFloatingpointnumbersinbinaryarerepresentedinamannersimilartoscientificnotation.\nRecall that in scientific notation, a number is normalized by multiplying it by some power\nof 10 so that it its most significant digit is between 1 and 9. The resulting normalized\nnumber is called the significand while the power of ten that the number was scaled by is\ncalled the exponent (and since we are base-10, 10 is the base). In general, a number in\nscientific notation is represented as:\nsignificand\u00d7baseexponent\nFor example,\nexponent\n(cid:122)(cid:125)(cid:124)(cid:123)\n4\n14326.123 = 1.4326123\u00d7 10\n(cid:124) (cid:123)(cid:122) (cid:125) (cid:124)(cid:123)(cid:122)(cid:125)\nsignificand base\nSometimes the notations 1.4326123e+4, 1.4326123e4 or 1.4326123E4 are used. As before,\nwe can see that a fractional number in base-10 can be seen as a summation of powers of\n10:\n1.4326123 =1\u00d7101 +4\u00d710\u22121 +3\u00d710\u22122 +2\u00d710\u22123+\n6\u00d710\u22124 +1\u00d710\u22125 +2\u00d710\u22126 +3\u00d710\u22127\nIn binary, floating point numbers are represented in a similar way, but the base is 2,\nconsequently a fractional number in binary is a summation of powers of 2. For example,\n110.011 =1\u00d722 +1\u00d721 +0\u00d720 +0\u00d72\u22121 +1\u00d72\u22122 +1\u00d72\u22123\n1 1 1\n=1\u00d74+1\u00d72+0\u00d71+0\u00d7 +1\u00d7 +1\u00d7\n2 4 8\n1 1\n=4+2+0+0+ +\n4 8\n=6.375\nIn binary, the significand is often referred to as a mantissa. We also normalize a binary\nfloating point number so that the mantissa is between 1 and 1. This is where the term\n2\nfloating point comes from: the decimal point (more generally called a radix point) \u201cfloats\u201d\nleft and right to ensure that the number is always normalized. The example above would\nnormalized to\n0.110011\u00d723\nHere, 0.110011 is the mantissa and 3 is the exponent (which in binary would be 0b11).\n25 2. Basics\nName Bits Exponent Bits Mantissa Bits SignificantDigits Approximate\nof Precision Range\nHalf 16 5 10 \u2248 3.3 103 \u223c 104.5\nSingle 32 8 23 \u2248 7.2 10\u221238 \u223c 1038\nDouble 64 11 52 \u2248 15.9 10\u2212308 \u223c 10308\nQuadruple 128 15 112 \u2248 34.0 10\u22124931 \u223c 104931\nTable 2.3.: Summary of Floating-point Precisions in the IEEE 754 Standard. Half and\nquadruple are not widely adopted.\nMost modern programming languages implement floating point numbers according to the\nInstitute of Electrical and Electronics Engineers (IEEE) 754 Standard [20] (also called\nthe International Electrotechnical Commission (IEC) 60559 [19]). When represented\nin binary, a fixed number of bits must be used to represent the sign, mantissa and\nexponent. The standard defines several precisions that each use a fixed number of bits\nwith a resulting number of significant digits (base-10) of precision. Table 2.3 contains a\nsummary of a few of the most commonly implemented precisions.\nJust as with integers, the finite precision of floating point numbers results in several limi-\ntations. First, irrational numbers such as \u03c0 = 3.14159... can only be approximated out\nto a certain number of digits. For example, with single precision \u03c0 \u2248 3.1415927 which is\naccurateonlytothe6thdecimalplaceandwithdoubleprecision, \u03c0 \u2248 3.1415926535897931\napproximate to only 15 decimal places.3 In fact, regardless of how many bits we allow in\nour representation, an irrational number like \u03c0 (that never repeats and never terminates)\nwill only ever be an approximation. Real numbers like \u03c0 require an infinite precision,\nbut computers are only finite machines.\nEven numbers that have a finite representation (rational numbers) such as 1 = 0.333 are\n3\nnot represented exactly when using floating point numbers. In double precision binary,\n1\n= 0b1.0101010101010101010101010101010101010101010101010101\u00d72\u22122\n3\nwhich when represented in scientific notation in decimal is\n3.3333333333333330\u00d710\u22121\nThat is, there are only 16 digits of precision, after which the remaining (infinite) sequence\nof 3s get cut off.\nProgramming languages usually only support the common single and double precisions\ndefined by the IEEE 754 standard as those are commonly supported by hardware.\n3The first 80 digits of \u03c0 are\n3.14159265358979323846264338327950288419716939937510582097494459230781640628620899\nthough only 39 digits of \u03c0 are required to accurately calculate the volume of the known universe to\nwithin one atom.\n26 2.2. Variables\nHowever, there are languages that support arbitrary precision (also called multiprecision)\nnumbers and yet other languages that have many libraries to support \u201cbig number\u201d\narithmetic. Arbitrary precision is still not infinite: instead, as more digits are needed,\nmore memory is allocated. If you want to compute 10 more digits of \u03c0, you can but at a\ncost. To support the additional digits, more memory is allocated. Also, operations are\nperformed in software using many operations which can be much slower than performing\nfixed-precision arithmetic directly in hardware. Still, there are many applications where\nsuch accuracy or large numbers are absolutely essential.\nCharacters & Strings\nAnother type of data is textual data which can either be single characters or a sequence\nof characters which are called strings. Strings are sometimes used for human readable\ndata such as messages or output, but may also model general data. For example, DNA\nis usually encoded using strings consisting of the characters C, G, A, T (corresponding\nto the nucleases cytosine, guanine, adenine, and thymine). Numerical characters and\npunctuation can also be used in strings in which case they do not represent numbers,\nbut instead may represent textual versions of numerical data.\nDifferent programming languages implement characters and strings in different ways (or\nmay even treat them the same). Some languages implement strings by defining arrays\nof characters. Other languages may treat strings as dynamic data types. However, all\nlanguages use some form of character encoding to represent strings. Recall that computers\nonly speak in binary: 0s and 1s. To represent a character like the capital letter \u201cA\u201d, the\nbinary sequence 0b1000001 is used. In fact, the most common alphanumeric characters\nare encoded according to the American Standard Code for Information Interchange\n(ASCII) text standard. The basic ASCII text standard assigns characters to the decimal\nvalues 0\u2013127 using 7 bits to encode each character as a number. Table 2.4 contains a\ncomplete listing of standard ASCII character set.\nTheASCIItablewasdesignedtoenforcealexicographicordering: lettersareinalphabetic\norder, uppercase precede lowercase versions, and numbers precede both. This design\nallows for an easy and natural comparison among strings, \u201calpha\u201d would come before\n\u201cbeta\u201d because they differ in the first letter. The characters have numerical values 97\nand 98 respectively; since 97 < 98, the order follows. Likewise, \u201cAlpha\u201d would come\nbefore \u201calpha\u201d (since 65 < 97), and \u201calpha\u201d would come before \u201calphanumeric\u201d: the\nsixth character is empty in the first string (usually treated as the null character with\nvalue 0) while it is \u201cn\u201d in the second (value of 110). This is the ordering that we would\nexpect in a dictionary.\nThere are several other nice design features built into the ASCII table. For example, to\nconvert between uppercase and lowercase versions, you only need to \u201cflip\u201d the second\nbit (0 for uppercase, 1 for lowercase). There are also several special characters that\n27 2. Basics\nBinary Dec Character Binary Dec Character Binary Dec Character\n0b000 0000 0 \\0Nullcharacter 0b010 1011 43 + 0b101 0110 86 V\n0b000 0001 1 StartofHeader 0b010 1100 44 , 0b101 0111 87 W\n0b000 0010 2 StartofText 0b010 1101 45 - 0b101 1000 88 X\n0b000 0011 3 EndofText 0b010 1110 46 . 0b101 1001 89 Y\n0b000 0100 4 EndofTransmission 0b010 1111 47 \/ 0b101 1010 90 Z\n0b000 0101 5 Enquiry 0b011 0000 48 0 0b101 1011 91 [\n0b000 0110 6 Acknowledgment 0b011 0001 49 1 0b101 1100 92 \\\n0b000 0111 7 \\aBell 0b011 0010 50 2 0b101 1101 93 ]\n0b000 1000 8 \\bBackspace 0b011 0011 51 3 0b101 1110 94 ^\n0b000 1001 9 \\tHorizontalTab 0b011 0100 52 4 0b101 1111 95\n0b000 1010 10 \\nLinefeed 0b011 0101 53 5 0b110 0000 96 \u2018\n0b000 1011 11 \\vVerticalTab 0b011 0110 54 6 0b110 0001 97 a\n0b000 1100 12 \\fFormfeed 0b011 0111 55 7 0b110 0010 98 b\n0b000 1101 13 \\rCarriagereturn 0b011 1000 56 8 0b110 0011 99 c\n0b000 1110 14 ShiftOut 0b011 1001 57 9 0b110 0100 100 d\n0b000 1111 15 ShiftIn 0b011 1010 58 : 0b110 0101 101 e\n0b001 0000 16 DataLinkEscape 0b011 1011 59 ; 0b110 0110 102 f\n0b001 0001 17 DeviceControl1 0b011 1100 60 < 0b110 0111 103 g\n0b001 0010 18 DeviceControl2 0b011 1101 61 = 0b110 1000 104 h\n0b001 0011 19 DeviceControl3 0b011 1110 62 > 0b110 1001 105 i\n0b001 0100 20 DeviceControl4 0b011 1111 63 ? 0b110 1010 106 j\n0b001 0101 21 NegativeAck 0b100 0000 64 @ 0b110 1011 107 k\n0b001 0110 22 Synchronousidle 0b100 0001 65 A 0b110 1100 108 l\n0b001 0111 23 EndofTrans. Block 0b100 0010 66 B 0b110 1101 109 m\n0b001 1000 24 Cancel 0b100 0011 67 C 0b110 1110 110 n\n0b001 1001 25 EndofMedium 0b100 0100 68 D 0b110 1111 111 o\n0b001 1010 26 Substitute 0b100 0101 69 E 0b111 0000 112 p\n0b001 1011 27 Escape 0b100 0110 70 F 0b111 0001 113 q\n0b001 1100 28 FileSeparator 0b100 0111 71 G 0b111 0010 114 r\n0b001 1101 29 GroupSeparator 0b100 1000 72 H 0b111 0011 115 s\n0b001 1110 30 RecordSeparator 0b100 1001 73 I 0b111 0100 116 t\n0b001 1111 31 UnitSeparator 0b100 1010 74 J 0b111 0101 117 u\n0b010 0000 32 (space) 0b100 1011 75 K 0b111 0110 118 v\n0b010 0001 33 ! 0b100 1100 76 L 0b111 0111 119 w\n0b010 0010 34 \" 0b100 1101 77 M 0b111 1000 120 x\n0b010 0011 35 # 0b100 1110 78 N 0b111 1001 121 y\n0b010 0100 36 $ 0b100 1111 79 O 0b111 1010 122 z\n0b010 0101 37 % 0b101 0000 80 P 0b111 1011 123 {\n0b010 0110 38 & 0b101 0001 81 Q 0b111 1100 124 |\n0b010 0111 39 \u2019 0b101 0010 82 R 0b111 1101 125 }\n0b010 1000 40 ( 0b101 0011 83 S 0b111 1110 126 ~\n0b010 1001 41 ) 0b101 0100 84 T 0b111 1111 127 Delete\n0b010 1010 42 * 0b101 0101 85 U\nTable 2.4.: ASCII Character Table. The first and second column indicate the binary and\ndecimal representation respectively. The third column visualizes the resulting\ncharacter when possible. Characters 0\u201331 and 127 are control characters that\nare not printable or print whitespace. The encoding is designed to impose a\nlexicographic ordering: A\u2013Z are in order, uppercase letters precede lowercase\nletters, numbers precede letters and are also in order.\n28 2.2. Variables\nneed to be escaped to be defined. For example, though your keyboard has a tab and an\nenter key, if you wanted to code those characters, you would need to specify them in\nsome way other than using those keys (since typing those keys will affect what you are\ntyping rather than specifying a character). The standard way to escape characters is to\nuse a backslash along with another, single character. The three most common are the\n(horizontal) tab, \\t, the endline character, \\n, and the null terminating character, \\0.\nThe tab and endline character are used to specify their whitespace characters respectively.\nThe null character is used in some languages to denote the end of a string and is not\nprintable.\nASCII is quite old, originally developed in the early sixties. President Johnson first\nmandated that all computers purchased by the federal government support ASCII in 1968.\nHowever, it is quite limited with only 128 possible characters. Since then, additional\nextensions have been developed. The Extended ASCII character set adds support for\n128 additional characters (numbered 128 through 255) by adding 1 more bit (8 total).\nIncluded in the extension are support for common international characters with diacritics\nsuch as u\u00a8, n~ and \u00a3 (which are characters 129, 164, and 156 respectively).\nEven 256 possible characters are not enough to represent the wide array of international\ncharacters when you consider languages like Chinese Japanese Korean (CJK). Unicode\nwas developed to solve this problem by establishing a standard encoding that supports\n1,112,064 possible characters, though only a fraction of these are actually currently\nassigned.4 Unicode is backward compatible, so it works with plain ASCII characters. In\nfact, the most common encoding for Unicode, UTF-8 uses a variable number of bytes to\nencode characters. 1-byte encodings correspond to plain ASCII, there are also 2, 3, and\n4-byte encodings.\nIn most programming languages, strings literals are defined by using either single or\ndouble quotes to indicate where the string begins and ends. For example, one may be\nable to define the string \"Hello World\". The double quotes are not part of the string,\nbut instead specify where the string begins and ends. Some languages allow you to use\neither single or double quotes. PHP for example would allow you to also define the same\nstring as 'Hello World'. Yet other languages, such as C distinguish the usage of single\nand double quotes: single quotes are for single characters such as 'A' or '\\n' while\ndouble quotes are used for full strings such as \"Hello World\".\nIn any case, if you want a single or double quote to appear in your string you need to\nescape it similar to how the tab and endline characters are escaped. For example, in C\n'\\'' would refer to the single quote character and \"Dwayne \\\"The Rock\\\" Johnson\"\nwould allow you to use double quotes within a string. In our pseudocode we\u2019ll use the\nstylized double quotes, \u201cHello World\u201d in any strings that we define. We will examine\n4As of 2012, 110,182 are assigned to characters, 137,468 are reserved for private use (they are valid\ncharacters, but not defined so that organizations can use them for their own purposes), with 2,048\nsurrogates and 66 non-character control codes. 864,348 are left unassigned meaning that we are\nwell-prepared for encoding alien languages when they finally get here.\n29 2. Basics\nstring types more fully in Chapter 8.\nBoolean Types\nA Boolean is another type of variable that is used to hold a truth value, either true or\nfalse, of a logical statement. Some programming languages explicitly support a built-in\nBoolean type while others implicitly support them. For languages that have explicit\nBoolean types, typically the keywords true and false are used, but logical expressions\nsuch as x \u2264 10 can also be evaluated and assigned to Boolean variables.\nSome languages do not have an explicit Boolean type and instead support Booleans\nimplicitly, sometimes by using numeric types. For example, in C, false is associated with\nzero while any non-zero value is associated with true. In either case, Boolean values are\nused to make decisions and control the flow of operations in a program (see Chapter 3).\nObject & Reference Types\nNot everything is a number or string. Often, we wish to model real-world entities such\nas people, locations, accounts, or even interactions such as exchanges or transactions.\nMost programming languages allow you to create user-defined types by using objects or\nstructures. Objects and structures allow you to group multiple pieces of data together\ninto one logical entity; this is known as encapsulation. For example, a Student object may\nconsist of a first-name, last-name, GPA, year, major, etc. Grouping these separate pieces\nof data together allows us to define a more complex type. We explore these concepts in\nmore depth in Chapter 10.\nIn contrast to the built-in numeric, character\/string, and Boolean types (also called\nprimitive data types) user-defined types do not necessarily take a fixed amount of memory\nto represent. Since they are user-defined, it is up to the programmer to specify how\nthey get created and how they are represented in memory. A variable that refers to an\nobject or structure is usually a reference or pointer: a reference to where the object is\nstored in memory on a computer. Many programming languages use the keyword null\n(or sometimes NULL or a some variation) to indicate an invalid reference. The null\nkeyword is often used to refer to uninitialized or \u201cmissing\u201d data.\nAnother common user-defined type is an enumerated type which allows a user to define a\nlist of keywords associated with integers. For example, the cardinal directions, \u201cnorth\u201d,\n\u201csouth\u201d, \u201ceast\u201d, and \u201cwest\u201d could be associated with the integers 0, 1, 2, 3 respectively.\nDefining an enumerated type then allows you to use these keywords in your program\ndirectly without having to rely on mysterious numerical values, making a program more\nreadable and less prone to error.\n30 2.2. Variables\n2.2.3. Declaring Variables: Dynamic vs. Static Typing\nIn some languages, variables must be declared before they can be referred to or used.\nWhen you declare a variable, you not only give it an identifier, but also define its type.\nFor example, you can declare a variable named numberOfStudents and define it to be\nan integer. For the life of that variable, it will always be an integer type. You can only\ngive that variable integer values. Attempts to assign, say, a string type to an integer\nvariable may either result in a syntax error or a runtime error when the program is\nexecuted or lead to unexpected or undefined behavior. A language that requires you to\ndeclare a variable and its type is a statically typed language.\nThe declaration of a variable is typically achieved by writing a statement that includes\nthe variable\u2019s type (using a built-in keyword of the language) along with the variable\nname. For example, in C-style languages, a line like\nint x;\nwould create an integer variable associated with the identifier x.\nIn other languages, typically interpreted languages, you do not have to declare a variable\nbefore using it. Such languages are generally referred to as dynamically typed languages.\nInstead of declaring a variable to have a particular type, the type of a variable is\ndetermined by the type of value that is assigned to it. If you assign an integer to a\nvariable it becomes an integer. If you assign a string to it, it becomes a string type.\nMoreover, a variable\u2019s type can change during the execution of a program. If you reassign\na value to a variable, it dynamically changes its type to match the type of the value\nassigned.\nIn PHP for example, a line like\n$x = 10;\nwould create an integer variable associated with the identifier $x. In this example, we\ndid not declare that $x was an integer. Instead, it was inferred by the value that we\nassigned to it (10).\nAt first glance it may seem that dynamically typed languages are better. Certainly\nthey are more flexible (and allow you to write less so-called \u201cboilerplate\u201d code), but\nthat flexibility comes at a cost. Dynamically typed variables are generally less efficient.\nMoreover, dynamic typing opens the door to a lot of potential type mismatching errors.\nFor example, you may have a variable that is assumed to always be an integer. In a\ndynamically typed language, no such assumption is valid as a reassignment can change\nthe variable\u2019s type. It is impossible to enforce this assumption by the language itself and\nmay require a lot of extra code to check a variable\u2019s type and deal with \u201ctype safety\u201d\nissues. The advantages and disadvantages of each continue to be debated.\n31 2. Basics\n{\n1\nint a;\n2\n{\n3\n\/\/this is a new code block inside the outer block\n4\nint b;\n5\n\/\/at this point in the code, both a and b are in-scope\n6\n}\n7\n\/\/at this point, only a is in-scope, b is out-of-scope\n8\n}\n9\nCode Sample 2.1.: Example of variable scoping in C\n2.2.4. Scoping\nThe scope of a variable is the section of code in which a variable is valid or \u201cknown.\u201d\nIn a statically typed language, a variable must be declared before it can be used. The\ncode block in which the variable is declared is therefore its scope. Outside of this code\nblock, the variable is invalid. Attempts to reference or use a variable that is out-of-scope\ntypically result in a syntax error. An example using the C programming language is\ndepicted in Code Sample 2.1.\nScoping in a dynamically typed language is similar, but since you don\u2019t declare a variable,\nthe scope is usually defined by the block of code where you first use or reference the\nvariable. In some languages using a variable may cause that variable to become globally\nscoped.\nA globally scoped variable is valid throughout the entirety of a program. A global variable\ncan be accessed and referenced on every line of code. Sometimes this is a good thing:\nfor example, we could define a variable to represent \u03c0 and then use it anywhere in our\nprogram. We would then be assured that every computation involving \u03c0 would be using\nthe same definition of \u03c0 (rather than one line of coding using the approximation 3.14\nwhile another uses 3.14159).\nOn the same token, however, global variables make the state and execution of a program\nless predictable: if any piece of code can access a global variable, then potentially any\npiece of code could change that variable. Imagine some questionable code changing the\nvalue of our global \u03c0 variable to 3. For this reason, using global variables is generally\nconsidered bad practice.5 Even if no code performs such an egregious operation, the\nfact that anything can change the value means that when testing, you must test for\n5Coders often say \u201cglobals are evil\u201d and indeed have often demonstrated that they have low moral\nstandards. Global variables that is. Coders are always above reproach.\n32 2.3. Operators\nthe potential that anything will change the value, greatly increasing the complexity\nof software testing. To capture the advantages of a global variable while avoiding the\ndisadvantages, it is common to only allow global constants; variables whose values cannot\nbe changed once set.\nAnother argument against globally scoped variables is that once the identifier has been\nused, it cannot be reused or redefined for other purposes (a floating point variable with\nthe identifier pi means we cannot use the identifier pi for any other purpose) as\nit would lead to conflicts. Defining many globally scoped variables (or functions, or\nother elements) starts to pollute the namespace by reserving more and more identifiers.\nProblems arise when one attempts to use multiple libraries that have both used the same\nidentifiers for different variables or functions. Resolving the conflict can be difficult or\nimpossible if you have no control over the offending libraries.\n2.3. Operators\nNow that we have variables, we need a way to work with variables. That is, given two\nvariables we may wish to add them together. Or we may wish to take two strings and\ncombine them to form a new string. In programming languages this is accomplished\nthrough operators which operate on one or more operands. An operator takes the values\nof its operands and combines them in some way to produce a new value. If an operator\nis applied to variable(s), then the values used in the operation are the values stored in\nthe variable at the time that the operator is evaluated.\nMany common operators are binary in thatthey operateon twooperands such ascommon\narithmetic operations like addition and multiplication. Some operators are unary in that\nthey only operate on one variable. The first operator that we look at is a unary operator\nand allows us to assign values to variables.\n2.3.1. Assignment Operators\nThe assignment operator is a unary operator that allows you to take a value and assign\nit to a variable. The assignment operator usually takes the following form: the value is\nplaced on the right-hand-side of the operator while the variable to which we are assigning\nthe value is placed on the left-hand-side of the operator. For our pseudocode, we\u2019ll use a\ngeneric \u201cleft-arrow\u201d notation:\na \u2190 10\nwhich should be read as \u201cplace the value 10 into the variable a.\u201d Many C-style pro-\ngramming languages commonly use a single equal sign for the assignment operator. The\nexample above might be written as\n33 2. Basics\na = 10;\nIt is important to realize that when this notation is used, it is not an algebraic declaration\nlike a = b which is an algebraic assertion that the variables a and b are equal. An\nassignment operator is different: it means place the value on the right-hand-side into the\nvariable on the left-hand-side. For that reason, writing something like\n10 = a;\nis invalid syntax. The left-hand-side must be a variable.\nThe right-hand-side, however, may be a literal, another variable, or even a more complex\nexpression. In the example before,\na \u2190 10\nthe value 10 was acting as a numerical literal: a way of expressing a (human-readable)\nvalue that the computer can then interpret as a binary value. In code, we can conveniently\nwrite numbers in base-10; when compiled or interpreted, the numerical literals are\nconverted into binary data that the computer understands and placed in a memory\nlocation corresponding to the variable. This entire process is automatic and transparent\nto the user. Literals can also be strings or other values. For example:\nmessage \u2190 \u201chello world\u201d\nWe can also \u201ccopy\u201d values from one variable to another. Assuming that we\u2019ve assigned\nthe value 10 to the variable a, we can then copy it to another variable b:\nb \u2190 a\nThis does not mean that a and b are the same variable. The value that is stored in the\nvariable a at the time that this statement is executed is copied into the variable b. There\nare now two different variables with the same value. If we reassign the value in a, the\nvalue in b is unaffected. This is illustrated in Algorithm 2.1\na \u2190 10\n1\nb \u2190 a\n2\n\/\/a and b both store the value 10 at this point\na \u2190 20\n3\n\/\/now a has the value 20, but b still has the value 10\nb \u2190 25\n4\n\/\/a still stores a value of 20, b now has a value of 25\nAlgorithm 2.1: Assignment Operator Demonstration\nThe right-hand-side can also be a more complex expression, for example the result of\nsumming two numbers together.\n34 2.3. Operators\n2.3.2. Numerical Operators\nNumerical operators allow you to create complex expressions involving either numerical\nliterals and\/or numerical variables. For most numerical operators, it doesn\u2019t matter if\nthe operands are integers or floating point numbers. Integers can be added to floating\npoint numbers without much additional code for example.\nThe most basic numerical operator is the unary negation operator. It allows you to\nnegate a numerical literal or variable. For example,\na \u2190 \u221210\nor\na \u2190 \u2212b\nThe usage of a negation is so common that it is often not perceived to be an operator\nbut it is.\nAddition & Subtraction\nYou can also add (sum) two numbers using the + (plus) operator and subtract using the\n\u2212 (minus) operator in a straightforward way. Note that most languages can distinguish\nthe minus operator and the negation operator by how you use it just like a mathematical\nexpression. If applied to one operand, it is interpreted as a negation operator. If applied\nto two operands, it represents subtraction. Some examples can be found in Algorithm\n2.2.\na \u2190 10\n1\nb \u2190 20\n2\nc \u2190 a+b\n3\nd \u2190 a\u2212b\n4\n\/\/c has the value 30 while d has the value \u221210\nc \u2190 a+10\n5\nd \u2190 \u2212d\n6\n\/\/c now has the value 20 and d now has the value 10\nAlgorithm 2.2: Addition and Subtraction Demonstration\nMultiplication & Division\nYou can also multiply and divide literals and variables. In mathematical expressions\nmultiplication is represented as a\u00d7b or a\u00b7b or simply just ab and division is represented\n35 2. Basics\nas a\u00f7b or a\/b or a. In our pseudocode, we\u2019ll generally use a\u00b7b and a, but in programming\nb b\nlanguages it is difficult to type these symbols. Usually programming languages use *\nfor multiplication and \/ for division. Similar examples are provided in Algorithm 2.3.\na \u2190 10\n1\nb \u2190 20\n2\nc \u2190 a\u00b7b\n3\nd \u2190 a\n4\nb\n\/\/c has the value 200 while d has the value 0.5\nAlgorithm 2.3: Multiplication and Division Demonstration\nCareful! Some languages specify that the result of an arithmetic operation on variables\nof a certain type must match. That is, an integer plus an integer results in an integer. A\nfloating point number divided by a floating point number results a floating point number.\nWhen we mix types, say an integer and a floating point number, the result is generally a\nfloating point number. For the most part this is straightforward. The one tricky case is\nwhen we have an integer divided by another integer, 3\/2 for example.\nSince both operands are integers, the result must be an integer. Normally, 3\/2 = 1.5,\nbut since the result must be an integer, the fractional part gets truncated (cut-off) and\nonly the integral part is kept for the final result. This can lead to weird results such as\n1\/3 = 0 and 99\/100 = 0. The result is not rounded down or up; instead the fractional\npart is completely thrown out. Care must be taken when dividing integer variables in a\nstatically typed language. Type casting can be used to force variables to change their\ntype for the purposes of certain operations so that the full answer is preserved. For\nexample, in C we can write\nint a = 10;\n1\nint b = 20;\n2\ndouble c;\n3\nint d;\n4\nc = (double) a \/ (double) b;\n5\nd = a \/ b;\n6\n\/\/the value in c is correctly 0.5 but the value in d is 0\n7\n36 2.3. Operators\nInteger Division\nRecall that in arithmetic, when you divide integers a\/b, b might not go into a evenly in\nwhich case you get a remainder. For example, 13\/5 = 2 with a remainder r = 3. More\ngenerally we have that\na = qb+r\nWhere a is the dividend, b is the divisor, q is the quotient (the result) and r is the\nremainder. We can also perform integer division in most programming languages. In\nparticular, the integer division operator is the operator that gives us the remainder of\nthe integer division operation in a\/b. In mathematics this is the modulo operator and is\ndenoted\na mod b\nFor example,\n13 mod 5 = 3\nIt is possible that the remainder is zero, for example,\n10 mod 5 = 0\nMany programming languages support this operation using the percent sign. For example,\nc = a % b;\n2.3.3. String Concatenation\nStrings can also be combined to form new strings. In fact, strings can often be combined\nwith non-string variables to form new strings. You would typically do this in order to\nconvert a numerical value to a string representation so that it can be output to the user\nor to a file for longterm storage. The operation of combining strings is referred to as\nstring concatenation. Some languages support this through the same plus operator that\nis used with addition. For example,\nmessage \u2190 \u201chello \u201d+\u201cworld!\u201d\nwhich combines the two strings to form one string containing the characters \u201chello world!\u201d,\nstoring the value into the message variable. For our pseudocode we\u2019ll adopt the plus\noperator for string concatenation.\nThe string concatenation operator can also sometimes be combined with non-string\ntypes; numerical types for example. This allows you to easily convert numbers to a\nhuman-readable, base-10 format so that they can be printed to the output. For example\nsuppose that the variable b contains the value 20, then\nmessage \u2190 \u201cthe answer is \u201d+b\n37 2. Basics\nmight result in the string \u201cthe answer is 20\u201d being stored in the variable message.\nOther languages use different symbols to distinguish concatenation and addition. Still\nyet other languages do not directly support an operator for string concatenation which\nmust instead be done using a function.\n2.3.4. Order of Precedence\nIn mathematics, when you write an expression such as:\na+b\u00b7c\nyou interpret it as \u201cmultiply b and c and then add a.\u201d This is because multiplication has\na higher order of precedence than addition. The order of precedence (sometimes referred\nto as order of operations) is a set of rules which define the order in which operations\nshould be evaluated. In this case, multiplication is performed before addition. If, instead,\nwe had written\n(a+b)\u00b7c\nwe would have a different interpretation: \u201cadd a and b and then multiply the result by\nc.\u201d That is, the inclusion of parentheses changes the order in which we evaluate the\noperations. Adding parentheses can have no effect (if we wrote a+(bc) for example), or\nit can cause operations with a lower order of precedence to be evaluated first as in the\nexample above.\nNumerical operators are similar when used in most programming languages. The same\norder of precedence is used and parentheses can be used to change the order of evaluation.\n2.3.5. Common Numerical Errors\nWhendealingwithnumerictypesitisimportanttoknowandunderstandtheirlimitations.\nIn mathematics, the following operations might be considered invalid.\n\u2022 Division by zero: a where b = 0. This is an undefined operation in mathematics\nb\nand also in programming languages. Depending on the language, any number of\nthings may happen. It may be a fatal error or exception; the program may continue\nexecuting but give \u201cgarbage\u201d results from then on; the result may be a special value\nsuch as null, \u201cNaN\u201d (not-a-number) or \u201cINF\u201d (a special representation of infinity).\nIt is best to avoid such an operation entirely using conditionals statements and\ndefensive programming (see Chapter 3).\n\u2022 Other potentially invalid operations involve common mathematical functions. For\n\u221a\nexample, \u22121 would be a complex result, i which some languages do support.\n38 2.3. Operators\nHowever, many do not. Similarly, the natural logarithm of zero, ln(0) and negative\nvalues, ln(\u22121) is undefined. In either case you could expect a result like \u201cNaN\u201d or\n\u201cINF.\u201d\n\u2022 Still other operations seem like they should be valid, but because of how numbers\nare represented in binary, the results are invalid. Recall that for a 32-bit signed,\ntwo\u2019s complement number, the maximum representable value is 2,147,483,647.\nSuppose this maximum value is stored in a variable, b. Now suppose we attempt\nto add one more,\nc \u2190 b+1\nMathematically we\u2019d expect the result to be 2,147,483,648, but that is more than\nthe maximum representable integer. What happens is something called arithmetic\noverflow. The actual number stored in binary in memory for 2,147,483,647 is\n0b011...11\n(cid:124) (cid:123)(cid:122) (cid:125)\n311s\nWhen we add 1 to this, it is carried over all the way to the 32nd bit, giving the\nresult\n0b100...00\n(cid:124) (cid:123)(cid:122) (cid:125)\n310s\nin binary. However, the 32nd bit is the sign bit, so this is a negative number.\nIn particular, if this is a two\u2019s complement integer, it has the decimal value\n\u22122,147,483,648 which is obviously wrong. Another example would be if we have a\n\u201clarge number, say 2 billion and attempt to double it (multiply by 2). We would\nexpect 4 billion as a result, but again overflow occurs and the result (using 32-bit\nsigned two\u2019s complement integers) is \u2212294,967,296.\n\u2022 A similar phenomenon can happen with floating point numbers. If an operation\n(say multiplying two \u201csmall\u201d numbers together) results in a number that is smaller\nthan the smallest floating point number that can be represented, the result is said\nto have resulted in underflow. The result can essentially be zero, or an error can\nbe raised to indicate that underflow has occurred. The consequences of underflow\ncan be very complex.\n\u2022 Floating-point operations can also result in a loss of precision even if no overflow\nor underflow occurs. For example, when adding a very large number a and a very\nsmall number b, the result might be no different from the value of a. This is because\n(for example) double precision floating point numbers only have about 16 significant\ndigits of precision with the least significant digits being cutoff in order to preserve\nthe magnitude.\n\u221a\nAs another example, suppose we compute 2 = 1.41421356.... If we squared the\nresult, mathematically we would expect to get 2. However, since we only have a\ncertain number of digits of precision, squaring the result in a computer may result\nin a value slightly different from 2 (either 1.9999998 or 2.0000001).\n39 2. Basics\n2.3.6. Other Operators\nMany programming languages support other \u201cconvenience\u201d operators that allow you to\nperform common operations using less code. These operators are generally syntactic\nsugar: the don\u2019t add any functionality. The same operation could be achieved using\nother operators. However, they do add simpler or more terse syntax for doing so.\nIncrement Operators\nAdding or subtracting one to a variable is a very common operation. So common, that\nmost programming languages define increment operators such as i++ and i-- which\nadd one and subtract one from the variables applied. The same effect could be achieved\nby writing\ni \u2190 (i+1) and i \u2190 (i\u22121)\nbut the increment operators provide a shorthand way of expressing the operation.\nThe operators i++ and i-- are postfix operators: the operator is written after (post)\nthe operand. Some languages define similar prefix increment operators, ++i and --i.\nThe effect is similar: each adds or subtracts one from the variable i. However, the\ndifference is when the operator is used in a larger expression. A postfix operator retains\nthe original value for the expression, a prefix operator takes on the new, incremented\nvalue in the expression.\nTo illustrate, suppose the variable i has the value 10. In the following line of code, i is\nincremented and used in an expression that adds 5 and stores the result in a variable x:\nx = 5 + (i++);\nThe value of x after this code is 15 while the value of i is now 11. This is because\nthe postfix operator increments i, but i++ retains the value 10 in the expression. In\ncontrast, with the line\nx = 5 + (++i);\nthe variable i again now has the value 11, but the value of x is 16 since ++i takes\non the new, incremented value of 11. Appropriately using each can lead to some very\nconcise code, but it is important to remember the difference.\nCompound Assignment Operators\nIf we want to increment or decrement a variable by an amount other than 1 we can do\nso using compound assignment operators that combine an arithmetic operator and an\nassignment operator into one. For example, a += 10 would add 10 to the variable a.\n40 2.4. Basic Input\/Output\nint a = 10;\n1\na += 5; \/\/adds 5 to a\n2\na -= 3; \/\/subtracts 3 from a\n3\na *= 2; \/\/multiplies a by 2\n4\na \/= 4; \/\/divides a by 4\n5\n6\n\/\/you can also use compound assignment operators with variables:\n7\nint b = 5;\n8\na += b; \/\/adds the value stored in b to a\n9\na -= b; \/\/subtracts the value stored in b from a\n10\na *= b; \/\/multiplies a by b\n11\na \/= b; \/\/divides a by b\n12\nCode Sample 2.2.: Compound Assignment Operators in C\nThe same could be achieved by coding a = a + 10, but the former is a bit shorter as\nwe don\u2019t have to repeat the variable.\nYou can do the same with subtraction, multiplication, and division. More examples\nusing the C programming language can be found in Code Snippet 2.2. It is important to\nnote that these operators are not, strictly speaking, equivalent. That is, a += 10 is not\nequivalent to a = a + 10. They have the same effect, but the first involves only one\noperator while the second involves two operators.\n2.4. Basic Input\/Output\nNot all variables can be coded using literals. Sometimes a program needs to read in\nvalues as input from a user who can give different values on different runs of a program.\nLikewise, a computer program often needs to produce output to the user to be of any\nuse.\nThe most basic types of programs are interactive programs that interact with a human\nuser. Generally, the program may interactive the user to enter some input value(s) or\nmake some choices. It may then compute some values and respond to the user with some\noutput. In the following sections we\u2019ll overview the various types of input and output\n(I\/O for short) that are available.\n41 2. Basics\n2.4.1. Standard Input & Output\nThe standard input (stdin for short), standard output (stdout) and standard error (stderr)\nare three standard communication streams that are defined by most computer systems.\nThough perhaps an over simplification, the keyboard usually serves as a standard input\ndevice while the monitor (or the system console) serves as a standard output device. The\nstandard error is usually displayed in the same display but may be displayed differently\non some systems (it is typeset in red in some consoles that support color to indicate that\nthe output is communicating an error).\nAs a program is executing, it may prompt a user to enter input. A program may wait\n(called blocking) until a user has typed whatever input they want to provide. The user\ntypically hits the enter key to indicate their input is done and the program resumes,\nreading the input provided via the standard input. The program may also produce\noutput which is displayed to the user.\nThe standard input and output are generally universal: almost any language, and\noperating system will support them and they are the most basic types of input\/output.\nHowever, the type of input and output is somewhat limited (usually limited to text-based\nI\/O) and doesn\u2019t provide much in the way of input validation. As an example, suppose\nthat a program prompts a user to enter a number. Since the input device (keyboard) is\ndoes not really restrict the user, a more obstinate user may enter a non-numeric value,\nsay \u201chello\u201d. The program may crash or provide garbage output with such input.\n2.4.2. Graphical User Interfaces\nA much more user-oriented way of reading input and displaying output is to use a\nGraphical User Interface (GUI). GUIs can be implemented as traditional \u201cthick-client\u201d\napplications (programs that are installed locally on your machine) or as \u201cthin-client\u201d\napplications such as a web application. They typically support general \u201cwidgets\u201d such as\ninput boxes, buttons, sliders, etc. that allow a user to interact with the program in a\nmore visual way. They also allow the programmer to do better input validation. Widgets\ncould be design so that only good input is allowed by creating modal restrictions: the\nuser is only allowed to select one of several \u201cradio\u201d buttons for example. GUIs also\nsupport visual feedback cues to the user: popups, color coding, and other elements can\nbe used to give feedback on errors and indicate invalid selections.\nGraphical user interfaces can also make use of more modern input devices: mice, touch\nscreens with gestures, even gaming devices such as the Kinect allow users to use a full\nbody motion as an input mechanism. We discuss GUIs in more detail in Chapter 13. To\nbegin, we\u2019ll focus more on plain textual input and output.\n42 2.4. Basic Input\/Output\nLanguage Standard Output String Output\nC printf() sprintf()\nJava System.out.printf() String.format()\nPHP printf() sprintf()\nTable 2.5.: printf()-style Methods in Several Languages. Languages support format-\nting directly to the Standard Output as well as to strings that can be further\nusedormanipulated. Mostlanguagesalsosupport printf()-styleformatting\nto other output mechanisms (streams, files, etc.).\n2.4.3. Output Using printf()-style Formatting\nRecall that many languages allow you to concatenate a string and a non-string type in\norder to produce a string that can then be output to the standard output. However,\nconcatenation doesn\u2019t provide much in the way of customizability when it comes to\nformatting output. We may want to format a floating point number so that it only prints\ntwo decimal places (as with US currency). We may want to align a column of data so\nthat number places match up. Or we may want to justify text either left or right.\nSuch data formatting can be achieved through the use of a printf()-style formatting\nfunction. The ideas date back to the mid-60s, but the modern printf() comes from\nthe C programming language. Numerous programming languages support this style\nof formatted output (printf() stands for print formatted). Most support either\nprinting the resulting formatted output to the standard output as well as to strings and\nother output mechanisms (files, streams, etc.). Table 2.5 contains a small sampling of\nprintf()-style functions supported in several languages. We\u2019ll illustrate this usage\nusing the C programming language for our examples, but the concepts are generally\nuniversal across most languages.\nThe function works by providing it a number of arguments. The first argument is always\na string that specifies the formatting of the result using several placeholders (flags that\nbegin with a percent sign) which will be replaced with values stored in variables but\nin a formatted manner. Subsequent arguments to the function are the list of variables\nto be printed; each argument is delimited by a comma. Figure 2.3 gives an example\nof of a printf() statement with two placeholders. The placeholders are ultimately\nreplaced with the values stored in the provided variables a,b. If a,b held the values 10\nand 2.718281, the code would end up printing\nThe value of a = 10, the value of b is 2.718281\nThough there are dozens of placeholders that are supported, we will focus only on a few:\n\u2022 %d formats an integer variable or literal\n43 2. Basics\nFormat String\nprintf(\"The value of a = %d, the value of b is %f\\n\", a, b);\nPrint List\nPlaceholders\nFigure 2.3.: Elements of a printf() statement in C\n\u2022 %f formats a floating point variable or literal\n\u2022 %c formats a single character variable or literal\n\u2022 %s formats a string variable or literal\nMisuse of placeholders may result in garbage output. For example, using an integer\nplaceholder, %d, but providing a string argument; since strings cannot be (directly)\nconverted to integers, the output will not be correct.\nIn addition to these placeholders, you can also add modifiers. A number n between\nthe percent sign and character (%nd, %nf, %ns)) specifies that the result should be\nformatted with a minimum of n columns. If the output takes less than n columns,\nprintf() will pad out the result with spaces so that there are n columns. If the output\ntakes n or more columns, then the modifier will have no effect (it specifies a minimum\nnot a maximum).\nFloating-point numbers have a second modifier that allows you to specify the number of\ndigits of precision to be formatted. In particular, you can use the placeholder %n.mf in\nwhich n has the same meaning, but m specifies the number of decimals to be displayed.\nBy default, 6 decimals of precision are displayed. If m is greater than the precision of the\nnumber, zeros are usually used for subsequent digits; if m is smaller than the precision of\nthe number, rounding may occur. Note that the n modifier includes the decimal point\nas a column. Both modifiers are optional.\nFinally, each of these modifiers can be made negative (example: %-20d) to left-justify\nthe result. By default, justification is to the right. Several examples are illustrated in\nCode Sample 2.3 with the results in Code Sample 2.4.\n2.4.4. Command Line Input\nNot all programs are interactive. In fact, the vast majority of software is developed to\ninteract with other software and does not expect that a user is sitting at the console\n44 2.4. Basic Input\/Output\nint a = 4567;\n1\ndouble b = 3.14159265359;\n2\n3\nprintf(\"a=%d\\n\", a);\n4\nprintf(\"a=%2d\\n\", a);\n5\nprintf(\"a=%4d\\n\", a);\n6\nprintf(\"a=%8d\\n\", a);\n7\n8\n\/\/by default, prints 6 decimals of precision\n9\nprintf(\"b=%f\\n\", b);\n10\n\/\/the .m modifier is optional:\n11\nprintf(\"b=%10f\\n\", b);\n12\n\/\/the n modifier is also optional:\n13\nprintf(\"b=%.2f\\n\", b);\n14\n\/\/note that this rounds!\n15\nprintf(\"b=%10.3f\\n\", b);\n16\n\/\/zeros are added so that 15 decimals are displayed\n17\nprintf(\"b=%20.15f\\n\", b);\n18\nCode Sample 2.3.: printf() examples in C\na=4567\na=4567\na=4567\na= 4567\nb=3.141593\nb= 3.141593\nb=3.14\nb= 3.142\nb= 3.141592653590000\nCode Sample 2.4.: Result of computation in Code Sample 2.3. Spaces are highlighted\nwith a for clarity.\n45 2. Basics\nconstantly providing it with input. Most languages and operating systems support\nnon-interactive input from the Command Line Interface (CLI). This is input that is\nprovided at the command line when the program is executed. Input provided from the\ncommand line are usually referred to as command line arguments. For example, if we\ninvoke a program named myProgram from the command line prompt using something\nlike the following:\n~>.\/myProgram a 10 3.14\nThen we would have provided 4 command line arguments. The first argument is usually\nthe program\u2019s name, all subsequent arguments are separated by whitespace. Command\nlineargumentsareprovidedtotheprogramasstringsanditistheprogram\u2019sresponsibility\nto convert them if needed and to validate them to ensure that the correct expected\nnumber and type of arguments were provided.\nWithin a program, command line arguments are usually referred to as an argument vector\n(sometimes in a variable named argv) and argument count (sometimes in a variable\nnamed argc). We explore how each language supports this in subsequent chapters.\n2.5. Debugging\nMaking mistakes in programming is inevitable. Even the most expert of software\ndevelopers make mistakes.6 Errors in computer programs are usually referred to as\nbugs. The term was popularized by Grace Hopper in 1947 while working on a Mark\nII Computer at a US Navy research lab. Literally, a moth stuck in the computer was\nimpeding its operation. Removing the moth or \u201cdebugging\u201d the computer fixed it. In\nthis section we will identify general types of errors and outline ways to address them.\n2.5.1. Types of Errors\nWhen programming, there are several types of errors that can occur. Some can be easily\ndetected (or even easily fixed) by compilers and other modern code analysis tools such\nas IDEs.\n6A severe security bug in the popular unix bash shell utility went undiscovered for 25 years before it\nwas finally fixed in September 2014, missed by thousands of experts and some of the best coders in\nthe world.\n46 2.5. Debugging\nSyntax Errors\nSyntax errors are errors in the usage of a programming language itself. A syntax error\ncan be a failure to adhere to the rules of the language such as misspelling a keyword or\nforgetting proper \u201cpunctuation\u201d (such as missing an ending semicolon). When you have a\nsyntax error, you\u2019re essentially not \u201cspeaking the same language.\u201d You wouldn\u2019t be very\ncomprehensible if you started injecting non-sense words or words from different language\nwhen speaking to someone in English. Similarly, a computer can\u2019t understand what\nyou\u2019re trying to say (or what directions you\u2019re trying to give it) if you\u2019re not speaking\nthe same language.\nTypically syntax errors prevent you from even compiling a program, though syntax\nerrors can be a problem at runtime with interpreted languages. When a syntax error is\nencountered, a compiler will fail to complete the compilation process and will generally\nquit. Ideally, the compiler will give reasons for why it was unable to compile and will\nhopefully identify the line number where the syntax error was encountered with a hint on\nwhat was wrong. Unfortunately, many times a compiler\u2019s error message isn\u2019t too helpful\nor may indicate a problem on one line where the root cause of the problem is earlier\nin the program. One cannot expect too much from a compiler after all. If a compiler\nwere able to correctly interpret and fix our errors for us, we\u2019d have \u201cnatural language\u201d\nprogramming where we could order the computer to execute our commands in plain\nEnglish. If we had this science fiction-level of computer interaction we wouldn\u2019t need\nprogramming languages at all.\nFixing syntax errors involves reading and interpreting the compiler error messages,\nreexamining the program and fixing any and all issues to conform to the syntax of\nthe programming language. Fixing one syntax error may enable the compiler to find\nadditional syntax errors that it had not found before. Only once all syntax errors have\nbeen resolved can a program actually compile. For interpreted languages, the program\nmay be able to run up to where it encounters a syntax error and then exits with a fatal\nerror. It may take several test runs to resolve such errors.\nRuntime Errors\nOnce a program is free of syntax errors it can be compiled and be run. However, that\ndoesn\u2019t mean that the program is completely free of bugs, just that it is free of the types\nof bugs (syntax errors) that the compiler is able to detect. A compiler is not able to\npredict every action or possible event that could occur when a program is actually run.\nA runtime error is an error that occurs while a program is being executed. For example,\na program could attempt to access a file that does not exist, or attempt to connect to a\nremote database, but the computer has lost its network connection, or a user could enter\nbad data that results in an invalid arithmetic operation, etc.\n47 2. Basics\nA compiler cannot be expected to detect such errors because, by definition, the conditions\nunder which runtime errors occur occur at runtime, not at compile time. One run of\na program could execute successfully, while another subsequent run could fail because\nthe system conditions have changed. That doesn\u2019t mean that we should not attempt to\nmitigate the consequences of runtime errors.\nAs a programmer it is important to think about the potential problems and runtime\nerrors that could occur and make contingency plans accordingly. We can make reasonable\nassumptions that certain kinds of errors may occur in the execution of our program and\nadd code to handle those errors if they occur. This is known as error handling (which\nwe discuss in detail in Chapter 6). For example, we could add code that checks if a user\nenters bad input and then re-prompt them to enter good input. If a file is missing, we\ncould add code to create it as needed. By checking for these errors and preventing illegal,\npotentially fatal operations, we practice defensive programming.\nLogic Errors\nOther errors may be a result of bad code or bad design. Computers do exactly as they\nare told to do. Logic errors can occur if we tell the computer to do something that we\ndidn\u2019t intend for them to do. For example, if we tell the computer to execute command\nA under condition X, but we meant to have the computer execute command B under\ncondition Y, we have caused a logical error. The computer will perform the first set of\ninstructions, not the second as we intended. The program may be free of syntax errors\nand may execute without any problems, but we certainly don\u2019t get the results that we\nexpected.\nLogic errors are generally only detected and addressed by rigorous software testing. When\ndeveloping software, we can also design a collection of test cases: a set of inputs along\nwith correct outputs that we would expect the program of code to produce. We can then\ntest the program with these inputs to see if they produce the same output as in the test\ncases. If they don\u2019t, then we\u2019ve uncovered a logical error that needs to be addressed.\nRigorous testing can be just as complex (or even more complex) than writing the program\nitself. Testing alone cannot guarantee that a program is free of bugs (in general, the\nnumber of possible inputs is infinite; it is impossible to test all possibilities). However,\nthe more test cases that we design and pass the higher the confidence we have that the\nprogram is correct.\nTesting can also be very tedious. Modern software engineering techniques can help\nstreamline the process. Many testing frameworks have been developed and built that\nattempt to automate the testing process. Test cases can be randomly generated and\ntest suites can be repeatedly run and verified throughout the development process.\nFrameworks can perform regression testing to see if fixing one bug caused or uncovered\nanother, etc.\n48 2.5. Debugging\n2.5.2. Strategies\nA common beginner\u2019s way of debugging a program is to insert temporary print statements\nthroughouttheirprogramtoseewhatvaluesvariableshaveatcertainpointsinanattempt\nto isolate where an error is occurring. This is an okay strategy for extremely simple\nprograms, but its the \u201cpoor man\u2019s\u201d way of debugging. As soon as you start writing\nmore complex programs you quickly realize that this strategy is slow, inefficient, and\ncan actually hide the real problems. The standard output is not guaranteed to work as\nexpected if an error has occurred, so print statements may actually mislead you into\nthinking the problem occurs at one point in the program when it actually occurs in a\ndifferent part.\nInstead, it is much better to use a proper debugging tool in order to isolate the problem.\nA debugger is a program, that allows you to \u201csimulate\u201d an execution of your program.\nYou can set break points in your program on certain lines and the debugger will execute\nyour program up to those points. It then pauses and allows you to look at the program\u2019s\nstate: you can examine the contents of memory, look at the values stored in certain\nvariables, etc. Debuggers will also allow you to resume the execution of your program\nto the next break point or allow you to \u201cstep\u201d through the execution of your program\nline by line. This allows you to examine the execution of a program at human speed in\norder to diagnose the exact point in execution where the problem occurs. IDEs allow\nyou to do this visually with a graphical user interface and easy visualization of variables.\nHowever, there are command line debuggers such as GDB (GNU\u2019s Not Unix! (GNU)\nDebugger) that you interact with using text commands.\nIn general, debugging strategies attempt to isolate a problem to the smallest possible code\nsegment. Thus, it is best practice to design your code using good procedural abstraction\nand place your code into functions and methods (see Chapter 5). It is also good practice\nto create test cases and test suites as you develop these small pieces of code.\nIt can also help to diagnose a problem by looking at the nature of the failure. If some\ntest cases pass and others fail you can get a hint as to what\u2019s wrong by examining the\nkey differences between the test cases. If one value passes and another fails, you can\ntrace that value as it propagates through the execution of your program to see how it\naffects other values.\nIn the end, good debugging skills, just like good coding skills, come from experience. A\nseasoned expert may be able to look at an error message and immediately diagnose the\nproblem. Or, a bug can escape the detection of hundreds of the best developers and\nsoftware tools and end up costing millions of dollars and thousands of man-hours.\n49 2. Basics\n2.6. Examples\nLet\u2019s apply these concepts by developing several prompt-and-compute style programs.\nThat is, the programs will prompt the user for input, perform some calculations, and\nthen output a result.\nTo write these programs, we\u2019ll use pseudocode, an informal, abstract description of a\nprogram\/algorithm. Pseudocode does not use any language-specific syntax. Instead,\nit describes processes at a high-level, making use of plain English and mathematical\nnotation. This allows us to focus on the actual process\/program rather than worrying\nabout the particular syntax of a specific language. Good pseudocode is easily translated\ninto any programming language.\n2.6.1. Temperature Conversion\nTemperature can be measured in several different scales. The most common for everyday\nuse is Celsius and Fahrenheit. Let\u2019s write a program to convert from Fahrenheit to\nCelsius using the following formula:\n5\nC = \u00b7(F \u221232)\n9\nThe basic outline of the program will be three simple steps:\n1. Read in a Fahrenheit value from the user\n2. Compute a Celsius value using the formula above\n3. Output the result to the user\nThis is actually pretty good pseudocode already, but let\u2019s be a little more specific using\nsome of the operators and notation we\u2019ve established above. The full program can be\nfound in Algorithm 2.4.\nprompt the user to enter a temperature in Fahrenheit\n1\nF \u2190 read input from user\n2\nC \u2190 5 \u00b7(F \u221232)\n3\n9\nOutput C to the user\n4\nAlgorithm 2.4: Temperature Conversion Program\n50 2.7. Exercises\n2.6.2. Quadratic Roots\nA common math exercise is to find the roots of a quadratic equation with coefficients,\na,b,c,\nax2 +bx+c = 0\nusing the quadratic formula,\n\u221a\n\u2212b\u00b1 b2 \u22124ac\nx =\n2a\nFollowing the same basic outline, we\u2019ll read in the coefficients from the user, compute\neach of the roots, and output the results to the user. We need two computations, one for\neach of the roots which we label r ,r . The full procedure is presented in Algorithm 2.5.\n1 2\nprompt the user to enter a\n1\na \u2190 read input from user\n2\nprompt the user to enter b\n3\nb \u2190 read input from user\n4\nprompt the user to enter c\n5\nc \u2190 read input from user\n6\n\u221a\nr \u2190 \u2212b+ b2\u22124ac\n7 1 2a\n\u221a\nr \u2190 \u2212b\u2212 b2\u22124ac\n8 2 2a\nOutput \u201cthe roots of ax2 +bx+c are r ,r \u201d\n9 1 2\nAlgorithm 2.5: Quadratic Roots Program\n2.7. Exercises\nExercise 2.1. Write a program that calculates mileage deduction for income tax using\nthe standard rate of $0.575 per mile. Your program will read in a beginning and ending\nodometer reading and calculate the difference and total deduction. Take care that your\noutput is in whole cents. An example run of the program may look like the following.\nINCOME TAX MILEAGE CALCULATOR\nEnter beginning odometer reading--> 13505.2\nEnter ending odometer reading--> 13810.6\nYou traveled 305.4 miles. At $.575 per mile,\nyour reimbursement is $175.61\n51 2. Basics\nExercise 2.2. Write a program to compute the total \u201ccost\u201d C of a loan. That is, the\ntotal amount of interest paid over the life of a loan. To compute this value, use the\nfollowing formula.\np\u00b7i\u00b7(1+i)12n\nC = \u221712n\u2212p\n(1+i)12n \u22121\nwhere\n\u2022 p is the starting principle amount\n\u2022 i = r where r is the APR on the interval [0,1]\n12\n\u2022 n is the number of years the loan is to be paid back\nExercise 2.3. Write a program to compute the annualized appreciation of an asset (say\na house). The program should read in a purchase price p, a sale price s and compute\ntheir difference d = s\u2212p (it should support a loss or gain). Then, it should compute an\nappreciation rate: r = d along with an (average) annualized appreciation rate (that is,\np\nwhat was the appreciation rate in each year that the asset was held that compounded ):\n1\n(1+r)y \u22121\nWhere y is the number of years (possibly fractional) the asset was held (and r is on the\nscale [0,1]).\nExercise 2.4. The annual percentage yield (APY) is a much more accurate measure of\nthe true cost of a loan or savings account that compounds interest on a monthly or daily\nbasis. For a large enough number of compounding periods, it can be calculated as:\nAPY = ei \u22121\nwhere i is the nominal interest rate (6% = 0.06). Write a program that prompts the user\nfor the nominal interest rate and outputs the APY.\nExercise 2.5. Write a program that calculates the speed of sound (v, feet-per-second)\nin the air of a given temperature T (in Fahrenheit). Use the formula,\n(cid:114)\n5T +297\nv = 1086\n247\nBe sure your program does not lose the fractional part of the quotient in the formula\nshown and format the output to three decimal places.\nExercise 2.6. Write a program to convert from radians to degrees using the formula\n180\u00b7rad\ndeg =\n\u03c0\nHowever, radians are on the scale [0,2\u03c0). After reading input from the user be sure to\ndo some error checking and give an error message if their input is invalid.\n52 2.7. Exercises\nExercise 2.7. Write a program to compute the Euclidean Distance between two points,\n(x ,y ) and (x ,y ) using the formulate:\n1 2 2 2\n(cid:112)\n(x \u2212x )2 +(y \u2212y )2\n1 2 1 2\nExercise 2.8. Write a program that will compute the value of sin(x) using the first 4\nterms of the Taylor series:\nx3 x5 x7\nsin(x) \u2248 x\u2212 + \u2212\n3! 5! 7!\nIn addition, your program will compute the absolute difference between this calculation\nand a standard implementation of the sine function supported in your language. Your\nprogram should prompt the user for an input value x and display the appropriate output.\nYour output should looks something like the following.\nSine Approximation\n===================\nEnter x: 1.15\nSine approximation: 0.912754\nSine value: 0.912764\nDifference: 0.000010\nExercise 2.9. Write a program to compute the roots of a quadratic equation:\nax2 +bx+c = 0\nusing the well-known quadratic formula:\n\u221a\n\u2212b\u00b1 b2 \u22124ac\n2a\nYour program will prompt the user for the values, a,b,c and output each real root.\nHowever, for \u201cinvalid\u201d input (a = 0 or values that would result in complex roots), the\nprogram will instead output a message that informs the user why that the inputs are\ninvalid (with a specific reason).\nExercise 2.10. One of Ohm\u2019s laws can be used to calculate the amount of power in\nWatts (the rate of energy conversion; 1 joule per second) in terms of Amps (a measure of\ncurrent, 1 amp = 6.241\u00d71018 electrons per second) and Ohms (a measure of electrical\nresistance). Specifically:\nW = A2 \u00b7O\nDevelop a simple program to read in two of the terms from the user and output the third.\n53 2. Basics\nExercise 2.11. Ohm\u2019s Law models the current through a conductor as follows:\nV\nI =\nR\nwhere V is the voltage (in volts), R is the resistance (in Ohms) and I is the current (in\namps). Write a program that, given two of these values computes the third using Ohm\u2019s\nLaw.\nThe program should work as follows: it prompts the user for units of the first value:\nthe user should be prompted to enter V, R, or I and should then be prompted for the\nvalue. It should then prompt for the second unit (same options) and then the value. The\nprogram will then output the third value depending on the input. An example run of\nthe program:\nCurrent Calculator\n==============\nEnter the first unit type (V, R, I): V\nEnter the voltage: 25.75\nEnter the second unit type (V, R, I): I\nEnter the current: 72\nThe corresponding resistance is 0.358 Ohms\nExercise 2.12. Consider the following linear system of equations in two unknowns:\nax+by = c\ndx+ey = f\nWrite a program that prompts the user for the coefficients in such a system (prompt for\na,b,c,d,e,f). Then output a solution to the system (the values for x,y). Take care to\nhandle situations in which the system is inconsistent.\nExercise 2.13. The surface area of a sphere of radius r is\n4\u03c0r2\nand the volume of a sphere with radius r is\n4\n\u03c0r3\n3\nWrite a program that prompts the user for a radius r and outputs the surface area\nand volume of the corresponding sphere. If the radius entered is invalid, print an error\nmessage and exit. Your output should look something like the following.\n54 2.7. Exercises\nSphere Statistics\n=================\nEnter radius r: 2.5\narea: 78.539816\nvolume: 65.449847\nExercise 2.14. Write a program that prompts for the latitude and longitude of two\nlocations (an origin and a destination) on the globe. These numbers are in the range\n[\u2212180,180] (negative values correspond to the western and southern hemispheres). Your\nprogram should then compute the air distance between the two points using the Spherical\nLaw of Cosines. In particular, the distance d is\nd = arccos(sin(\u03d5 )sin(\u03d5 )+cos(\u03d5 )cos(\u03d5 )cos(\u2206))\u00b7R\n1 2 1 2\n\u2022 \u03d5 is the latitude of location A, \u03d5 is the latitude of location B\n1 2\n\u2022 \u2206 is the difference between location B\u2019s longitude and location A\u2019s longitude\n\u2022 R is the (average) radius of the earth, 6,371 kilometers\nNote: the formula above assumes that latitude and longitude are measured in radians r,\n\u2212\u03c0 \u2264 r \u2264 \u03c0. See Exercise 2.6 for how to convert between them. Your program output\nshould look something like the following.\nCity Distance\n========================\nEnter latitude of origin: 41.9483\nEnter longitude of origin: -87.6556\nEnter latitude of destination: 40.8206\nEnter longitude of destination: -96.7056\nAir distance is 764.990931\nExercise 2.15. Write a program that prompts the user to enter in a number of days.\nYour program should then compute the number of years, weeks, and days that number\nrepresents. For this exercise, ignore leap years (thus all years are 365 days). Your output\nshould look something like the following.\nDay Converter\n=============\n55 2. Basics\nEnter number of days: 1000\nThat is\n2 years\n38 weeks\n4 days\nExercise 2.16. The derivative of a function f(x) can be estimated using the difference\nfunction:\nf(x+\u2206x)\u2212f(x)\nf(cid:48)(x) \u2248\n\u2206x\nThat is, this gives us an estimate of the slope of the tangent line at the point x. Write a\nprogram that prompts the user for an x value and a \u2206x value and outputs the value of\nthe difference function for all three of the following functions:\nf(x) = x2\nf(x) = sin(x)\nf(x) = ln(x)\nYour output should looks something like the following.\nDerivative Approximation\n===================\nEnter x: 2\nEnter delta-x: 0.1\n(x^2)' ~= 4.100000\nsin'(x) ~= -0.460881\nln'x(x) ~= 0.487902\nIn addition, your program should check for invalid inputs: \u2206x cannot be zero, and ln(x)\nis undefined for x \u2264 0. If given invalid inputs, appropriate error message(s) should be\noutput instead.\nExercise 2.17. Write a program that prompts the user to enter two points in the plane,\n(x ,y ) and (x ,y ) which define a line segment (cid:96). Your program should then compute and\n1 1 2 2\noutput an equation for the perpendicular line intersecting the midpoint of (cid:96). You should\ntake care that invalid inputs (horizontal or vertical lines) are handled appropriately. An\nexample run of your program would look something like the following.\n56 2.7. Exercises\nPerpendicular Line\n====================\nEnter x1: 2.5\nEnter y1: 10\nEnter x2: 3.5\nEnter y2: 11\nOriginal Line:\ny = 1.0000 x + 7.5000\nPerpendicular Line:\ny = -1.0000 x + 13.5000\nExercise 2.18. Write a program that computes the total for a bill. The program should\nprompt the user for a sub-total. It should then prompt whether or not the customer is\nentitled to an employee discount (of 15%) by having them enter 1 for yes, 2 for no. It\nshould then compute the new sub-total and apply a 7.35% sales tax, and print the receipt\ndetails along with the grand total. Take care that you properly round each operation.\nAn example run of the program should look something like the following.\nPlease enter a sub-total: 100\nApply employee discount (1=yes, 2=no)? 1\nReceipt\n========================\nSub-Total $ 100.00\nDiscount $ 15.00\nTaxes $ 6.25\nTotal $ 91.25\nExercise 2.19. The ROI (Return On Investment) is computed by the following formula:\nGain from Investment\u2212Cost of Investment\nROI =\nCost of Investment\nWrite a program that prompts the user to enter the cost and gain (how much it was sold\nfor) from an investment and computes and outputs the ROI. For example, if the user\nenters $100,000 and $120,000 respectively, the output look similar to the following.\n57 2. Basics\nCost of Investment: $100000.00\nGain of Investment: $120000.00\nReturn on Investment: 20.00%\nExercise 2.20. Write a program to compute the real cost of driving. Gas mileage (in\nthe US) is usually measured in miles per gallon but the real cost should be measured in\nhow much it costs to drive a mile, that is, dollars per mile. Write a program to assist a\nuser in figuring out the real cost of driving. Prompt the user for the following inputs.\n\u2022 Beginning odometer reading\n\u2022 Ending odometer reading\n\u2022 Number of gallons it took to fill the tank\n\u2022 Cost of gas in dollars per gallon\nFor example, if the user enters 50,125, 50,430, 10 (gallons), and $3.25 (per gallon), then\nyour output should be something like the following.\nMiles driven: 305\nMiles per gallon: 30.50\nCost per mile: $0.11\nExercise 2.21. A bearing can be measured in degrees on the scale of [0,360) with 0\u25e6\nbeing due north, 90\u25e6 due east, etc. The (initial) directional bearing from location A to\nlocation B can be computed using the following formula.\n(cid:0) (cid:1)\n\u03b8 = atan2 sin(\u2206)\u00b7cos(\u03d5 ), cos(\u03d5 )\u00b7sin(\u03d5 )\u2212sin(\u03d5 )\u00b7cos(\u03d5 )cos(\u2206)\n2 1 2 1 2\nWhere\n\u2022 \u03d5 is the latitude of location A\n1\n\u2022 \u03d5 is the latitude of location B\n2\n\u2022 \u2206 is the difference between location B\u2019s longitude and location A\u2019s longitude\n\u2022 atan2 is the two-argument arctangent function\nNote: the formula above assumes that latitude and longitude are measured in radians r,\n\u2212\u03c0 < r < \u03c0. To convert from degrees d (\u2212180 < d < 180) to radians r, you can use the\n58 2.7. Exercises\nsimple formula:\nd\nr = \u03c0\n180\nWrite a program to prompt a user for a latitude\/longitude of two locations (an origin and\na destination) and computes the directional bearing (in degrees) from the origin to the\ndestination. For example, if the user enters: 40.8206,\u221296.7056 (40.8206\u25e6 N, 96.7056\u25e6 W)\nand 41.9483,\u221287.6556 (41.9483\u25e6 N, 87.6556\u25e6 W), your program should output something\nlike the following.\nFrom (40.8206, -96.7056) to (41.9483, -87.6556):\nbearing 77.594671 degrees\nExercise 2.22. General relativity tells us that time is relative to your velocity. As you\napproach the speed of light (c = 299,792 km\/s), time slows down relative to objects\ntraveling at a slower velocity. This time dilation is quantified by the Lorentz equation\nt\nt(cid:48) =\n(cid:113)\n1\u2212 v2\nc2\nWhere t is the time duration on the traveling space ship and t(cid:48) is the time duration on\nthe (say) Earth.\nFor example, if we were traveling at 50% the speed of light relative to Earth, one hour in\nour space ship (t = 1) would correspond to\n1\nt(cid:48) = = 1.1547\n(cid:112)\n1\u2212(.5)2\nhours on Earth (about 1 hour, 9.28 minutes).\nWrite a program that prompts the user for a velocity which represents the percentage\np of the speed of light (that is, p = v) and a time duration t in hours and outputs the\nc\nrelative time duration on Earth.\nFor example, if the user enters 0.5 and 1 respectively as in our example, it should output\nsomething like the following:\nTraveling at 1 hour(s) in your space ship at\n50.00% the speed of light, your friends on\nEarth would experience:\n1 hour(s)\n9.28 minute(s)\n59 2. Basics\nYour output should be able to handle years, weeks, days, hours, and minutes. So if the\nuser inputs something like 0.9999 and 168, your output should look something like:\nTraveling at 168.00 hour(s) in your space ship at\n99.99% the speed of light, your friends on\nEarth would experience:\n1 year(s)\n18 week(s)\n3 day(s)\n17 hour(s)\n41.46 minute(s)\nExercise 2.23. Radioactive isotopes decay into other isotopes at a rate that is measured\nby a half-life, H. For example, Strontium-90 has a half-life of 28.79 years. If you started\nwith 10 kilograms of Strontium-90, 28.79 years later you would have only 5 kilograms\n(with the remaining 5 kilograms being Yttrium-90 and Zirconium-90, Strontium-90\u2019s\ndecay products).\nGiven a mass m of an isotope with half-life H we can determine how much of the isotope\nremains after y years using the formula,\n(cid:18) 1(cid:19)(y\/H)\nr = m\u00b7\n2\nFor example, if we have m = 10 kilograms of Strontium-90 with H = 28.79, after y = 2\nyears we would have\n(cid:18) 1(cid:19)(2\/28.79)\nr = 10\u00b7 = 9.5298\n2\nkilograms of Strontium-90 left.\nWrite a program that prompts the user for an amount m (mass, in kilograms) of an\nisotope and its half-life H as well as a number of years y and outputs the amount of\nthe isotope remaining after y years. For the example above your output should look\nsomething like the following.\nStarting with 10.00kg of an isotope with half-life\n28.79 years, after 2.00 years you would have\n9.5298 kilograms left.\n60 2.7. Exercises\nExercise 2.24. In sports, the magic number is a number that indicates the combination\nof the number of games that a leader in a division must win and\/or the 2nd place team\nmust lose for the leader to clinch the division. The magic number can be computed using\nthe following formula:\nG+1\u2212W \u2212L\nA B\nwhere G is the number of games played in the season, W is the number of wins the\nA\nleader currently has and L is the number of losses the 2nd place team currently has.\nB\nWrite a program that prompts the user to enter:\n\u2022 G, the total number of games in the season\n\u2022 W the number of wins of the leading team\nA\n\u2022 L the number of losses of the leading team\nA\n\u2022 W the number of wins of the second place team\nB\n\u2022 L the number of losses of the second place\nB\nYour program will then output the current win percentages of both teams, the magic\nnumber of the leading team as well as the percentage of the remaining games that must\ngo in team A\u2019s favor to satisfy the magic number (for this, we will assume A and B do\nnot play each other).\nFor example, if a user enters the values 162, 96, 58, 93, 62, the output should look\nsomething like the following.\nTeam Wins Loss Perc Magic Number\nA 96 58 62.34% 5\nB 93 62 60.00%\nWith 15 total games remaining, 33.33% must go in Team A's favor\nExercise 2.25. The Doppler Effect is a change in the observed spectral frequency of\nlight when objects in space are moving toward or away from us. If the spectral frequency\nof the object is known, then the relative velocity can be estimated based on either the\nblue-shift (for objects traveling toward the observer) or the red-shift (for objects traveling\naway from the observer) of the observed frequency.\nThe blue-shift equation to determine velocity is given by\n(cid:18) (cid:19)\n\u03bb\nv = c \u22121\nb\n\u03bb\nb\n61 2. Basics\nThe red-shift equation to determine velocity is given by\n(cid:18) (cid:19)\n\u03bb\nv = c 1\u2212\na\n\u03bb\nr\nwhere\n\u2022 c is the speed of light (299,792.458 km\/s)\n\u2022 \u03bb is the actual spectral line of the object (ex: hydrogen is 434nm)\n\u2022 \u03bb is the observed (red-shifted) spectral line and \u03bb is the observed (blue-shifted)\nr b\nspectral line\nWrite a program that prompts the user to enter which spectral shift they want to compute\n(1 for blue-shift, 2 for red-shift). The program should then prompt for the spectral line\nof an object and the observed (shifted) frequency and output the velocity of the distant\nobject. For example, if a user enters the values 1 (blue-shifted), 434 (nm) and 487 (nm),\nthe output should look something like the following.\nSpectral Line: 434nm\nObserved Line: 487nm\nRelative Velocity: 32626.28 km\/s\nExercise 2.26. Radiometric dating is a technique by which the age of rocks, minerals,\nand other material can be estimated by measuring the proportion of radioactive isotopes\nit still has to its decay products. It can be computed with the following formula:\nD = D +N(e\u03bbt \u22121)\n0\nwhere\n\u2022 t is age of the sample,\n\u2022 D is number of atoms of the daughter isotope in the sample,\n\u2022 D is number of atoms of the daughter isotope in the original composition,\n0\n\u2022 N is number of atoms of the parent isotope in the sample\n\u2022 \u03bb is the decay constant of the parent isotope,\nln2\n\u03bb =\nt\n1\/2\nwhere t is the half-life of the parent isotope (in years).\n1\/2\n62 2.7. Exercises\nWrite a program that prompts the user to enter D,D ,N, and t and computes the\n0 1\/2\napproximate age of the material, t.\nFor example, if the user were to enter 150, 50, 300, 28.8 (Strontium-90\u2019s half-life) then\nthe program should output something like the following.\nThe sample appears to be 11.953080 years old.\nExercise 2.27. Suppose you have two circles each centered at (0,0) and (d,0) with radii\nof R,r respectively. These circles may intersect at two points, forming an asymmetric\n\u201clens\u201d as in Figure 2.4.\nThe area of this lens can be computed using the following formula:\n(cid:18) d2 +r2 \u2212R2(cid:19) (cid:18) d2 +R2 \u2212r2(cid:19)\nA = r2cos\u22121 +R2cos\u22121 \u2212\n2dr 2dR\n1(cid:112)\n(\u2212d+r+R)(d+r\u2212R)(d\u2212r+R)(d+r+R)\n2\nWrite a program that prompts the user for the two radii and the x-offset d and computes\nthe area of this lens. Your program should handle the special cases where the two circles\ndo not intersect and when they intersect at a single point (the area is zero).\nFigure 2.4.: Intersection of two circles.\n63  3. Conditionals\nWhen writing code, its important to be able to distinguish between one or more situations.\nBased on some condition being true or false, you may want to perform some action if\nits true, while performing another, different action if it is false. Alternatively, you may\nsimply want to perform one action if and only if the condition is true, and do nothing\n(move forward in your program) if it is false.\nNormally, the control flow of a program is sequential: each statement is executed top-to-\nbottom one after the other. A conditional statement (sometimes called selection control\nstructures) interrupts this normal control flow and executes statements only if some\nspecified condition holds. The usual way of achieving this in a programming language is\nthrough the use conditional statements such as the if statement, if-else statement, and\nif-else-if statement.\nBy using conditional statements, we can design more expressive programs whose behavior\ndepends on their state: if the value of some variable is greater than some threshold, we\ncan perform action A, otherwise, we can perform action B. You do this on a daily basis\nas you make decisions for yourself. At a cafe you may want to purchase the grande coffee\nwhich costs $2. If you have $2 or more, then you\u2019ll buy it. Otherwise, if you have less\nthan $2, you can settle for the normal coffee which costs $1. Yet still, if you have less\nthan $1 you\u2019ll not be able to make a purchase. The value of your pocket book determines\nyour decision and subsequent actions that you take.\nSimilarly, our programs need to be able to \u201cmake decisions\u201d based on various conditions\n(they don\u2019t actually make decisions for themselves as computer are not really \u201cintelligent\u201d,\nwe are simply specifying what should occur based on the conditions). Conditions in a\nprogram are specified by coding logical statements using logical operators.\n3.1. Logical Operators\nIn logic, everything is black and white: a logical statement is an assertion that is either\ntrue or it is false. As previously discussed, some programming languages allow you to\ndefine and use Boolean variables that can be assigned the value true or false. We can\nalso formulate statements that involve other types of variables whose truth values are\ndetermined by the values of the variables at run time.\n65 3. Conditionals\n3.1.1. Comparison Operators\nSuppose we have a variable age representing the age of an individual. Suppose we wish\nto execute some code if the person is an adult, age \u2265 18 and a different piece of code if\nthey are not an adult, age < 18. To achieve this, we need to be able to make comparisons\nbetween variables, constants, and even more complex expressions. Such logical statements\nmay not have a fixed truth value. That is, they could be true or false depending on the\nvalue of the variables involved when the program is run.\nSuch comparisons are common in mathematics and likewise in programming languages.\nComparison operators are usually binary operators in that they are applied to two\noperands: a left operand and a right operand. For example, if a,b are variables (or\nconstants or expressions), then the comparison,\na \u2264 b\nis true if the value stored in a is less than or equal to the value stored in b. Otherwise, if\nthe value stored in b is strictly less than the value stored in a, the expression is false.\nFurther, a,b are the operands and \u2264 is the binary operator.\nIn general, operators do not commute. That is,\na \u2264 b and b \u2264 a\nare not equivalent, just as they are not in mathematics. However,\na \u2264 b and b \u2265 a\nare equivalent. Thus, the order of operands is important and can change the meaning\nand truth value of an expression.\nA full listing of binary operators can be found in Table 3.1. In this table, we present both\nthe mathematical notation used in our pseudocode examples as well as the most common\nways of representing these comparison operators in most programming languages. The\nneed for alternative representations is because the mathematical symbols are not part of\nthe ASCII character set common to most keyboards.\nWhen using comparison operators, either operand can be variables, constants, or even\nmorecomplexexpressions. Forexample, youcanmakecomparisonsbetweentwovariables,\na < b, a > b, a \u2264 b, a \u2265 b, a = b, a (cid:54)= b\nor they can be between a variable and a constant\na < 10, a > 10, a \u2264 10, a \u2265 10, a = 10, a (cid:54)= 10\nor\n10 < b, 10 > b, 10 \u2264 b, 10 \u2265 b, 10 = b, 10 (cid:54)= b\n66 3.1. Logical Operators\nPsuedocode Code Meaning Type\n< < less than relational\n> > greater than relational\n\u2264 <= less than or equal to relational\n\u2265 >= greater than or equal to relational\n= == equal to equality\n(cid:54)= != not equal to equality\nTable 3.1.: Comparison Operators\nComparisons can also be used with more complex expressions such as\n\u221a\nb2 \u22124ac < 0\nwhich could commonly be expressed in code as\nsqrt(b*b - 4*a*c) < 0\nObserve that both operands could be constants, such as 5 \u2264 10 but there would be little\npoint. Since both are constants, the truth value of the expression is already determined\nbefore the program runs. Such an expression could easily be replaced with a simple true\nor false variable. These are referred to as tautologies and contradictions respectively.\nWe\u2019ll examine them in more detail below.\nPitfalls\nSometimes you may want to check that a variable falls within a certain range. For\nexample, we may want to test that x lies in the interval [0,10] (between 0 and 10 inclusive\non both ends). Mathematically we could express this as\n0 \u2264 x \u2264 10\nand in code, we may try to do something like\n0 <= x <= 10\nHowever, when used in code, the operators <= are binary and must be applied to two\noperands. In a language the first inequality, 0 <= x would be evaluated and would\nresult in either true or false. The result is then used in the second comparison which\nresults in a question such as true \u2264 10 or false \u2264 10.\nSome languages would treat this as a syntax error and not allow such an expression to\nbe compiled since you cannot compare a Boolean value to a numerical value. However,\nother languages may allow this, typically representing true with some nonzero value such\nas 1 and false with 0. In either case, the expression would evaluate to true since both\n67 3. Conditionals\n0 \u2264 10 and 1 \u2264 10. However, this is clearly wrong: if x had a value of 20 for example, the\nfirst expression would evaluate to false, making the entire expression true, but 20 (cid:54)\u2264 10.\nThe solution is to use logical operators to express the same logic using two comparison\noperators (see Section 3.1.3).\nAnother common pitfall when programming is to mistake the assignment operator\n(typically only one equals sign, =) and the equality operator (typically two equal signs,\n==). Asbefore, somelanguageswillnotallowit. Theexpression a = 10 wouldnot have\na truth value associated with it. Attempts to use the expression in a logical statement\nwould be a syntax error. Other languages may permit the expression and would give it a\ntruth value equal to the value of the variable. For example, a = 10 would take on the\nvalue 10 and be treated as true (nonzero value) while a = 0 would take on the value 0\nand be treated as false (zero). In either case, we probably do not get the result that we\nwant. Take care that you use proper equality comparison operators.\nOther Considerations\nThecomparisonoperatorsthatwe\u2019veexaminedaregenerallyusedforcomparingnumerical\ntypes. However, sometimes we wish to compare non-numeric types such as single\ncharacters or strings. Some languages allow you to use numeric operators with these\ntypes as well.\nSome dynamically typed languages (PHP, JavaScript, etc.) have additional rules when\ncomparison operators are used with mixed types (that is, we compare a string with a\nnumeric type). They may even have additional \u201cstrict\u201d comparison operators such as\n(a === b) and (a !== b) which are true only if the values and types match. So, for\nexample, (10 == \"10\") may be true because the values match, but (10 === \"10\")\nwould be false since the types do not match (one is an integer, the other a string). We\ndiscuss specifics in subsequent chapters are they pertain to specific languages.\n3.1.2. Negation\nThe negation operator is an operator that \u201cflips\u201d the truth value of the expression that\nit is applied to. It is very much like the numerical negation operator which when applied\nto positive numbers results in their negation and vice versa. When the logical negation\noperator is applied to a variable or statement, it negates its truth value. If the variable\nor statement was true, its negation is false and vice versa.\nAlso like the numerical negation operator, the logical negation operator is a unary\noperator as it applies to only one operand. In modern logic, the symbol \u00ac is used to\n68 3.1. Logical Operators\na \u00aca\nfalse true\ntrue false\nTable 3.2.: Logical Negation, \u00ac Operator\ndenote the negation operator1, examples:\n\u00acp, \u00ac(a > 10), \u00ac(a \u2264 b)\nWe will adopt this notation in our pseudocode, however most programming languages use\nthe exclamation mark, ! for the negation operator, similar to its usage in the inequality\ncomparison operator, !=. The negation operator applies to the variable or statement\nimmediately following it, thus\n\u00ac(a \u2264 b) and \u00aca \u2264 b\nare not the same thing (indeed, the second expression may not even be valid depending\non the language). Further, when used with comparison operators, it is better to use the\n\u201copposite\u201d comparison. For example,\n\u00ac(a \u2264 b) and (a > b)\nare equivalent, but the second expression is preferred as it is simpler. Likewise,\n\u00ac(a = b) and (a (cid:54)= b)\nare equivalent, but the second expression is preferred.\n3.1.3. Logical And\nThe logical and operator (also called a conjunction) is a binary operator that is true if\nand only if both of its operands is true. If one of its operands is false, or if both of them\nare false, then the result of the logical and is false.\nMany programming languages use two ampersands, a && b to denote the logical And\noperator.2 However, for our pseudocode we will adopt the notation And and we will\nuse expressions such as aAndb. Table 3.3 contains a truth table representation of the\nlogical And operator.\n1 This notation was first used by Heyting, 1930 [16]; prior to that the tilde symbol was used (\u223cp for\nexample) by Peano [33] and Whitehead & Russell [37]. However, the tilde operator has been adopted\nto mean bit-wise negation in programming languages.\n2In logic, the \u201cwedge\u201d symbol, p\u2227q is used to denote the logical And. It was first used again by\nHeyting, 1930 [16] but should not be confused for the keyboard caret, \u02c6, symbol. Many programming\nlanguages do use the caret as an operator, but it is usually the exclusive-or operator which is true if\nand only if exactly one of its operands is true.\n69 3. Conditionals\na b aAndb\nfalse false false\nfalse true false\ntrue false false\ntrue true true\nTable 3.3.: Logical And Operator\nThe logical And is used to combine logical statements to form more complex logical\nstatements. Recall that we couldn\u2019t directly use two comparison operators to check that\na variable falls within a range, 0 \u2264 x \u2264 10. However, we can now use a logical And to\nexpress this:\n(0 \u2264 x)And(x \u2264 10)\nThis expression is true only if both comparisons are true.\nThough the And operator is a binary operator, we can write statements that involve\nmore than one variable or expression by using multiple instances of the operator. For\nexample,\nb2 \u22124ac \u2265 0Anda (cid:54)= 0Andc > 0\nThe above statement would be evaluated left-to-right; the first two operands would be\nevaluated and the result would be either true or false. Then the result would be used as\nthe first operand of the second logical And. In this case, if any of the operands evaluated\nto false, the entire expression would be false. Only if all three were true would the\nstatement be true.\n3.1.4. Logical Or\nThe logical or operator is the binary operator that is true if at least one of its operands\nis true. If both of its operands are false, then the logical or is false. This is in contrast\nto what is usually meant by \u201cor\u201d colloquially. If someone says \u201cyou can have cake\nor ice-cream,\u201d usually they implicitly also mean, \u201cbut not both.\u201d With the logical or\noperator, if both operands are true, the result is still true.\nMany programming languages use two vertical bars (also referred to as Sheffer strokes),\n|| to denote the logical Or operator.3. However, for our pseudocode we will adopt the\nnotation Or, thus the logical or can be expressed as aOrb. Table 3.4 contains a truth\ntable representation of the logical Or operator.\nAs with the logical And, the logical Or is used to combine logical statements to make\n3In logic, the \u201cvee\u201d symbol, p\u2228q is used to denote the logical Or. It was first used by Russell, 1906\n[35].\n70 3.1. Logical Operators\na b aOrb\nfalse false false\nfalse true true\ntrue false true\ntrue true true\nTable 3.4.: Logical Or Operator\nmore complex statements. For example,\n(age \u2265 18)Or(year = \u201csenior\u201d)\nwhich is true if the individual is aged 18 or older, is a senior, or is both 18 or older and\na senior. If the individual is aged less than 18 and is not a senior, then the statement\nwould be false.\nWe can also write statements with multiple Or operators,\na > bOrb > cOra > c\nwhich will be evaluated left-to-right. If any of the three operands is true, the statement\nwill be true. The statement is only false when all three of the operands is false.\n3.1.5. Compound Statements\nThe logical And and Or operators can be combined to express even more complex logical\nstatements. For example, you can express the following statements involving both of the\noperators:\naAnd(bOrc) aOr(bAndc)\nAs an example, consider the problem of deciding whether or not a given year is a leap\nyear. The Gregorian calendar defines a year as a leap year if it is divisible by 4. However,\nevery year that is divisible by 100 is not a leap year unless it is also divisible by 400.\nThus, 2012 is a leap year (4 goes into 2012 503 times), however, 1900 was not a leap year:\nthough it is divisible by 4 (1900\/4 = 475 with no remainder), it is also divisible by 100.\nThe year 2000 was a leap year: it was divisible by 4 and 100 thus it was divisible by 400.\nWhen generalizing these rules into logical statements we can follow a similar process: A\nyear is a leap year if it is divisible by 400 or it is divisible by 4 and not by 100. This\nlogic can be modeled with the following expression.\nyear mod 400 = 0Or(year mod 4 = 0Andyear mod 100 (cid:54)= 0)\nWhen writing logical statements in programs it is generally best practice to keep things\nsimple. Logical statements should be written in the most simple and succinct (but\ncorrect) way possible.\n71 3. Conditionals\nTautologies and Contradictions\nSome logical statements have the same meaning regardless of the variables involved. For\nexample,\naOr\u00aca\nis always true regardless of the value of a. To see this, suppose that a is true, then the\nstatement becomes\naOr\u00aca = trueOrfalse\nwhich is true. Now suppose that a is false, then the statement is\naOr\u00aca = falseOrtrue\nwhich again is true. A statement that is always true regardless of the truth values of its\nvariables is a tautology.\nSimilarly, the statement\naAnd\u00aca\nis always false (at least one of the operands will always be false). A statement that is\nalways false regardless of the truth values of its variables is a contradiction.\nIn most cases, it is pointless to program a conditional statement with tautologies or\ncontradictions: if an if-statement is predicated on a tautology it will always be executed.\nLikewise, an if-statement involved with a contradiction will never be executed. In either\ncase, many compilers or code analysis tools may indicate and warn about these situations\nand encourage you to modify the code or to remove \u201cdead code.\u201d Some languages may\nnot even allow you write such statements.\nThere are always exceptions to the rule. Sometimes you may wish to intentionally write\nan infinite loop (see Section 4.5.2) for example in which case a statement similar to the\nfollowing may be written.\nwhile true do\n1\n\/\/some computation\nend\n2\nDe Morgan\u2019s Laws\nAnother tool to simplify your logic is De Morgan\u2019s Laws. When a logical And statement\nis negated, it is equivalent to an unnegated logical Or statement and vice versa. That is,\n\u00ac(aAndb) and \u00acaOr\u00acb\n72 3.1. Logical Operators\nOrder Operator\n1 \u00ac\n2 And\n3 Or\nTable 3.5.: Logical Operator Order of Precedence\nare equivalent to each other;\n\u00ac(aOrb) and \u00acaAnd\u00acb\nare also equivalent to each other. Though equivalent, it is generally preferable to write\nthe simpler statement. From one of our previous examples, we could write\n\u00ac((0 \u2264 x)And(x \u2264 10))\nor we could apply De Morgan\u2019s Law and simplify this to\n(0 > x)Or(x > 10)\nwhich is more concise and arguably more readable.\nOrder of Precedence\nRecall that numerical operators have a well defined order of precedence that is taken from\nmathematics (multiplication is performed before addition for example, see Section 2.3.4).\nWhen working with logical operators, we also have an order of precedence that somewhat\nmirrors those of numerical operators. In particular, negations are always applied first,\nfollowed by And operators, and then lastly Or operators.\nFor example, the statement\naOrbAndc\nis somewhat ambiguous. We don\u2019t just evaluate it left-to-right since the And operator\nhas a higher order of precedence (this is similar to the mathematical expression a+b\u00b7c\nwhere the multiplication would be evaluated first). Instead, this statement would be\nevaluated by evaluating the And operator first and then the result would be applied to\nthe Or operator. Equivalently,\naOr(bAndc)\nIf we had meant that the Or operator should be evaluated first, then we should have\nexplicitly written parentheses around the operator and its operands like\n(aOrb)Andc\n73 3. Conditionals\nIn fact, its best practice to write parentheses even if it is not necessary. Writing\nparentheses is often clearer and easier to read and more importantly communicates intent.\nBy writing\naOr(bAndc)\nthe intent is clear: we want the And operator to be evaluated first. By not writing the\nparentheses we leave our meaning somewhat ambiguous and force whoever is reading the\ncode to recall the rules for order of precedence. By explicitly writing parentheses, we\nreduce the chance for error both in writing and in reading. Besides, its not like we\u2019re\npaying by the character.\nFor similar operators of the same precedence, they are evaluated left-to-right, thus\naOrbOrc is equivalent to ((aOrb)Orc)\nand\naAndbAndc is equivalent to ((aAndb)Andc)\n3.1.6. Short Circuiting\nConsider the following statement:\naAndb\nAs we evaluate this statement, suppose that we find that a is false. Do we need to\nexamine the truth value of b? The answer is no: since a is false, regardless of the truth\nvalue of b, the statement is false because it is a logical And. Both operands must be\ntrue for an And to be true. Since the first is false, the second is irrelevant.\nNow imagine evaluating this statement in a computer. If the first operand of an And\nstatement is false, we don\u2019t need to examine\/evaluate the second. This has some potential\nfor improved efficiency: if the second operand does not need to be evaluated, a program\ncould ignore it and save a few CPU cycles. In general, the speed up for most operations\nwould be negligible, but in some cases the second operand could be very \u201cexpensive\u201d to\ncompute (it could be a complex function call, require a database query to determine,\netc.) in which case it could make a substantial difference.\nHistorically, avoiding even a few operations in old computers meant a difference on\nthe order of milliseconds or even seconds. Thus, it made sense to avoid unnecessary\noperations. This is now known as short circuiting and to this day is still supported in\nmost programming languages.4 Though the differences are less stark in terms of CPU\nresources, most developers and programmers have come to expect this behavior and write\nstatements under the assumption that short-circuiting will occur.\n4 Historically, the short-circuited version of the And operator was known as McCarthy\u2019s sequential\nconjunction operation which was formally defined by John McCarthy (1962) as \u201cif p then q, else\nfalse\u201d, eliminating the evaluation of q if p is false [23].\n74 3.2. The If Statement\nShort circuiting is commonly used to \u201ccheck\u201d for invalid operations. This is commonly\nused to prevent invalid operations. For example, consider the following statement:\n(d (cid:54)= 0And1\/d > 1)\nThe first operand is checking to see if d is not zero and the second checks to see if its\nreciprocal is greater than 1. With short-circuiting, if d = 0, then the second operand\nwill not be evaluated and the division by zero will be prevented. If d =(cid:54) 0 then the\nfirst operand is true and so the second operand will be evaluated as normal. Without\nshort-circuiting, both operands would be evaluated leading to a division by zero error.\nThere are many other common patterns that rely on short-circuiting to avoid invalid or\nundefined operations. For example, short-circuiting is used to check that a variable is\nvalid (defined or not Null) before using it, or to check that an index variable is within\nthe range of an array\u2019s size before accessing a value.\nBecause of short-circuiting, the logical And is effectively not commutative. An operator\nis commutative if the order of its operands is irrelevant. For example, addition and\nmultiplication are both commutative,\nx+y = y +x x\u00b7y = y \u00b7x\nbut subtraction and division are not,\nx\u2212y (cid:54)= y \u2212x x\/y (cid:54)= y\/x\nInlogic,theAndandOroperatorsarecommutative,butwhenusedinmostprogramming\nlanguages they are not,\n(aAndb) (cid:54)= (bAnda) and (aOrb) (cid:54)= (bOra)\nIt is important to emphasize that they are still logically equivalent, but they are not\neffectively equivalent: because of short-circuiting, each of these statements have a\npotentially different effect.\nThe Or operator is also short-circuited: if the first operand is true, then the truth value\nof the expression is already determined to be true and so the second operand will not be\nevaluated. In the expression,\naOrb\nif a evaluates to true, then b is not evaluated (since if either operand is true, the entire\nexpression is true).\n3.2. The If Statement\nNormally, the flow of control (or control flow) in a program is sequential. Each instruction\nis executed, one after the other, top-to-bottom and in individual statements left-to-right\n75 3. Conditionals\njust as one reads in English. Moreover, in most programming languages, each statement\nexecutes completely before the next statement begins. A visualization of this sequential\ncontrol flow can be found in the control flow diagram in Figure 3.1(a).\nHowever, it is often necessary for a program to \u201cmake decisions.\u201d Some segments of code\nmay need to be executed only if some condition is satisfied. The if statement is a control\nstructure that allows us to write a snippet of code predicated on a logical statement.\nThe code executes if the logical statement is true, and does not execute if the logical\nstatement is false. This control flow is featured in Figure 3.1(b)\nAn example using pseudocode can be found in Algorithm 3.1. The use of the keyword\n\u201cif\u201d is common to most programming languages. The logical statement associated with\nthe if-statement immediately follows the \u201cif\u201d keyword and is usually surrounded by\nparentheses. The code block immediately following the if-statement is bound to the\nif-statement.\nif ((cid:104)condition(cid:105)) then\n1\nCode Block\n2\nend\n3\nAlgorithm 3.1: An if-statement\nAs in the flow chart, if the (cid:104)condition(cid:105) evaluates to true, then the code block bound to\nthe statement executes in its entirety. Otherwise, if the condition evaluates to false, the\ncode block bound to the statement is skipped in its entirety.\nA simple if-statement can be viewed as a \u201cdo this if and only if the condition holds.\u201d\nAlternatively, \u201cif this condition holds do this, otherwise don\u2019t.\u201d In either case, once the\nif-statement finishes execution, the program returns to the normal sequential control\nflow.\n3.3. The If-Else Statement\nAn if-statement allows you to specify a code segment that is executed or is not executed.\nAn if-else statement allows you to specify an alternative. An if-else statement allows you\nto define a condition such that if the condition is true, one code block executes and if\nthe condition is false, an entirely different code block executes.\nThe control flow of an if-else statement is presented in Figure 3.2. Note that Code\nBlock A and Code Block B are mutually exclusive. That is, one and only one of them is\nexecuted depending on the truth value of the (cid:104)condition(cid:105). A presentation of a generic\nif-else statement in our pseudocode can be found in Algorithm 3.2\n76 3.3. The If-Else Statement\nStatement 1\ntrue Code\n(cid:104)condition(cid:105)\nBlock\nStatement 2\nfalse\nRemaining\nProgram\nStatement 3\n(a) Sequential Flow Chart (b) If-Statement Flow Chart\nFigure 3.1.: Control flow diagrams for sequential control flow and an if-statement. In\nsequential control, statements are executed one after the other as they are\nwritten. In an if-statement, the normal flow of control is interrupted and a\nCode Block is only executed if the given condition is true, otherwise it is\nnot. After the if-statement, normal sequential control flow resumes.\n77 3. Conditionals\ntrue Code\n(cid:104)condition(cid:105)\nBlockA\nfalse\nCode\nBlockB\nRemaining\nProgram\nFigure 3.2.: An if-else Flow Chart\nJust as with an if-statement, the keyword \u201cif\u201d is used. In fact, the if-statement is simply\njust an if-else statement with the else block omitted (equivalently, we could have defined\nan empty else block, but since it would have no effect, a simple if-statement with no\nelse block is preferred). It is common to most programming languages to use the \u201celse\u201d\nkeyword to denote the else block of code. Since there is only one (cid:104)condition(cid:105) to evaluate\nand it can only be true or false, it is not necessary to specify the conditions under which\nthe else block executes. It is assumed that if the (cid:104)condition(cid:105) evaluates to false, the else\nblock executes.\nAs with an if-statement, the block of code associated with the if-statement as well as the\nblock of code associated with the else-statement are executed in their entirety or not at\nall. Whichever block of code executes, normal flow of control returns and the remaining\nprogram continues executing sequentially.\n3.4. The If-Else-If Statement\nAn if-statement allows you to define a \u201cdo this or do not\u201d and an if-else statement allows\nyou to define a \u201cdo this or do that\u201d statement. Yet another generalization is an if-else-if\nstatement. Using such a statement you can define any number of mutually exclusive\ncode blocks.\n78 3.4. The If-Else-If Statement\nif ((cid:104)condition(cid:105)) then\n1\nCode Block A\n2\nelse\n3\nCode Block B\n4\nend\n5\nAlgorithm 3.2: An if-else Statement\nTo illustrate, consider the case in which we have exactly three mutually exclusive\npossibilities. At a particular university, there are three possible semesters depending\non the month. January through May is the Spring semester, June\/July is the Summer\nsemester, and August through December is the Fall semester. These possibilities are\nmutually exclusive because it cannot be both Spring and Summer at the same time\nfor example. Suppose we have the current month stored in a variable named month.\nAlgorithm 3.3 expresses the logic for determining which semester it is using an if-else-if\nstatement.\nif (month \u2265 January)And(month \u2264 May) then\n1\nsemester \u2190 \u201cSpring\u201d\n2\nelse if (month > May)And(month \u2264 July) then\n3\nsemester \u2190 \u201cSummer\u201d\n4\nelse\n5\nsemester \u2190 \u201cFall\u201d\n6\nend\n7\nAlgorithm 3.3: Example If-Else-If Statement\nLet\u2019s understand how this code works. First, the \u201cif\u201d and \u201celse\u201d keywords are used\njust as the two previous control structures, but we are now also using the \u201celse if\u201d\nkeyword combination to specify an additional condition. Each condition, starting with\nthe condition associated with the if-statement is checked in order. If and when one of the\nconditions is satisfied (evaluates to true), the code block associated with that condition\nis executed and all other code blocks are ignored.\nEach of the code blocks in an if-else-if control structure are mutually exclusive. One\nand only one of the code blocks will ever execute. Similar to the sequential control flow,\nthe first condition that is satisfied is the one that is executed. If none of the conditions\nis satisfied, then the code block associated with the else-statement is the one that is\nexecuted.\nIn our example, we only identified three possibilities. You can generalize an if-else-if\nstatement to specify as many conditions as you like. This generalization is depicted in\n79 3. Conditionals\ntrue\nCode\nif((cid:104)condition1(cid:105)) (cid:104)condition1(cid:105)\nBlockA\nfalse\ntrue\nCode\nelseif((cid:104)condition2(cid:105)) (cid:104)condition2(cid:105)\nBlockB\nfalse\ntrue\nCode\nelseif((cid:104)condition3(cid:105)) (cid:104)condition3(cid:105)\nBlockC\nfalse\n... ...\nfalse\ntrue\nCode\nelseif((cid:104)conditionn(cid:105)) (cid:104)conditionn(cid:105)\nBlockN\nfalse\nCode\nelse\nBlockM\nRemaining\nProgram\nFigure 3.3.: Control Flow for an If-Else-If Statement. Each condition is evaluated in\nsequence. The first condition that evaluates to true results in the corre-\nsponding code block being executed. After executing, the program continues.\nThus, each code block is mutually exclusive: at most one of them is executed.\n80 3.4. The If-Else-If Statement\nAlgorithm 3.4 and visualized in Figure 3.3. Similar to the if-statement, the else-statement\nand subsequent code block is optional. If omitted, then it may be possible that none of\nthe code blocks is executed.\nif ((cid:104)condition1(cid:105)) then\n1\nCode Block A\n2\nelse if ((cid:104)condition2(cid:105)) then\n3\nCode Block B\n4\nelse if ((cid:104)condition3(cid:105)) then\n5\nCode Block C\n6\n...\n7\nelse\n8\nCode Block\n9\nend\n10\nAlgorithm 3.4: General If-Else-If Statement\nThe design of if-else-if statements must be done with care to ensure that your statements\nare each mutually exclusive and capture the logic you intend. Since the first condition\nthat evaluates to true is the one that is executed, the order of the conditions is important.\nA poorly designed if-else-if statement can lead to bugs and logical errors.\nAsanexample,considerdescribingtheloudnessofasoundbyitsdecibel levelinAlgorithm\n3.5.\nif decibel \u2264 70 then\n1\ncomfort \u2190 \u201cintrusive\u201d\n2\nelse if decibel \u2264 50 then\n3\ncomfort \u2190 \u201cquiet\u201d\n4\nelse if decibel \u2264 90 then\n5\ncomfort \u2190 \u201cannoying\u201d\n6\nelse\n7\ncomfort \u2190 \u201cdangerous\u201d\n8\nend\n9\nAlgorithm 3.5: If-Else-If Statement With a Bug\nSuppose that decibel = 20 which should be described as a \u201cquite\u201d sound. However, in the\nalgorithm, the first condition, decibel \u2264 70 evaluates to true and the sound is categorized\nas \u201cintrusive\u201d. The bug is that the second condition, decibel \u2264 50 should have come first\nin order to capture all decibel levels less than or equal to 50.\nAlternatively, we could have followed the example in Algorithm 3.3 and completely\n81 3. Conditionals\nspecified both lower bounds and upper bounds in our condition. For example, the\ncondition for \u201cintrusive\u201d could have been\n(decibel > 50)And(decibel \u2264 70)\nHowever, doing this is unnecessary if we order our conditions appropriately and we can\npotentially write simpler conditions if we remember the fact that the if-else-if statement\nis mutually exclusive.\n3.5. Ternary If-Else Operator\nAnother conditional operator is the ternary if-then-else operator. It is often used to\nwrite an expression that can take on one of two values depending on the truth value of a\nlogical expression. Most programming languages support this operator which has the\nfollowing syntax:\nE ? X : Y\nHere, E is a Boolean expression. If E evaluates to true, the statement takes on the\nvalue X which does not need to be a Boolean value: it can be anything (an integer,\nstring, etc.). If E evaluates to false, the statement takes on the value Y.\nA simple usage of this expression is to find the minimum of two values:\nmin = ( (a < b) ? a : b );\nIf a < b is true, then min will take on the value a. Otherwise it will take on the value b\n(in which case a \u2265 b and so b is minimal). Most programming languages support this\nspecial syntax as it provides a nice convenience (yet another example of syntactic sugar).\n3.6. Examples\n3.6.1. Meal Discount\nConsider the problem of computing a receipt for a meal. Suppose we have the subtotal\ncost of all items in the meal. Further, suppose that we want to compute a discount\n(senior citizen discount, student discount, or employee discount, etc.). We can then apply\nthe discount, compute the sales tax, and sum a total, reporting each detail to the user.\nTo do this, we first prompt the user to enter a subtotal. We can then ask the user if\nthere is a discount to be computed. If the user answers yes, then we again prompt them\nfor an amount (to allow different types of discounts). Otherwise, the discount will be\n82 3.6. Examples\nzero. We can then proceed to calculate each of the amounts above. To do this we\u2019ll need\nan if-statement. We could also use a conditional statement to check to see if the input\nmakes sense: we wouldn\u2019t want a discount amount that is greater than 100%. The full\nalgorithm is presented in Algorithm 3.6.\nPrompt the user for a subtotal\n1\nsubTotal \u2190 read input from user\n2\ndiscountPercent \u2190 0\n3\nAsk the user if they want to apply a discount\n4\nhasDiscount \u2190 get user input if hasDiscount = \u201cyes\u201d then\n5\nPrompt the user for a discount amount\n6\ndiscountPercent \u2190 read user input\n7\nend\n8\nif discountPercent > 100 then\n9\nError! Discount cannot be more than 100%\n10\nend\n11\ndiscount \u2190 subTotal\u00d7discountPercent\n12\ndiscountTotal \u2190 subTotal\u2212discount\n13\ntax \u2190 taxRate\u00d7discountTotal\n14\ngrandTotal \u2190 discountTotal+tax\n15\noutput subTotal,discountTotal,tax,grandTotal to user\n16\nAlgorithm 3.6: A simple receipt program\n3.6.2. Look Before You Leap\nRecall that dividing by zero is an invalid operation in most programming languages (see\nSection 2.3.5). Now that we have a means by which numerical values can be checked, we\ncan prevent such errors entirely.\nSuppose that we were going to compute a quotient of two variables x\/y. If y = 0, this\nwould be an invalid operation and lead to undefined, unexpected or erroneous behavior.\nHowever, if we checked whether or not the denominator is zero before we compute the\nquotient then we could prevent such errors. We present this idea in Algorithm 3.7.\nif y (cid:54)= 0 then\n1\nq \u2190 x\/y\n2\nend\n3\nAlgorithm 3.7: Preventing Division By Zero Using an If Statement\n83 3. Conditionals\nThis approach to programming is known as defensive programming. We are essentially\nchecking the conditions for an invalid operation before performing that operation. In\nthe example above, we simply chose not to perform the operation. Alternatively, we\ncould use an if-else statement to perform alternate operations or handle the situation\ndifferently. Defensive programming is akin to \u201clooking before leaping\u201d: before taking a\npotentially dangerous step, you look to see if you are at the edge of a cliff, and if so you\ndon\u2019t take that dangerous step.\n3.6.3. Comparing Elements\nSuppose we have two students, student A and student B and we want to compare them:\nwe want to determine which one should be placed first in a list and which should be\nplaced second. For this exercise let\u2019s suppose that we want to order them first by their\nlast names (so that Anderson comes before Zadora). What if they have the same last\nname, like Jane Smith and John Smith? If the last names are equal, then we\u2019ll want to\norder them by their first names (Jane before John). If both their first names and last\nnames are the same, we\u2019ll say either order is okay.\nNames will likely be represented using strings, so let\u2019s say that <, = and > apply to\nstrings, ordering them lexicographically (which is consistent with alphabetic ordering).\nWe\u2019ll first need to compare their last names. If equal, then we\u2019ll need another conditional\nconstruct. This is achieved by nesting conditional statements as in Algorithm 3.8.\nif A\u2019s last name < B\u2019s last name then\n1\noutput A comes first\n2\nelse if A\u2019s last name > B\u2019s last name then\n3\noutput B comes first\n4\nelse\n5\n\/\/last names are equal, so compare their first names\nif A\u2019s first name < B\u2019s first name then\n6\noutput A comes first\n7\nelse if A\u2019s first name > B\u2019s first name then\n8\noutput B comes first\n9\nelse\n10\nEither ordering is fine\n11\nend\n12\nend\n13\nAlgorithm 3.8: Comparing Students by Name\n84 3.6. Examples\n3.6.4. Life & Taxes\nAnother example in which there are several cases that have to be considered is computing\nan income tax liability using marginal tax brackets. Table 3.6 contains the 2014 US\nFederal tax margins and marginal rates for a married couple filing jointly based on the\nAdjusted Gross Income (income after deductions).\nAGI is over But not over Tax\n0 $18,150 10% of the AGI\n$18,150 $73,800 $1,815 plus 15% of the AGI in excess of\n$18,150\n$73,800 $148,850 $10,162.50 plus 25% of the AGI in excess of\n$73,800\n$148,850 $225,850 $28,925 plus 28% of the AGI in excess of\n$148,850\n$225,850 $405,100 $50,765 plus 33% of the AGI in excess of\n$225,850\n$405,100 $457,600 $109,587.50 plus 35% of the AGI in excess\nof $405,100\n$457,600 \u2014 $127,962.50 plus 39.6% of the AGI in excess\nof $457,600\nTable 3.6.: 2014 Tax Brackets for Married Couples Filing Jointly\nIn addition, one of the tax credits (which offsets tax liability) tax payers can take is the\nchild tax credit. The rules are as follows:\n\u2022 If the AGI is $110,000 or more, they cannot claim a credit (the credit is $0)\n\u2022 Each child is worth a $1,000 credit, however at most $3,000 can be claimed\n\u2022 The credit is not refundable: if the credit results in a negative tax liability, the tax\nliability is simply $0\nAs an example: suppose that a couple has $35,000 AGI (placing them in the second tax\nbracket) and has two children. Their tax liability is\n$1,815+0.15\u00d7($35,000\u2212$18,150) = $4,342.50\nHowever, the two children represent a $2,000 refund, so their total tax liability would be\n$2,342.50.\nLet\u2019s first design some code that computes the tax liability based on the margins and\nrates in Table 3.6. We\u2019ll assume that the AGI is stored in a variable named income.\nUsing a series of if-else-if statements as presented in Algorithm 3.9, the variable tax will\n85 3. Conditionals\ncontain our initial tax liability.\nif income \u2264 18,150 then\n1\ntax \u2190 .10\u00b7income\n2\nelse if income > 18,150Andincome \u2264 73,800 then\n3\ntax \u2190 1,815+.15\u00b7(income\u221218,150)\n4\nelse if income > 73,800Andincome \u2264 148,850 then\n5\ntax \u2190 10,162.50+.25\u00b7(income\u221273,800)\n6\nelse if income > 148850Andincome \u2264 225,850 then\n7\ntax \u2190 28,925+.28\u00b7(income\u2212148,850)\n8\nelse if income > 225,850Andincome \u2264 405,100 then\n9\ntax \u2190 50,765+.33\u00b7(income\u2212225,850)\n10\nelse if income > 405,100Andincome \u2264 457,600 then\n11\ntax \u2190 109,587.50+.35\u00b7(income\u2212405,100)\n12\nelse\n13\ntax \u2190 127,962.50+.396\u00b7(income\u2212457,600)\n14\nend\n15\nAlgorithm 3.9: Computing Tax Liability with If-Else-If\nWe can then compute the amount of a tax credit and adjust the tax accordingly by using\nsimilar if-else-if and if-else statements as in Algorithm 3.10.\nif income \u2265 110,000 then\n1\ncredit \u2190 0\n2\nelse if numberOfChildren \u2264 3 then\n3\ncredit \u2190 numberOfChildren\u22171,000\n4\nelse\n5\ncredit \u2190 3000\n6\nend\n7\n\/\/Now adjust the tax, taking care that its a nonrefundable credit\nif credit > tax then\n8\ntax \u2190 0\n9\nelse\n10\ntax \u2190 (tax\u2212credit)\n11\nend\n12\nAlgorithm 3.10: Computing Tax Credit with If-Else-If\n86 3.7. Exercises\n3.7. Exercises\nExercise 3.1. Write a program that prompts the user for an x and a y coordinate in\nthe Cartesian plane and prints out a message indicating if the point (x,y) lies on an axis\n(x or y axis, or both) or what quadrant it lies in (see Figure 3.4).\ny\nQuadrant II Quadrant I\nx\nQuadrant III Quadrant IV\nFigure 3.4.: Quadrants of the Cartesian Plane\nExercise 3.2. A BOGO (Buy-One, Get-One) sale is a promotion in which a person\nbuys two items and receives a 50% discount on the less expensive one. Write a program\nthat prompts the user for the cost of two items, computes a 50% discount on the less\nexpensive one, and then computes a grand total.\nExercise 3.3. Price Per Mile. Write a program to determine which type of gas is the\nbetter deal with respect to price-per-mile driven. For example, suppose unleaded costs\n$2.50 per gallon and your vehicle is able to get an average of 30 miles per gallon. The\ntrue cost of unleaded is thus 8.33 cents per mile. Now suppose that the ethanol fuel costs\nonly $2.25 per gallon but only yields 25 miles per gallon, thus 9 cents per mile, a worse\ndeal.\nWrite a program that prompts the user to enter the price (per gallon) of one type of gas\nas well as the miles-per-gallon. Then prompt for the same two values for a second type\nof gas and compute the true cost of each type. Print a message indicating which type of\ngas is the better deal. For example, if the user enters the values above the output would\nlook something like:\n87 3. Conditionals\nGas A: $0.0833 per mile\nGas B: $0.0900 per mile\nGas A is the better deal.\nExercise 3.4. Various substances have different boiling points. A selection of substances\nand their boiling points can be found in Table 3.7. Write a program that prompts the\nuser for the observed boiling point of a substance in degrees Celsius and identifies the\nsubstance if the observed boiling point is within 5% of the expected boiling point. If the\ndata input is more than 5% higher or lower than any of the boiling points in the table, it\nshould output Unknown substance.\nSubstance Boiling Point (C)\nMethane -161.7\nButane -0.5\nWater 100\nNonane 150.8\nMercury 357\nCopper 1187\nSilver 2193\nGold 2660\nTable 3.7.: Expected Boiling Points\nExercise 3.5. Electrical resistance in various metals can be measured using nano-ohm\nmetres (n\u2126\u00b7m). Table 3.8 gives the resistivity of several metals.\nMaterial Resistivity (n\u2126\u00b7m)\nCopper 16.78\nAluminum 26.50\nBeryllium 35.6\nPotassium 72.0\nIron 96.10\nTable 3.8.: Resistivity of several metals\nWrite a program that prompts the user for an observed resistivity of an unknown material\n(as nano-ohm metres) and identifies the substance if the observed resistivity is within\n\u00b13% of the known resistivity of any of the materials in Table 3.8. If the input value lies\noutside the \u00b13% range, output Unknown substance.\nExercise 3.6. The visible light spectrum is measured in nanometer (nm) frequencies.\nRanges roughly correspond to visible colors as depicted in Table 3.9.\n88 3.7. Exercises\nColor Wave length range (nm)\nViolet 380 \u2013 450\nBlue 450 \u2013 475\nIndigo 476 \u2013 495\nGreen 495 \u2013 570\nYellow 570 \u2013 590\nOrange 590 \u2013 620\nRed 620 - 750\nTable 3.9.: Visible Light Spectrum Ranges\nWrite a program that takes an integer corresponding to a wavelength and outputs the\ncorresponding color. If the value lies outside the ranges it should output Not a visible\nwavelength. If a value lies within multiple color ranges it should print all that apply\n(for example, a wavelength of 495 is \u201cIndigo-green\u201d).\nExercise 3.7. A certain production of steel is graded according to the following condi-\ntions:\n(i) Hardness must be greater than 50\n(ii) Carbon content must be less than 0.7\n(iii) Tensile strength must be greater than 5600\nA grade of 5 thru 10 is is assigned to the steel according to the conditions in Table 3.10.\nWrite a program that will read in the hardness, carbon content, and tensile strength as\nGrade Conditions\n10 All three conditions are met\n9 Conditions (i) and (ii) are met\n8 Conditions (ii) and (iii) are met\n7 Conditions (i) and (iii) are met\n6 If only 1 of the three conditions is met\n5 If none of the conditions are met\nTable 3.10.: Grades of Steel\ninputs and output the corresponding grade of the steel.\nExercise 3.8. A triangle can be characterized in terms of the length of its three sides.\nIn particular, an equilateral triangle is a triangle with all three sides being equal. A\ntriangle such that two sides have the same length is isosceles and a triangle with all three\nsides having a different length is scalene. Examples of each can be found in Figure 3.5.\nIn addition, the three sides of a triangle are valid only if the sum of any two sides is\nstrictly greater than the third length.\n89 3. Conditionals\nWrite a program to read in three numbers as the three sides of a triangle. If the three\nsides do not form a valid triangle, you should indicate so. Otherwise, if valid, your\nprogram should output whether or not the triangle is equilateral, isosceles or scalene.\n(a) Equilateral Triangle (b) Isosceles Triangle (c) Scalene Triangle\nFigure 3.5.: Three types of triangles\nExercise 3.9. Body Mass Index (BMI) is a healthy statistic based on a person\u2019s mass\nand height. For a healthy adult male BMI is calculated as\nm\nBMI = \u00b7703.069579\nh2\nwhere m is the person\u2019s mass (in lbs) and h is the person\u2019s height (in whole inches).\nWrite a program that reads in a person\u2019s mass and height as input and outputs a\ncharacterization of the person\u2019s health with respect to the categories in Table 3.11.\nRange Category\nBMI < 15 Very severely underweight\n15 \u2264 BMI < 16 Severely underweight\n16 \u2264 BMI < 18.5 Underweight\n18.5 \u2264 BMI < 25 Normal\n25 \u2264 BMI < 30 Overweight\n30 \u2264 BMI < 35 Obese Class I\n35 \u2264 BMI < 40 Obese Class II\nBMI \u2265 40 Obese Class III\nTable 3.11.: BMI Categories\nExercise 3.10. Let R and R be rectangles in the plane defined as follows. Let (x ,y )\n1 2 1 1\nbe point corresponding to the lower-left corner of R and let (x ,y ) be the point of its\n1 2 2\nupper-right corner. Let (x ,y ) be point corresponding to the lower-left corner of R and\n3 3 2\nlet (x ,y ) be the point of its upper-right corner.\n4 4\nWrite a program to determine the intersection of these two rectangles. In general, the\nintersection of two rectangles is another rectangle. However, if the two rectangles abut\neach other, the intersection could be a horizontal or vertical line segment (or even a\npoint). It is also possible that the intersection is empty. Your program will need to\ndistinguish between these cases.\n90 3.7. Exercises\ny\n(8.5,8.25)\n(6,7.5)\n(4,5.5)\n(2,1)\nx\nFigure 3.6.: Intersection of Two Rectangles\nIf the intersection of R ,R is a rectangle, R , your program should output two points\n1 2 3\n(the lower-left and upper-right corners of R ) as well as the area of R . If the intersection\n3 3\nis a line segment, your program should output the two end-points and whether it is a\nvertical or horizontal line segment. Finally, if the intersection is empty your program\nshould output \u201cempty intersection\u201d. Your program should also be robust enough to\ncheck that the input is valid (it should not accept empty or \u201creversed\u201d rectangles).\nYour program should read in x ,y ,x ,y ,x ,y ,x ,y from the user and perform the\n1 1 2 2 3 3 4 4\ncomputationabove. Asanexample,thevalues2,1,6,7.5,4,5.5,8.5,8.25wouldcorrespond\nto the two rectangles in Figure 3.6.\nThe output for this instance should look something like the following.\nIntersecting rectangle: (4, 5.5), (6, 7.5)\nArea: 4.00\nExercise 3.11. Write an app to help people track their cell phone usage. Cell phone\nplans for this particular company give you a certain number of minutes every 30 days\nwhich must be used or they are lost (no rollover). We want to track the average number\nof minutes used per day and inform the user if they are using too many minutes or can\nafford to use more.\nWrite a program that prompts the user to enter the following pieces of data:\n91 3. Conditionals\n\u2022 Number of minutes in the plan per 30 day period, m\n\u2022 The current day in the 30 day period, d\n\u2022 The total number of minutes used so far u\nThe program should then compute whether the user is over, under, or right on the average\ndaily usage under the plan. It should also inform them of how many minutes are left\nand how many, on average, they can use per day for the rest of the month. Of course, if\nthey\u2019ve run out of minutes, it should inform them of that too.\nFor example, if the user enters m = 250, d = 10, and u = 150, your program should print\nout something similar to the following.\n10 days used, 20 days remaining\nAverage daily use: 15 min\/day\nYou are EXCEEDING your average daily use (8.33 min\/day),\ncontinuing this high usage, you'll exceed your minute plan by\n200 minutes.\nTo stay below your minute plan, use no more than 5 min\/day.\nOf course, if the user is under their average daily use, a different message should be\npresented. You are allowed\/encouraged to compute any other stats for the user that you\nfeel would be useful.\nExercise 3.12. Write a program to help a floor tile company determine how many tiles\nthey need to send to a work site to tile a floor in a room. For simplicity, assume that all\nrooms are perfectly rectangular with no obstructions; we will also omit any additional\nmeasurements related to grouting.\nFurther, we will assume that all tile is laid in a grid pattern centered at the center of the\nroom. That is, four tiles will meet at their corners at the center of the room with tiles\nlaid out to the edge of the room. Thus, it may be the case that the final row and\/or\ncolumn at the edge may need to be cut. Also note that if the cut is short enough, the\nremaining tile can be used on the other end of the room (same goes for the corners).\nThe program will take the following input:\n\u2022 w - the width of the room\n\u2022 l - the length of the room\n92 3.7. Exercises\nCenter of the room Center of the room\n10.0 10.0\n0.9 0.9 0.4 0.4\n9.8 8.8\n(a) Example 1 (b) Example 2\nFigure 3.7.: Examples of Floor Tiling\n\u2022 t - width\/length of the tile (all tiles are perfectly square)\nIf we can use whole tiles to perfectly fit the room, then we do so. For example, on\nthe input (10,10,1), we could perfectly tile a 10\u00d710 room with 100 1\u00d71 tiles. If the\ntiles don\u2019t perfectly fit, then we have to consider the possibility of waste and\/or reuse.\nConsider the examples in Figure 3.7.\nThe first example is from the input (9.8,100,1). In this case, we lay the tiles from the\ncenter of the room (8 full tile lengths) but are left with 0.9 on either side. If we cut a\ntile to fit the left side, we are left with only .1 tile which is too short for the right side.\nTherefore, we are forced to waste the 0.1 length and cut a full tile for the right side. In\nall, 100 tiles are required.\nThe second example is from the input (8.8,100,1). In this case, we again lay tiles from\nthe center of the room (8 full tile lengths) and are left with 0.4 lengths on either side.\nHere, we can reuse the cut tile: cut a tile on one side 0.4 with 0.6 remaining, and cut 0.4\non the other side of the tile (with the center 0.2 length of the tile being waste). Thus,\nboth sides can be tiled with a single tile, meaning only 90 full tiles are needed to tile this\nroom.\nYou may further assume that tiles used on the length-side end of the room cannot be\nused to tile the width-side of the room (and vice versa). Your program will compute and\noutput the number of tiles required.\n93  4. Loops\nComputers are really good at automation. A key aspect of automation is the ability to\nrepeat a process over and over on different pieces of data until some condition is met.\nFor example, if we have a collection of numbers and we want to find their sum we would\niterate over each number, adding it to a total, until we have examined every number.\nAnother example may include sending an email message to each student in a course. To\nautomate the process, we could iterate over each student record and for each student we\nwould generate and send the email.\nAutomated repetition is where loops come in handy. Computers are perfectly suited for\nperforming such repetitive tasks. We can write a single block of code that performs some\naction or processes a single piece of data, then we can write a loop around that block of\ncode to execute it a number of times.\nLoops provide a much better alternative than repeating (cut-paste-cut-paste) the same\ncode over and over with different variables. Indeed, we wouldn\u2019t even do this in real\nlife. Suppose that you took a 100 mile trip. How would you describe it? Likely, you\nwouldn\u2019t say, \u201cI drove a mile, then I drove a mile, then I drove a mile, ...\u201d repeated 100\ntimes. Instead, you would simply state \u201cI drove 100 miles\u201d or maybe even, \u201cI drove until\nI reached my destination.\u201d\nLoops allow us to write concise, repeatable code that can be applied to each element in\na collection or perform a task over and over again until some condition is met. When\nwriting a loop, there are three essential components:\n\u2022 An initialization statement that specifies how the loop begins\n\u2022 A continuation (or termination) condition that specifies whether the loop should\ncontinue to execute or terminate\n\u2022 An iteration statement that makes progress toward the termination condition\nThe initialization statement is executed before the loop begins and serves as a way to set\nthe loop up. Typically, the initialization statement involves setting the initial value of\nsome variable.\nThe continuation statement is a logical statement (that evaluates to true or false) that\nspecifies if the loop should continue (if the value is true) or should terminate (if the value\nis false). Upon termination, code returns to a sequential control flow and the program\n95 4. Loops\nInitialization:\ni \u2190 1\nContinuation: false\ni \u2264 10?\ntrue\nloopbody\nIteration:\nrepeat i \u2190 (i+1)\nremaining\nprogram\nFigure 4.1.: A Typical Loop Flow Chart\n96 4.1. While Loops\ncontinues.\nThe iteration statement is intended to update the state of a program to make progress\ntoward the termination condition. If we didn\u2019t make such progress, the loop would\ncontinue on forever as the termination condition would never be satisfied. This is known\nas an infinite loop , and results in a program that never terminates.\nAs a simple example, consider the following outline.\n\u2022 Initialize the value of a variable i to 1\n\u2022 While the value of i is less than or equal to 10... (continuation condition)\n\u2022 Perform some action (this is sometimes referred to as the loop body\n\u2022 Iterate the variable i by adding one to its value\nThe code outline above specifies that some action is to be performed once for each value:\ni = 1,i = 2,...,i = 10, after which the loop terminates. Overall, the loop executes a\ntotal of 10 times. Prior to each of the 10 executions, the value of i is checked; as it is less\nthan or equal to 10, the action is performed. At the end of each of the 10 iterations, the\nvariable i is incremented by 1 and the termination condition is checked again, repeating\nthe process. There are several different types of loops that vary in syntax and style but\nthey all have the same three basic components.\n4.1. While Loops\nA while loop is a type of loop that places the three components in their logical order. The\ninitialization statement is written before the loop code. Typically the keyword while is\nused to specify the continuation\/termination condition. Finally, the iteration statement\nis usually performed at the end of the loop inside the code block associated with the loop.\nA small, counter-controlled while loop is presented in Algorithm 4.1 which illustrates the\nprevious example of iterating a variable i from 1 to 10.\n1 i \u2190 1 \/\/Initialization statement\nwhile (i \u2264 10) do\n2\nPerform some action\n3\n4 i \u2190 (i+1) \/\/Iteration statement\nend\n5\nAlgorithm 4.1: Counter-Controlled While Loop\nPrior to the while statement, the variable i is initialized to 1. This action is only\n97 4. Loops\nperformed once and it is done so before the loop code. Then, before the loop code is\nexecuted, the continuation condition is checked. Since i = 1 \u2264 10, the condition evaluates\nto true and the loop code block is executed. The last line of the code block is the iteration\nstatement, where i is incremented by 1 and now has a value of 2. The code returns to\nthe top of the loop and again evaluates the continuation condition (which is still true as\ni = 2 \u2264 10).\nOn the 10th iteration of the loop when i = 10, the loop will execute for the last time. At\nthe end of the loop, i is incremented to 11. The loop still returns to the top and the\ncontinuation condition is still checked one last time. However, since i = 11 (cid:54)\u2264 10, the\ncondition is now false and the loop terminates. Regular sequential control flow returns\nand the program continues executing whatever code is specified after the loop.\n4.1.1. Example\nIn the previous example we knew that we wanted the loop to execute ten times. Though\nyou can use a while loop in counter-controlled situations, while loops are typically used\nin scenarios when you may not know how many iterations you want the loop to execute\nfor. Instead of a straightforward iteration, the loop itself may update a variable in a\nless-than-predictable manner.\nAs an example, consider the problem of normalizing a number as is typically done in\nscientific notation. Given a number x (for simplicity, we\u2019ll consider x \u2265 1), we divide\nit by 10 until its value is in the interval [1,10), keeping track of how many times we\u2019ve\ndivided by 10. For example, if we have the number x = 32,145.234, we would divide by\n10 four times, resulting in 3.2145234 so that we could express it as\n3.2145234\u00d7104\nA simple realization of this process is presented in Algorithm 4.2. Rather than some\nfixed number of iterations, the number of times the loop executes depends on how large\nx is. For the example mentioned, it executes 4 times; for an input of x = 10,000,000 it\nwould execute 7 times. A while loop allows us to specify the repetition process without\n98 4.2. For Loops\nhaving to know up front how many times it will execute.\nInput :A number x, x \u2265 0\nOutput:x normalized, k its exponent\nk \u2190 0\n1\nwhile x > 10 do\n2\nx \u2190 (x\/10)\n3\nk \u2190 (k +1)\n4\nend\n5\noutput x,k\n6\nAlgorithm 4.2: Normalizing a Number With a While Loop\n4.2. For Loops\nA for loop is similar to a while loop but allows you to specify the three components on\nthe same line. In many cases, this results in a loop that is more readable; if the code\nblock in a while loop is long it may be difficult to see the initialization, continuation,\nand iteration statements clearly. For loops are typically used to iterate over elements\nstored in a collection such as an array (see Chapter 7). Usually the keyword for is used\nto identify all three components. A general example is given in Algorithm 4.3.\nfor ( (cid:104)initialization(cid:105); (cid:104)continuation(cid:105); (cid:104)iteration(cid:105) ) do\n1\nPerform some action\n2\nend\n3\nAlgorithm 4.3: A General For Loop\nNote the additional syntax: in many programming languages, semicolons are used at\nthe end of executable statements. Semicolons are also used to delimit each of the three\nloop components in a for-loop (otherwise there may be some ambiguity as to where\neach of the components begins and ends). However, the semicolons are typically only\nplaced after the initialization statement and continuation condition and are omitted after\nthe iteration statement. A more concrete example is given in Algorithm 4.4 which is\nequivalent to the counter-controlled while loop we examined earlier.\nThough all three components are written on the same line, the initialization statement\nis only ever executed once; at the beginning of the loop. The continuation condition is\nchecked prior to each and every execution of the loop. Only if it evaluates to true does\nthe loop body execute. The iteration condition is performed at the end of each loop\niteration.\n99 4. Loops\nfor ( i \u2190 1; i \u2264 10; i \u2190 (i+1) ) do\n1\nPerform some action\n2\nend\n3\nAlgorithm 4.4: Counter-Controlled For Loop\n4.2.1. Example\nAs a more concrete example, consider Algorithm 4.5 in which we do the same iteration\n(i will take on the values 1,2,3,...,10), but in each iteration we add the value of i for\nthat iteration to a running total, sum.\nsum \u2190 0\n1\nfor ( i \u2190 1; i \u2264 10; i \u2190 (i+1) ) do\n2\nsum \u2190 (sum+i)\n3\nend\n4\nAlgorithm 4.5: Summation of Numbers in a For Loop\nAgain, the initialization of i = 1 is only performed once. On the first iteration of the loop,\ni = 1 and so sum will be given the value sum+i = 0+1 = 1 At the end of the loop, i will\nbe incremented and will have a value of 2. The continuation condition is still satisfied, so\nonce again the loop body executes and sum will be given the value sum+i = 1+2 = 3.\nOn the 10th (last) iteration, sum will have a value 1+2+3+\u00b7\u00b7\u00b7+9 = 45 and i = 10.\nThus sum+i = 45+10 = 55 after which i will be incremented to 11. The continuation\ncondition is still checked, but since 11 (cid:54)\u2264 10, the loop body will not be executed and the\nloop will terminate, resulting in a final sum value of 55.\n4.3. Do-While Loops\nYet another type of loop is the do-while loop. One major difference between this type\nof loop and the others is that it is always executed at least once. The way that this is\nachieved is that the continuation condition is checked at the end of the loop rather than\nprior to is execution. The same counter-controlled example can be found in Algorithm\n4.6.\nIn contrast to the previous examples, the loop body is executed on the first iteration\nwithout checking the continuation condition. Only after the loop body, including the\nincrementing of the iteration variable i is the continuation condition checked. If true, the\nloop repeats at the beginning of the loop body.\n100 4.3. Do-While Loops\ni \u2190 1\n1\ndo\n2\nPerform some action\n3\ni \u2190 (i+1)\n4\nwhile i \u2264 10\n5\nAlgorithm 4.6: Counter-Controlled Do-While Loop\nInitialization:\ni \u2190 1\nloopbody\nIteration:\ni \u2190 (i+1)\nContinuation:\ni \u2264 10? true\nfalse\nremaining\nprogram\nFigure 4.2.: A Do-While Loop Flow Chart. The continuation condition is checked after\nthe loop body.\nDo-while loops are typically used in scenarios in which the first iteration is used to \u201csetup\u201d\nthe continuation condition (thus, it needs to be executed at least once). A common\nexample is if the loop body performs an operation that may result in an error code (or\nflag) that is either true (an error occurred) or false (no error occurred).\nFrom this perspective, a do-while loop can also be seen as a do-until loop: perform a\ntask until some condition is no longer satisfied. The subtle wording difference implies\n101 4. Loops\ndo\n1\nRead some data\n2\nisError \u2190 result of reading\n3\nwhile isError\n4\nAlgorithm 4.7: Flag-Controlled Do-While Loop\nthat we\u2019ll perform the action before checking to see if it should be performed again.\n4.4. Foreach Loops\nMany languages support a special type of loop for iterating over individual elements\nin a collection (such as a set, list, or an array). In general, such loops are referred to\nas foreach loops. These types of loops are essentially syntactic sugar: iterating over a\ncollection could be achieved with a for loop or a while loop, but foreach loops provide a\nmore convenient way to iterate over a collections. We will revisit these loops when we\nexamine arrays in Chapter 7. For now, we look at a simple example in Algorithm 4.8.\nforeach element a in the collection A do\n1\nprocess the element a\n2\nend\n3\nAlgorithm 4.8: Example Foreach Loop\nHow the elements are stored in the collection and how they are iterated over is not our\n(primary) concern. We simply want to apply the same block of code to each element,\nthe foreach loop handles the details on how each element is iterated over. The syntax\nalso provides a way to refer to each element (the a variable in the algorithm). On each\niteration of the loop, the foreach loop updates the reference a to the next element in\nthe array. The loop terminates after it has iterated through each and every one of the\nelements. In this way, a foreach loop simplifies the syntax: we don\u2019t have to specify any\nof the three components ourselves. As a more concrete example, consider iterating over\neach student in a course roster. For each student, we wish to compute their grade and\nthen email them the results. The foreach loop allows us to do this without worrying\nabout the iteration details (see Algorithm 4.9).\n102 4.5. Other Issues\nforeach (student s in the class C) do\n1\ng \u2190 compute a\u2019s grade\n2\nsend a an email informing them of their grade g\n3\nend\n4\nAlgorithm 4.9: Foreach Loop Computing Grades\n4.5. Other Issues\n4.5.1. Nested Loops\nJust as with conditional statements, we can nest loops within loops to perform more\ncomplex processes. Though you can do this with any type of loop, we present a simple\nexample using for loops in Algorithm 4.10.\nn \u2190 10\n1\nm \u2190 20\n2\nfor (i \u2190 1; i \u2264 m; i \u2190 (i+1)) do\n3\nfor (j \u2190 1; j \u2264 n; j \u2190 (j +1)) do\n4\noutput (i,j)\n5\nend\n6\nend\n7\nAlgorithm 4.10: Nested For Loops\nThe outer for loop executes a total of 20 times while the inner for loop executes 10\ntimes. Since the inner for loop is nested inside the outer loop, the entire inner loop\nexecutes all 10 iterations for each of the 20 iterations of the outer loop. Thus, in\ntotal the inner most output operation executes 10 \u00d7 20 = 200 times. Specifically, it\noutputs (1,1),(1,2),...,(1,10),(2,1),(2,2),...,(2,10),(3,1),...,(20,10). Nested loops\nare commonly used when iterating over elements in two-dimensional arrays such as\ntabular data or matrices. Nested loops can also be used to process all pairs in a collection\nof elements.\n4.5.2. Infinite Loops\nSometimes a simple mistake in the design of a loop can make it execute forever. For\nexample, if we accidentally iterate a variable in the wrong direction or write the opposite\n103 4. Loops\ntermination\/continuation condition. Such a loop is referred to as an infinite loop. As an\nexample, suppose we forgot the increment operation from a previous example.\nsum \u2190 0\n1\ni \u2190 1\n2\nwhile i \u2264 10 do\n3\nsum \u2190 (sum+i)\n4\nend\n5\nAlgorithm 4.11: Infinite Loop\nIn Algorithm 4.11 we never make progress toward the terminating condition! Thus, the\nloop will execute forever, i will continue to have the value 0 and since 0 \u2264 10, the loop\nbody will continue to execute. Care is needed in the design of your loops to ensure that\nthey make progress toward the termination condition.\nMostofthetimeaninfiniteloopisnotsomethingyouwantandusuallyyoumustterminate\nyour buggy program externally (sometimes referred to as \u201ckilling\u201d it). However, infinite\nloops do have their uses. A poll loop is a loop that is intended to not terminate. At a\nsystem level, for example, a computer may poll devices (such as input\/output devices)\none-by-one to see if there is any active input\/output request. Instead of terminating,\nthe poll loop simply repeats itself, returning back to the first device. As long as the\ncomputer is in operation, we don\u2019t want this process to stop. This can be viewed as an\ninfinite loop as it doesn\u2019t have any termination condition.\nThe Zune Bug\nThough proper testing and debugging should reduce the likelihood of such bugs, there\nare several notable instances in which an infinite loop impacted real software. One\nsuch instance was the Microsoft Zune bug. The Zune was a portable music player, a\ncompetitor to the iPod. At about midnight on the night of December 31st, 2008, Zunes\neverywhere failed to startup properly. A firmware clock driver designed by a 3rd party\ncompany contained the following code.\n2008 was a leap year, so the check on line 2 evaluated to true. However, though December\n31st, 2008 was the 366th day of the year (days = 366) the third line evaluated to false\nand the loop was repeated without any of the program state being updated. The problem\nwas \u201cfixed\u201d 24 hours later when it was the 367th day and line 3 worked. The problem\nwas that line 3 should have been days >= 366).\nThe failure was that this code was never tested on the \u201ccorner cases\u201d that it was designed\nfor. No one thought to test the driver to see if it worked on the last day of a leap year.\n104 4.5. Other Issues\nwhile(days > 365) {\n1\nif(IsLeapYear(year)) {\n2\nif(days > 366) {\n3\ndays -= 366;\n4\nyear += 1;\n5\n}\n6\n} else {\n7\ndays -= 365;\n8\nyear += 1;\n9\n}\n10\n}\n11\nCode Sample 4.1.: Zune Bug\nThe code worked the vast majority of the time, but this illustrates the need for rigorous\ntesting.\n4.5.3. Common Errors\nWhen writing loops its important to use the proper syntax in the language in which you\nare coding. Many languages use semicolons to terminate executable statements. However,\nthe while statements are not executable: they are part of the control structure of the\nlanguage and do not have semicolons at the end. A misplaced semicolon could be a\nsyntax error, or it could be syntactically correct but lead to incorrect results. A common\nerror is to place a semicolon at the end of a while statement as in\nwhile(count <= 10); \/\/WRONG!!!\nIn this example, the while loop binds to an empty executable statement and results in\nan infinite loop!\nOther common errors are the result of misidentifying either the initialization statement\nor the continuation condition. Starting a counter at 1 instead of zero, or using a \u2264\ncomparison instead of a < , etc. These can lead to a loop being off-by-one resulting in a\nlogic error.\nOther errors are the result of using improper variable types. Recall that operations\ninvolving floating-point numbers can have round off and precision errors, 1 + 1 + 1 may\n3 3 3\nnot be equal to one for example. It is best to avoid using floating-point numbers or\ncomparisons in the control of your loops. Boolean and integer types are much less error\n105 4. Loops\nprone.\nFinally, you must always ensure that your loops are making progress toward the termina-\ntion condition. A failure to properly increment a counter can lead to incorrect results or\neven an infinite loop.\n4.5.4. Equivalency of Loops\nIt might not seem obvious at first, but in fact, any type of loop can be re-written as\nanother type of loop and perform equivalent operations. That is, any while loop can be\nrewritten as an equivalent for loop. Any do-while loop can be rewritten as an equivalent\nwhile loop!\nSo why do we have different types of loops? The short answer is that we want our\nprogramming languages to be flexible. We could design a language in which every loop\nhad to be a while loop for example, but there are some situations in which it would be\nmore \u201cnatural\u201d to write code with a for loop. By providing several options, programmers\nhave the choice of which type of loop to write.\nIn general, there are no \u201crules\u201d as to which loop to apply to which situation. There\nare general trends, best practices, and situations where it is more common to use one\nloop rather than another, but in the end it does come down to personal choice and style.\nSome software projects or organizations may have established guidelines or style guide\nthat establishes such guidelines in the interest of consistency and uniformity.\n4.6. Problem Solving With Loops\nLoops can be applied to any problem that requires repetition of some sort or to simplify\nrepeated code. When designing loops, it is important to identify the three components\nby asking the questions:\n\u2022 Where does the loop start? What variables or other state may need to be initialized\nor setup prior to the beginning of the loop?\n\u2022 What code needs to be repeated? How can it be generalized to depend on loop\ncontrol variables? This helps you to identify and write the loop body.\n\u2022 When should the loop end? How many times do we want it to execute? This helps\nyou to identify the continuation and\/or termination condition.\n\u2022 How do we make progress toward the termination condition? What variable(s)\nneed to be incremented and how?\n106 4.7. Examples\n4.7. Examples\n4.7.1. For vs While Loop\nLet\u2019s consider how to write a loop to compute the classic geometric series,\n\u221e\n1 (cid:88)\n= xk = 1+x+x2 +x3 +\u00b7\u00b7\u00b7\n1\u2212x\nk=0\nObviously a computer cannot compute an infinite series as it is required to terminate in\na finite number of steps. Thus, we can approach this problem in a number of different\nways.\nOne way we could approximate the series is to compute it out to a fixed number of terms.\nTo do so, we could initialize a sum variable to zero, then iteratively compute and add\nterms to the sum until we have computed n terms. To keep track of the terms, we can\ndefine a counter variable, k as in the summation.\nFollowingourstrategy, wecanidentifytheinitialization: k shouldstartat0. Theiteration\nis also easy: k should be incremented by 1 each time. The continuation condition should\ncontinue the loop until we have computed n terms. However, since k starts at 0, we\nwould want to continue while k < n. We would not want to continue the iteration when\nk = n as that would make n+1 iterations (again since k starts at 0). Further, since\nwe know the number of iterations we want to execute, a for loop is arguably the most\nappropriate loop for this problem. Our solution is presented in Algorithm 4.12.\nInput :x, n \u2265 0\nOutput:An approximated value of 1 using a geometric series\n1\u2212x\nsum \u2190 0\n1\nfor (k = 0; k < n; k \u2190 (k +1)) do\n2\nsum \u2190 (sum+xk)\n3\nend\n4\noutput sum\n5\nAlgorithm 4.12: Computing the Geometric Series Using a For Loop\nAs an alternative, consider the following approach: instead of computing a predefined\nnumber of terms, what if we computed terms until the difference between the value in the\nprevious iteration and the value in the current iteration is negligible, say less than some\nsmall (cid:15) amount. We could stop our computation because any further iterations would\nonly affect the summation less and less. That is, the current value represents a \u201cgood\nenough\u201d approximation. That way, if someone wanted an even better approximation,\nthey could specify a smaller (cid:15).\n107 4. Loops\nThis approach will be more straightforward with a while loop since the continuation\ncondition will be more along the lines of \u201cwhile the estimation is not yet good enough,\ncontinue the summation.\u201d This approach will also be easier if we keep track of both\na current and a previous value of the summation, then computing and checking the\ndifference will be easier.\nInput :x, (cid:15) > 0\nsum \u2190 0\n1 prev\nsum \u2190 1\n2 curr\nk \u2190 1\n3\nwhile |sum \u2212sum | \u2265 (cid:15) do\n4 prev curr\nsum \u2190 sum\n5 prev curr\nsum \u2190 (sum +xk)\n6 curr curr\nk \u2190 (k +1)\n7\nend\n8\noutput sum\n9\nAlgorithm 4.13: Computing the Geometric Series Using a While Loop\nOn lines 1\u20132 we initialize our values to ensure that the while loop will execute at least\nonce. In the continuation condition, we use the absolute value of the difference as the\nseries can oscillate between negative and positive values.\n4.7.2. Primality Testing\nAn integer n > 1 is called prime if the only integers that divide it evently are 1 and itself.\nOtherwise it is called composite. For example, 30 is composite as it is divisible by 2, 3,\nand 5 among others. However, 31 is prime as it is only divisible by 1 and 31.\nConsider the problem of determining whether or not a given integer n is prime or\ncomposite, referred to as primality testing. A straightforward way of determining this is\n\u221a\nto simply try dividing by every integer 2 up to n: if any of these integers divides n,\nthen n is composite. Otherwise, if none of them do, n is prime. Observe that we only\n\u221a\nneed to go up to n since any prime divisor greater than that will correspond to some\n\u221a\nprime divisor less than n.\nA simple for loop can be constructed to capture this idea. Our initialization clearly starts\n\u221a\nat i = 2, incrementing by 1 each time until i has exceeded n. This solution is presented\nin Algorithm 4.14. Of course this is certainly not the most efficient way to solve this\nproblem, but we will not go into more advanced algorithms here.\nNow consider this more general problem: given an integer m > 1, determine how many\n108 4.7. Examples\nInput :n > 1\n\u221a\nfor (i \u2190 2; i \u2264 n; i \u2190 (i+1)) do\n1\nif i divides n then\n2\noutput composite\n3\nend\n4\nend\n5\noutput prime\n6\nAlgorithm 4.14: Determining if a Number is Prime or Composite\nprime numbers \u2264 m there are. A key observation is that we\u2019ve already solved part of\nthe problem: determining if a given number is prime in the previous exercise. To solve\nthis more general problem, we could reuse or adapt our previous solution. In particular,\nwe could surround the previous solution in an outer loop and iterate over integers from\n2 up to m. The inner loop would then determine if the integer is prime and instead of\noutputting a result, could increment a counter of the number of primes it has found so\nfar. This solution is presented in Algorithm 4.15.\nInput :m > 1\nnumberOfPrimes \u2190 0\n1\nfor (j = 2; j \u2264 m; j \u2190 (j +1)) do\n2\nisPrime \u2190 true\n3\n\u221a\nfor (i \u2190 2; i \u2264 j; i \u2190 (i+1)) do\n4\nif (i divides j) then\n5\nisPrime \u2190 false\n6\nend\n7\nend\n8\nif (isPrime) then\n9\nnumberOfPrimes \u2190 (numberOfPrimes+1)\n10\nend\n11\nend\n12\noutput numberOfPrimes\n13\nAlgorithm 4.15: Counting the number of primes.\n4.7.3. Paying the Piper\nBanks issue loans to customers as one lump sum called a principle P that the borrower\nmust pay back over a number of terms. Usually payments are made on a monthly basis.\n109 4. Loops\nFurther, banks charge an amount of interest on a loan measured as an Annual Percentage\nRate (APR). Given these conditions, the borrower makes monthly payments determined\nby the following formula.\niP\nmonthlyPayment =\n1\u2212(1+i)\u2212n\nWhere i = apr is the monthly interest rate, and n is the number of terms (in months).\n12\nFor simplicity, suppose we borrow P = $1,000 at 5% interest (apr = 0.05) to be paid\nback over a term of 2 years (n = 24). Our monthly payment would (rounded) be\n.05 \u00b71000\nmonthlyPayment = 12 = $43.87\n1\u2212(1+ .05)\u221224\n12\nWhen the borrower makes the first month\u2019s payment, some of it goes to interest, some of\nit goes to paying down the balance. Specifically, one month\u2019s interest on $1,000 is\n0.05\n$1,000\u00b7 = $4.17\n12\nand so $43.87\u2212$4.17 = $39.70 goes to the balance, making the new balance $960.30.\nThe next month, this new balance is used to compute the new interest payment,\n0.05\n$960.30\u00b7 = $4.00\n12\nAnd so on until the balance is fully paid. This process is known as loan amortization.\nLet\u2019s write a program that will calculate a loan amortization schedule given the inputs as\ndescribed above. To start, we\u2019ll need to compute the monthly payment using the formula\nabove and for that we\u2019ll need a monthly interest rate. The balance will be updated\nmonth-to-month, so we\u2019ll use another variable to represent the balance. Finally, we\u2019ll\nwant to track the current month in the loan schedule process.\nOnce we have these variables setup, we can start a loop that will repeat once for each\nmonth in the loan schedule. We could do this using either type of loop, but for this\nexercise, let\u2019s use a while loop. Using our month variable, we\u2019ll start by initializing it to\n1 and run the loop through the last month, n.\nOn each iteration we compute that month\u2019s interest and principle payments as above,\nupdate the balance, and also be sure to update our month counter variable to ensure\nwe\u2019re making progress toward the termination condition. On each iteration we\u2019ll also\noutput each of these variables to the user. The full program can be found in Algorithm\n4.16.\nIf we were to actually implement this we\u2019d need to be more careful. This outlines the basic\nprocess, but keep in mind that US dollars are only accurate to cents. A monthly payment\n110 4.8. Exercises\ncan\u2019t be $43.871 cents. We\u2019ll need to take care to round properly. This introduces another\nissue: by rounding the final month\u2019s payment may not match the expected monthly\npayment (we may over or under pay in the final month). An actual implementation may\nneed to handle the final month\u2019s payment separately with different logic and operations\nthan are outside the loop.\nInput :A principle, P, a number of terms, n, an APR, apr\nOutput:A loan amortization schedule\n1 balance \u2190 P \/\/The initial balance is the principle\n2 i \u2190 apr \/\/monthly interest rate\n12\nmonthlyPayment \u2190 iP\n3\n1\u2212(1+i)\u2212n\n4 month \u2190 1 \/\/A month counter\nwhile (month \u2264 n) do\n5\nmonthInterest \u2190 i\u00b7balance\n6\nmonthPrinciple \u2190 monthlyPayment\u2212monthInterest\n7\nbalance \u2190 balance\u2212monthPrinciple\n8\nmonth = (month+1)\n9\noutput month,monthInterest,monthPrinciple,balance\n10\nend\n11\nAlgorithm 4.16: Computing a loan amortization schedule\n4.8. Exercises\nExercise 4.1. Write a for-loop and a while-loop that accomplishes each of the following.\n(a) Prints all integers 1 thru 100 on the same line delimited by a single space\n(b) Prints all even integers 0 up to n in reverse order\n(c) A list of integers divisible by 3 between a and b where a,b are parameters or inputs\n(d) Prints all positive powers of two up to 230 : 1,2,4,...,1073741824 one value per\nline (try computing up to 231 and 232 and discern reasons for why it may fail)\n(e) Prints all even integers 2 thru 200 on 10 different lines (10 numbers on each line)\nin reverse order\n(f) Prints the following pattern of numbers (hint: use two nested loops; the result can\nbe computed using some value of i+10j)\n111 4. Loops\n11 21 31 41 51 61 71 81 91 101\n12 22 32 42 52 62 72 82 92 102\n13 23 33 43 53 63 73 83 93 103\n14 24 34 44 54 64 74 84 94 104\n15 25 35 45 55 65 75 85 95 105\n16 26 36 46 56 66 76 86 96 106\n17 27 37 47 57 67 77 87 97 107\n18 28 38 48 58 68 78 88 98 108\n19 29 39 49 59 69 79 89 99 109\n20 30 40 50 60 70 80 90 100 110\nExercise 4.2. Civil engineers have come up with two different models on how a city\u2019s\npopulation will grow over the next several years. The first projection assumes a 10%\nannual growth rate while the second projection assumes a linear growth rate of 50,000\nadditional citizens per year. Write a program to project the population growth under\nboth models. Take, as input, the initial population of the city along with a number of\nyears to project the population.\nIn addition, compute how many years it would take to double the population under each\nmodel.\nExercise 4.3. Write a loan program similar to the amortization schedule program we\ndeveloped in Section 4.7.3. However, give the user an option to specify an extra monthly\npayment amount in order to pay off the loan early. Calculate how much quicker the loan\ngets paid off and how much they save in interest.\nExercise 4.4. The rate of decay of a radioactive isotope is given in terms of its half-life\nH, the time lapse required for the isotope to decay to one-half of its original mass.\nFor example, the isotope Strontium-90 (90Sr) has a half-life of 28.9 years. If we start\nwith 10kg of Strontium-90 then 28.9 years later you would expect to have only 5kg of\nStrontium-90 (and 5kg of Yttrium-90 and Zirconium-90, isotopes which Strontium-90\ndecays into).\nWrite a program that takes the following input:\n\u2022 Atomic Number (integer)\n\u2022 Element Name\n\u2022 Element Symbol\n\u2022 H (half-life of the element)\n\u2022 m, an initial mass in grams\n112 4.8. Exercises\nYour program will then produce a table detailing the amount of the element that remains\nafter each year until less than 50% of the original amount remains. This amount can be\ncomputed using the following formula:\n(cid:18) 1(cid:19)(y\/H)\nr = m\u00d7\n2\ny is the number of years elapsed, and H is the half-life of the isotope in years.\nFor example, using your program on Strontium-90 (symbol: Sr, atomic number: 38)\nwith a half-life of 28.9 years and an initial amount of 10 grams would produce a table\nsomething like the following.\nStrontium-90 (38-Sr)\nElapsed Years Amount\n-------------------------\n- 10g\n1 9.76g\n2 9.53g\n3 9.30g\n...\n28 5.11g\n29 4.99g\nExercise 4.5. Write a program that computes various statistics on a collection of\nnumbers that can be read in from the command line, as command line arguments, or via\nother means. In particular, given n numbers,\nx ,x ,...,x\n1 2 n\nyour program should compute the following statistics:\n\u2022 The minimum number\n\u2022 The maximum number\n\u2022 The mean,\nn\n1 (cid:88)\n\u00b5 = x\ni\nn\ni=1\n\u2022 The variance,\nn\n1 (cid:88)\n\u03c32 = (x \u2212\u00b5)2\ni\nn\ni=1\n113 4. Loops\n\u2022 And the standard deviation,\n(cid:118)\n(cid:117) n\n(cid:117)1 (cid:88)\n\u03c3 = (cid:116) (x \u2212\u00b5)2\ni\nn\ni=1\nwhere n is the number of numbers that was provided. For example, with the numbers,\n3.14,2.71,42,3,13\nyour output should look something like:\nMinimum: 2.71\nMaximum: 42.00\nMean: 12.77\nVariance: 228.77\nStandard\nDeviation: 15.13\nExercise 4.6. The ancient Greek mathematician Euclid developed a method for finding\nthe greatest common divisor of two positive integers, a and b. His method is as follows:\n1. If the remainder of a\/b is 0 then b is the greatest common divisor.\n2. If it is not 0, then find the remainder r of a\/b and assign b to a and the remainder\nr to b.\n3. Return to step (1) and repeat the process.\nWrite a program that uses a function to perform this procedure. Display the two integers\nand the greatest common divisor.\nExercise 4.7. Write a program to estimate the value of e \u2248 2.718281... using the series:\n\u221e\n(cid:88) 1\ne =\nk!\nk=0\nObviously, you will need to restrict the summation to a finite number of n terms.\nExercise 4.8. The value of \u03c0 can be expressed by the following infinite series:\n(cid:18) (cid:19)\n1 1 1 1 1 1\n\u03c0 = 4\u00b7 1\u2212 + \u2212 + \u2212 + \u2212\u00b7\u00b7\u00b7\n3 5 7 9 11 13\n114 4.8. Exercises\nAn approximation can be made by taking the first n terms of the series. For n = 4, the\napproximation is\n(cid:18) (cid:19)\n1 1 1\n\u03c0 \u2248 4\u00b7 1\u2212 + \u2212 = 2.8952\n3 5 7\nWrite a program that takes n as input and outputs an approximation of \u03c0 according to\nthe series above.\nExercise 4.9. The sine function can be approximated using the following Taylor series.\n(cid:88)\u221e (\u22121)i x3 x5\nsin(x) = x2i+1 = x\u2212 + \u2212\u00b7\u00b7\u00b7\n(2i+1)! 3! 5!\ni=0\nWrite a function that takes x and n as inputs and approximates sinx by computing the\nfirst n terms in the series above.\nExercise 4.10. One way to compute \u03c0 is to use Machin\u2019s formula:\n\u03c0 1 1\n= 4arctan \u2212arctan\n4 5 239\nTo compute the arctan function, you could use the following series:\nx x3 x5 x7 (cid:88)\u221e (\u22121)i\narctanx = \u2212 + \u2212 +\u00b7\u00b7\u00b7 = x2i+1\n1 3 5 7 2k +1\ni=0\nWrite a program to estimate \u03c0 using these formulas but allowing the user to specify how\nmany terms to use in the series to compute it. Compare the estimate with the built-in\ndefinition of \u03c0 in your language.\nExercise 4.11. The arithmetic-geometric mean of two numbers x,y, denoted M(x,y) (or\n\u221a\nagm(x,y)) can be computed iteratively as follows. Initially, a = 1(x+y) and g = xy\n1 2 1\n(i.e. the normal arithmetic and geometric means). Then, compute\na = 1(a +g )\nn+1 \u221a2 n n\ng = a g\nn+1 n n\nThe two sequences will converge to the same number which is the arithmetic-geometric\nmean of x,y. Obviously we cannot compute an infinite sequence, so we compute until\n|a \u2212g | < (cid:15) for some small number (cid:15).\nn n\nExercise 4.12. The integral of a function is a measure of the area under its curve. One\nnumerical method for computing the integral of a function f(x) on an interval [a,b] is\nthe rectangle rule. Specifically, an interval [a,b] is split up into n equal subintervals of\nsize h = b\u2212a. Then the integral is approximated by computing:\nn\n(cid:90) b n\u22121\n(cid:88)\nf(x)dx \u2248 f(a+ih)\u00b7h\na\ni=0\n115 4. Loops\nWrite a program to approximate an integral using the rectangle method. For this\nparticular exercise you will integrate the function\nsinx\nf(x) =\nx\nFor reference, the function is depicted in Figure 4.3. Write a program that will read the\nend points a,b and the number of subintervals n and computes the integral of f using\nthe rectangle method. It should then output the approximation.\nFigure 4.3.: Plot of f(x) = sinx\nx\nExercise 4.13. Another way to compute an integral is to a technique called Monte\nCarlo Integration, a randomized numerical integration method.\nGiven the interval [a,b], we enclose the function in a region of interest with a rectangle\nof a known area A . We then randomly select n points within the rectangle and count\nr\nthe number of random points that are within the function\u2019s curve. If m of the n points\nare within the curve, we can estimate the integral to be\n(cid:90) b m\nf(x)dx \u2248 A\nr\nn\na\nConsider again the function f(x) = sin(x). Note that the global maximum and minimum\nx\nof this function are 1 and \u2248 \u22120.2172 respectively. Therefore, we can also restrict the\nrectangle along the y-axis from \u2212.25 to 1. That is, the lower left of the rectangle will be\n(a,\u2212.25) and the upper right will be (b,1) for a known area of\nA = |a\u2212b|\u00d71.25\nr\nFigure 4.4 illustrates the rectangle for the interval [\u22125,5].\nWrite a program that will takes as input interval values a,b, and an integer n and perform\na Monte Carlo estimate of the integral of the function above. Realize that this is just an\napproximation and it is randomized so your answers may not match exactly and may be\ndifferent on various executions of your program. Take care that you handle points within\nthe curve but under the x-axis correctly.\n116 4.8. Exercises\nFigure 4.4.: A rectangle for the interval [\u22125,5].\nExercise 4.14. Consider a ball trapped in a 2-D box. Suppose that it has an initial\nposition (x,y) within the box (the box\u2019s dimensions are specified by its lower left (x ,y )\n(cid:96) (cid:96)\nand an upper right (x ,y ) points) along with an initial angle of travel \u03b8 in the range\nr r\n[0,2\u03c0). As the ball travels in this direction it will eventually collide with one of the sides\nof the box and bounce off. For this model, we will assume no loss of velocity (it keeps\ngoing) and its angle of reflection is perfect.\nWrite a program that takes as input, x,y,\u03b8,x ,y ,x ,y , and an integer n and computes\n(cid:96) (cid:96) r r\nthe first n\u22121 Euclidean points on the box\u2019s perimeter that the ball bounces off of in its\ntravel (include the initial point in your printout for a total of n points). You may assume\nthat the input will always be \u201cgood\u201d (the ball will always begin somewhere inside the\nbox and the lower left and upper right points will not be reversed).\nAs an example, consider the inputs:\nx = 1,y = 1,\u03b8 = .392699,x = 0,y = 0,x = 4,y = 3,n = 20\n(cid:96) (cid:96) r r\nStarting at (1,1), the ball travels up and to the right bouncing off the right wall. Figure\n4.5 illustrates this and the subsequent bounces back and forth.\nYour output should simply be the points and should look something like the following.\n(1.000000, 1.000000)\n(4.000000, 2.242640)\n(2.171572, 3.000000)\n(0.000000, 2.100506)\n(4.000000, 0.443652)\n(2.928929, 0.000000)\n(0.000000, 1.213202)\n(4.000000, 2.870056)\n(3.686287, 3.000000)\n(0.000000, 1.473090)\n117 4. Loops\ny\n(1.284,3)\n(1,1)\nx\nFigure 4.5.: Follow the bouncing ball\n(3.556355, 0.000000)\n(4.000000, 0.183764)\n(0.000000, 1.840617)\n(2.798998, 3.000000)\n(4.000000, 2.502529)\n(0.000000, 0.845675)\n(2.041640, 0.000000)\n(4.000000, 0.811179)\n(0.000000, 2.468033)\n(1.284282, 3.000000)\nExercise 4.15. An integer n \u2265 2 is prime if its only divisors are 1 and itself, n. For\nexample, 2,3,5,7,11,... are primes. Write a program that outputs all prime numbers 2\nup to m where m is read as input.\nExercise 4.16. An integer n \u2265 2 is prime if the only integers that evenly divide it are 1\nand n itself, otherwise it is composite. The prime factorization of an integer is a list of\nits prime divisors along with their multiplicities. For example, the prime decomposition\nof 188,760 is:\n188,760 = 2\u00b72\u00b72\u00b73\u00b75\u00b711\u00b711\u00b713\nWrite a program that takes an integer n as input and outputs the prime factorization of\nn. If n is invalid, an appropriate error message should be displayed instead. Your output\nshould look something like the following.\n118 4.8. Exercises\n1001 = 7 * 11 * 13\nExercise 4.17. One way of estimating \u03c0 is to randomly sample points within a 2\u00d72\nsquare centered at the origin. If the distance between the randomly chosen point (x,y)\nand the origin is less than or equal to 1, then the point lies inside the unit circle centered\nat the origin and we count it. If the point lies outside the circle then we can ignore it. If\ny\nx\nFigure 4.6.: Sampling points in a circle\nwe sample n points and m of them lie within the circle, then \u03c0 can be estimated as\n4m\n\u03c0 \u2248\nn\nGiven a point (x,y), its distance from the origin is simply\n(cid:112)\nx2 +y2\nThis idea is illustrated in Figure 4.6. Example code is given to randomly generate\nnumbers within a bound. Write a program that takes an integer n as input and randomly\nsamples n points within the 2\u00d72 square and outputs an approximation of \u03c0.\nOf course, you\u2019ll need a way to generate random numbers within the range [\u22121,1]. Since\nyou are using some randomization, the result is just an approximation and may not\nmatch exactly or even be the same between two different runs of your program.\n119 4. Loops\nFigure 4.7.: Regular polygons\nExercise 4.18. A regular polygon is a polygon that is equiangular. That is, it has n\nsides and n points whose angle from the center are all equal in measure. Examples for\nn = 3 through n = 8 can be found in Figure 4.7.\nWrite a program that takes n and a radius r as inputs and computes the points of a\nregular n-sided polygon centered at the origin (0,0). Each point should be distance r\nfrom the origin and the first point should lie on the positive x-axis. Each subsequent\npoint should be at an angle \u03b8 equal to 2\u03c0 from the previous point. Recall that given the\nn\npolar coordinates \u03b8,r we can convert to cartesian coordinates (x,y) using the following.\nx = r\u00b7cos\u03b8\ny = r\u00b7sin\u03b8\nYour program should be robust enough to check for invalid inputs. If invalid, an error\nmessage should be printed and the program should exit.\nFor example, running your program with n = 5,r = 6 should produce the points of a\npentagon with \u201cradius\u201d 6. The output should look something like:\nRegular 5-sided polygon with radius 6.0:\n(6.0000, 0.0000)\n(1.8541, 5.7063)\n(-4.8541, 3.5267)\n(-4.8541, -3.5267)\n(1.8541, -5.7063)\nExercise 4.19. Let p = (x ,y ) and p = (x ,y ) be two points in the cartesian plane\n1 1 1 2 2 2\nwhich define a line segment. Suppose we travel along this line starting at p taking n\n1\nsteps that are an equal distance apart until we reach p . We wish to know which points\n2\ncorrespond to each of these steps and which step along this path is closest to anther\npoint p = (x ,y ). Recall that the distance between two points can be computed using\n3 3 3\nthe Euclidean distance formula:\n(cid:112)\n\u03b4 = (x \u2212x )2 +(y \u2212y )2\n1 2 1 2\nWrite a program that takes three points and an integer n as inputs and outputs a sequence\nof points along the line defined by p ,p that are distance \u03b4 apart from each other. It\n1 2 n\n120 4.8. Exercises\nshould also indicate which of these computed points is the closest to the third point.\nFor example, the execution of your program with inputs 0,2,\u22125.5,7.75,\u22122,3,10 should\nproduce output that looks something like:\n(0.00, 2.00) to (-5.50, 7.75) distance: 7.9569\n(0.00, 2.00)\n(-0.55, 2.58)\n(-1.10, 3.15)\n(-1.65, 3.72) <-- Closest point to (-2, 3)\n(-2.20, 4.30)\n(-2.75, 4.88)\n(-3.30, 5.45)\n(-3.85, 6.02)\n(-4.40, 6.60)\n(-4.95, 7.17)\n(-5.50, 7.75)\nExercise 4.20. The natural log of a number x is usually computed using some numerical\napproximation method. One such method is to use the following Taylor series.\n(x\u22121)2 (x\u22121)3 (x\u22121)4\nlnx = (x\u22121)\u2212 + \u2212 +\u00b7\u00b7\u00b7\n2 3 4\nHowever, this only works for |x\u22121| \u2264 1 (except for x = 0) and diverges otherwise. For\nx such that |x| > 1, we can use the series\ny 1 1 1\nln = + + +\u00b7\u00b7\u00b7\ny \u22121 y 2y2 3y3\nwhere y = x . Of course such an infinite computation cannot be performed by a\nx\u22121\ncomputer. Instead, we approximate lnx by computing the series out to a finite number\nof terms, n. Your program should print an error message and exit for x \u2264 0; otherwise it\nshould use the first series for 0 < x \u2264 1 and the second for x > 1.\nAnother series that has better convergence properties and works for any range of x is as\nfollows\n(cid:18) (cid:19)\n1+y 1 1 1\nlnx = ln = 2y 1+ y2 + y4 + y6\u00b7\u00b7\u00b7\n1\u2212y 3 5 7\nwhere y = (x\u22121).\n(x+1)\nYou will write a program that approximates lnx using these two methods computed to n\nterms. You will also compute the error of each method by comparing the approximated\nvalue to the standard math library\u2019s log function.\n121 4. Loops\nYour program should accept x and n as inputs. It should be robust enough to reject\nany invalid inputs (lnx is not defined for x = 0 you may also print an error for any\nnegative value; n must be at least one). It will then compute an approximation using\nboth methods and print the relative error of each method.\nFor example, the execution of your program with inputs 3.1415,6 should produce output\nthat looks something like:\nTaylor Series: ln(3.1415) ~= 1.11976\nError: 0.02494\nOther Series: ln(3.1415) ~= 1.14466\nError: 0.00004\nExercise 4.21. There are many different numerical methods to compute the square root\nof a number. In this exercise, you will implement several of these methods.\n(a) The Exponential Identity Method involves the following identity:\n\u221a\nx =\ne1ln(x)\n2\nWhich assumes the use of built-in (or math-library) functions for e and the natural\nlog, ln.\n(b) The Babylonian Method involves iteratively computing the following recurrence:\n(cid:18) (cid:19)\n1 x\na = a +\ni i\u22121\n2 a\ni\u22121\nwhere a = 1.0. Computation is repeated until |a \u2212 a | \u2264 \u03b4 where \u03b4 is some\n1 i i\u22121\nsmall constant value.\n(c) A method developed for one of the first electronic computers (EDSAC [29]) involves\nthe following iteration. Let a = x, c = x\u22121. Then compute\n0 0\na = a \u2212 aici\ni+1 i 2\nc =\nc2 i(ci\u22123)\ni+1 4\nThe iteration is performed for as many iterations as specified (n), or until the\nchange in a is negligible. The resulting value for a is used as an approximation for\n\u221a\nx \u2248 a. However, this method only works for values of x such that 0 < x < 3. We\ncan easily overcome this by scaling x by some power of 4 so that the scaled value\nof x satisfies 1 \u2264 x < 2. After applying the method we can then scale back up by\n2 \u221a\nthe appropriate value of 2 (since 4 = 2). Algorithm 4.17 describes how to scale x.\n122 4.8. Exercises\nWrite a program to compute the square root of an input number using these methods\nand compare your results.\npower \u2190 0\n1\nwhile x < 1 do\n2\n2\n\/\/Scale up\nx \u2190 (x\u00b74)\n3\npower \u2190 (power\u22121)\n4\nend\n5\nwhile x \u2265 2 do\n6\n\/\/Scale down\nx \u2190 x\n7\n4\npower \u2190 (power+1)\n8\nend\n9\nAlgorithm 4.17: Scaling a value x so that it satisfies 1 \u2264 x < 2. After execution,\n2\npower indicates what power of 2 the value x was scaled by.\nExercise 4.22. There are many different numerical methods to compute the natural\nlogarithm of a number, lnx. In this exercise, you will implement several of these methods.\n(a) A formula version approximates the natural logarithm as:\n\u03c0\nln(x) \u2248 \u2212mln(2)\n2M(1,4\/s)\nWhere M(a,b) is the arithmetic-geometric mean and s = x2m. In this formula, m\nis a parameter (a larger m provides more precision).\n(b) The standard Taylor Series for the natural logarithm is:\n(cid:88)\u221e (\u22121)n+1\nln(x) = (x\u22121)n\nn\nn=1\nAs we cannot compute an infinite series, we will simply compute the series to the\nfirst m terms. Also note that this series is not convergent for values x > 1\n(c) Borchardt\u2019s algorithm is an iterative method that works as follows. Let\n1+x \u221a\na = b = x\n0 0\n2\nThen repeat:\na = a k+b k\nk+1 (cid:112)2\nb = a b\nk+1 k+1 k\n123 4. Loops\nuntil the absolute difference between a ,b is small; that is |a \u2212b | < (cid:15). Then the\nk k k k\nlogarithm is approximated as\nx\u22121\nln(x) \u2248 2\na +b\nk k\n(d) Newton\u2019s method works if x is sufficiently close to 1. It works by setting y = 1\n0\nand then computing\nx\u2212eyn\ny = y +2\nn+1 n x+eyn\nThe iteration is performed m times.\nTo ensure that some of the methods above work, you may need to scale the number x to\nbe as close as possible to 1. One way to do this is to divide or multiply by e until x is\nclose to 1. Suppose we divided by e k times; that is x = z\u00b7ek where z is close to 1. Then\nln(x) = ln(z \u00b7ek) = ln(z)+ln(ek) = ln(z)+k\nThus, we can apply the methods above to Newton\u2019s method to z and add k to the result\nto get ln(x). A similar trick can be used to ensure that the Taylor Series method is\nconvergent.\nExercise 4.23. Write a program that takes a positive integer n as a command line\nargument and outputs a list of all pairs of integers x,y such that 1 \u2264 x,y \u2264 n whose\nsum, x+y is prime. For example, if n = 5, the output should look something like the\nfollowing.\n1 + 2 = 3 is prime\n1 + 4 = 5 is prime\n2 + 3 = 5 is prime\n2 + 5 = 7 is prime\n3 + 4 = 7 is prime\nExercise 4.24. Consider the following variation on the classical \u201cFizzBuzz\u201d challenge.\nWrite a program that will print out numbers 1 through n where n is provided as a\ncommand line argument. However, if the number is a perfect square (that is, the square\nof some integer; for example 1 = 12,4 = 22,9 = 32, etc.) print \u201cGo Huskers\u201d instead. If\nthe number is a prime (2,3,5,7, etc.) print \u201cGo Cubs\u201d instead.\nExercise 4.25. Implement a program to solve the classic \u201cRainfall Problem\u201d (which\nhas been used in CS education studies to assess programming knowledge and skills).\nWrite an interactive program that repeatedly prompts the user to enter an integer (which\n124 4.8. Exercises\nrepresents the amount of rainfall on a particular day) until it reads the integer 99999.\nAfter 99999 is entered, it should print out the correct average. That is, it should not count\nthe final 99999. Negative values should also be ignored. For example, if the user entered\nthe sequence 4 0 -1 10 99999 the output should look something like the following.\nAverage rainfall: 4.66\nExercise 4.26. Write a program that takes an integer n and a subsequent list of integers\nas command line arguments and determines which number(s) between 1 and n are\nmissing from the list. For example, if the following numbers are given to the program:\n10 5 2 3 9 2 8 8 your output should look something like:\nMissing numbers 1 thru 10:\n1, 4, 6, 7, 10\nExercise 4.27. Write a program that takes a list of pairs of numbers representing\nlatitudes\/longitudes (on the scale [\u2212180,180] (negative values correspond to the southern\nand western hemispheres). Then, starting with the first pair, calculate the intermediate\nair distances between each location as well as a final total distance.\nTo compute air distance from location A to a location B, use the Spherical Law of\nCosines:\nd = arccos(sin(\u03d5 )sin(\u03d5 )+cos(\u03d5 )cos(\u03d5 )cos(\u2206))\u00b7R\n1 2 1 2\nwhere\n\u2022 \u03d5 is the latitude of location A, \u03d5 is the latitude of location B\n1 2\n\u2022 \u2206 is the difference between location B\u2019s longitude and location A\u2019s longitude\n\u2022 R is the (average) radius of the earth, 6,371 kilometers\nNote: the formula above assumes that latitude and longitude are measured in radians r,\n\u2212\u03c0 \u2264 r \u2264 \u03c0. To convert from degrees deg (\u2212180 \u2264 deg \u2264 180) to radians r, you can use\nthe simple formula:\ndeg\nr = \u03c0\n180\nFor example, if the command line arguments were\n40.8206 -96.756 41.8806 -87.6742 41.9483 -87.6556 28.0222 -81.7329\n125 4. Loops\nyour output should look something like:\n(40.8206, -96.7560) to (41.8806, -87.6742): 766.8053km\n(41.8806, -87.6742) to (41.9483, -87.6556): 7.6836km\n(41.9483, -87.6556) to (28.0222, -81.7329): 1638.7151km\nTotal Distance: 2413.2040\nExercise 4.28. A DNA sequence is made up of a sequence of four nucleotide bases, A,\nC, G, T (adenine, cytosine, guanine, thymine). One particularly interesting statistic of a\nDNA sequence is finding a CG island: a subsequence that contains the highest frequency\nof guanine and cytosine.\nFor simplicity, we will be interested in subsequences of a particular length, n that will be\nprovided as part of the input.\nWrite a program that takes, as command line arguments, an integer n and a DNA\nsequence. The program should then find all subsequences of the given DNA string of\nlength n with the maximal frequency of C and G in it. For example, if the DNA sequence\nis\nACAAGATGCCATTGTCCCCCGGCCTCCTGCTGCTGCTGCTCTCCGGGGCCACGGC\nand the \u201cwindow\u201d size that we\u2019re interested in is n = 5 then you would scan the sequence\nand find every subsequence with the maximum number of C or G bases. Your output\nshould include all CG Islands (by indices) in the sequence similar to the following.\nn = 5\nhighest frequency: 5 \/ 5 = 100.00%\nCG Islands:\n15 thru 20: CCCCC\n16 thru 21: CCCCG\n17 thru 22: CCCGG\n18 thru 23: CCGGC\n19 thru 24: CGGCC\n42 thru 47: CCGGG\n43 thru 48: CGGGG\n44 thru 49: GGGGC\n45 thru 50: GGGCC\n126 4.8. Exercises\nExercise 4.29. Write a program that will assist people in saving for retirement using a\ntax-deferred 401k program.\nYour program will read the following inputs as command line arguments.\n\u2022 An initial starting balance\n\u2022 A monthly contribution amount (we\u2019ll assume its the same over the life of the\nsavings plan)\n\u2022 An (average) annual rate of return (on the scale [0,1])\n\u2022 An (average) annual rate of inflation (on the scale [0,1])\n\u2022 A number of years until retirement\nYour program will then compute a monthly savings table detailing the (inflation-adjusted)\ninterest earned each month, contribution, and new balance. The inflation-adjusted rate\nof return can be computed with the following formula.\n1+rate of return\n\u22121\n1+inflation rate\nTo get the monthly rate, simply divide by 12. Each month, interest is applied to the\nbalance at this rate (prior to the monthly deposit) and the monthly contribution is added.\nThus, the earnings compound month to month.\nBe sure that your program handles bad inputs as well as it can. It should also round to\nthe nearest cent for every figure. Finally, as of 2014, annual 401k contributions cannot\nexceed $17,500. If the user\u2019s proposed savings schedule violates this limit, display an\nerror message instead of the savings table.\nFor inputs 10000 500 0.09 0.012 10 your output should look something like the\nfollowing:\nMonth Interest Balance\n1 $ 64.23 $ 10564.23\n2 $ 67.85 $ 11132.08\n3 $ 71.50 $ 11703.58\n4 $ 75.17 $ 12278.75\n5 $ 78.87 $ 12857.62\n6 $ 82.58 $ 13440.20\n7 $ 86.33 $ 14026.53\n8 $ 90.09 $ 14616.62\n9 $ 93.88 $ 15210.50\n127 4. Loops\n...\n116 $ 678.19 $ 106767.24\n117 $ 685.76 $ 107953.00\n118 $ 693.37 $ 109146.37\n119 $ 701.04 $ 110347.41\n120 $ 708.75 $ 111556.16\nTotal Interest Earned: $ 41556.16\nTotal Nest Egg: $ 111556.16\nExercise 4.30. An affine cipher is an encryption scheme that encrypts messages using\nthe following function:\ne (x) = (ax+b) mod n\nk\nWhere n is some integer and 0 \u2264 a,b,x \u2264 n\u22121. That is, we fix n, which will be used to\nencode an alphabet as in Table 4.1.\nx character\n0 (space)\n1 A\n2 B\n3 C\n. .\n. .\n. .\n25 Y\n26 Z\n27 .\n28 !\nTable 4.1.: Character Mapping for n = 29\nThen we choose integers a,b to define the encryption function. Suppose a = 10,b = 13,\nthen\ne (x) = (10x+13) mod 29\nk\nSo to encrypt \u201cHELLO!\u201d we would encode it as 8,5,12,12,15,27, then encrypt them,\ne (8) = (10\u00b78+13) mod 29 = 6\nk\ne (5) = (10\u00b75+13) mod 29 = 5\nk\ne (12) = (10\u00b712+13) mod 29 = 17\nk\ne (12) = (10\u00b712+13) mod 29 = 17\nk\ne (15) = (10\u00b715+13) mod 29 = 18\nk\n128 4.8. Exercises\ne (28) = (10\u00b728+13) mod 29 = 3\nk\nWhich, when mapped back to characters using our encoding is \u201cFEQQRC.\u201d\nTo decrypt a message we need to invert the decryption function, that is,\n(cid:0) (cid:1)\nd (y) = a\u22121 \u00b7(y \u2212b) mod n\nk\nwhere a\u22121 is the inverse of a modulo n. The inverse of an integer a is the value such that\n(a\u00b7a\u22121) mod n = 1\nso for a = 10,n = 29, the inverse, 10\u22121 mod 29 = 3 since 3\u00b710 mod 29 = 1. Given a and\nn, how can we find an inverse, a\u22121? Obviously it cannot be zero, nor can it be 1 (1 is its\nown inverse). There is a simple algorithm (the Extended Euclidean Algorithm) that can\nsolve this problem, but n = 29 is small enough that a brute-force strategy of testing all\npossibilities will suffice.\nWrite a program that takes a,b and an encrypted message as command line arguments\nand decrypts the message. Your program should print the decrypted message and other\ncipher information to the standard output. For example:\na = 10\nb = 13\na^-1 = 3\nEncrypted Message: FEQQRC\nDecrypted Message: HELLO!\nExercise 4.31. A centroid (or barycenter) of a plane figure is the arithmetic mean of all\nthe points in the shape. The centroid of a non-self-intersecting closed polygon defined by\nn vertices (x ,y ),(x ,y ),...,(x ,y ) is the point (C ,C ) which can be computed\n0 0 1 1 n1 n\u22121 x y\nusing:\nn\u22121\n1 (cid:88)\nC = (x +x )(x y \u2212x y )\nx i i+1 i i+1 i+1 i\n6A\ni=0\nn\u22121\n1 (cid:88)\nC = (y +y )(x y \u2212x y )\ny i i+1 i i+1 i+1 i\n6A\ni=0\nwith A being the polygon\u2019s signed area:\n129 4. Loops\n(2,3.6)\n(2.468,1.902) (4.25,2.1)\n(1,1.5)\n(3.7,1.5)\n(2.25,0.25)\nFigure 4.8.: A polygon and its centroid. Whoo!\nn\u22121\n1 (cid:88)\nA = (x y \u2212x y )\ni i+1 i+1 i\n2\ni=0\nIn these formulas, the vertices are assumed to be numbered in order of their occurrence\nalong the polygon\u2019s perimeter. Furthermore, the vertex (x ,y ) = (x ,y ).\nn n 0 0\nWrite a program that takes n pairs of x-y coordinates as command line arguments that\nrepresent a polygon and computes its centroid. For example, the an input such as\n1 1.5 2 3.6 4.25 2.1 3.7 1.5 2.25 0.25\nwould correspond to the polygon in Figure 4.8 with a centroid of (2.46,1.90). The output\nshould look something like the following.\nCentroid: (2.468405, 1.902874)\nExercise 4.32. Suppose we are given a set of n points (x ,y ),(x ,y ),...,(x ,y )\n0 0 1 1 n1 n\u22121\nin the plane. Write a program that outputs instructions for someone to \u201cwalk\u201d to each\npoint in the order that they are given starting at the origin by only going in the cardinal\ndirections (not \u201cas the bird flies\u201d). For example, if the following input is given,\n3 5 2 7 9 5\nThen the output should look like the following.\nGo north 5.00 units\nGo east 3.00 units\nGo north 2.00 units\n130 4.8. Exercises\nGo west 1.00 units\nGo south 2.00 units\nGo east 7.00 units\nExercise 4.33. A histogram is a graphical representation of the distribution of numerical\ndata. Typically, a histogram is represented as a (vertical) bar graph. However, we\u2019ll limit\nour attention to graphing a horizontal ASCII histogram.\nIn particular, write a program that takes a sequence of numerical values representing\ngrades (on a 0\u2013100 scale; reject any invalid values). The program will then display\na horizontal graph of the distribution of these values over 6 fixed ranges that looks\nsomething like the following.\n0 - 49 (2, 11.11%) ******\n50 - 59 (1, 5.56%) ***\n60 - 69 (1, 5.56%) ***\n70 - 79 (5, 27.78%) **************\n80 - 89 (4, 22.22%) ************\n90 - 100 (5, 27.78%) **************\nIn the diagram, each star, * represents (at least) 2%\nExercise 4.34. Shannon entropy is a measure of information in a piece of data; specifi-\ncally it is the expected value (average) of the information the data contains. A higher\nentropy value corresponds to more random data while 0 indicates highly structured data.\nEntropy is calculated using the following formula.\nn\n(cid:88)\nH(X) = \u2212 p(x )\u00b7log p(x )\ni 2 i\ni=1\nwhere x ,x ,...,x are the distinct symbols in the data sequence X and p(x ) is the\n1 2 n i\nprobability of the x -th symbol. If the length of X is n, then this is simply\ni\nc(x )\ni\np(x ) =\ni\nn\nwhere c(x ) is a count of the number of times x appears in X. For example, the string\ni i\n\u201cHello World\u201d has 8 distinct symbols with the probability of \u201cl\u201d being .2727, \u201co\u201d being\n.1818 and the remaining being .0909. Thus the entropy would be\nH(\u2019Hello World\u2019) = 2.845351\n131 4. Loops\nWrite a program that takes a string as command line input (which may contain spaces)\nand computes its entropy.\n132 5. Functions\nIn mathematics, a function is a mapping from a set of inputs to a set of outputs such\nthat each input is mapped to exactly one output. For example, the function\nf(x) = x2\nmaps numeric values to their squares. The input is a variable x. When we assign an\nactual value to x and evaluate the function, then the function has a value, its output. For\nexample, setting x = 2 as input, the output would be 22 = 4. Mathematical functions\ncan have multiple inputs,\nf(x,y) = x2 +y2 f(x,y,z) = 2x+3y \u22124z\nHowever, a function will only ever have a single output value.\nIn programming languages, a function (sometimes called subroutine or procedure) can\ntake multiple inputs and produce one output value. We\u2019ve already seen some examples\nof these functions. For example, most languages provide a math library that you can\nuse to evaluate the square root or sine of a value x. We\u2019ve also seen some functions\nwith multiple input values such as the \u201cpower\u201d function that allows you to compute\nf(x,y) = xy. Finally, the main entry point to many programs is defined by a main\nfunction.\nMore formally, a function is a sequence of instructions (code) that is packaged into a\nunit that can be reused. A function performs a specific task: given a number of inputs,\nit executes some sequence of operations (executes some code) and \u201creturns\u201d (outputs) a\nresult. The output can be captured into a variable or used in an expression by whatever\ncode invoked or \u201ccalled\u201d the function.\nDefining and using functions in programming has numerous advantages. The most\nobvious advantage is that it allows you a way to organize code. By separating a program\nit into distinct units of code it is more organized and it is clearer what each piece or\nsegment of code does. This also facilitates top-down design: one way to approach a\nproblem is to split it up into a series of subproblems until each subproblem is either\ntrivial to deal with, or an existing, \u201coff-the-shelf\u201d solution already exists for it. Functions\nmay serve as the logical unit for each subproblem.\nAnother advantage is that by organizing code into functions, those functions can be reused\nin multiple places either in your program\/project or even in other programs\/projects.\n133 5. Functions\nA prime example of this are the standard libraries available in most programming\nlanguages that provide functions to perform standard input\/output or mathematical\nfunctions. These standard libraries provide functions that are used by thousands of\ndifferent programs across multiple different platforms.\nFunctions also form an isolated unit of code. This allows for better and easier testing.\nBy isolating pieces of code, we can rigorously test those pieces of code by themselves\nwithout worrying about the larger program or contexts.\nFunctions facilitates procedural abstraction. Placing code into functions allows you to\nabstract the details of how the function computes its answer. As an example: consider\na standard math library\u2019s square root function: it may use some interpolation method,\na Taylor series, or some other method entirely to compute the square root of a given\nnumber. However, by putting this functionality into a function, we, as programmers, do\nnot need to concern ourselves about these details. Instead, we simply use the function,\nallowing us to focus on the larger issues at hand in our program.\n5.1. Defining & Using Functions\nLike variables, many programming languages may require that you declare a function\nbefore you can use it. A function declaration may simply include a description of the\nfunction\u2019s input\/output and name. A function declaration may require you to define the\nfunction\u2019s body at the same time or separately. Functions can also have scope: some\nareas of the code may be able to \u201csee\u201d the function or know about it and be able to\ninvoke the function while other areas of the code may not be able to see the function\nand therefore may not be able to invoke it.\nSome interpreted programming languages use function hoisting which allows you to\nuse\/invoke functions before you declare them. This works because the interpreter does\nan initial scan of the code and identifies all function declarations. Only after it has\n\u201choisted\u201d all functions into scope does it start to execute the program. Thus, a function\ndeclaration can appear after it has been used and it will still work.\n5.1.1. Function Signatures\nA function is usually defined by its signature: every function can be identified by its\nname (also called an identifier), its list of input parameters, and its output. A function\nsignature allows the programming language to uniquely identify each function so that\n134 5.1. Defining & Using Functions\nwhen you invoke a function there is no ambiguity in which function you are calling.\nFunction sum(a, b)\n1\nx \u2190 a+b\n2\nreturn x\n3\nend\n4\nAlgorithm 5.1: A function in pseudocode. In this case, the name (identifier) of\nthe function is sum and it has two parameters, a and b. Its body is contained in\nlines 2\u20133. Its return value is indicated by the return statement on line 3.\nA function declaration in pseudocode is presented in Algorithm 5.1. In the pseudocode,\nexplicit variable types are omitted, and thus the return type is inferred from the return\nstatement. In Figure 5.1 we have provided an example of a function declaration in the C\nprogramming language with each element labeled.\nParameters\ndouble getDistance(double x1, double y1, double x2, double y2);\nReturn Identifier\nType (name)\nFigure 5.1.: A function declaration (prototype) in the C programming language with the\nreturn type, identifier, and parameter list labeled.\nSome languages only allow you to use one identifier for one function (like variables) while\nother languages allow you to define multiple functions with the same identifier as long\nas the parameter list is different (see Section 5.3.2 below). In general, like variables,\nfunction names are case sensitive. Also similar to variables, modern lower camel casing\nis used with function names.\nWhen defining the parameters to a function (its input), you usually provide a comma\ndelimited list of variable names. In the case of statically typed languages, the types of\nthe variable parameters are also specified. The order is important as when you invoke\nthe function, the number of inputs must match the number of parameters in the function\ndeclaration. The variable types may also need to match. In some dynamically typed\nlanguages, you may be able to call functions with different types or you may be able to\nomit some of the parameters (see Section 5.3.4 below).\nSimilarly, the return type of the function may need to be specified in statically typed\nlanguages while with dynamic languages, functions may conditionally return different\ntypes. We generally refer to the \u201creturn value\u201d or \u201creturn type\u201d because when a function\n135 5. Functions\nis done executing, it \u201creturns\u201d the control flow back to the line of code that invoked it,\nreturning its computed value.\nYou can also define functions that may not have any inputs or may not have any output.\nSome languages use the keyword void to indicate no return value and such functions are\nknown as \u201cvoid functions.\u201d When a function doesn\u2019t have any input values, its parameter\nlist is usually empty.\nThefunctionsignaturemaybeaccompaniedbythefunctionbody whichcontainstheactual\ncode that specifies what the function does. Typically the function body is demarcated\nwith a code block using opening and closing curly brackets, { ... }. Within the\nfunction you can generally write any valid code including declaring variables. When you\ndeclare a variable inside a function, however, it is local to that function. That is, the\nvariable\u2019s scope is only defined within the function. A local variable cannot be accessed\noutside the function, indeed the local variable does not usually survive when the function\nends its execution and returns control back to line of code that called it. Function\nparameters are essentially locally scoped variables as well and can usually be treated as\nsuch.\n5.1.2. Calling Functions\nWhen a function has been defined and is in scope, you can invoke or \u201ccall\u201d the function\nby coding the function name and providing the input parameters which can be either\nvariables or literals. When provided as inputs, parameters are referred to as arguments\nto the function. The arguments are typically provided as a comma delimited list and\nplaced inside parentheses.\nInvoking a function changes the usual flow of control. When invoked, control flow is\ntransferred over to the function. When the function finishes executing the code in its\nbody, control flow returns to the point in the code that invoked it. It is common for a\nprogram to be written so that a function calls another function and that function calls\nanother. This can form a deep chain of function calls in which the flow of control is\ntransferred multiple times. Upon the completion of each function, control is returned\nback to the function that called it, referred to as the calling function.\nIf a function returns a value it can either be captured in a variable using an assignment\n136 5.2. How Functions Work\noperator or by using it in an expression.\na \u2190 10\n1\nb \u2190 20\n2\nc \u2190 sum(a,b)\n3\nAlgorithm 5.2: Using a function. We invoke a function by indicating its name\n(identifier) and passing it arguments.\n5.1.3. Organizing\nFunctions provide code organization, but functions themselves should also be organized.\nWe\u2019ve seen this with standard libraries. Functions that provide basic input\/output are\nall grouped together into one library. Functions that involve math functions are grouped\ntogether into a separate math library.\nSome languages allow you to define and \u201cimport\u201d individual libraries which organize\nsimilar functions together. Some languages do this by collecting functions into \u201cutility\u201d\nclasses or modules. Only when you import these modules do the functions come into\nscope and can be used in your code. If you do not import these modules, then the\nfunctions are out of scope and cannot be used.\nIn some languages once a function is imported it is part of the global scope and can be\n\u201cseen\u201d by any part of the code. This can cause conflicts: if you import modules from two\ndifferent libraries each with different functions that have the same name or signature,\nthen the two function definitions may be in conflict or it may make your code ambiguous\nas to which function you intend to invoke. This is sometimes referred to as \u201cpolluting the\nnamespace.\u201d There are several techniques that can avoid this situation. Some languages\nallow you to place functions into a namespace to keep functions with the same name in\ndifferent \u201cspaces.\u201d Other languages allow you to place functions into different classes and\nthen invoke them by explicitly specifying which class\u2019s function you want to call. Yet\nother languages don\u2019t have great support for function organization and it is the library\ndesigner\u2019s responsibility to avoid naming conflicts, typically by adding a library-specific\nprefix to every function.\n5.2. How Functions Work\nTo understand how functions work in practice, it is necessary to understand how a\nprogram operates at a lower level. In particular, each program has a program stack (also\ncalled a call stack). A stack is a data structure that holds elements in a Last-In First-Out\n137 5. Functions\n(LIFO) manner. Elements are added to the \u201ctop\u201d of the stack in an operation called\npush and elements can be removed from the top of the stack in an operation called pop.\nIn general, elements cannot be inserted or removed from the middle or \u201cbottom\u201d of the\nstack.\nIn the context of a program, a call stack is used to keep track of the flow of control.\nDepending on the operating system, compiler and architecture, the details of how\nelements are stored in the program stack may vary. In general when a program begins,\nthe operating system loads it into memory at the bottom of the call stack. Global\nvariables (static data) are stored on top of the main program. Each time a function is\ncalled, a new stack frame is created and pushed on top of the stack. This frame contains\nenough space to hold values for the arguments passed to the function, local variables\ndeclared and used by the function, as well as a space for a return value and a return\naddress. The return address is a memory location that the program should return to after\nthe execution of the function. That way, when the function finishes its execution, the\nstack frame can be removed (popped) and the lower stack frame of the calling function\nis preserved. This is a very efficient way to keep track of the flow of control in a program.\nAs each function calls another function, each stack frame is preserved by pushing a new\none on top of the program stack. Each time a function terminates execution and returns,\nthe removal of the stack frame means that all local variables go out of scope. Thus,\nvariables that are local to a function are not accessible outside the function.\nTo illustrate, consider the following snippet of C code. The main() function invokes\nthe average() function which in turn invokes the sum() function. Each invocation\ncreates a new stack frame on top of the last in the program stack which is depicted in\nFigure 5.2.\ndouble sum(double a, double b) {\n1\ndouble x = a + b;\n2\nreturn x;\n3\n}\n4\n5\ndouble average(double a, double b) {\n6\ndouble y = sum(a, b) \/ 2.0;\n7\nreturn y;\n8\n}\n9\n10\nint main(int argc, char **argv) {\n11\ndouble n = 10.0;\n12\ndouble m = 16.0;\n13\ndouble ave = average(n, m);\n14\nprintf(\"average = %f\\n\", ave);\n15\nreturn 0;\n16\n}\n17\n138 5.2. How Functions Work\nUnused stack space\nTop of the stack\n(low memory)\nlocal variables x\nsum() stack frame\nreturn address, value (26.0)\narguments a, b\nlocal variables y\naverage() stack frame\nreturn address, value (13.0)\narguments a, b\nlocal variables n, m, ave\nreturn address, value (0) main() stack frame\narguments argc, argv\nGlobal Variables\nStatic Content\nBottom of the stack\n(high memory) Program Code\nFigure 5.2.: Program Stack. At the bottom we have the program\u2019s code, followed by\nstatic content such as global variables. Each function call has its own stack\nframe along with its own arguments and local variables. In particular, the\nvariable arguments a and b in two different stack frames are completely\ndifferent variables. Upon returning from the sum() function call, the top-\nmost stack frame would be popped and removed, returning to the code\nfor the average() function via the return address. The stack is depicted\nbottom-up with high memory at the bottom and low memory at the top,\nbut this may differ depending on the architecture.\n139 5. Functions\n5.2.1. Call By Value\nWhen a function is invoked, arguments are passed to it. When you invoke a function you\ncan pass it variables as arguments. However, the variables themselves are not passed to\nthe function, but instead the values stored in the variables at the time that you call the\nfunction are passed to the function. This mechanism is known as call by value and the\nvariable values are passed by value to the function.\nRecall that the arguments passed to a function are placed in a new stack frame for that\nfunction. Thus, in reality copies of the values of the variables are passed to the function.\nAny changes to the parameters inside the function have no effect on the original variables\nthat were \u201cpassed\u201d to the function when it was invoked.\nTo illustrate, consider the following C code. We have a function sum that takes two\ninteger parameters a and b which are passed by value. Inside sum, we create another\nvariable x which is the sum of the two passed variables. We then change the value\nof the first variable, a to 10. Elsewhere in the code we call sum on two variables,\nn, m with values 5 and 15 respectively. The invocation of the function sum means\nthat the two values, 5 and 15, stored in the variables are copied into a new stack frame.\nThus, changing the value to the first parameter changes the copy and has no effect on\nthe variable n. At the end of this code snippet n retains its original value of 5. The\nprogram stack frames are depicted in Figure 5.3.\nint sum(int a, int b) {\n1\nint x = a + b;\n2\na = 10;\n3\nreturn x;\n4\n}\n5\n6\n...\n7\n8\nint n = 5;\n9\nint m = 15;\n10\nint k = sum(n, m);\n11\n5.2.2. Call By Reference\nSome languages allow you to pass a parameter to a function by providing its memory\naddress instead of the value stored in it. Since the memory address is being provided\nto the function, the function is able to access the original variable and manipulate the\n140 5.2. How Functions Work\n0x0088 x = 20 0x0088 x = 20\nsum() sum()\n0x0084 b = 15 0x0084 b = 15\nstackframe stackframe\n0x0080 a = 5 0x0080 a = 10\n... ...\n0x0018 k 0x0018 k\ncallingfunction callingfunction\n0x0014 m = 10 0x0014 m = 10\nstackframe stackframe\n0x0010 n = 5 0x0010 n = 5\n(a) Uponinvocationofthe sum() function,anew (b) The change to the variable a in the sum()\nstack frame is created which holds the parameters function changes the parameter variable, but the\nand local variable. The parameter variables a original variable n is unaffected.\nand b are distinct from the original argument\nvariables n and m.\n0x0088 x = 20 0x0088 x = 20\nsum() sum()\n0x0084 b = 15 0x0084 b = 15\nstackframe stackframe\n0x0080 a = 10 0x0080 a = 10\n... ...\n0x0018 k 0x0018 k = 20\ncallingfunction callingfunction\n0x0014 m = 10 0x0014 m = 10\nstackframe stackframe\n0x0010 n = 5 0x0010 n = 5\n(c) When the sum() function finishes execution, (d) Thereturnedvalueisstoredinthevariable k\nits stack frame is removed and the variables a, and the variable n retains its original value.\nb, and x are no longer valid. The return value\n20 is stored in another return value location.\nFigure 5.3.: Demonstration of Pass By Value. Passing variables by value means that\ncopies of the values stored in the variables are provided to the function.\nChanges to parameter variables do not affect the original variables.\n141 5. Functions\ncontents stored at that memory address. In particular, the function is now able to make\nchanges to the original variable. This mechanism is known as call by reference and the\nvariables are passed by reference.\nTo illustrate, consider the following C code. Here, the variable a is passed by reference\n(b is still passed by value, the *a and &n in the following code are dereferencing and\nreferencing operators respectively. For details, see Section 18.2). Below when we invoke\nthe sum() function, we pass not the value stored in n, but the memory address of the\nvariable n. Thus, when we change the value of the variable a in the function, we are\nactually changing the value of n (since we have access to its memory location). At the\nconclusion of this snippet of code, the value stored in n has been changed to 10. The\nprogram stack frames are depicted in Figure 5.4.\nint sum(int *a, int b) {\n1\nint x = *a + b;\n2\n*a = 10;\n3\nreturn x;\n4\n}\n5\n6\n...\n7\n8\nint n = 5;\n9\nint m = 15;\n10\nint k = sum(&n, m);\n11\nWhether or not a variable is passed by value or by reference depends on the language,\ntype of variable, and the syntax used.\n5.3. Other Issues\n5.3.1. Functions as Entities\nIn programming languages, any entity that can be stored in a variable or passed as\nan argument to a function or returned as a value from a function is referred to as a\n\u201cfirst-class citizen.\u201d Numerical values for example are usually first-class citizens as they\ncan be stored in variables and passed to functions.\nFunctional Programming is a programming language paradigm in which functions them-\nselves are first-class citizens. That is, functions can be assigned to variables, functions\n142 5.3. Other Issues\n0x0088 x = 20 0x0088 x = 20\nsum() sum()\n0x0084 b = 15 0x0084 b = 15\nstackframe stackframe\n0x0080 a = 0x0010 0x0080 a = 0x0010\n... ...\n0x0018 k 0x0018 k\ncallingfunction callingfunction\n0x0014 m = 10 0x0014 m = 10\nstackframe stackframe\n0x0010 n = 5 0x0010 n = 10\n(a) Uponinvocationofthe sum() function,anew (b) The change to the variable a in the sum()\nstack frame is created which holds the parameters function actually changes what the variable a\nand local variable. The parameter variable a references. That is, the original variable n.\nholds the memory location of the original variable\nn.\n0x0088 x = 20 0x0088 x = 20\nsum() sum()\n0x0084 b = 15 0x0084 b = 15\nstackframe stackframe\n0x0080 a = 0x0010 0x0080 a = 0x0010\n... ...\n0x0018 k 0x0018 k = 20\ncallingfunction callingfunction\n0x0014 m = 10 0x0014 m = 10\nstackframe stackframe\n0x0010 n = 10 0x0010 n = 10\n(c) When the sum() function finishes execution, (d) Thereturnedvalueisstoredinthevariable k\nits stack frame is removed and the variables a, and the value in the variable n has now changed.\nb, and x are no longer valid. The return value\n20 is stored in another return value location.\nFigure 5.4.: Demonstration of Pass By Reference. Passing variables by reference means\nthat the memory address of the variables are provided to the function. The\nfunction is able to make changes to the original variable because it knows\nwhere it is stored.\n143 5. Functions\ncan be passed to other functions as arguments, and functions can even return functions\nas a result. This is done as a matter of course in functional programming languages\nsuch as Haskell and Clojure, but many programming languages contain some functional\naspects.\nFor example, some languages support the same concept by using function pointers which\nare essentially references to where the function is stored in memory. As a memory\nlocation is essentially a number, it can be passed around in functions and be stored in a\nvariable. Purists would argue that this is not sufficient to call a function a \u201cfirst-class\ncitizen\u201d in such a language. They may argue that a language must be able to create\nnew functions at runtime for it to be considered a language in which functions are \u201ctrue\u201d\nfirst-class citizens.\nIn any case, there are several advantages to being able to pass functions around as\narguments or store them in variables. Passing a function to another function as an\nargument gives you the ability to provide a callback. A callback is simply a function\nthat gets passed to another function as an argument. The idea is that the function that\nreceives the callback will execute or \u201ccall back\u201d the passed function at some point.\nUsing callbacks enables us to program a \u201cgeneric\u201d function that provides some generalized\nfunctionality. Then more specific behavior can be be implemented in the callback function.\nFor example, we could create a generic sort function that sorts elements in a collection.\nWe could make the sort function generic so that it could sort any type of data: numbers,\nstrings, objects, etc. A callback would provide more specific behavior on how to order\nindividual elements in the sorted array.\nAs another example, consider GUI Programming in which we want to design a user\ninterface. In particular, we may be able to create a button element in our interface. We\nneed to be able to specify what happens when the user clicks the button. This could be\nachieved by passing in a function as a callback to \u201cregister\u201d it with the click \u201cevent.\u201d\nA related issue is anonymous functions (also known as lambda expressions). Typically, we\nsimply want to create a function so that we can pass it as a callback to another function.\nWe may have no intention of actually calling this function directly as it may not be of\nmuch use other than passing it as a callback. Some languages allow you to define a\nfunction \u201cinline\u201d without an identifier so that it can be passed to another function. Since\nthe function has no name and cannot be invoked by other sections of the code (other\nthan the function we passed it to), it is known as an anonymous function.\n5.3.2. Function Overloading\nSome languages do not allow you to define more than one function with the same name\nin the same scope. This is to prevent ambiguity in the code. When you write code to\ninvoke a function and there are several functions with that name, which one are you\n144 5.3. Other Issues\nactually calling?\nSome languages do allow you to define multiple functions with the same name as long as\nthey differ in either the number (also called arity) or type of parameters. For example,\nyou could define two absolute value, |x| functions with the same name, but one of them\ntakes a floating point number while the other takes an integer as its parameter. This\nis known as function overloading because you are \u201coverloading\u201d the code by defining\nmultiple functions with the same name.\nThe ambiguity problem is solved by requiring that each function with the same name\ndiffers in their parameters. If you invoke the absolute value function and pass it a floating\npoint number, clearly you meant to call the first version. If you passed it an integer, it is\nclear that you intended to invoke the second version. Depending on the type and number\nof arguments you pass to a function, the compiler or interpreter is able to determine\nwhich version you intend to call and is able to make the right function call. This process\nis known as static dispatch.\nIn a language without function overloading, we would be forced to use different names\nfor functions that perform the same operation but on different types.\n5.3.3. Variable Argument Functions\nMany languages allow you to define special functions that take a variable number of\nparameters. Often they are referred to as \u201cvararg\u201d (short for variable argument) functions.\nThe syntax for doing so varies as does how you can write a function to operate on a\nvariable number of arguments (usually through some array or collection data structure).\nThe standard printf (print formatted) function found in many languages is a good\nexample of a vararg function. The printf function allows you to use one function to\nprint any number of variables or values. Without a vararg function, you would have to\nimplement a printf version for no arguments, 1 argument, 2 arguments, etc. Even\nthen, you would only be able to support up to n arguments for as many functions as\nyou defined. By using a vararg function, we can write a single function that operates\non all of these possibilities. It is import to note, a vararg function is not an example\nof function overloading. There is still only one function defined, it just takes a variable\nnumber of arguments.\n5.3.4. Optional Parameters & Default Values\nSuppose that you define a function which has, say, three parameters. Now suppose you\ninvoke the function but only provide it 2 of the 3 arguments that it expects. Some\nlanguages would not allow this and it would be considered a syntax or runtime error. Yet\n145 5. Functions\nother languages may have very complex rules about what happens when an argument is\nomitted. Some languages allow you to omit some arguments when calling functions as a\nfeature of the language. That is, the parameters to a function are optional.\nWhen a language allows parameters to be optional, it usually also allows you to define\ndefault values to the parameters if the calling function does not provide them. If a\nuser calls the function without specifying a parameter, it takes on the default value.\nAlternatively, the default could be a non-value like \u201cnull\u201d or \u201cundefined.\u201d Inside the\nfunction you could implement logic that determined whether or not a parameter was\npassed to the function and alter the behavior of the function accordingly.\n5.4. Exercises\nExercise 5.1. Recall that the greatest common divisor (gcd) of two positive integers, a\nand b is the largest positive integer that divides both a and b. Adapt the solution from\nExercise 4.6 into a function. If the language you use supports it, return the gcd via a\npass by reference variable.\nExercise 5.2. Write a function that scales an input x to to its scientific notation scale\nso that 1 \u2264 x < 10. If you language supports pass by reference, the amount that x is\nshifted should be stored in a pass-by-reference parameter. For example, a call to this\nfunction with x = 314.15 should return 3.1415 and the amount it is scaled by is n = \u22122.\nExercise 5.3. Write a function that returns the most significant digit of a floating point\nnumber. The function should only return an integer in the range 1\u20139 (it should return\nzero only if x = 0).\nExercise 5.4. Write a function that, given an integer x, sums the values of its digits.\nThat is, for x = 29423 the sum 2+9+4+2+3 = 20.\nExercise 5.5. Write a function to convert radians to degrees using the formula,\n180\u00b7rad\ndeg =\n\u03c0\nWrite another function to covert degrees to radians.\nExercise 5.6. Write functions to compute the diameter, circumference and area of a\ncircle given its radius. If your language supports pass by reference, compute all three of\nthese with one function.\nExercise 5.7. The arithmetic-geometric mean of two numbers x,y, denoted M(x,y) (or\n\u221a\nagm(x,y)) can be computed iteratively as follows. Initially, a = 1(x+y) and g = xy\n1 2 1\n(i.e. the normal arithmetic and geometric means). Then, compute\na = 1(a +g )\nn+1 \u221a2 n n\ng = a g\nn+1 n n\n146 5.4. Exercises\nThe two sequences will converge to the same number which is the arithmetic-geometric\nmean of x,y. Obviously we cannot compute an infinite sequence, so we compute until\n|a \u2212g | < (cid:15) for some small number (cid:15).\nn n\nExercise 5.8. Write a function to compute the annual percentage yield (APY) given an\nannual percentage rate (APR) using the formula\nAPY = eAPR \u22121\nExercise 5.9. Write a function that will compute the air distance between two locations\ngiven their latitudes and longitudes. Use the formula as in Exercise 2.14.\nExercise 5.10. Write a function to convert a color represented in the RGB (red-green-\nblue) color model (used in digital monitors) to a CMYK (cyan-magenta-yellow-key) used\nin printing. RGB values are integers in the range [0,255] while CMYK are fractional\nnumbers in the range [0,1]. To convert to CMYK, you first need to scale each integer\nvalue to the range [0,1] by simply computing\nr g b\nr(cid:48) = , g(cid:48) = , b(cid:48) =\n255 255 255\nand then using the following formulas:\nK = 1\u2212max{r(cid:48),g(cid:48),b(cid:48)}\nC = (1\u2212r(cid:48) \u2212k)\/(1\u2212k)\nM = (1\u2212g(cid:48) \u2212k)\/(1\u2212k)\nY = (1\u2212b(cid:48) \u2212k)\/(1\u2212k)\nExercise 5.11. Write a function to convert from CMYK to RGB using the following\nformulas.\nr = 255\u00b7(1\u2212C)\u00b7(1\u2212K)\ng = 255\u00b7(1\u2212M)\u00b7(1\u2212K)\nb = 255\u00b7(1\u2212Y)\u00b7(1\u2212K)\nExercise 5.12. Write some functions to convert an RGB color to a gray scale, \u201cremoving\u201d\nthe color values. An RGB color value is grayscale if all three components have the same\nvalue. To transform a color value to grayscale, there there are several possible techniques.\nThe average method simply sets all three values to the average:\nr+g +b\n3\nThe lightness method averages the most prominent and least prominent colors:\nmax{r,g,b}+min{r,g,b}\n2\n147 5. Functions\nThe luminosity technique uses a weighted average to account for a human perceptual\npreference toward green:\n0.21r+0.72g +0.07b\nExercise 5.13. Adapt the methods to compute a square root in Exercise 4.21 into\nfunctions.\nExercise 5.14. Adapt the methods to compute the natural logarithm in Exercise 4.22\ninto functions.\nExercise 5.15. Weight (mass in the presence of gravity) can be measured in several\nscales: kilogram force (kgf), pounds (lbs), ounces (oz), or Newtons (N). To convert\nbetween these scales, you can use the following facts:\n\u2022 1 kgf is equal to 2.20462 pounds\n\u2022 There are 16 ounces in a pound\n\u2022 1 kgf is equal to 9.80665 Newtons\nWrite a collection of functions to convert between these scales.\nExercise 5.16. Length can be measured by several different units. We will concern\nourselves with the following scales: kilometer, mile, nautical mile, and furlong. A measure\nin each one of these scales can be converted to another using the following facts.\n\u2022 One mile is equivalent to 1.609347219 kilometers\n\u2022 One nautical mile is equivalent to 1.15078 miles\n\u2022 A furlong is 1-th of a mile\n8\nWrite a collection of functions to convert between these scales.\nExercise 5.17. Temperature can be measured in several scales: Celsius, Kelvin, Fahren-\nheit, and Newton. To convert between these scales, you can use the following conversion\ntable.\nFrom\/To Celsius Kelvin Fahrenheit Newton\nCelsius \u2013 c+273.15 c9 +32 c 33\n5 100\nKelvin k \u2212273.15 \u2013 9k \u2212459.67 .33k \u221290.1395\n5\nFahrenheit (f \u221232)5 5f +255.372 \u2013 11f \u2212 88\n9 9 60 15\nNewton n100 100n+273.15 60n+32 \u2013\n33 33 11\nTable 5.1.: Conversion Chart\nWrite a collection of functions to convert between these scales.\n148 5.4. Exercises\nExercise 5.18. Energy can be measured in several different scales: calories (c), joules\n(J), ergs (erg) and foot-pound force (ft-lbf) among others. To convert between these\nscales, you can use the following facts:\n\u2022 1 erg equals 1.0\u00d710\u22127J\n\u2022 1 ft-lbs equals 1.3558 joules\n\u2022 1 calorie is equal to 4.184 joules\nWrite a collection of functions to convert between these scales.\nExercise 5.19. Pressure is a measure of force applied to the surface of an object per\nunit area. There are several units that can be used to measure pressure:\n\u2022 Pascal (Pa) which is one Newton per square meter\n\u2022 Pound-force Per Square Inch (psi)\n\u2022 Atmosphere (atm) or standard atmospheric pressure\n\u2022 The torr, an absolute scale for pressure\nTo convert between these units, you can use the following formulas.\n\u2022 1 psi is equal to 6,894.75729 Pascals, 1 psi is equal to 0.06804596 atmospheres\n\u2022 1 atmosphere is equal to 101,325 Pascals\n\u2022 1 torr is equal to 1 atmosphere and 101,325 Pascals\n760 760\nWrite a collection of functions to convert between these scales.\n149  6. Error Handling\nWriting perfect code is difficult. The more complex a system or code base, the more\nlikely it is to have bugs. That is, flaws or mistakes in a program that result in incorrect\nbehavior or unintended consequences. The term \u201cbug\u201d has been used in engineering\nfor quite a while. The term was popularized in the context of computer systems by\nGrace Hopper who, when working on the Naval Mark II computer in 1946, tracked a\nmalfunction to a literal bug, a moth, trapped in a relay [2].\nSome of the biggest modern engineering failures can be tracked to simple software bugs.\nFor example, on September 26th, 1983 a newly installed Soviet early warning system\ngave indication that nuclear missiles had been launched on the Soviet Union by the\nUnited States. Stanislav Petrov, a lieutenant colonel in the Soviet Air Defense Forces and\nduty officer at the time, did not trust the new system and did not report the incident to\nsuperiors who may have ordered a counter strike. Petrov was correct as the false alarm\nwas caused by sunlight reflections off of high altitude clouds as well as other bugs in the\nnewly deployed system [28].\nIn September 1999 the Mars Climate Orbiter, a project intended to study the Martian\nclimate and atmosphere was lost after it entered into the upper atmosphere of Mars and\ndisintegrated. The error was due to a subsystem that measured the craft\u2019s momentum\nin a non-standard pound force per second unit when all other systems expected the\nstandard newton second unit [1]. The loss of the project was calculated at over $125\nmillion.\nThere are numerous other examples, some that have caused inconvenience to users (such\nas the Zune bug mentioned in Section 4.5.2) to bugs in medical devices that have cost\ndozens of lives to those resulting in the loss of millions of dollars [6].\nIn some sense, Software Engineering and programming is unique. If you build a bridge\nand forget one bolt its likely not going to cause the bridge to collapse. If you draw\nup plans for a development and the land survey is a few inches off overall, its not a\ncatastrophic problem. However, if you forget one character or are off by one number in a\nprogram, it can cause a complete system failure.\nThere are a variety of reasons for why bugs make it into systems. Bugs could be the result\nof a fundamental misunderstanding of the problem or requirements. Poor management\nand the pressure of time constraints to deliver a project may make developers more\ncareless. A lack of proper testing may mean many more bugs survive the development\n151 6. Error Handling\nprocess than otherwise should have. Even expert programmers can overlook a simple\nmistake when writing thousands of lines of code.\nGiven the potential for error, it is important to have good software development method-\nologies that emphasize testing a system at all levels. Working in teams where regular\ncode reviews are held so that colleagues can examine, critique, and catch potential bugs\nare essential for writing robust code.\nModern coding tools and techniques can also help to improve the robustness of code. For\nexample, debuggers are tools that help a developer debug (that is, find and fix the cause\nof an error) a program. Debuggers allow you to simulate the execution of a program\nstatement-by-statement and view the current state of the program such as variable values.\nYou can \u201cstep through\u201d the execution line by line to find where an error occurs in order\nto localize and identify a bug.\nOther tools allow you to perform static analysis on source code to search for potential\nproblems. That is, problems that are not syntax errors and are not necessarily bugs\nthat are causing problems, but instead are anti-patterns or code smells. Anti-patterns\nare essentially common bad-habits that can be found in code. They are an attempted\nsolution to a commonly encountered problem but which don\u2019t actually solve the problem\nor introduces new problems. Code smells are \u201csymptoms\u201d in a source code that indicate\na possible deeper design or implementation flaw. Failure to adhere to good programming\nprinciples such as properly initializing variables or failure to check for null values are\nexamplesofsmells. Staticanalysistoolsautomaticallyexaminethecodebaseforpotential\nissues like these. For example, a lint (or linter) is a tool that can examine source code\nsuspicious or non-portable code or code that does not comply with generally accepted\nstandards or ways of doing things.\nEven if code contains no bugs, it is still susceptible to errors. For example, a program\ncould connect to a remote database to query and process data. However, if the network\nconnection is temporarily unavailable, the program will not be able to execute properly.\nBecause of the potential of such errors, it is important to write code that is not only bug\nfree but is also robust and resilient. We must anticipate possible error conditions and\nwrite code to detect, prevent, or recover from such errors. Generally, this is referred to\nas error handling.\nMuch of what we now consider Software Engineering was pioneered by people like\nMargaret Hamilton who was the lead Apollo flight software designer at NASA. During\nthe Apollo 11 Moon landing (1969), an error in one system caused the lander\u2019s computer\nto become overworked with data. However, because the system was designed with a\nrobust architecture, it could detect and handle such situations by prioritizing more\nimportant tasks (those related to landing) over lower priority tasks. The resilience that\nwas built into the system is credited with its success [11].\n152 6.1. Error Handling\n6.1. Error Handling\nIn general, errors are potential conditions or situations that can reasonably be anticipated\nby a developer. For example, if we write code to open and process a file, there are several\nthings that could go wrong. The file may not exist, or we may not have permission on\nthe system to read it, or the formatting in the file may be corrupted or not as expected.\nStill yet, everything could be fine with the file, but it may contain erroneous or invalid\nvalues.\nIf an error can be anticipated, we may be able to write code that detects the particular\nerror condition and handles it by executing code that may be able to recover from the\nerror condition. In the case of a missing file for example, we may be able to prompt the\nuser for an alternate file.\nWe may be able to detect but not necessarily recover from certain errors. For example, if\nthe file has been corrupted in example above, there may not be a way to properly \u201cfix\u201d\nit. If it contains invalid data, we may not even want the program to fix it as it may\nindicate a bug or other issue that needs to be addressed. Still yet, there may be some\nerror conditions that we cannot recover from at all as they are completely unexpected.\nIn such instances, we may want the error to result in the termination of the program in\nwhich case the error is considered fatal.\n6.2. Error Handling Strategies\nThere are several general strategies for performing error handling. We\u2019ll look at two\ngeneral methods here: defensive programming and exceptions.\n6.2.1. Defensive Programming\nDefensiveprogrammingisa\u201clookbeforeyouleap\u201dstrategy. Supposewehaveapotentially\n\u201cdangerous\u201dsectionofcode; thatis,alineorblockofcodewhoseexecutioncouldencounter\nor result in an error condition. Before we execute the code, we perform a check to see\nif the error condition is present (usually using a conditional statement). If the error\ncondition does not hold, then we proceed with the code as normal. However, if the error\ncondition does hold, instead of executing the code, we execute alternative code that\nhandles the error.\nSuppose we are about to divide by a number. To prevent a division by zero error, we\ncan check if our denominator is zero or not. If it is, then we raise or handle the error\ninstead of performing the division. What should be done in such a case? We could, as an\nalternative, use a predefined value as a result instead. Or we could notify the user and\n153 6. Error Handling\nask for an alternative. Or we could log the error and proceed as normal. Or we could\ndecide that the error is so egregious that it should be fatal and terminate the execution\nof the program.\nWhich is the right way to handle this error? It really depends on your design requirements\nreally. This raises the question, though: \u201cwho\u201d is responsible for making these decisions?\nSuppose we\u2019re designing a function for a library that is not just for our project but others\nas well (as is the case with the standard library functions). Further, the function we\u2019re\ndesigning could have multiple different error conditions that it checks for. In this scenario\nthere are two entities that could handle the errors: the function itself and the code that\ninvokes the function.\nSuppose that we decide to handle the errors inside the function. As designers of the\nfunction, we\u2019ve made the decision to handle the errors for the user (the code that invokes\nour function). Regardless of how we decide to handle the errors, this design decision has\nessentially taken any decision making ability away from users. This is not very flexible\nfor someone using our code. If they have different design considerations or requirements,\nthey may need or want to handle the errors in a different way than we did.\nNow suppose that we decide not to handle the errors inside our function. Defensive\nprogramming may still be used to prevent the execution of code that results in an error.\nHowever, we now need a way to communicate the error condition to the calling function\nso that it can know what type of error happened and handle it appropriately.\nError Codes\nOne common pattern to communicate errors to a calling function is to use the return\ntype as an error code. Usually this is an integer type. By convention 0 is used to indicate\n\u201cno error\u201d and various other non-zero values are used to indicate various types of errors.\nDepending on the system and standard used, error codes may have a predefined value or\nmay be specific to an application or library.\nOne problem with using the return type to indicate errors is that functions are no longer\nable to use the return type to return an actual computed value. If a language supports\npass by reference, then this is not generally a problem. However, even with such languages\nthere are situations where the return type must be used to return a value. In such cases,\nthe function can still communicate a general error message by returning some flag value\nsuch as null.\nAlternatively, a language may support error codes by using a shared global variable that\ncan be set by a function to indicate an error. The calling function can then examine the\nvariable to see if an error occurred during the invocation of the function.\n154 6.2. Error Handling Strategies\nLimitations\nDefensive programming has its limitations. Let\u2019s return to the example of processing a\nfile. To check for all four of the error conditions we identified, we would need a series of\nchecks similar to the following.\nif file does not exists then\n1\nreturn an error code\n2\nend\n3\nif we do not have permissions then\n4\nreturn an error code\n5\nend\n6\nif the file is corrupted then\n7\nreturn an error code\n8\nend\n9\nif the file contains invalid values then\n10\nreturn an error code\n11\nend\n12\nprocess file data\n13\nA problem arises when an error condition is checked and does not hold. Then, later in\nthe execution, circumstances change and the error condition does hold. However, since\nit was already checked for, the program remains under the assumption that the error\ncondition does not hold. For example, suppose that another process or program deletes\nthe file that we wish to process after its existence has been checked but before we start\nprocessing it. Because of the sequential nature of our program, this type of error checking\nis susceptible to these issues.\n6.2.2. Exceptions\nAn exception is an event or occurrence of an anomalous, erroneous or \u201cexceptional\u201d\ncondition that requires special handling. Exceptions interrupt the normal flow of control\nin a program by handing the flow of control over to exception handlers.\nLanguages usually support exception handling using a try-catch control structure such\nas the following.\ntry {\n\/\/potentially dangerous code here\n155 6. Error Handling\n} catch(Exception e) {\n\/\/exception handling code here\n}\nThe try is used to encapsulate potentially dangerous code, or simply code that would\nfail if an error condition occurs. If an error occurs at some point within the try block,\ncontrol flow is immediately transferred to the catch block. The catch block is where\nyou specify how to handle the exception. If the code in the try block does not result in\nan exception, then control flow will skip over the catch statement and resume normally\nafter.\nIt is important to understand how exceptions interrupt the normal control flow. For\nexample, consider the following pseudocode.\ntry {\nstatement1;\nstatement2;\nstatement3;\n} catch(Exception e) {\n\/\/exception handling code here\n}\nSuppose statement1 executes with no error but that when statement2 executes, it\nresults an exception. Control flow is then transferred to the catch block, skipping\nstatement3 entirely. In general, there may not be a mechanism for your catch block\nto recover and execute statement3. Therefore, it may be necessary to make your\ntry-catch blocks fine-grained, perhaps having only a single statement within the try\nstatement.\nSome languages only support a generic Exception and the type of error may need to be\ncommunicated through other means such as a string error message. Still other languages\nmay support many different types of exceptions and you may be able to provide multiple\ncatch statements to handle each one differently. In such languages, the order in which\nyou place your catch statements may be important. Similar to an if-else-if statement,\nthe first one that matches the exception will be the one that executes. Thus, it is best\npractice to order your catch blocks from the most specific to the most general.\nSome languages also support a third finally control statement as in the following\nexample.\n156 6.3. Exercises\ntry {\n\/\/potentially dangerous code here\n} catch(Exception e) {\n\/\/exception handling code here\n} finally {\n\/\/unconditionally executed code here\n}\nThe try-catch block operates as previously described. However, the finally block\nwill execute regardless of whether or not an exception was raised. If no exception\nwas raised, then the try block will fully execute and the finally block will execute\nimmediately after. If an exception was raised, control flow will be transferred to the\ncatch block. After the catch block has executed, the finally block will execute.\nfinally blocks are generally used to handle resources that need to be \u201ccleaned up\u201d\nwhether or not an exception occurs. For example, opening a connection to a database\nto retrieve and process data. Whether or not an exception occurs during this process\nthe connection will need to be properly closed as it represents a substantial amount of\nresources (a network connection, memory and processing time on both the server and\nclient machines, etc.). Failure to properly close the connection may result in wasted\nresources. By placing the clean up code inside a finally statement, we can be assured\nthat it will execute regardless of an error or exception.\nIn addition to handling exceptions, a language may allow you to \u201cthrow\u201d your own\nexceptions by using the keyword throw. In this way you can also practice defensive\nprogramming. You could write a conditional statement to check for an error condition\nand then throw an appropriate exception.\n6.3. Exercises\nExercise 6.1. Rewrite the function to compute the GCD in Exercise 5.1 to handle\ninvalid inputs.\nExercise 6.2. Rewrite the function to compute statistics of a circle in Exercise 5.6 to\nhandle invalid input (negative radius).\nExercise 6.3. Rewrite the function to compute the annual percentage yield in Exercise\n5.8 to handle invalid input.\nExercise 6.4. Rewrite the function to compute air distance in Exercise 5.9 to handle\ninvalid input (latitude\/longitude values outside the range [\u2212180,180]).\n157 6. Error Handling\nExercise 6.5. Rewrite the function to convert from RGB to CMYK in Exercise 5.10 to\nhandle invalid inputs (values outside the range [0,255]).\nExercise 6.6. Rewrite the function to convert from CMYK to RGB in Exercise 5.11 to\nhandle invalid inputs.\nExercise 6.7. Rewrite the square root functions from Exercise 5.13 to handle invalid\ninputs.\nExercise 6.8. Rewrite the natural logarithm functions from Exercise 5.14 to handle\ninvalid inputs.\nExercise 6.9. Rewrite the weight conversion functions from Exercise 5.15 to handle\ninvalid inputs.\nExercise 6.10. Rewrite the length conversion functions from Exercise 5.16 to handle\ninvalid inputs.\nExercise 6.11. Rewrite the temperature conversion functions from Exercise 5.17 to\nhandle invalid inputs.\nExercise 6.12. Rewrite the energy conversion functions from Exercise 5.18 to handle\ninvalid inputs.\nExercise 6.13. Rewrite the pressure conversion functions from Exercise 5.19 to handle\ninvalid inputs.\n158 7. Arrays, Collections & Dynamic\nMemory\nRarely do we ever deal with a single piece of data in a program. Instead, most data is\nmade up of a collection of similar elements. A program to compute grades would be\ndesigned to operate on an entire roster of students. Scientific data represents a collection\nof many different samples or measurements. A bank maintains and processes many\ndifferent accounts, etc.\nArrays are a way to collect similar pieces of data together in an ordered collection. The\npieces of data stored in an array are referred to as elements and are stored in an ordered\nmanner. That is, there is a \u201cfirst\u201d element, \u201csecond\u201d element, etc. and a \u201clast\u201d element.\nThough the elements are ordered, they are not necessarily sorted in any particular manner.\nInstead, the order is usually determined by the order in which you place elements into\nthe array.\nSome languages only allow you to store the same types of elements in an array. For\nexample, an integer array would only be able to store integers, an array of floating-point\nnumbers would only be able to store floating-point numbers. Other languages allow you\nto create arrays that can hold mixed elements. A mixed array would be able to hold\nelements of any type, so it could hold integers, floating-point numbers, strings, objects,\nor even other arrays.\nSome languages treat arrays as full-fledged object types that not only hold elements, but\nhave methods that can be called to manipulate or transform the contents of the array.\nOther languages treat arrays as a primitive type, simply using arrays as storage data\nstructures.\nLanguages can vary greatly in how they implement and represent arrays of elements, but\nmany have the same basic usage patterns allowing you to create arrays and manipulate\ntheir contents.\n159 7. Arrays, Collections & Dynamic Memory\nindex 0 1 2 3 4 5 6 7 8 9\ncontents 2 3 5 7 11 13 17 19 23 29\nFigure 7.1.: An integer array of size 10. Using zero-indexing, the first element is at index\n0, the last at index 9.\n7.1. Basic Usage\nCreating Arrays\nThough there can be great variation in how a language uses arrays, there are some\ncommonalities. Languages may allow you to create static arrays or dynamically allocated\narrays (see Section 7.2 below for a detailed discussion). Static arrays are generally created\nusing the program stack space while dynamically allocated arrays are stored in the heap.\nIn either case you generally declare an array by specifying its size. In statically typed\nlanguages, you must also declare the array\u2019s type (integer, floating-point, etc.).\nIndexing Arrays\nOnce an array has been created you can use it by assigning values to it or by retrieving\nvalues from it. Because there is more than one element, you must specify which element\nyou are assigning or retrieving. This is generally done through indexing. An index is\nan integer that specifies an element in the array. The index is used in conjunction with\n(usually) square brackets and the array\u2019s identifier. For example, if the array\u2019s identifier\nis arr and the index is an integer value stored in the variable i, we would refer to the\ni-th element using the syntax arr[i]. An example is presented in Figure 7.1.\nFor most programming languages, indices start at zero. This is known as zero-indexing.1\nThus, the first element is at arr[0], the second at arr[1] etc. When an array is\nstored in memory, each element is usually stored one after the other in one contiguous\nspace in memory. Further, each element is of a specific type which is represented using a\nfixed number of bytes in memory. Thus the index actually acts as an offset in memory\nfrom the beginning of the array. For example, if we have an array of integers which each\ntake 4 bytes each, then the 5th element would be stored at index 4, which is an an offset\nequal to 4\u00d74 = 16 bytes away from the beginning of the array. The first element, being\nat index 0 is 4\u00d70 = 0 bytes from the beginning of the array (that is, the first element is\nat the beginning of the array).\nOnce an element has been indexed, it can essentially be treated as a regular variable,\n1Some languages do use 1-indexing but there are very strong arguments in favor of zero-indexing [13].\n160 7.1. Basic Usage\nassigning and retrieving values as you would regular variables. Care must be taken so\nthat you do not make a reference to an element that does not exist. For example, using a\nnegative index or an index i \u2265 n in an array of n elements. Depending on the language,\nindexing an array element that is out-of-bounds may result in undefined behavior, an\nexception being thrown, or a corruption of memory.\nIteration\nSince we can simply index elements in an array, it is natural to iterate over elements\nin an array using a for loop. We can create a for loop using an index variable i which\nstarts at 0, and increments by one on each iteration, accessing the i-th element using the\nsyntax described above, arr[i]. One issue is that such a loop would need to know how\nlarge the array is in order to define a terminating condition.\nn \u2190 size of array arr\n1\nfor (i \u2190 0;i < (n\u22121);i \u2190 (i+1)) do\n2\nprocess element arr[i]\n3\nend\n4\nSome languages build the size of the array into a property that can be accessed. Java,\nfor example, has a arr.length property. Other languages provide functions that you\ncan use to determine their size. Still other languages (such as C), place the burden of\n\u201cbookkeeping\u201d the size of an array on you, the programmer. Whenever you pass an array\nto a function you need to also pass a size parameter that informs the function of how\nmany elements are in the array. Yet other functions may also require you to pass the\nsize of each element in the array.\nSome languages also support a basic foreach loop (cf. Section 4.4). A foreach loop is\nsyntactic sugar that allows you to iterate over the elements in an array (usually in order)\nwithout the need for boilerplate code that creates and increments an index variable.\nforeach element a in arr do\n1\nprocess element a\n2\nend\n3\nThe actual syntax may vary if a language supports such a loop.\n161 7. Arrays, Collections & Dynamic Memory\nUsing Arrays in Functions\nMost programming languages allow you to use arrays as both function parameters and as\nreturn types. You can pass arrays to functions and functions can be defined that return\narrays. Typically, when arrays are passed to functions, they are passed by reference so\nas to avoid making an entirely new copy of the array. As a consequence, if the function\nmakes changes to the array elements, those changes may be realized in the calling function.\nSometimes you may want this behavior. However, sometimes you may not want the\nfunction to make changes to the passed array. Some languages allow you to use various\nkeywords to prevent any changes to the passed array.\nIf a function is designed to return an array, care must be taken to ensure that the correct\ntype of array is returned. Recall that static arrays are allocated on the call stack. It\nwould be inappropriate to return static arrays from a function as the array is part of\nthe stack frame that is destroyed when the function returns control back to the calling\nfunction (we discuss this in detail below). Instead, if a function returns an array, it\nshould be an array that has been dynamically allocated (on the heap).\n7.2. Static & Dynamic Memory\nRecall that arrays can be declared as static arrays, meaning that when you declare them,\nthey are allocated and stored on the program\u2019s call stack within the stack frame in which\nthey are declared. For example, if a function foo() creates a static array of 5 integers,\neach requiring 4 bytes, then 20 contiguous bytes are allocated on the stack frame for\nfoo() to store the static array.\nThis can cause several potential problems. First, the typical stack space allocated for a\nprogram is relatively small. It can be as large as a couple of Megabytes (MBs) or on\nsome older systems or those with limited resources, even on the order of a few hundred\nKilobytes (KBs). When dealing with data of any substantial size, you could quickly run\nout of stack space, resulting in a stack overflow.\nAnother problem arises if we want to return a static array from a function. Recall that\nwhen a function returns control to the calling function, its stack frame is popped off the\ntop and goes out-of-scope (see Section 5.2). Since the array is part of the stack frame of\nthe function, it too goes out of scope. Depending on how the system works, the contents\nof the frame may be completely changed in the \u201cbookkeeping\u201d process of returning from\nthe function. Even if the contents remain unchanged when the function returns, they\nwill almost certainly be overwritten when another function call is made and a new stack\nframe overwrites the old one. For these reasons, static arrays are of very limited use.\nThey must be kept small and cannot be returned from a function.\n162 7.2. Static & Dynamic Memory\nDemonstration in C\nTo make this concept a bit more clear, we\u2019ll use a concrete example in the C programming\nlanguage. Consider the program code in Figure 7.2. Here, we have a function foo()\nthat creates a static integer array of size 5, int b[5];. This memory is allocated on\nthe stack frame and then assigned values. Printing them in the function will give the\nexpected results,\nb[0] = 5\nb[1] = 10\nb[2] = 15\nb[3] = 20\nb[4] = 25\n#include<stdlib.h>\n1\n#include<stdio.h>\n2\n3\nint * foo(int n) {\n4\nint i;\n5\nint b[5];\n6\nfor(i=0; i<5; i++) {\n7\nb[i] = n*i;\n8\nprintf(\"b[%d] = %d\\n\", i, b[i]);\n9\n}\n10\nreturn b;\n11\n}\n12\n13\nint main(int argc, char **argv) {\n14\nint i, m = 5;\n15\nint *a = foo(m);\n16\nfor(i=0; i<5; i++) {\n17\nprintf(\"a[%d] = %d\\n\", i, a[i]);\n18\n}\n19\nreturn 0;\n20\n}\n21\nFigure 7.2.: Example returning a static array\n163 7. Arrays, Collections & Dynamic Memory\nHowever, when the function foo() ends execution and returns control back to the\nmain() function, (sometimes called unwinding), the contents of foo()\u2019s stack frame\nare altered as part of the process. Some of the contents are the same, but elements have\nbeen completely altered. Printing the \u201creturned\u201d contents of the array gives us garbage:\na[0] = 1564158624\na[1] = 32767\na[2] = 15\na[3] = 20\na[4] = -626679356\nThis is not an issue when returning primitive types as the return value is placed in a\nspecial memory location available to the calling function. Even in our example, the\nreturn value is properly communicated to the calling function: its just that the returned\nvalue is a pointer to the array\u2019s location (which happens to be a memory address in the\n\u201cstale\u201d stack frame). The stack frames are depicted in Figure 7.3.\n7.2.1. Dynamic Memory\nThe solution to the problems presented by static arrays is to use dynamically allocated\narrays. Such arrays are not allocated and stored in the program call stack, but instead\nare stored in another area called the heap. In fact, because of the shortcomings of static\narrays, some languages only allow you to use dynamically allocated arrays even if it is\ndone so implicitly.\nRecall that when a program is loaded into memory, its code is placed on the program call\nstack in memory. On top of that is any static data (global variables or data for example).\nSubsequent function calls place new stack frames on top of that. In addition, at the\n\u201cother end\u201d of the program\u2019s memory space, the heap is allocated. The heap is a \u201cpile\u201d of\nmemory like the stack is, but it is less structured. The stack is one contiguous piece of\nmemory, but the heap may have \u201choles\u201d in it as various chunks of it are allocated and\ndeallocated for the program. In general, the heap is larger but allocation and deallocation\nis a more involved and more costly process while the stack is smaller and faster to\nallocate\/deallocate stack frames from.\nInitially, a program is allocated a certain amount of memory for its heap. When a\nprogram attempts to dynamically allocate memory, say for a new array of integers, it\nmakes a request to the operating system for a certain amount of memory (a certain\nnumber of bytes). The system responds by allocating a chunk of the heap memory which\nthe program can then use to store elements in the array. Usually, the memory space is\n164 7.2. Static & Dynamic Memory\nstored as a pointer or reference. The reference is stored in a variable in a stack frame,\nbut the actual contents of the array are stored in the heap space.\nDepending on the language and system, if a program uses all of its heap space and runs\nout, the operating system may terminate the program or it may attempt to reserve even\nmore memory for the program.\nMemory Management\nIf a program no longer needs a dynamically allocated memory space, it should \u201cclean up\u201d\nafter itself by deallocating or \u201cfreeing\u201d the memory, releasing it back to the heap space\nso that it can be reused either by the program or some other program or process on the\nsystem. The process of allocating and deallocating memory is generally referred to as\nmemory management. If a program does not free up memory, it may eventually run out\nand be forced to terminate. Even if it does not necessarily run out of available memory,\nits performance may degrade or it may impact system performance.\nIf a program has poor memory management and fails to deallocate memory when it is\nno longer needed, the memory \u201cleaks\u201d: the available memory gradually runs out because\nit is not released back to the heap for reallocation. Programs which such poor memory\nmanagement are said to have a memory leak. Sometimes this is a consequence of a\ndangling pointer: when a program dynamically allocates a chunk of memory but then\ndue to carelessness, loses the reference to the memory chunk, making it impossible to\nfree up.\nSome languages have automatic garbage collection that handle memory management for\nus. The language itself is able to monitor the dynamically allocated pieces of memory\nand determine if any variable in the program still references it. If the memory is no\nlonger referenced, it is \u201cgarbage\u201d and becomes eligible to be \u201ccollected.\u201d The system\nitself then frees the memory and makes it available to the program or operating system.\nIn such \u201cmemory managed\u201d languages, we are responsible for allocating memory, but are\nnot (necessarily) responsible for deallocating it.\nEven if a language offers automated memory management, it is still possible to have\nmemory leaks and other memory allocation issues. Automated memory management\ndoes not solve all of our memory management problems. Moreover, it comes at a cost.\nThe additional resources and overhead required to monitor memory can have a significant\nperformance cost. However, with modern garbage collection systems and algorithms,\nthe performance gap between garbage collected languages and user-managed memory\nlanguages has been shrinking. In any case, all program memory is reclaimed by the\noperating system when the program terminates.\n165 7. Arrays, Collections & Dynamic Memory\n7.2.2. Shallow vs. Deep Copies\nIn most languages, an array variable is actually a reference to the array in memory.\nWe could create an array referred to by a variable A and then create another reference\nvariable B and set it \u201cequal\u201d to A. However, this is simply a shallow copy. Both the\nreference variables refer to the same data in memory. Consequently, if we change the\nvalue of an element in one, the change is realized in both.\nOften, we want a completely different copy, referred to as a deep copy. With a deep copy,\nA and B would refer to different memory blocks. Changes to one would not affect the\nother. This distinction is illustrated in Figure 7.5.\n7.3. Multidimensional Arrays\nA normal array is usually one dimensional. One can think an array as a single \u201crow\u201d in a\ntable that contains a certain number of entries. Most programming languages allow you\nto define multidimensional arrays. For example, two dimensional arrays would model\nhaving multiple rows in a full table. You can also view two dimensional arrays as matrices\nin mathematics. A matrix is a rectangular array of numbers that have a certain number\nof rows and a certain number of columns.\nAs an example, consider the following 2\u00d73 matrix (it has 2 rows and 3 columns):\n(cid:20) (cid:21)\n1 9 \u22128\n2.5 3 5\nIn mathematics, entries in a matrix are indexed via their row and column. For example,\na would refer to the element in the i-th row and j-th column. Referring to the row\ni,j\nfirst and column second is referred to as row major ordering. If the number of rows and\nthe number of columns are the same, the matrix is referred to as a square matrix. For\nexample, the following is a square, 10\u00d710 matrix.\n\uf8ee \uf8f9\n2 68 9 44 80 79 77 59 27 2\n\uf8ef 3 86 22 42 58 24 45 39 7 47 \uf8fa\n\uf8ef \uf8fa\n\uf8ef 5 7 17 12 29 56 68 14 65 3 \uf8fa\n\uf8ef \uf8fa\n\uf8ef 7 35 64 69 79 56 52 77 82 85 \uf8fa\n\uf8ef \uf8fa\n\uf8ef 11 55 36 5 25 6 22 25 72 37 \uf8fa\n\uf8ef \uf8fa\n\uf8ef 13 20 37 74 3 53 87 70 3 78 \uf8fa\n\uf8ef \uf8fa\n\uf8ef 17 72 68 26 11 6 63 70 29 16 \uf8fa\n\uf8ef \uf8fa\n\uf8ef 19 59 6 26 87 18 82 27 75 19 \uf8fa\n\uf8ef \uf8fa\n\uf8f0 23 73 30 80 51 14 34 67 59 58 \uf8fb\n29 48 2 39 18 21 33 28 40 34\n166 7.4. Other Collections\nWe can do something similar in most programming languages. First, languages may\nvary in how you can create multidimensional arrays, but you usually have to provide a\nsize for each dimension when you create them. Once created, you can index them by\nproviding multiple indices. For example, with a two dimensional array, we could provide\ntwo indices each in their own square brackets arr[i][j] referring to the i-th row and\nj-th column. Multidimensional arrays usually use the same 0-indexing scheme as single\ndimensional arrays.\nYou can further generalize this and create 3-dimensional arrays, 4-dimensional arrays, etc.\nHowever, the use cases for arrays of dimension 3 and certainly for arrays of dimension\n4 or greater are rare. If you need to store such data, it may be more appropriate to\ndefine a custom, user-defined structure or object (see Chapter 10) instead of a higher\ndimensional array.\nWe usually think of 2-dimensional arrays as having the same number of elements in\neach \u201crow\u201d. In the example above, both of the matrix\u2019s rows had 3 elements in it. Some\nlanguages allow you to create 2-dimensional arrays with a different number of elements\nin each row. Special care must be taken to ensure that you do not index an element that\ndoes not exist.\n7.4. Other Collections\nAside from basic arrays, many languages have rich libraries of other dynamic collections.\nDynamic collections are not the same thing as dynamically allocated arrays. Once an\narray is created, its size is fixed and cannot, in general, be changed. However, dynamic\ncollections can grow (and shrink) as needed when you add or remove elements from them.\nLists are ordered collections that are essentially dynamic arrays. Lists are ordered and\nare usually zero-indexed just like arrays. Lists are generally objects and provide methods\nthat can be used to add, remove, and retrieve elements from the list. If you add an\nelement to a list, the list will automatically grow to accommodate it, so its size is not\nfixed when created. Two common implementations of lists are array-based lists and\nlinked lists. Array-based lists indexarray-based list use an array to store elements. When\nthe array fills up, the list allocates a new, larger array to hold more elements, copying the\noriginal contents over to the new array with a larger capacity. Linked lists hold elements\nin nodes that are linked together. Adding a new element simply involves creating a new\nnode and linking it to the last element in the list.\nSome languages also define what are called sets. Sets allow you to store elements\ndynamically just like lists, but sets are generally unordered. There is no concept of a\nfirst, second, or last element in a set. Iterating over the elements in a set could result\nin a different enumeration of the elements each time. Elements in sets are also usually\nunique. For example, a set containing integers would only ever contain one instance of\n167 7. Arrays, Collections & Dynamic Memory\neach integer. The value 10, for example, would only ever appear once. If you added 10\nto a set that already contained it, the operation would have no effect on the set.\nAnother type of dynamic array are associative arrays (sometimes called dictionaries).\nAn associative array holds elements, but may not be restricted in how they are indexed.\nIn particular, a language that supports associative arrays may allow you to use integers\nor strings as indices, or even any arbitrary object. Further, when using integers to index\nelements, indices need not be fully defined nor contiguous. In an associative array you\ncould define an element at index 5 and then place the next element at index 10, skipping\nindex 6 through 9 which would remain undefined.\nOne way to look at associative arrays is as a map. A map is a data structure that\nstores elements as key-value pairs. Both they keys and values could be any arbitrary\ntype (integers or strings) or object depending on the language. You could map account\nnumbers (stored as strings) to account objects, or vice versa. Using a smart data structure\nlike a map can make data manipulation a lot easier and more straightforward.\n7.5. Exercises\nExercise 7.1. Write a function to return the index of the maximum element in an array\nof numbers.\nExercise 7.2. Write a function to return the index of the minimum element in an array\nof numbers.\nExercise 7.3. Write a function to compute the mean (average) of an array of numbers.\nExercise 7.4. Writeafunctiontocomputethestandarddeviationofanarrayofnumbers,\n(cid:118)\n(cid:117) N\n(cid:117) 1 (cid:88)\n\u03c3 = (cid:116) (x \u2212\u00b5)2\ni\nN\ni=1\nwhere \u00b5 is the mean of the array of numbers.\nExercise 7.5. Write a function that takes two arrays of numbers that are sorted and\nmerges them into one array (retuning a new array as a result).\nExercise 7.6. Write a function that takes an integer n and produces a new array of size\nn filled with 1s.\nExercise 7.7. Write a function that takes an array of numbers are computes returns\nthe median element. The median is defined as follows:\n\u2022 If n is odd, the median is the n+1-th largest element\n2\n168 7.5. Exercises\n\u2022 If n is even, the median is the average of the n and the (n +1)-th largest elements\n2 2\nExercise 7.8. The dot product of two arrays (or vectors) of the same dimension is\ndefined as the sum of the product of each of their entries. That is,\nn\n(cid:88)\na \u00d7b\ni i\ni=1\nWrite a function to compute the dot product of two arrays (you may assume that they\nare of the same dimension)\nExercise 7.9. The norm of an n-dimensional vector, (cid:126)x = (x ,x ,...,x ) captures the\n1 2 n\nnotion of \u201cdistance\u201d in a higher dimensional space and is defined as\n(cid:113)\n(cid:107)(cid:126)x(cid:107) = x2 +\u00b7\u00b7\u00b7+x2\n1 n\nWrite a function that takes an array of numbers that represents an n-dimensional vector\nand computes its norm.\nExercise 7.10. Write a function that takes two arrays A,B and creates and returns a\nnew array that is the concatenation of the two. That is, the new array will contain all\nelements a followed by all elements in b.\nExercise 7.11. Write a function that takes an array of numbers A and an element x\nand returns true\/false if A contains x\nExercise 7.12. Write a function that takes an array of numbers A, an element x and\ntwo indices i,j and returns true\/false if A contains x somewhere between index i and j.\nExercise 7.13. Write a function that takes an array of numbers A and an element x\nand returns the multiplicity of x; that is the number of times x appears in A.\nExercise 7.14. Writeafunctiontocomputeasliding window mean. Thatis, itcomputes\nthe average of the first m numbers in the array. The next value is the average of the\nvalues index from 1 to m, then 2 to m+1, etc. The last window is the average of the\nlast m elements. Obviously, m \u2264 n (for m = n, this is the usual mean). Since there is\nmore than one value, your function will return a (new) array of means of size n\u2212m+1.\nExercise 7.15. Write a function to compute the mode of an array of numbers. The\nmode is the most common value that appears in the array. For example, if the array\ncontained the elements 2,9,3,4,2,1,8,9,2, the mode would be 2 as it appears more than\nany other element. The mode may not be unique; multiple elements could appear the\nsame, maximal number of times. Your function should simply return a mode.\nExercise 7.16. Write a function to find all modes of an array. That is, it should find\nall modes in an array and return a new array containing all the mode values.\n169 7. Arrays, Collections & Dynamic Memory\nExercise 7.17. Write a function to filter out certain elements from an array. Specifically,\nthe function will create a new array containing only elements that are greater than or\nequal to a certain threshold \u03b4.\nExercise 7.18. Write a function that takes an array of numbers and creates a new\n\u201cdeep\u201d copy of the array. In addition, the function should take a new \u201csize\u201d parameter\nwhich will be the size of the copy. If the new size is less than the original, then the new\narray will be a truncated copy. If the new size is greater then the copy will be padded\nwith zero values at the end.\nExercise 7.19. Write a function that takes an array A and two indices i,j and returns\na new array that is a subarray of A consisting of elements i through j.\nExercise 7.20. Write a function that takes two arrays A,B and creates and returns a\nnew array that represents the unique intersection of A and B. That is, an array that\ncontains elements that are in both A and B. However, elements should not be included\nmore than once.\nExercise 7.21. Write a function that takes two arrays A,B and creates and returns a\nnew array that represents the unique union of A and B. That is, an array that contains\nelements that are either in A or B (or both). However, elements should not be included\nmore than once.\nExercise 7.22. Write a function that takes an array of numbers and returns the sum of\nits elements.\nExercise 7.23. Write a function that takes an array of numbers and two indices i,j\nand computes the sum of its elements between i and j inclusive.\nExercise 7.24. Write a function that takes two arrays of numbers and determines if\nthey are equal: that is, each index contains the same element.\nExercise 7.25. Write a function that takes two arrays of numbers and determines if\nthey both contain the same elements (though are not necessarily equal) regardless of\ntheir multiplicity. That is, the function should return true even if the arrays\u2019 elements\nappear a different number of times or in a different order. For example [2,2,3] would be\nequal to an array containing [3,2,3,3,3,2,2,2].\nExercise 7.26. A suffix array is a lexicographically sorted array of all suffixes of a string.\nSuffix arrays have many applications in text indexing, data compression algorithms and\nin bioinformatics. Write a program that takes a string and produces its suffix array.\nFor example, the suffixes of science are science, cience, ience, ence, nce, ce,\nand e. The suffix array (sorted) would look something like the following.\n170 7.5. Exercises\nce\ncience\ne\nence\nience\nnce\nscience\nExercise 7.27. An array of size n represents a permutation if it contains all integers\n0,1,2,...,(n\u22121) exactly once. Write a function to determine if an array is a permutation\nor not.\nExercise 7.28. The k-th order statistic of an array is the k-th largest element. For our\npurposes, k starts at 0, thus the minimum element is the 0-th order statistic and the\nlargest element is the n\u22121-th order statistic.\nAnother way to view it is: suppose we were to sort the array, then the k-th order statistic\nwould be the element at index k in the sorted array. Write a function to find the k-th\norder statistic.\nExercise 7.29. Write a function that takes two n\u00d7n square matrices A,B and returns\na new n\u00d7n matrix C which is the product, A\u00d7B. The product of two matrices of\ndimension n\u00d7n is defined as follows:\nn\n(cid:88)\nc = a b\nij ik kj\nk=1\nWhere 1 \u2264 i,j \u2264 n and c is the (i,j)-th entry of the matrix C.\nij\nExercise 7.30. Wecanmultiplyamatrixbyasinglescalarvaluexbysimplymultiplying\neach entry in the matrix by x. Write a function that takes a matrix of numbers and an\nelement x and performs scalar multiplication.\nExercise 7.31. Write a function that takes two matrices and determines if they are\nequal (all of their elements are the same).\nExercise 7.32. Write a function that takes a matrix and an index i and returns a new\narray that contains the elements in the i-th row of the matrix.\nExercise 7.33. Write a function that takes a matrix and an index j and returns a new\narray that contains the elements in the j-th column of the matrix.\nExercise 7.34. Iterated Matrix Multiplication is where you take a square matrix, A\nand multiply it by itself k times,\nAk = A\u00d7A\u00d7\u00b7\u00b7\u00b7\u00d7A\n(cid:124) (cid:123)(cid:122) (cid:125)\nktimes\nWrite a function to compute the k-th power of a matrix A.\n171 7. Arrays, Collections & Dynamic Memory\nExercise 7.35. The transpose of a square matrix is an operation that \u201cflips\u201d the matrix\nalong the diagonal from the upper left to the lower right. In particular the values m\ni,j\nand m are swapped. Write a function to transpose a given matrix\nj,i\nExercise 7.36. Write a function that takes a matrix, a row index i, and a number x\nand adds x to each value in the i-th row.\nExercise 7.37. Write a function that takes a matrix, a row index i, and a number x\nand multiples each value in the i-th row with x.\nExercise 7.38. Write a function that takes a matrix, and two row indices i,j and swaps\neach value in row i with the value in row j\nExercise 7.39. A special matrix that is often used is the identity matrix. The identity\nmatrix is an n\u00d7n matrix with 1s on its diagonal and zeros everywhere else. Write a\nfunction that, given n, creates a new n\u00d7n identity matrix.\nExercise 7.40. Write a function to convert a matrix of integers to floating point numbers.\nExercise 7.41. Write a function to determine if a given matrix is a permutation matrix.\nA permutation matrix is a matrix that represents a permutation of the rows of an identity\nmatrix. That is, A is a permutation matrix if every row and every column has exactly\none 1 and the rest are zeros.\nExercise 7.42. Write a function to determine if a given square matrix is symmetric. A\nmatrix is symmetric if m = m for all i,j.\ni,j j,i\nExercise 7.43. Write a function to compute the trace of a matrix. The trace of a matrix\nis the sum of its elements along its diagonal.\nExercise 7.44. Write a function that returns a \u201cresized\u201d copy of a matrix. The function\ntakes a matrix of size n\u00d7m (not necessarily square) and creates a copy that is p\u00d7q (p,q\nare part of the input to the function). If p < n and\/or q < m, the values are \u201ccut off\u201d. If\np > n and\/or q > m, the matrix is padded (to the right and to the bottom) with zeros.\nExercise 7.45. A submatrix is a matrix formed by selecting certain rows and columns\nfrom a larger matrix. Write a function that constructs a submatrix from a larger matrix.\nTo do so, the function will take a matrix as well as two row indices i,j and two column\nindices k,(cid:96) and it will return a new matrix which consists of entries from the i-th row\nthrough the j-th row and k-th column through the (cid:96)-th column.\nFor example, if A is\n\uf8ee \uf8f9\n8 2 4 1\nA = \uf8f010 4 2 3\uf8fb.\n12 42 1 0\nthen a call to this function with i = 1,j = 2,k = 2,(cid:96) = 3) should result in\n(cid:20) (cid:21)\n2 3\nA = .\n1 0\n172 7.5. Exercises\nExercise7.46. TheKronecker product(http:\/\/en.wikipedia.org\/wiki\/Kronecker_\nproduct) is a matrix operation on two matrices that produces a larger block matrix.\nSpecifically, if A is an m\u00d7n matrix and B is a p\u00d7q matrix, then the Kronecker product\nA\u2297B is the mp\u00d7nq block matrix:\n\uf8ee \uf8f9\na B \u00b7\u00b7\u00b7 a B\n11 1n\nA\u2297B = \uf8ef . . . ... . . . \uf8fa\n\uf8f0 \uf8fb\na B \u00b7\u00b7\u00b7 a B\nm1 mn\nmore explicitly:\n\uf8ee \uf8f9\na b a b \u00b7\u00b7\u00b7 a b \u00b7\u00b7\u00b7 \u00b7\u00b7\u00b7 a b a b \u00b7\u00b7\u00b7 a b\n11 11 11 12 11 1q 1n 11 1n 12 1n 1q\n\uf8efa b a b \u00b7\u00b7\u00b7 a b \u00b7\u00b7\u00b7 \u00b7\u00b7\u00b7 a b a b \u00b7\u00b7\u00b7 a b \uf8fa\n11 21 11 22 11 2q 1n 21 1n 22 1n 2q\n\uf8ef \uf8ef . .\n.\n. .\n.\n... . .\n.\n. .\n.\n. .\n.\n... . .\n.\n\uf8fa \uf8fa\n\uf8ef \uf8fa\n\uf8ef \uf8fa\na b a b \u00b7\u00b7\u00b7 a b \u00b7\u00b7\u00b7 \u00b7\u00b7\u00b7 a b a b \u00b7\u00b7\u00b7 a b\n\uf8ef 11 p1 11 p2 11 pq 1n p1 1n p2 1n pq\uf8fa\n\uf8ef \uf8ef . . . . . . . . . ... . . . . . . . . . \uf8fa \uf8fa\nA\u2297B = \uf8ef \uf8fa.\n\uf8ef\n\uf8ef\n. .\n.\n. .\n.\n. .\n.\n... . .\n.\n. .\n.\n. .\n.\n\uf8fa\n\uf8fa\n\uf8ef \uf8fa\n\uf8efa b a b \u00b7\u00b7\u00b7 a b \u00b7\u00b7\u00b7 \u00b7\u00b7\u00b7 a b a b \u00b7\u00b7\u00b7 a b \uf8fa\n\uf8ef m1 11 m1 12 m1 1q mn 11 mn 12 mn 1q\uf8fa\n\uf8efa b a b \u00b7\u00b7\u00b7 a b \u00b7\u00b7\u00b7 \u00b7\u00b7\u00b7 a b a b \u00b7\u00b7\u00b7 a b \uf8fa\n\uf8ef m1 21 m1 22 m1 2q mn 21 mn 22 mn 2q\uf8fa\n\uf8ef\n\uf8f0\n. .\n.\n. .\n.\n... . .\n.\n. .\n.\n. .\n.\n... . .\n.\n\uf8fa\n\uf8fb\na b a b \u00b7\u00b7\u00b7 a b \u00b7\u00b7\u00b7 \u00b7\u00b7\u00b7 a b a b \u00b7\u00b7\u00b7 a b\nm1 p1 m1 p2 m1 pq mn p1 mn p2 mn pq\nWrite a function that computes the Kronecker product.\nExercise 7.47. The Hadamard product is an entry-wise product of two matrices of\nequal size. Let A,B be two n\u00d7m matrices, then the Hadamard product is defined as\nfollows.\n\uf8eb \uf8f6 \uf8eb \uf8f6 \uf8eb \uf8f6\na a \u00b7\u00b7\u00b7 a b b \u00b7\u00b7\u00b7 b a b a b \u00b7\u00b7\u00b7 a b\n11 12 1m 11 12 1m 11 11 12 12 1m 1m\n\uf8eca a \u00b7\u00b7\u00b7 a \uf8f7 \uf8ecb b \u00b7\u00b7\u00b7 b \uf8f7 \uf8eca b a b \u00b7\u00b7\u00b7 a b \uf8f7\n21 22 2m 21 22 2m 21 21 22 22 2m 2m\nA\u25e6B = \uf8ec \uf8ec . .\n.\n. .\n.\n... . .\n.\n\uf8f7 \uf8f7\u25e6\uf8ec \uf8ec . .\n.\n. .\n.\n... . .\n.\n\uf8f7 \uf8f7 = \uf8ec \uf8ec . .\n.\n. .\n.\n... . .\n.\n\uf8f7 \uf8f7\n\uf8ed \uf8f8 \uf8ed \uf8f8 \uf8ed \uf8f8\na a \u00b7\u00b7\u00b7 a b b \u00b7\u00b7\u00b7 b a b a b \u00b7\u00b7\u00b7 a b\nn1 n2 nm n1 n2 nm n1 n1 n2 n2 nm nm\nWrite a function to compute the Hadamard product of two n\u00d7m matrices.\n173 7. Arrays, Collections & Dynamic Memory\nStack Frame Variable Address Content\n. .\n. .\n. .\nb[4] 0x5c44cb76 25\nb[3] 0x5c44cb72 20\nb[2] 0x5c44cb68 15\nb[1] 0x5c44cb64 10\nb[0] 0x5c44cb60 5\ni 0x5c44cb56 5\nfoo n 0x5c44cb52 5\n. .\n. .\n. .\na 0x5c44cb34 NULL\nm 0x5c44cb30 5\nmain i 0x5c44cb26 0\n(a) Program stack at the end of the execution of foo() prior to\nreturning control back to main().\nStack Frame Variable Address Content\n. .\n. .\n. .\nb[4] 0x5c44cb76 -626679356\nb[3] 0x5c44cb72 20\nb[2] 0x5c44cb68 15\nb[1] 0x5c44cb64 32767\nb[0] 0x5c44cb60 1564158624\ni 0x5c44cb56 5\nfoo n 0x5c44cb52 5\n. .\n. .\n. .\na 0x5c44cb34 0x5c44cb60\nm 0x5c44cb30 5\nmain i 0x5c44cb26 0\n(b) Upon returning, the stack frame is no longer valid; the pointer\nvariable a points to a stack memory address but the frame and\nits local variables are no longer valid. Some have been overwritten\nwith other values. Subsequent usage or access of the values in a are\nundefined behavior.\nFigure 7.3.: Illustration of the pitfalls of returning a static array in C. Static arrays\nare locally scoped and exist only within the function\/block in which they\nare declared. The program stack frame in which the variables are stored\nis invalid when the function returns control back to the calling function.\nDepending on how the system\/compiler\/language handles this unwinding\nprocess, values may be changed, unavailable, etc.\n174 7.5. Exercises\nHeap Growth\nAllocated Heap\nAvailable Heap\nAvailable Stack\nAllocated Stack\nStatic Content\nStack Growth\nProgram Code\nFigure 7.4.: Depiction of Application Memory. The details of how application memory\nis allocated and how the stack\/heap \u201cgrow\u201d may vary depending on the\narchitecture. The figure shows stack memory growing \u201cupward\u201d while heap\nallocation grows \u201cdownward.\u201d Allocation and deallocation may fragment\nthe heap space though.\n175 7. Arrays, Collections & Dynamic Memory\n0 1 2 3 4 5 6 7 8 9\nA 2 3 5 7 11 13 17 19 23 29\nB\n(a) A shallow copy. B refers to A which refers to the array. Thus, B implicitly\nrefers to the same array.\n0 1 2 3 4 5 6 7 8 9\nA 2 3 5 7 11 13 -1 19 23 29\nB\n(b) When an element in a shallow copy is changed, A[6] = -1;, it is changed\nfrom the perspective of both A and B.\n0 1 2 3 4 5 6 7 8 9\nA 2 3 5 7 11 13 17 19 23 29\n0 1 2 3 4 5 6 7 8 9\nB 2 3 5 7 11 13 17 19 23 29\n(c) A deep copy. B refers to its own copy of the array distinct from A. Both are\nstored in separate memory locations.\n0 1 2 3 4 5 6 7 8 9\nA 2 3 5 7 11 13 -1 19 23 29\n0 1 2 3 4 5 6 7 8 9\nB 2 3 5 7 11 13 17 19 23 29\n(d) When an element in a deep copy is changed, A[6] = -1;, it is changed\nonly in the array A. The element in B is unaffected.\nFigure 7.5.: Shallow copies are when two references refer to the same data in memory\n(a) and (b). Changes to one affect the other. Deep copies (c) and (d) are\ndistinct data in memory, changes to one do not affect the other.\n176 8. Strings\nA string is an ordered sequence of characters. We\u2019ve previously seen string data types\nas literals. Most languages allow you to define and use static string literals using the\ndouble quote syntax. We used strings to specify output formatting using printf()-style\nfunctions for example. When reading input from a user, we read it as a string and\nconverted the input to numbers. We also described some basic operations on strings\nincluding concatenation. We now examine strings in more depth.\nProgramming languages vary greatly in how they represent string data types. Some\nlanguages have string types built-in to the language and others require that you use\narrays and yet others treat strings as a special type of object. One issue with string\nrepresentations is determining where and how the string ends. Some languages use a\nlength prefix string representation. The length (the number characters in the string)\nis stored in a special location at the beginning of a string. Then the string characters\nare stored as an array. Other Object-Oriented Programming (OOP) languages use a\nspecial character, the null-terminating character to denote the end of a string. Still\nother languages store strings as arrays or dynamic arrays and the \u201cbookkeeping\u201d is done\ninternally as part of an object representation.\nOther details vary as well. Most languages support the basic ASCII characters, others\nhave full Unicode support or support Unicode through a library. Most languages also\nprovide large libraries of functions and operations that make working with strings easier.\n8.1. Basic Operations\nDepending on how a language supports strings, it may support various basic operations\nto create strings and assign them to variables. Usually languages allow you to create\nand use string literals using the double quote syntax. Modifying a string or copying\none string into another may be supported by the built-in assignment operator or it may\nrequire the use of a copy function. When copying strings, similar issues come into play\nas with arrays. The \u201ccopy\u201d could be a shallow copy or a deep copy (see Section 7.2.2).\nOther basic operations may include accessing and\/or modifying individual characters\nin a string. In order to do so, we may also need to know a string\u2019s length (so that we\ndo not access invalid characters). A language could provide this as part of the string\n177 8. Strings\nitself (usually called a property of the string) or through a function call. We can further\nuse such functionality to iterate over the individual characters in a string using an\nindex-controlled for-loop.\nMore advanced operations on strings include concatenation which is the operation of\ncombining one or more strings to create a new string. Concatenation simply appends one\nstring to the end of another string. Another common operation is to extract a substring\nfrom a string, that is create a new string from a portion of another string. Commonly,\nthis is done via some standard function that may operate by specifying indices and\/or\nthe length of the desired substring. Finally, it is also common to deal with collections\nof strings. Some languages allow you to create arrays of strings or dynamic collections\n(lists or sets) of strings. for languages in which strings are arrays of characters, an array\nof strings might be implemented with a 2-dimensional array of characters.\n8.2. Comparisons\nWhen processing strings there are several other standard operations. In particular, we\noften have need to make comparisons between two string variables or between a string\nvariable and a literal. Some languages allow you to use the same operators such as ==\nor even < to make comparisons between strings. The implied behavior would compare\nstrings for equality (case sensitive) or for lexicographic order. For example \u201cApple\u201d <\n\u201cBanana\u201d might evaluate to true because \u201cApple\u201d precedes \u201cBanana\u201d in alphabetic order.\nMany languages, however, require that you make string comparisons using a function.\nUsing the equality operator == may be correct syntactically, but is usually making a\npointer or reference comparison which evaluates to true if and only if the two variables\nrepresent the same memory address. Even if two string variables have the same content,\nthe equality operator may evaluate to false if they are distinct (deep) copies of the same\nstring. Likewise, the inequality operators <,\u2264, etc. may only be comparing memory\naddresses which is meaningless for comparing strings.\nThe solution that many languages provide is the use of a comparator, which is either a\nfunction or an object that facilitates the comparison of strings (and more generally, any\nobject). Generally, a comparator function takes two arguments, a,b and compares them,\nnot just for equality, but for their relative order: does a \u201ccome before\u201d b or does b \u201ccome\nbefore\u201d a, or are they equal. To distinguish between these three cases, a comparator\nreturns an integer value with the following general contract: it returns\n\u2022 Something negative if a < b\n\u2022 Zero if a = b\n\u2022 Something positive if a > b\n178 8.3. Tokenizing\nUsing this contract we can determine the relative ordering of any two strings. In general\nwe cannot make any assumptions about the actual value that a comparator returns, only\nthat it returns something negative or positive. The actual magnitude of the returned\nvalue need not be \u22121 or +1, and it may not even have any predefined meaning.\n8.3. Tokenizing\nIt is common to store different pieces of data as a string such that each individual piece\nof data is demarcated by some delimiter. For example, Comma Separated Values (CSV)\nor Tab Separated Values (TSV) data use commas and tabs to delimit data. For example,\nthe string\nSmith,Joe,12345678,1985-09-08\nis a CSV string holding data about a particular person (last name, first name, ID, date\nof birth). Often we need to process such strings to extract each individual piece of data.\nProcessing such strings is usually referred to as parsing. In particular, a string is \u201csplit\u201d\ninto a collection of individual strings called tokens (thus the process is also sometimes\nreferred to as tokenizing). In the example above, the string would be processed into\n4 individual strings, Smith, Joe, 12345678, and 1985-09-08. Each string could\nfurther be tokenized if needed, such as parsing the date of birth to extract the year,\nmonth, and date.\nMost languages provide a function to facilitate tokenization. Some do so by directly\nreturning an array or collection of the resulting tokens (usually with the delimiter\nremoved). Others have a more manual process that requires a loop structure to iterate\nover each token.\n8.4. Exercises\nExercise 8.1. Write functions to reverse a string. If appropriate, write versions to do\nso by manipulating a given string and returning a new string that is a reversed copy.\nExercise 8.2. Write a function to replace all spaces in a string with two spaces.\nExercise 8.3. Write a program to take a phrase (International Business Machines) and\n\u201cacronymize\u201d it by producing a string that is an upper-cased string of the first letter of\neach word in the phrase (IBM).\nExercise 8.4. Write a function that takes a string containing a word and returns a\npluralized version according to the following rules.\n179 8. Strings\n1. If the noun ends in \u201cy,\u201d remove the \u201cy\u201d and add \u201cies\u201d\n2. If the noun ends in \u201cs,\u201d \u201cch,\u201d or \u201csh,\u201d add \u201ces\u201d\n3. In all other cases, just add \u201cs\u201d\nExercise 8.5. Write a function that takes a string and determines if it is a palindrome\nor not. A palindrome is a word that is spelled exactly the same when the letters are\nreversed.\nExercise 8.6. Write a function to compute the longest common prefix of two strings.\nFor example, the longest common prefix of \u201cglobal\u201d and \u201cglossary\u201d is \u201cglo\u201d. If two\nstrings have no common prefix, then the longest common prefix is the empty string.\nExercise 8.7. Write a function to remove any whitespace from a given string. For exam-\nple, if the string passed to the function contains \"Hello World How are you? \"\nthen it should result in the string \"HelloWorldHowareyou?\"\nExercise 8.8. Write a function that takes a string and flips the case of each alphabetic\ncharacter in it. For example, if the input string is \"GNU Image Processing Tool-Kit\"\nthen it should output \"gnu iMAGE pROCESSING tOOL-kIT\"\nExercise 8.9. Write a function to validate a variable name according to the rules that it\nmust begin with an alphabetic character, a\u2013z or A\u2013Z but may contain any alphanumeric\ncharacter a\u2013z, A\u2013Z, 0\u20139, or underscores _. Your function should take a string with a\npossible variable name and return true or false depending on whether or not it is valid.\nExercise 8.10. Write a function to convert a string that represents a variable name using\nunder_score_casing to lowerCamelCasing. Thatis, itshouldremoveallunderscores,\nand replace the first letter of each word with an uppercase (except the first word).\nExercise 8.11. Write a function that takes a string and another character c and counts\nthe number of times that c appears in the string.\nExercise 8.12. Write a function that takes a string and another character c and removes\nall instances of c from the string. For example, a call to this function on the string\n\"Hello World\" with c being equal to 'o' would result in the string \"Hell Wrld\".\nExercise 8.13. Write a function that takes a string and two characters, c and d and\nreplaces all instances of c with d.\nExercise 8.14. Write a function to determine if a given string s contains a substring t.\nThe function should return true if t appears anywhere inside s and false otherwise.\nExercise 8.15. Write a function that takes a string s and returns a new string that\ncontains the first character of each word in s capitalized. You may assume that words\nare separated by a single space. For example, if we call this function with the string\n\"International Business Machines\" it should return \"IBM\". If we call it with the\nstring \"Flint Lockwood Diatonic Super Mutating Dynamic Food Replicator\" it\nshould return \"FLDSMDFR\"\n180 8.4. Exercises\nExercise 8.16. Write a function that trims leading and trailing white space from a\nstring. Inner whitespace should not be modified.\nExercise 8.17. Write a function that splits a string containing a unix path\/file into its\nthree components: the directory path, the file base name and the file extension. For\nexample, if the input string is \/usr\/home\/message.txt then the three components\nwouldbe \/usr\/home\/, message and txt respectively. Forthepurposesofthisfunction,\nyou may assume that the path ends with the last forward slash (or is empty if none) and\nthat the extension is always after the last period. That is, you should be able to handle\ninputs such as ..\/foo\/bar\/baz.old.txt.\nExercise 8.18. Write a function that (re)formats a string representing a telephone\nnumber. Phone numbers can be written using a variety of formats, for example\n1-402-555-1234 or +4025551234 or 402 555-1234, etc. Assume that you will only\ndeal with 10 digit US phone numbers. Create a new string that uses the \u201cstandard\u201d\nformat of (402) 555-1234.\nExercise 8.19. Write a function that takes a string and splits it up to an array of\nstrings. The split will be length-based: the function will also take an integer n and will\nsplit the given string up into strings of length n. It is possible that the last string will\nnot be of length n.\nFor example, if we pass \"Hello World, how are you?\" with n = 3 then it should\nreturn an array of size 9 containing the strings \"Hel\", \"lo \", \"Wor\", \"ld,\", \" ho\",\n\"w a\", \"re \", \"you\", \"?\"\nExercise 8.20. HyperText Markup Language (HTML) (Hypertext Markup Language)\nis the primary document description language for the World Wide Web (WWW). Certain\ncharacters are not rendered in browsers as they are special characters used in HTML; in\nparticular tags which begin and end with the < and >.\nTo display such characters correctly they need to be escaped (similar to how you need\nto escape tabs \\t and endline \\n characters). Properly escaping these characters\nis not only important for proper rendering, but there are also security issues involved\n(Cross-Site Scripting Attacks).\nWrite a function that takes a string and escapes the HTML characters in Table 8.1.\nReplace the following with this\n& &amp;\n< &lt;\n> &gt;\n\" &quot;\nTable 8.1.: Replacement HTML Characters\n181  9. File Input\/Output\nA file is a block of data used for storing information. Normally, we think of a file as\nsomething that is stored on a hard drive (or memory stick or other physical media),\nbut the concept of a file is much more general. For example, when a file is loaded\n(\u201cread\u201d) by a program it then exists in main memory. An executable program itself is a\nfile (containing instructions to be executed), both stored on the hard drive and run in\nmemory.\nIn a typical unix-based system, everything is a file. Directories are files, executables are\nfiles, devices are files, etc. Even the familiar standard input and standard output are\nbuffers that are treated as files that can be read from or written to.\nData files may be stored as binary data or as plaintext files. Plaintext files are still stored\nas binary data, but are stored in an encoding using the ASCII text values. Binary files\nwill also have structure, but it depends on the application that produced the file to give\nmeaning to the data. For example, an image file in a Joint Photographic Experts Group\n(JPEG) format is essentially just binary data but it has a very specific format that an\nimage viewer would be able to process, but, say, a text editor would not. Further, if the\nbinary format is corrupted, the image viewer might not be able to display the image\ncorrectly\nTypical programs are short lived, anywhere from a few milliseconds to maybe a user\n\u201csession.\u201d We often want data to be saved across multiple runs of a program. We need\nto save it or persist it in some durable storage medium (disk). Files provide a way to\nachieve data persistence.\n9.1. Processing Files\nIn general, processing data in a file involves three basic steps:\n1. Open (or create) the file\n2. Read from (or write to) the file\n3. Close the file\n183 9. File Input\/Output\nDepending on the language, the act of opening a file may determine if it will be read\nfrom or written to. When read from, the file is referred to as an input file while a file\nthat is written to is an output file. Languages may also have different a different API or\nfunctions to read\/write or append to a file.\nA file may be read line by line until the end of the end of the file has been reached.\nLanguages usually support this by using a special End Of File (EOF) flag or value to\nindicate the end of a file has been reached.\nA file is a resource just like memory and we need to properly manage it. We need to\nmake sure that we close a file once we are finished processing it. Depending on the\nlanguage and other factors such as the operating system, failure to close a file may result\nin corrupted data. Though a file may be closed automatically for us when the program\nterminates, its still best practice to properly close it.\n9.1.1. Paths\nWhen opening a file on a file system, it is necessary to specify which file you want to open.\nThis is typically done by specifying at least the name of the file. Often files will have\n\u201cextensions\u201d which indicate the type of file it is such as .txt for text files or .html for\nHTML files. However, file extensions are only for organizational purposes and have no\nreal bearing on what data is stored in the file.\nMore important is the path of the file. Usually, if no path is specified, then implicitly\nwe are opening the file in the Current Working Directory (CWD). For example, if we\nopen the file data.txt then we are opening the file in the same directory in which our\nprogram is executing. When specifying a path we can either specify an absolute path\nor a relative path. An absolute path specifies each and every subdirectory in the file\nsystem from the root to the directory that the file is located in. The root directory is the\ntop-most directory in the file system. Each subdirectory is separated by some delimiter.\nWindows systems use a backslash as a directory delimiter while the root directory is\nspecified using a \u201cvolume\u201d name such as C:\\. For example, an absolute path on a\nWindows system may look something like:\nC:\\applications\\users\\data\\data.txt\nOn a Unix-based system, a forward slash is used as a directory delimiter and the root\ndirectory is simply a single forward slash. The same directory structure in a Unix-based\nsystem would look like the following.\n\/applications\/users\/data\/data.txt\nA path may also be relative to the current working directory. In most systems (Windows\nand Unix-based) the current directory is denoted using a single period, .. You can use\n184 9.1. Processing Files\nthis to specify directories deeper in the directory tree from the current directory. For\nexample (in Unix),\n.\/app\/data\/data.txt\nwould refer to the directory app in the current working directory, the directory data\nwithin that, and finally the file data.txt within that directory.\nWe can also refer to files further up the directory tree using the \u201cparent\u201d directory symbol\nwhich is two periods, ... For example,\n..\/..\/system\/data.txt\nwould refer to a file two levels up in the subdirectory system.\n9.1.2. Error Handling\nWhen dealing with files there are many potential error conditions that may be anticipated\nand may need to be dealt with. Some types of errors that can occur include the following.\n\u2022 Permission errors \u2013 Your program may not have the proper permissions to read or\nwrite to a particular directory or file. For example, user-level processes typically\ndo not have permissions to read system-level files (such as password files) nor can\nthey write to them lest they corrupt critical system data.\n\u2022 File Not Found errors \u2013 Your program may attempt to open a file that does not\nexist. Sometimes, particularly when writing, the file will be created if it does not\nexist. However, for reading, this may be a serious error.\n\u2022 I\/O Errors \u2013 We may be able to successfully find and open a file, but while\nprocessing it something might go wrong with the file system that results in a\ngeneral input\/output error.\n\u2022 Formattingerrors\u2013Aspreviouslymentioned, theformatofafileishighlydependent\non the application that created it (though there are universal data formats such as\nXML or JavaScript Object Notation (JSON)). If the format is not as expected the\nfile may be corrupted and the program may not be able to successfully read data\nfrom it.\nDepending on the language, these errors may be fatal or may result in error codes or\nerror values that can be dealt with. Or they may result in exceptions that can be caught\nand handled.\n185 9. File Input\/Output\n\/proc\/self\/\n|-- attr\n|-- cwd -> \/proc\n|-- fd\n| `-- 3 -> \/proc\/15589\/fd\n|-- fdinfo\n|-- net\n| |-- dev_snmp6\n| |-- netfilter\n| |-- rpc\n| | |-- auth.rpcsec.context\n| | |-- auth.rpcsec.init\n| | |-- auth.unix.gid\n| | |-- auth.unix.ip\n| | |-- nfs4.idtoname\n| | |-- nfs4.nametoid\n| | |-- nfsd.export\n| | `-- nfsd.fh\n| `-- stat\n|-- root -> \/\n`-- task\n`-- 15589\n|-- attr\n|-- cwd -> \/proc\n|-- fd\n| `-- 3 -> \/proc\/15589\/task\/15589\/fd\n|-- fdinfo\n`-- root -> \/\nFigure 9.1.: The Linux file system (like most file systems), defines a tree directory\nstructure. Each file and directory is contained in subdirectories all contained\nwithin the root directory, \/. This diagram was generated by the Tree\ncommand, http:\/\/mama.indstate.edu\/users\/ice\/tree\/.\n186 9.1. Processing Files\n9.1.3. Buffered and Unbuffered\nWhen processing files the input\/output may be either buffered or unbuffered. A buffered\ninput or output \u201cstream\u201d is one in which data that is read\/written is actually stored in\nmemory in a \u201cbuffer\u201d until such a time as the buffer is \u201cflushed\u201d and the accumulated\ndata is passed to\/from the actual file.\nFor example, in a buffered output file, our program could write several kilobytes of data\nto the output file, but it might not actually be written to the file right away. Instead,\nthose kilobytes of data are stored in memory until the buffer fills up or some other event\ntakes place to cause the buffer to be flushed. At that point, the data stored in the buffer\nis emptied and written to the file.\nBuffered input\/output is used because I\/O operations are expensive in terms of system\nresources and can slow the system down. Because of this, it is better to keep I\/O\noperations as infrequent as possible. Buffers help to reduce the number of I\/O operations\nperformed by a program by making them less frequent.\nThere are some instances in which we want unbuffered I\/O. When error messages are\nwritten to the standard error output for example, we would prefer to know about errors\nas soon as possible rather than waiting for error messages to accumulate in a buffer.\nUsing an unbuffered output means that data is written to the standard error (which is a\nfile) immediately. However, because errors are (hopefully) infrequent and (likely) fatal,\nthis is not a performance issue.\n9.1.4. Binary vs Text Files\nAs previously mentioned, files can be stored as pure binary data or as plaintext (ASCII).\nDepending on our application and the nature of the data being written to files, the choice\nof which to use may be clear. If we want the data in our files to be human-readable, then\nwe need to store them as plaintext. However, in general, we should prefer storing data in\na binary format. The reason for this is that binary generally requires less space and is\nmore efficient to process.\nConsider as an example, storing a collection of integers in a file. Each integer requires 4\nbytes when represented in binary. However, when represented as a string, it requires as\nmany bytes as there are digits in the number. For example, the maximum representable\nvalue of such an integer would be 231\u22121 = 2,147,483,647, requiring 10 ASCII characters\nand thus 10 bytes to represent, two and a half times as much memory as with the binary\nrepresentation. Further, if a lot of numbers are stored, each number (as a string) would\nneed to be delimited by yet another character. With a binary representation, no delimiter\nwould be necessary as we would know that each 4 byte block represents a single number.\nThis disparity can be even more stark with other types such as floating-point numbers.\n187 9. File Input\/Output\nThere are additional performance issues when reading\/writing the data and converting\nbinary numbers to their string representations. With binary data no such parsing is\nnecessary. As long as the data does not need to be human-readable, binary formats\nshould be preferred.\n9.2. Exercises\nExercise 9.1. Write a function that takes a string representing a file name and opens\nand processes the file, returning all of its contents as a single string.\nExercise 9.2. Consider an irregular, 2-D simple polygon with n points,\n(x ,y ),(x ,y ),...,(x ,y )\n1 1 2 2 n n\nThe area A of the polygon can be computed as\nn\u22121\n1 (cid:88)\nA = (x y \u2212x y )\ni i+1 i+1 i\n2\ni=0\nNote, that the initial and end point will be the same, (x ,y ) = (x ,y ). An example\n0 0 n n\npolygon for n = 5 can be found in Figure 9.2.\nFigure 9.2.: An example polygon for n = 5\nWrite a program to open and process a text file containing n coordinates. In particular,\nthe first line is a single integer n that indicates how many points should be read in. Each\nline after that has the x,y coordinates of each point separated by a single space.\n4\n1.0 0.0\n13.2 1.25\n20.5 18.4\n16.37 24.54\n188 9.2. Exercises\nAfter reading the file in, it will compute the area of the polygon according to the formula\nabove and output it to the user. For example, the output for the above file may be\nsomething like Area of the polygon: 197.9135\nExercise 9.3. Write a program that processes an input text file and scrubs it of any\nHTML characters that need to be escaped (see Exercise 8.20 for details). It should\nproduce a new output file with all special characters escaped.\nExercise 9.4. Write a program that spell checks a plain text file. The program will\nopen a text file and process each word separately, checking for proper spelling against a\nstandard dictionary.\nYou may assume that each word is separated by some whitespace (you may assume that\nthere are no multi-line hyphenated words). However, you should ignore all punctuation\n(periods, question marks, etc.).\nUse a standard American dictionary provided on your unix system which stores words\none per line. Your output should include all misspelled or unrecognized words (words\nnot contained in the dictionary file).\nExercise 9.5. A standard word search consists of an n\u00d7n grid in which there are a\nnumber of words hidden, some intersecting, with dummy letters filling in the blanks. An\nexample is provided in Figure 9.3.\nFigure 9.3.: A Word Search\nWrite a program to solve a word search. Your program will read in an input file with\nthe following format: the first line will contain a single integer n which is followed by n\nlines with n characters (not including the end line character) corresponding to the word\nsearch.\nOnce you read in the word search, you will iterate through all possible words running\ndown, right, or diagonally down-right. You will attempt to match each possibility against\na standard English dictionary. If the word matches a word in the dictionary, output it to\nthe standard output, otherwise ignore it. To simplify, you may restrict your attention to\nwords that have a length between 3 and 8 (inclusive).\n189 9. File Input\/Output\nExercise 9.6. Write a crossword puzzle cheater. The program will take, as input, a\n\u201cpartial\u201d word in a crossword puzzle. That is, some of the letters are known (from other\nsolved clues) while some of the letters are not known. For the purposes of this exercise,\nwe\u2019ll use a hyphen as a placeholder for missing letters.\nYour program will match the partial word against words in a standard English dictionary\nand list all possible matches. For example, if the user provided foo- as input it might\nmatch food, fool, and foot.\nExercise 9.7. Bridge is a four player (2 team) game played with a standard 52-card\ndeck. Prior to play, a round of bidding is performed to determine which team is playing\nfor or against the contract, the trump suit, and at what level. Understanding the rules of\nthe game or the bidding conventions involved are not necessary for this exercise. Instead,\nwrite a program to assist players in how they should bid based on the following point\nsystem.\nA standard 52-card deck is dealt evenly to 4 different hands (Players 1 thru 4, 13 cards\neach). Each player\u2019s hand is worth a number of points based on the following rules:\n\u2022 Each Ace in the hand is worth 4 points\n\u2022 Each King is worth 3\n\u2022 Each Queen is worth 2\n\u2022 Each Jack is worth 1\n\u2022 For each suit (Diamond, Spade, Club, Heart) such that the hand has only 2 cards\n(a \u201cdoubleton\u201d) an additional point is added\n\u2022 For each suit that the hand has only 1 card in (a \u201csingleton\u201d) two additional points\nare added\n\u2022 For each suit that the hand has no cards (a \u201cvoid\u201d) 3 additional points are added.\nWrite a program that reads in a text file containing a deal. The formatting is as\nfollows: the input file will have 4 lines, one for each player. Each line contains the cards\ndealt to that player delimited by a single space. The cards are indicated by the rank\n(A,K,Q,J,10,9,...,2) and the suit (D, S, C, H). An example:\n3C 3D 7S QD KC AS 6S AC JS 4S JD 7H 6D\n5D 8C 7D AH 3H QC 8D JH 5H 9D 7C 9C 4D\n2H 10D 8H KS QH 4C 10S 9S 6H 8S KD AD QS\n2D 10C 6C 2C 10H 4H 2S 3S 5C 9H KH JC 5S\n190 9.2. Exercises\nYour program should process the file and output the total number of points each hand\nrepresents. You should not make any assumptions about the ordering of the input.\nHand 1 Points: 17\nHand 2 Points: 10\nHand 3 Points: 16\nHand 4 Points: 6\nExercise 9.8. The game of Sudoku is played on a 9\u00d79 grid in which entries consist of\nthe numbers 1 thru 9. Initially, the board is presented with some values filled in and\nothers blank. The player has to fill in the remaining values until all grid boxes are filled\nand the following constraints are satisfied.\n\u2022 In each of the 9 rows, each number, 1\u20139 must appear exactly once\n\u2022 In each of the 9 columns, each number 1\u20139 must appear exactly once\n\u2022 In each of the 3\u00d73 sub-grids, each number 1\u20139 must appear exactly once\nA full example is presented in Figure 9.4.\nFigure 9.4.: A solved Sudoku puzzle\nWrite a program that processes a text file containing a possible sudoku solution and\ndetermine if it is a valid or invalid solution. The file will have the following format: it\nwill contain 9 lines with 9 numbers on each line delimited by a single space. If the input\nrepresents a valid solution, output \u201dValid Solution\u201d, otherwise output at least one reason\nwhy the input is not a valid solution.\nExercise 9.9. Write a program that parses and processes a data file containing Comma\nSeparated Values (CSV) and produce an equivalent JSON (JavaScript Object Notation)\noutput file containing the same data.\n191 9. File Input\/Output\nThe input file will have the following format. The first line is a CSV list of column names.\nEach subsequent line is an individual record with values for each column. The number\nof columns and rows may vary from file to file. The following is an example containing\ndata about students, which has four columns and 3 records.\nlastName,firstName,NUID,GPA\nCastro,Starlin,11223344,3.48\nRizzo,Anthony,55667788,3.95\nBryant,Chris,01234567,2.7\nThe output file will be formatted in JSON where each \u201cobject\u201d (record) is denoted with\nopening and closing curly brackets, each record is separated by a comma, and all records\nare enclosed in square brackets (putting them in an array). For each record, each value is\ndenoted with a key (the column name) and a value. For this exercise, treat all values as\nstrings even if they are numbers. For example, the input file above would be formatted\nas follows.\n[\n1\n{\n2\n\"lastName\": \"Castro\",\n3\n\"firstName\": \"Starlin\",\n4\n\"NUID\": \"11223344\",\n5\n\"GPA\": \"3.48\"\n6\n},\n7\n{\n8\n\"lastName\": \"Rizzo\",\n9\n\"firstName\": \"Anthony\",\n10\n\"NUID\": \"55667788\",\n11\n\"GPA\": \"3.95\"\n12\n},\n13\n{\n14\n\"lastName\": \"Bryant\",\n15\n\"firstName\": \"Chris\",\n16\n\"NUID\": \"01234567\",\n17\n\"GPA\": \"2.7\"\n18\n}\n19\n]\n20\nExercise 9.10. Ranked voting elections are elections where each voter ranks each\ncandidate rather than just voting for a single candidate. If there are n candidates, then\n192 9.2. Exercises\neach voter will rank them 1 (best) through n (worst). Usually, the winner of such an\nelection is determined by a Condorcet method (the candidate that would win in by a\nmajority in all head-to-head contests). However, we\u2019ll use an alternative method, a Borda\ncount.\nIn a Borda count, points are awarded to each candidate for each ballot. For every number\n1 ranking, a candidate receives n points, for every 2 ranking, a candidate gets n \u2212 1\npoints, and so on. For a rank of n, the candidate only receives 1 point. The candidates\nare then ordered by their total points and the one with the highest point count wins\nthe election. Such a system usually leads to a \u201cconsensus\u201d candidate rather than one\npreferred by a majority.\nImplement a Borda-count based ranked voting program. Your program will read in a file\nin the following format. The first line will contain an ordered list of candidates delimited\nby commas. Each line after that will represent a single ballot\u2019s ranking of the candidates\nand will contain comma delimited integers 1 through n. The order of the rankings will\ncorrespond to the order of the candidates on the first line.\nYour program will take an input file name as a command line argument, open the file\nand process it. It will then report the results including the point total for each candidate\n(in order) as well as the overall winner. It will also report the total number of ballots.\nYou may assume each ballot is valid and all rankings are provided.\nAn example input:\nAlice,Bob,Charlie,Deb\n2,1,4,3\n3,4,2,1\n4,2,3,1\n3,2,1,4\n3,1,4,2\nAn example output:\nElection Results\nNumber of ballots: 5\nCandidate Points\nBob 15\nDeb 14\nCharlie 11\nAlice 10\n193 9. File Input\/Output\nWinner is Bob\nExercise 9.11. A DNA sequence is a sequence of some combination of the characters\nA (adenine), C (cytosine), G (guanine), and T (thymine) which correspond to the\nfour nucleobases that make up DNA. Given a long DNA sequence, its often useful to\ncompute the frequency of n-grams. An n-gram is a DNA subsequence of length n. Since\nthere are four bases, there are 4n possible n-grams.\nWrite a program that processes a DNA sequence from a plaintext file and, given n,\ncomputes the relative frequency of each n-gram as it appears in the sequence. As an\nexample, consider the sequence in Figure 9.5.\nGGAAGTAGCAGGCCGCATGCTTGGAGGTAAAGTTCATGGTTCCCTGGCCC\nFigure 9.5.: A DNA Sequence\nTo compute the frequency of all n = 2 n-grams, we would consider all 16 combinations\nof length-two DNA sequences. We would then go through the sequence and count up the\nnumber of times each 2-gram appears. We then compute the relative frequency (note:\nif a sequence is length L, then the total number of n-grams in it is L\u2212(n\u22121)). The\nrelative frequency of each such 2-gram is calculated below.\nAA 6.1224%\nAC 0.0000%\nAG 10.2041%\nAT 4.0816%\nCA 6.1224%\nCC 10.2041%\nCG 2.0408%\nCT 4.0816%\nGA 4.0816%\nGC 10.2041%\nGG 12.2449%\nGT 8.1633%\nTA 4.0816%\nTC 4.0816%\nTG 8.1633%\nTT 6.1224%\nExercise 9.12. Given a long DNA sequence, it is often useful to compute the number\nof instances of a certain subsequence. As an example, if we were to search for the\n194 9.2. Exercises\nsubsequence GTA in the DNA sequence in Figure 9.5, it appears twice. As another\nexample, in the sequence CCCC, the subsequence CC appears three times.\nWrite a program that processes a text file containing a DNA sequence and, given a\nsubequence s, searches the DNA sequence and counts the number of times s appears.\nExercise 9.13. Protein sequencing in an organism consists of a two step process. First\nthe DNA is translated into RNA by replacing each thymine (T) nucleotide with uracil\n(U). Then, the RNA sequence is translated into a protein according to the following rules.\nThe RNA sequence is processed 3 bases at a time. Each trigram is translated into a single\namino acid according to known encoding rules. There are 20 such amino acids, each\nrepresented by a single letter in (A,C,D,E,F,G,H,I,K,L,M,N,P,Q,R,S,T,V,W,Y).\nThe rules for translating trigrams are presented in Figure 9.6. Each triple defines a\nprotein, but we\u2019re only interested in the first letter of each protein. Moreover, the\ntrigrams UAA, UAG, and UGA are special markers that indicate a (premature) end to\nthe protein sequencing (there may be additional nucleotides left in the RNA sequence,\nbut they are ignored and the translation ends).\nFigure 9.6.: Codon Table for RNA to Protein Translation\nAs an example, suppose we start with the DNA sequence AAATTCCGCGTACCC;\nit would be encoded into RNA as AAAUUCCGCGUACCC; and into an amino acid\nsequence KFRVP.\nWrite a program that processes a file containing a DNA sequence and outputs the\ntranslated proteins (only the first letter of each protein) to an output file.\n195 9. File Input\/Output\nExercise 9.14. Recently, researchers have successfully inserted two new artificial nucle-\nases into simple bacteria that successfully reproduced the artificial bases through several\ngenerations. The artificial bases d5SICS and dNaM, (X and Y for short) mimic the\nnatural G, and C nucleobases respectively.\nWrite a program that takes a normal DNA sequence and replace some of its G,C pairs\nwith X,Y respectively. DNA is translated into RNA which is then translated into 20\ndifferent amino acids. Each amino acid produced depends on a 3 nucleobase codon. For\nthis exercise, we will change G,C pairs with X,Y pairs but only in codons that represent\nthe amino acids Threonine (an essential amino acid) and Alanine (a non-essential amino\nacid). Table 9.1 contains the codons corresponding to these amino acids and the codons\nyou should translate each one to. All other codons should not be modified.\nYour program should open and process a DNA sequence contained in a file and modify\nthe DNA sequence as described above and output the artificial DNA sequence to a new\noutput file.\nAmino Acid Codon Artificial Codon\nACT AYT\nACC AYY\nThreonine\nACA AYA\nACG AYX\nGCT XYT\nGCC XYY\nAlanine\nGCA XYA\nGCG XYX\nTable 9.1.: Amino Acid Codons\n196 10. Encapsulation & Objects\nOne reason we prefer to write programs in high-level programming languages is that we\ncan use syntax that is closer to plain English. Though programming language syntax\nis a far cry from \u201cnatural\u201d language, it is far closer than lower level languages such as\nassembly or binary machine code. However, from what we\u2019ve seen so far, when writing\nprograms we are still forced to utilize the primitive variable types built-in to the language\nwe\u2019re using, which is still quite limiting.\nAs a motivating example, suppose we were to write a program that involved organizing\nthe enrollment of students into courses. To model a particular student, we would need\na collection of variables, say a first name, last name, GPA, and a unique identification\nnumber (likely a lot more, but let\u2019s keep it simple). Each of these pieces of data could\nbe modeled by strings, a floating-point number and perhaps an integer.1 Each of these\npieces of data are stored in separate, unrelated variables even though they represent a\nsingle entity.\nEven worse, suppose that we needed to keep track of a collection of students. Each piece\nof data would need to be stored in a separate array. If we wanted to rearrange the data\n(say, sort it), we would need to do a lot of manual bookkeeping to make sure that the\nseparate pieces of data that represented a single entity were all aligned at the same index\nin each of the arrays. If we wanted to pass the data around to functions, we\u2019d be forced\nto pass multiple arrays to each function. This becomes all the more complex when we\nattempt to model entities with more pieces of data.\nThe solution is to encapsulate the pieces of data into one logical entity, sometimes referred\nto as an object. More formally, encapsulation is a mechanism by which pieces of data can\nbe grouped together along with the functions that operate on that data. Encapsulation\nmay also provides a means to protect that data by controlling the visibility of that data\nfrom code outside the object.\nContrast this with an array which is also a collection of data. However, an array usually\ncontains pieces of similar data (all elements are integers or all elements are floating\npoint numbers) while an object may collect pieces of dissimilar data that make up a\nlarger entity. It is like the difference between rows and columns in a table. Consider the\nstudent data in Table 10.1. Each row represents a record while each column represents a\n1Depending on the identification number, it may be more appropriately modeled with a string. Social\nSecurityNumbersforexamplearenotpurelynumeric; theyincludedashesandmaybeginwithzeros.\n197 10. Encapsulation & Objects\nFirst Name Last Name ID GPA\nTom Baker 74 3.75\nChristopher Eccleston 5 3.5\nDavid Tennant 10 4.0\nMatt Smith 29 3.2\nPeter Capaldi 13 2.9\nTable 10.1.: Student Data\ncollection of data from each record. A single column is comparable to an array while\neach row is comparable to an object. In this example, each object has four pieces of data\nencapsulated in it, a first name, last name, an ID, and a GPA.\nTo represent this data in code without objects we would need at least 4 separate arrays,\nmore if we wanted to model more data for a student. Moreover, data in separate\narrays or collections have no real logical relationship to each other. The solution that\nmost programming languages provide is allowing you to define an object or structure\nthat collects pieces of data into one logical unit, allowing you to name the object (say\n\u201cStudent\u201d) so that you can deal with the data in a more abstract way. With objects, we\ncan treat each row in the table as a single, distinct entity allowing us to collect Student\nobjects into a single array or collection rather than many separate ones.\n10.1. Objects\nThough languages differ in how they support objects, they all have some commonalities.\nA language needs to provide ways to define objects, create instances of objects, and to\nuse them in code.\n10.1.1. Defining\nMost object oriented programming languages such as C++ and Java are class-based\nlanguages. Meaning that they allow you to define objects by declaring and defining a\n\u201cclass.\u201d A class is essentially a blueprint for what the object is and how it is defined.\nGenerally, aclassdeclarationallowsyoutospecifymembervariablesandmembermethods\nwhich are part of the class. Further, full encapsulation is achieved by using visibility\nkeywords such as public or private to either allow or restrict access to variables and\nmethods from code outside the object.\nNon-object-oriented languages may not support full encapsulation. Instead they may\nallow you to define structures which support the grouping of data, but make it difficult\n198 10.1. Objects\nor impossible to achieve the other two aspects of encapsulation (the grouping of methods\nthat act on that data and the protection of data).\nIn either case, a language allows you to define the member variables and to name the\nclass or structure so that instances can be referred to by that type. Built-in types such\nas numbers or strings already have a type name defined by the language. However, an\nobject is a user-defined type that is not built-in to the language. Once defined, however,\nthe class or structure can be referred to just like any built-in variable type.\nIt is not unusual to create objects that are made of other objects. For example, a student\nobject may be defined by using two strings for its first and last name. In the language,\na string may also be an object. As a more complex example, suppose that we wanted\nan additional member variable to model a student\u2019s date of birth. A date may itself\nbe an object as it consists of several pieces of information (a year, month, and date\nat least). When an object \u201cowns\u201d an instance of another object it is referred to as\ncomposition as the object is composed of other objects. Further, an object may consist of\na collection of other objects (suppose that a student object owned an array of course\nobjects representing their schedule). This is a form of composition known as aggregation\n(multiple objects have been aggregated by the object).\n10.1.2. Creating\nOnce a blueprint for an object (or structure) has been declared and defined, we need a\nway to create instances of the object. The concept of an \u201cobject\u201d is general and abstract.\nIt is more like the idea of a student. Only once we have created an entity that exists in\nmemory do we have an actual instance of the class. Creating instances of an object is\nusually referred to as instantiation.\nLanguages may be able to automatically create instances of your object with default\nvalues. After all, your object is likely composed of built-in types. The student example\nabove for example could be modeled with two strings, an integer, and a floating point\nnumber. The language\/compiler\/interpreter \u201cknows\u201d how to deal with these built-in\ntypes, so it can extend that knowledge to create instances of your object which are\nessentially just collections of types that it already knows how to deal with.\nObject-oriented languages usually provide a special method for you to be able to specify\nthedetailsofhowtocreateaninstance. Thesearecalledconstructor methods. Sometimes\nyou can define multiple constructors methods that take different number(s) of arguments\nand\/or have different behavior. Constructor methods typically have special syntax or\nhave the same name as the class.\nIn other languages that do not fully support object-oriented programming, you must\ndefine utility functions that can be used to create instances of your object. Sometimes\nthese are referred to as factory functions as they are responsible for \u201cmanufacturing\u201d\n199 10. Encapsulation & Objects\ninstances of your object.\n10.1.3. Using Objects\nAfter defining and creating an object, you can usually use it like any regular variable. In\na strongly typed language you would declare a variable whose type matches the declared\nclass or structure. The variable type can usually be passed and returned from functions,\nassigned to other variables, etc.\nA language also provides ways to access the member variables or methods that are visible\nto the outside world. Languages usually allow you to do this through the \u201cdot operator\u201d\nor the \u201carrow operator.\u201d Suppose we have an instance of a student object stored in\na variable s. To access the first name of this instance, we may be able to use either\ns.firstName or s->firstName. We can access and invoke visible methods likewise.\nThe dot\/arrow operators are how code outside the object interacts with the object.\nOutside code is able to do this because it holds a reference, s to the object. However,\ninside the object, we may not have a reference (the variable s was ostensibly declared\nand used outside the object and so is not in scope inside the object). However, we\nstill have need to reference member variables or methods from inside the object. Many\nlanguages use open recursion , a mechanism by which we can write code so that an\ninstance is able to refer to itself. Languages use keywords such as this or self or\nsomething similar. The keyword is essentially a self-reference to the object itself so that\nyou can refer to \u201cthis\u201d object from within the object.\n10.2. Design Principles & Best Practices\nUsing objects in your code follows more of a bottom-up design rather than a top-down\ndesign approach. In a top-down design, a program is designed by breaking a program\nor problem down into smaller and smaller components. Bottom-up design approaches a\nproblem differently. First, real-world entities involved with the problem are modeled by\ndefining objects. Then objects are used as building blocks that can be combined and\nmade to interact to solve a problem.\nObject design is usually a straightforward process. Typically an object is modeling a\nreal-world entity, so it is simple enough to decompose the entity into its constituent\ncomponents. We do this until the component can either be modeled by a built-in type\nsuch as a string or number or by an existing object. In general, you want to keep things\nas simple as possible. Any time you need to associate pieces of data together into one\nlogical unit, it is appropriate to encapsulate them into an object.\nA good design principle is to utilize composition as much as possible. If you have multiple\n200 10.3. Exercises\npieces of data that define a logical entity or unit, it is good design to create another\nobject. For example, suppose a student object needs to model a mailing address; think\nabout what an address is: it is a street address, city, state, zip, etc. Rather than having\nthese as member fields to your object, it is probably more appropriate to define an\n\u201caddress\u201d object, especially if such an object would be useful elsewhere in a program.\n10.3. Exercises\nExercise 10.1. A complex number consists of two real numbers: a real component a\n\u221a\nand an imaginary component bi where b is a real number and i = \u22121. Define an object\nor structure to model a complex number. Write functions to:\n\u2022 Create a complex number\n\u2022 Print a complex number\n\u2022 Perform basic arithmetic operations on two complex numbers including addition,\nsubtraction and multiplication as defined by:\nc +c = (a +b i)+(a +b i) = (a +a )+(b +b )i\n1 2 1 1 2 1 1 2 1 2\nc \u2212c = (a +b i)\u2212(a +b i) = (a \u2212a )+(b \u2212b )i\n1 2 1 1 2 1 1 2 1 2\nc \u00b7c = (a +b i)\u00b7(a +b i) = (a a \u2212b b )+(a b +b a )i\n1 2 1 1 2 1 1 1 1 2 1 2 1 1\nExercise 10.2. Design an object (or structure) that models an album. Include at least\nthe album title, artist (or band) and release year. Include any other data that you think\nis relevant and write functions to support your object.\nExercise 10.3. Design an object (or structure) that models a bank savings account.\nInclude at least the balance, APR, an account \u201cnumber\u201d and customer information\n(which may be another object or structure). Include any other data that you think is\nrelevant and write functions to support your object.\nExercise 10.4. Design an object (or structure) that models a sports stadium. Include at\nleast the stadium name, the team that plays there, its city, state, and year built. Include\nboth latitude and longitude data. Include any other data that you think is relevant and\nwrite functions to support your object. Write a parser to process a flat file data of all\nstadiums (in your chosen sport) and build instances of all of them.\nExercise 10.5. Design an object (or structure) that models a network-connected elec-\ntronic device. Include at least a unique ID, a human-readable name for the device, a\nMedia Access Control (MAC) address and Internet Protocol (IP) address as well as the\ndevice\u2019s bandwidth in megabits per second. Include any other data that you think is\nrelevant and write functions to support your object.\n201 10. Encapsulation & Objects\nExercise 10.6. Design an object (or structure) that models an airport. Include at least\nthe name, FAA designation, its city, state, and latitude\/longitude data. Include any\nother data that you think is relevant and write functions to support your object.\n202 11. Recursion\nSuppose we wanted to write a simple program that performed a countdown, printing 10,\n9, 8, ..., 2, 1 and when it reached zero it printed a \u201cHappy New Year\u201d message. Likely\nour first instinct would be to write a very simple for loop using an increment variable.\nBut suppose we lived in a world without the usual loop control structures that we are\nnow familiar with. How might we write such a program?\nAfter thinking about it for a while, we might think: well, we don\u2019t have loops, but we\nstill have functions. In particular what if we had a function that took the \u201ccurrent\u201d value\nof our counter variable and decremented it, passing it to another function, which did the\nsame thing. For example, we could pass 10 to such a function, which would then subtract\n1, passing 9 to another function and so on. A check could be made to see if the value was\nzero, in which case we print our special message and no longer call any more functions.\nIn fact, we would not need to define 10 different functions to do so. Instead, we could\ndefine one function that called itself. It might look something like Algorithm 11.1.\nInput :An integer n \u2265 0\nOutput:A countdown of integers n,...0\nif n = 0 then\n1\noutput \u201cHappy New Year!!!\u201d\n2\nelse\n3\noutput n\n4\nCountDown(n\u22121)\n5\nend\n6\nAlgorithm 11.1: Recursive CountDown(n) Function\nThe function in this case is called CountDown(). In Line 5 the function calls itself on\na decremented value. When a function calls itself, it is a recursive function. When a\nlanguage allows functions to call themselves they support recursion.\nThis is not that odd of a concept. We\u2019ve seen many examples where functions invoke (call)\nother functions. Each function call simply creates a new stack frame on the program\nstack. There is nothing particularly special about which functions call which other\nfunctions, so there is little difference when a function calls itself.\n203 11. Recursion\nThis was not just a toy example. There are many programming languages in which\nrecursion is used as a matter of course. Functional programming languages tend to avoid\ncontrol structures like loops and even (mutable) variables. Instead, control flow is defined\nby evaluating a series of functions, making recursion a fundamental technique.\nRecursion is extensively used in mathematics. Recurrence relations or recursive functions\nare common. The Fibonacci sequence is a common, if not overused1 example. It has a\nsimple definition: the next value in the sequence is simply the sum of the two previous\nvalues. The sequence starts with the initial values of 1. The first few terms in the\nsequence:\n1,1,2,3,5,8,13,21,34,55,89,...\nThe more formal mathematical definition can be stated as follows.\n\uf8f1\n1 if n = 0\n\uf8f2\nF = 1 if n = 1\nn\n\uf8f3 F +F otherwise\nn\u22121 n\u22122\nThe Fibonacci sequence is the cliche example for recursion. We can define an algorithmic\nfunction to compute the n-th Fibonacci number as follows.\nInput :An integer n \u2265 0\nOutput:The n-th Fibonacci number, F\nn\nif n \u2264 1 then\n1\noutput 1\n2\nelse\n3\noutput Fibonacci(n\u22121)+Fibonacci(n\u22122)\n4\nend\n5\nAlgorithm 11.2: Recursive Fibonacci(n) Function\nThough hackneyed, it does provide a good example for how recursive functions work.\nWe\u2019ll also utilize it as an example of why you should avoid recursion in practice. We use\nit to illustrate how the problems with recursion can be mitigated or avoided altogether.\n11.1. Writing Recursive Functions\nWhen writing a recursive function, there are several key elements that we need to take\ncare of to ensure that it executes correctly. In particular, every recursive function requires\n1The Fibonacci sequence is nothing special; its simply a second order linear homogenous recurrence\nrelation with coefficients of 1. The near reverence that so many people attribute to it borders on\nmysticism.\n204 11.1. Writing Recursive Functions\nat least one base case or base condition which serves as a terminating condition for the\nrecursion. A base case is a condition which, instead of making a recursive call, processes\nand returns a value. Without a base case, the recursion would continue unbounded: the\nfunction would call itself over and over again, creating new stack frame after stack frame\nuntil we run out of stack space. If a program makes too many function calls and runs\nout of stack memory, it may lead to a stack overflow and the termination of the program.\nEven if we don\u2019t have unbounded recursion, it is still possible to run out of stack space\neven with simple recursion.\nThe other key element that we need is to ensure that every recursive call makes progress\ntoward one of the terminating conditions. If no progress is made, then again we may have\nan unbounded recursion. In the Fibonacci example in Algorithm 11.2, the base case can\nbe found in the first if-statement: when n reaches 1 or less, no recursive calls are made.\nIn the else-statement, we make two recursive calls, but both of them make progress\ntoward this base case. The first decrements n by 1 and the second by 2, eventually\nreaching n = 1.\n11.1.1. Tail Recursion\nMaking many function calls can be costly in terms of stack space. One optimization\nthat can be made is to use tail recursion. The last operation that a function executes\nis referred to as the tail operation. If a function invokes another function as its tail\noperation, its a tail call. For example, consider the following snippet of code:\nint foo(int x) {\n1\n...\n2\nreturn bar(x-1) + 1;\n3\n}\n4\nHere, foo() calls bar() but it is not the last operation before it returns. Instead, it\ninvokes bar(), takes the result and adds one then returns to the calling function. Note\nthat decrementing x is performed before the invocation of bar(). In contrast, consider\nthe following modified code:\nint foo(int x) {\n1\n...\n2\nreturn bar(x-1);\n3\n}\n4\n205 11. Recursion\nHere, the invocation of bar() is the last operation performed by foo(). Thus, this is\na tail call.\nTail calls have the advantage that a language or compiler can generally optimize the\nfunction call with respect to the stack frame. Since the function foo() is essentially\ndone with its computation, its stack frame is no longer needed. The system, therefore, can\nreuse the stack frame. Tail recursion is such an important optimization, some languages\nrequire it or \u201cguarantee\u201d it in other ways.\n11.2. Avoiding Recursion\nRecursion is not essential; some languages do not even support recursion. In fact,\nany recursive function can be rewritten to not use recursion. Usually, you can write\nan equivalent loop structure or use an in-memory stack data structure to replace the\nrecursion. So why use it? Proponents would argue that recursion allows you to write\nsimplecodethatmorecloselymatchesmathematicalfunctionsandexpressions. Recursion\nis also a natural way to think about certain problem solving techniques such as divide-\nand-conquer (see Chapter 12). It is also a natural way to code in functional programming\nlanguages.\nThese arguments, however, are subjective. One person\u2019s \u201ccleaner\u201d or \u201cmore understand-\nable\u201d code is another person\u2019s spaghetti code hack. What is \u201cnatural\u201d for one person may\nbe \u201cweird\u201d and \u201codd\u201d for another. However, there are many other arguments against\nrecursion, many of which are objective reasons: that recursion is more expensive and can\neasily lead to inefficient, exponential algorithms.\nIn general, recursion requires lots of function calls which requires creating and removing\nlots of stack frames. This usually results in a lot of overhead and resources being used\nto perform the computation. Unless you are using a language in which recursion is\noptimized and made to be more efficient (such as functional programming languages),\nthis is a lot more expensive than using simple loops and iteration.\nAnotherreasontoavoidrecursionisthatitcanleadtoalotofextraneousre-computations.\nThe cliched example of the Fibonacci recursion is a prime example of this.2 Consider\nthe computation of Fibonacci(5). This results in two recursive calls, each of those calls\nresults in 2 recursive calls and so on as depicted in Figure 11.1.\nAs depicted in the figure, several function calls are repeated: Fibonacci(3) is called\ntwice, Fibonacci(2) is called 3 times, etc. 15 total function calls are made to compute\n2Its overuse as an example of recursion is even less explicable as it solves a problem that no one cares\nabout.\n206 11.2. Avoiding Recursion\nFibonacci(5)\nFibonacci(4) Fibonacci(3)\nFibonacci(3) Fibonacci(2) Fibonacci(2) Fibonacci(1)\nFibonacci(2) Fibonacci(1) Fibonacci(1) Fibonacci(0) Fibonacci(1) Fibonacci(0)\nFibonacci(1) Fibonacci(0)\nFigure 11.1.: Recursive Fibonacci Computation Tree\nFibonacci(5). Ingeneral, thecomputationofFibonacci(n)willresultinanexponential\nnumber of function calls. The number of function calls to compute F with this recursive\nn\nsolution will be equal to\nn\u22121\n(cid:88)\nF + F\nn\u22122 i\ni=0\nThat is more than the first n\u22121 Fibonacci numbers combined! It should come as no\nsurprise that the Fibonacci sequence grows exponentially and thus so would the number\nof operations with this recursive solution.\nTo put this in perspective, consider computing F = 1,836,311,903 (n = 45), the\n45\nmaximum representable value for a 32-bit signed two\u2019s complement integer. Executing\na C implementation of this recursive algorithm took about 8 seconds3 and required\n3,672,623,805 function calls!\nWhat if we wanted to compute F = 573,147,844,013,817,084,101 (573 quintillion)\n100\nit would result in 1,146,295,688,027,634,168,201 (1.146 sextillion) function calls. Using\nthe same hardware, at 4.59\u00d7108 (459 million) function calls per second, it would take\n2.497\u00d71012 seconds to compute. That would be more than 79,191 years! Even if we\nperformed these (useless) calculations on hardware that was 1 million times faster than\nmy laptop, it would still take over 4 weeks!\n3On a 2.7GHz Intel Core i7.\n207 11. Recursion\n11.2.1. Memoization\nThe inefficiency in the example above comes from the fact that we make the same function\ncalls on the same values over and over. One way to avoid recomputing the same values is\nto store them into a table (or tableau if you prefer being fancy). Then, when you need\nto compute a value, you look at the table to see if it has already been computed. If\nit has, we reuse the value stored in the table, otherwise we compute it by making the\nappropriate recursive calls. Once computed, we place the value into the table so that it\ncan be looked up on subsequent function calls. This approach is usually referred to as\nmemoization.\nThe \u201ctable\u201d in this scenario is very general: it can be achieved using a number of different\ndata structures including simple arrays, or even maps (mapping input value(s) to output\nvalues). The table is essentially serving as a cache for the previously computed values. An\nillustration of how this might work can be found in Algorithm 11.3. Here, the recursion\nonly occurs if the value F is not yet defined.\nn\nInput :An integer n \u2265 0, a global map M that maps n values to F\nn\nOutput:The n-th Fibonacci number, F\nn\nif F is defined in M then\n1 n\noutput M(n)\n2\nelse\n3\na \u2190 Fibonacci(n\u22121)\n4\nb \u2190 Fibonacci(n\u22122)\n5\nDefine M(n) = a+b\n6\noutput (a+b)\n7\nend\n8\nAlgorithm 11.3: Recursive Fibonacci(n) Function With Memoization\nIn many functional programming languages, memoization is implicit and provided by\nthe language itself to ensure that we do not have the same problems with recomputing\nvalues as we observed above. In languages such as C and Java, memoization becomes\nour responsibility and is not an optimization provided by the language itself.\nHowever, if we are filling in a table of values anyway, we really don\u2019t need to make\nrecursive calls at all. We simply need to figure out in what order to fill out the values\nin the table. This is actually the basis of a powerful programming technique known\nas dynamic programming which is a \u201cbottom-up\u201d approach to solving problems by\ncombining solutions to smaller ones.\n208 11.3. Exercises\n11.3. Exercises\nExercise 11.1. The binomial coefficients, C(n,k) or\n(cid:0)n(cid:1)\n(\u201cn choose k\u201d), are defined as\nk\nthe number of ways you can select k distinct items from a collection of n items. A direct\ncombinatorial definition is\n(cid:18) (cid:19)\nn n!\n=\nk k!(n\u2212k)!\nAn alternative is Pascal\u2019s identity, which gives a recurrence to compute this value:\n(cid:18) (cid:19) (cid:18) (cid:19) (cid:18) (cid:19)\nn n\u22121 n\u22121\n= +\nk k k \u22121\nWhere\n(cid:0)n(cid:1)\n= 1 for any n and for all k > n,\n(cid:0)n(cid:1)\n= 0. Finally,\n(cid:0)n(cid:1)\n= n.\n0 k 1\n1. Write a recursive function using Pascal\u2019s identity to compute\n(cid:0)n(cid:1)\n. Benchmark its\nk\nperformance.\n2. Write a recursive version that uses memoization to avoid recomputing values\n3. Modify your functions to utilize an arbitrary precision numeric type so that you\ncan compute arbitrarily large values.\nExercise 11.2. The Jacobsthal sequence is very similar to the Fibonacci sequence in\nthat it is defined by its two previous terms. The difference is that the second term is\nmultiplied by two.\n\uf8f1\n0 if n = 0\n\uf8f2\nJ = 1 if n = 1\nn\n\uf8f3 J +2J otherwise\nn\u22121 n\u22122\n1. Write a recursive function that computes the n-th Jacobsthal number. Benchmark\nits performance.\n2. Write a recursive version that uses memoization to avoid recomputing values\n3. Modify your functions to utilize an arbitrary precision numeric type so that you\ncan compute arbitrarily large values.\n209  12. Searching & Sorting\nSearching and sorting are two fundamental operations when dealing with collections of\ndata. Both operations are not only important in and of themselves, but they also form\nthe basis of many algorithms and other more complex operations. These operations are\nso essential that a wide variety of algorithms and techniques have been developed to\nsolve them, each with their own advantages and disadvantages. This variety provides a\ngood framework from which to study the relative efficiency and complexity of algorithms\nthrough algorithm analysis.\n12.1. Searching\nSearching is a very basic operation. Given a collection of data, we wish to find a particular\nelement or elements that match a certain criteria. More formally, we have the following.\nProblem 1 (Searching).\nGiven: a collection of elements, A = {a ,a ,...,a } and a key element e\n1 2 n k\nOutput: The element a in A such that a = e\ni i k\nThe \u201cequality\u201d in this problem statement is not explicitly specified. In fact, this is a\nvery general, abstract statement of the basic search problem. We didn\u2019t specify that the\n\u201ccollection\u201d was an array, a list, a set, or any other particular data structure. Nor did we\nspecify what type of elements were in the collection. They could be numbers, they could\nbe strings, they could be objects.\nThere are many variations of this general search problem that we could consider. For\nexample, we could generalize it to find the \u201cfirst\u201d or \u201clast\u201d such element if our collection is\nordered. We could find all elements that match our criteria. Some basic operations that\nwe\u2019ve already considered such as finding the minimum or maximum (extremal elements),\nor median element are also variations on this search problem.\nWhen designing a solution to any of these variations additional considerations must be\nmade. We may wish our search to be index-based (that is, output the index i rather\nthan the element a ). We may need to think about how to handle unsuccessful searches\ni\n(return null? A special flag value? Throw an exception?, etc.).\n211 12. Searching & Sorting\nindex 0 1 2 3 4 5 6 7 8\ncontents 42 4 9 4 102 34 12 2 0\nFigure 12.1.: Array of Integers\nWhen implementing a solution in a programming language, we of course will need to be\nmore specific about the type of collection being searched and the type of elements in\nthe collection. However, we will still want to keep our solution as general as possible.\nAs we\u2019ll see, most programming languages facilitate some sort of generic programming\nso that we do not need to reimplement the solution for each type of collection or for\neach type of variable. Instead, we can write one solution, then configure it to allow for\ncomparisons of any type of variable (numeric, string, object, etc.).\n12.1.1. Linear Search\nThefirstsolutionthatwe\u2019lllookatisthelinear search algorithm(alsoknownassequential\nsearch). This is a basic, straightforward solution to the search problem that works by\nsimply iterating through each element a , testing for equality, and outputting the first\ni\nelement that matches the criteria. The pseudocode is presented as Algorithm 12.1.\nInput :A collection of elements A = {a ,...,a } and a key e\n1 n k\nOutput:An element a in A such that a = e according to some criteria; \u03c6 if no\nk\nsuch element exists\nforeach a in the collection A do\n1 i\nif a = e then\n2 i k\noutput a\n3 i\nend\n4\nend\n5\noutput \u03c6\n6\nAlgorithm 12.1: Linear Search\nTo illustrate, consider the following example searches. Suppose we wish to search the\n0-indexed array of integers in Figure 12.1.\nA search for the key e = 102 would start at the first element. 42 (cid:54)= 102 so the search\nk\nwould continue; it would compare it against 4, then 9, then 5, and finally find 102 at\nindex i = 4, making a total of 5 comparisons (including the final comparison to the\nmatched element).\n212 12.1. Searching\na\n1\n\u00b7\u00b7\u00b7 a n\u22121 a n a n+1 \u00b7\u00b7\u00b7 a\nn\n2 2 2\n< m m > m\nFigure 12.2.: When an array is sorted, all elements in the left half are less than the\nmiddle element m, all elements in the right half are greater than m.\nA search for the key e = 42 would get lucky. It would find it after only one comparison as\nk\nthe first element is a match. A search for the element 20 would result in an unsuccessful\nsearch with a total of 10 comparisons being made. Finally a search for e = 4 would\nk\nonly require two comparisons as we find 4 at the second index. There is a duplicate\nelement at index 3, but the way we\u2019ve defined linear search is to find the \u201cfirst\u201d such\nelement. Again, we could design any number of variations on this solution. We give a\nmore detailed analysis of this algorithm below.\n12.1.2. Binary Search\nAn alternative search algorithm is binary search. This is a clever algorithm that requires\nthat the array being searched is sorted in ascending order. Though it works on any type\nof data, let\u2019s again use an integer array as an example. Suppose we\u2019re searching for the\nkey element e . We start by looking at the element in the middle of the array, call it m.\nk\nSince the array is sorted, everything in the left-half of the array is < m and everything\nin the right-half of the array is > m.1 We will now make one comparison between e and\nk\nm. There are three cases to consider.\n1. If e = m, then we\u2019ve found an element that matches our key and search criteria\nk\nand we are done. We can output m and stop the algorithm.\n2. If e < m then we know that if a matching element exists, it must lie in the left-half\nk\nof the list. This is because all elements in the right-half are > m.\n3. If e > m then we know that if a matching element exists, it must lie in the\nk\nright-half of the list. This is because all elements in the left-half are < m.\nIn either of the second two cases, we have essentially cut the array in half, halving the\nnumber of elements we need to consider. Suppose that the second case applies. Then\nwe can consider elements indexed from 1 to n \u22121 (we need not consider a as the first\nn\n2 2\ncase would have applied if we found a match). We can then do the same trick: check the\nmiddle element among the remaining elements and determine which half to cutout and\n1If duplicate elements are in the array, then elements in the left\/right half could be less than or equal\nto and greater than or equal to m, but this will not affect how our algorithm works.\n213 12. Searching & Sorting\nwhich half to consider. We repeat this process until we\u2019ve either found the element we\nare looking for or the range in which we are searching becomes \u201cempty\u201d indicating an\nunsuccessful search.\nThis description suggests a recursive solution. Given two indices l,r, we can compute\nthe index of the middle element, m = l+r and make one of two recursive calls depending\n2\non the cases identified above. Of course, we will need to make sure that our base case is\ntaken care of: if the two indices are invalid, that is if the left is greater than the right,\nl > r, then we know that the search was unsuccessful.\nInput :A sorted collection of elements A = {a ,...,a }, bounds 1 \u2264 l,r \u2264 n,\n1 n\nand a key e\nk\nOutput:An element a in A such that a = e according to some criteria; \u03c6 if no\nk\nsuch element exists\nif l > r then\n1\noutput \u03c6\n2\nend\n3\nm \u2190 (cid:98)l+r(cid:99)\n4\n2\nif a = e then\n5 m k\noutput a\n6 m\nelse if a < e then\n7 m k\nBinarySearch(A,m+1,r,e )\n8 k\nelse\n9\nBinarySearch(A,l,m\u22121,e )\n10 k\nend\n11\nAlgorithm 12.2: Recursive Binary Search Algorithm, BinarySearch(A,l,r,e )\nk\nAs discussed in Chapter 11, non-recursive solutions are generally better than recursive\nones. We can design a straightforward iterative version of binary search using a while loop.\nWe initialize two index variables, l,r and update them on each iteration depending on\nthe three cases above. The loop stops when we\u2019ve found our element or l > r resulting in\nan unsuccessful search. The iterative version is presented in Algorithm 12.3, an example\n214 12.1. Searching\nrun of the algorithm is shown in Figure 12.3.\nInput :A sorted collection of elements A = {a ,...,a } and a key e\n1 n k\nOutput:An element a \u2208 A such that a = e according to some criteria; \u03c6 if no\nk\nsuch element exists\nl \u2190 1\n1\nr \u2190 n\n2\nwhile l \u2264 r do\n3\nm \u2190 (cid:98)l+r(cid:99)\n4\n2\nif a = e then\n5 m k\noutput a\n6 m\nelse if a < e then\n7 m k\nl \u2190 (m+1)\n8\nelse\n9\nr \u2190 (m\u22121)\n10\nend\n11\nend\n12\noutput \u03c6\n13\nAlgorithm 12.3: Iterative Binary Search Algorithm, BinarySearch(A,e )\nk\n12.1.3. Analysis\nWhen algorithms are implemented and run on a computer, they require a certain amount\nof resources. In general, we could consider a lot of different resources such as computation\ntime and memory. Algorithm analysis involves quantifying how many resource(s) an\nalgorithm requires to execute with respect to the size of the input it is run on.\nWhen analyzing algorithms, we want to keep the analysis as abstract and general as\npossible, independent of any particular language, framework or hardware. We could\nalways update the hardware on which we run our implementation, but that does not\nnecessarily make the algorithm faster. The algorithm would still execute the same number\nof operations. Faster machines just mean that more steps can be performed in less time.\nIn fact, the concept of an algorithm itself is a mathematical concept that predates modern\ncomputers by thousands of years. One of the oldest algorithms, for example, Euler\u2019s\nGCD (greatest common divisor) algorithm dates to 300 BCE. Whether or not you\u2019re\n\u201crunning\u201d it on a piece of papyrus 2,300 years ago or on a modern supercomputer, the\nsame number of divisions and subtractions are performed.\nTo keep things abstract, we analyze an algorithm by identifying an elementary operation.\n215 12. Searching & Sorting\nindex 0 1 2 3 4 5 6 7 8 9 10\ncontents -3 2 4 4 9 12 34 42 102 157 180\n(a) Initially, l=0,r =10 and so we examine the middle element at index m=5\nwhich is 12.\nindex 0 1 2 3 4 5 6 7 8 9 10\ncontents -3 2 4 4 9 12 34 42 102 157 180\n(b) Since 64 > 12, we update our left index variable l to m+1, thus l = 6 and\nwe\u2019ve eliminated the left half of the list from consideration.\nindex 0 1 2 3 4 5 6 7 8 9 10\ncontents -3 2 4 4 9 12 34 42 102 157 180\n(c) Our new middle index is m= l+r = 6+10 =8, corresponding to the element\n2 2\n102.\nindex 0 1 2 3 4 5 6 7 8 9 10\ncontents -3 2 4 4 9 12 34 42 102 157 180\n(d) Since 64<102, we update the right index variable r to m\u22121=7, eliminating\nthe right half of the subarray.\nindex 0 1 2 3 4 5 6 7 8 9 10\ncontents -3 2 4 4 9 12 34 42 102 157 180\n(e) Here, l = 6,r = 7, and so our new middle index is m = (cid:98)6+7(cid:99) = 6. Since\n2\n64>34, we update our left index variable l to m+1=7\nindex 0 1 2 3 4 5 6 7 8 9 10\ncontents -3 2 4 4 9 12 34 42 102 157 180\n(f) Since 64>42 we again update our left index variable l to m+1=8.\nindex 0 1 2 3 4 5 6 7 8 9 10\ncontents -3 2 4 4 9 12 34 42 102 157 180\n(g) Since l = 8 and r = 7, l > r and the loop terminates, resulting in an\nunsuccessful search.\nFigure 12.3.: The worst case scenario for binary search, resulting in an unsuccessful\nsearch for e = 64. This example is run on a 0-indexed array with an array\nk\nof integers of size 11.\n216 12.1. Searching\nThis is generally the most common or most \u201cexpensive\u201d operation that the algorithm\nperforms. Sometimes there may be more than one reasonable choice for an elementary\noperation which may give different results in our analysis. However, we generally do not\nconsider basic operations that are necessary to the control flow of an algorithm. For\nexample, variable assignments or the iteration of index variables.\nOnce we have identified an elementary operation, we can quantify the complexity of\nan algorithm by analyzing the number of times the elementary operation is executed\nwith respect to the input size. For a collection, the input size is generally the number\nof elements in the collection, n. We can then characterize the number of elementary\noperations and thus the complexity of the algorithm itself as a function of the input size.\nWe illustrate this process by analyzing and comparing the two search algorithms.\nLinear Search Analysis\nWhen considering the linear search algorithm, the input size is clearly the number of\nelements in the collection, n. The best candidate for the elementary operation is the\ncomparison (Line 2, Algorithm 12.1). To analyze this algorithm, we need to determine\nhow many comparisons are made with respect to the size of the collection, n.\nAs we saw in the examples, the number of comparisons made by linear search can vary\ndepending on the element we\u2019re searching and the configuration of the collection being\nsearched. Because of this variability, we can analyze the algorithm in one of three ways:\nby looking at the best case scenario, worst case scenario, and average case scenario.\nThe best case scenario is when the number of operations is minimized. For linear search,\nthe best case scenario happens when we get lucky and the first element that we examine\nmatches our criteria, requiring only a single comparison operation. In general, it is not\nreasonable to assume that the best case scenario will be commonly encountered.\nThe worst case scenario is when the number of operations is maximized. This happens\nwhen we get \u201cunlucky\u201d and have to search the entire collection finding a match at the\nlast element or not finding a match at all. In either case, we make n comparisons to\nsearch the collection.\nA formal average case analysis is not difficult, but is a bit beyond the scope of the\npresent analysis. However, informally, we could expect to make about n comparisons for\n2\nsuccessful searches if we assume that all elements have a uniform probability of being\nsearched for.\nBoth the worst-case and average-case are reasonable scenarios from which to analyze\nthe linear search algorithm. In the end, however, the only difference between the two\nanalyses is a constant factor. Both analyses result in two linear functions,\n1\nf (n) = n f (n) = n\n1 2\n2\n217 12. Searching & Sorting\nThe only difference being the constant factor 1. In fact, this is why the algorithm is called\n2\nlinear search. The number of comparison operations performed by the algorithm grows\nlinearly with respect to the input size. For example, if we were to double the input size\nfrom n to 2n, then we would expect the number of comparisons to search the collection\nwould also double (this applies in either the worst-case and average-case scenarios).\nThis is what is most important in algorithm analysis: quantifying the complexity of\nan algorithm by the rate of growth of the operations (and thus resources) required to\nexecute the algorithm as the input size n grows.2\nBinary Search Analysis\nLike linear search, the input size is the size of the collection n and the elementary\noperation is the comparison. As presented in the pseudocode, binary search would seem\nto perform two comparisons (Lines 5 and 7 in Algorithm 12.3). However, to make the\nanalysis simpler, we will instead count one comparison operation per iteration of the while\nloop. This is a reasonable simplification; in practice the comparison operation would\nlikely involve a single function call, after which distinguishing between the three cases is\na simple matter of control flow. Further, even if we were to consider both comparisons,\nit would only contribute a constant factor of 2 to the final analysis.\nSinceweperformonecomparisonforeachiterationofthewhileloop, weneedtodetermine\nhow many times the while loop executes. In the worst case, the number of iterations is\nmaximized when we fail to find an element that does not match our criteria. However\neach iteration essentially cuts the array in half each time. That is, if we start with an\narray of size n, then after the first iteration, it is of size n. After the second iteration we\n2\nhave cut it in half again, so it is of size n, after the third iteration it is of size n and so\n4 8\non. More generally, after k iterations, the size of the array is\nn\n2k\nThe loop terminates one iteration after the the index variables are equal, l = r. Equiv-\nalently, when l = r, the size of the subarray under consideration is 1. That is, the\nalgorithm stops when the array size has been cut down to 1:\nn\n= 1\n2k\nSolving for k gives us the number of iterations:\nk = log (n)\n2\nAdding one additional comparison for the final iteration gives us a total of\nk = log (n)\n2\n2This is the basis of Big-O analysis, something that we will not discuss in detail here, but is of prime\nimportance when analyzing algorithms.\n218 12.1. Searching\ncomparisons (see Table 12.1). Thus, binary search performs a logarithmic number of\ncomparisons in the worst case. As we will see, this is exponentially better than linear\nsearch.\nIteration Array Size Comparisons\n1 n 1\n2\n2 n 1\n4\n3 n 1\n8\n4 n 1\n16\n. . .\n. . .\n. . .\nk n 1\n2k\n. . .\n. . .\n. . .\nlog (n) 1 1\n2\nlog (n)+1 0 1\n2\nTotal log (n)+1\n2\nTable 12.1.: Numberofcomparisonsandarraysizeaftertheiterationduringtheexecution\nof binary search.\nComparative Analysis\nBinary search presents a clear advantage over linear search. There is an exponential\ndifference between a linear function, n and a logarithmic function, log (n). To put this\n2 2\nin perspective, consider searching a moderately large database of 1 trillion (1012) records.3\nUsing linear search, even the average-case scenario would require about\n1012\n= 5\u00d71011\n2\nor about 500 billion comparisons. However, using binary search would only require at\nmost\nlog (1012) = 12\u00b7log (10) < 40\n2 2\ncomparisons to search. This is a huge difference in performance.\nAs another comparison, let\u2019s consider how each algorithm\u2019s complexity grows as we\nincrease the size of the collection being searched. As observed earlier, if we double the\n3In the era of \u201cbig data,\u201d 1 trillion records only qualifies as moderately large.\n219 12. Searching & Sorting\ninput size, n \u2192 2n, we would expect the number of comparisons performed by linear\nsearch to also double. However, if we double the input size for binary search, we get the\nfollowing.\nlog (2n) = log (2)+log(n) = log(n)+1\n2 2\nThat is, only a single additional comparison is necessary to search an array of twice the\nsize.\nThe difference between these two algorithms shows up in many different instances. Figure\n12.4 contains a screen shot of the search feature in Windows 7. When searching for\nparticular files or content in particular files, the search can be greatly increased if the\nfiles have been indexed, that is, sorted. As the dialog indicates, non-indexed (unsorted)\nrecords will take far longer to search.\nFigure 12.4.: Example of the benefit of ordered (indexed) elements in Windows 7\nThough binary search presents a clear advantage over linear search, it only works if the\ncollection has been sorted.4 Thus, we now turn our attention to the problem of sorting a\ncollection.\n12.2. Sorting\nSorting a collection of data is another fundamental data operation. It is conceptually\nsimple, but is ubiquitous. There are a large variety of algorithms, data structures and\napplications built around the problem of sorting. As we\u2019ve already seen, being able\nto sort a collection provides a huge speed up when searching for a particular element.\nSorting provides a natural way to store and organize data.\nProblem 2 (Sorting).\nGiven: a collection of orderable elements, A = {a ,a ,...,a }\n1 2 n\nOutput: A, sorted in ascending order\nThe requirement that the collection be made of \u201corderable\u201d elements can be a bit\ntechnical5, but essentially we need to be guaranteed that given two elements, a,b in the\n4Binary search also only works when searching an array with random access to its elements. The\nperformance of binary search cannot generally be realized with data structures such as linked lists or\nunordered sets.\n5WerequirethatAbeatotalorder apartiallyorderedbinaryrelationsuchthatallpairsarecomparable.\n220 12.2. Sorting\ncollection, we can determine whether a < b, a = b or a > b. If such a determination\ncannot be made, then sorting is impossible.\nAgain, we can consider variations on this problem. We may want our collection to be\nsorted in descending order instead of ascending.6 We may also want the collection itself\nto be permuted (that is, reordered) or we may instead want a copy of the collection to be\ncreated and sorted so that the original is unchanged.\nWe will examine several standard sorting algorithms. Though there are dozens of sorting\nalgorithms, we will only focus on a few of the more common ones. As with searching,\nwe can analyze a sorting algorithm based on the number of comparisons it makes in the\nworst, best, or average cases. We may also look at alternative resources or operations:\nhow many swaps does the algorithm make? How much extra memory is required? Etc.\nThough we will examine, analyze and compare several sorting algorithms, most pro-\ngramming languages provide standard functionality to sort a collection of elements.\nIt is generally preferable to use the functionality built into whatever language you\u2019re\nusing rather that reimplementing your own. Typically, these functions are well-designed,\nwell-tested, optimized and more efficient than any custom alternatives.\n12.2.1. Selection Sort\nThe first sorting algorithm we\u2019ll examine is Selection Sort which is similar to the way\na human would sort a collection of objects. The basic idea is that you search through\nthe collection and find the minimal element (we say minimal and not minimum because\nthere could be elements with the same value). Once we\u2019ve found a minimal element, we\ncan swap it with the \u201cfirst\u201d element, a , placing the minimal element where it belongs in\n1\nthe collection.\nWe repeat this process for the remaining elements, a ,...,a , finding the minimal element\n2 n\namong these and swapping with a . In general, if we have already sorted the first i\u22121\n2\nelements, a ,...,a then we only need to examine the elements a ,...,a for the\n1 i\u22121 i n\nminimal element, swapping it with a . We end this process after we have sorted the first\ni\nn\u22121 elements, a ,...,a since the last element a will already be where it needs to\n1 n\u22121 n\nbe. We present Selection Sort as Algorithm 12.4. We illustrate the execution of Selection\n6Technically,thesearereferredtoasnon-decreasing andnon-increasing respectively. Thisisbecausethe\ncollection could contain duplicate elements and not lead to a strictly increasing or strictly decreasing\nordering.\n221 12. Searching & Sorting\nSort in Figure 12.5.\nInput :A collection A = {a ,...,a }\n1 n\nOutput:An array A(cid:48) containing all elements of A in nondecreasing order\nfor i = 1,...,(n\u22121) do\n1\na \u2190 a\n2 min i\nfor j = (i+1),...,n do\n3\nif a > a then\n4 min j\nmin \u2190 a\n5 j\nend\n6\nend\n7\nswap a and a\n8 min i\nend\n9\nAlgorithm 12.4: Selection Sort\nAnalysis\nWe now analyze Selection Sort to determine how complex it is. First, the elementary\noperation is the comparison on line 4. We need to determine how many times this line is\nexecuted with respect to the size of the input, n. Observe that on the i-th iteration, the\nfirst i\u22121 elements are sorted and we need not make any comparisons among them. We\nstart by assuming that the a is the minimum element and compare it to the remaining\ni\nn\u2212i elements, requiring n\u2212i comparisons, to find the minimal element. For example,\nin the first iteration we make n\u22121 comparisons, the second we make n\u22122, etc. The\nlast iteration we make only 1 comparison. Totaling these all up gives us\n(n\u22121)+(n\u22122)+(n\u22123)+\u00b7\u00b7\u00b7+3+2+1\nWhich can be rewritten as\nn\u22121\n(cid:88)\ni = 1+2+3+\u00b7\u00b7\u00b7+(n\u22122)+(n\u22121)\ni=1\nWe can use Gauss\u2019s Formula to solve this summation.\nTheorem 1 (Gauss\u2019s Formula). The sum of integers 1 up to n can be written as follows.\nn\n(cid:88) n(n+1)\ni = 1+2+3+\u00b7\u00b7\u00b7+(n\u22121)+n =\n2\ni=1\nInSelectionSort, thenumberofcomparisonsdoesn\u2019tsumupton, onlyn\u22121. Substituting\nthis in gives us\n222 12.2. Sorting\n42 4 9 4 102 34 12 2 0 0 4 9 4 102 34 12 2 42\nswap\n(a) First iteration. We find the minimal element, 0, at the last index,\nswapping it with the first element. At this point, the first element is sorted.\n0 4 9 4 102 34 12 2 42 0 2 9 4 102 34 12 4 42\nswap\n(b) Second Iteration. Now starting with the second element, the minimal\nelement among the remaining is found at the second to last element. 4 and\n2 are swapped. At this point, the first two elements are sorted.\n0 2 9 4 102 34 12 4 42\n0 2 4 9 102 34 12 4 42\nswap\n(c) Third iteration. Since we are using the strictly-less than comparison, the\nfirst 4 is the minimal element and swapped with 9.\n0 2 4 9 102 34 12 4 42 0 2 4 4 102 34 12 9 42\nswap\n(d) Fourth iteration. At this point, the first 3 elements are sorted. We find\nthe minimal element (the other 4) and swap it with 9. At the end of this\niteration, the first 4 elements are sorted.\n0 2 4 4 102 34 12 9 42 0 2 4 4 9 34 12 102 42\nswap\n(e) Fifth iteration. The 9 is swapped with 102, sorting the first 5 elements.\n0 2 4 4 9 34 12 102 42\n0 2 4 4 9 12 34 102 42\nswap\n(f) Sixth iteration. 12 is swapped with 34.\n0 2 4 4 9 12 34 102 42 0 2 4 4 9 12 34 102 42\nswap\n(g) Seventh iteration. 34 ends up being the minimal element and we essen-\ntially swap it with itself. Even though the \u201ccurrent\u201d element was also the\nminimal element, we still had to compare the current element with all other\nelements; in this case we made 2 comparisons.\n0 2 4 4 9 12 34 102 42 0 2 4 4 9 12 34 42 102\nswap\n(h) Eighth iteration. This is the final iteration, we swap 42 and 102. After\nthis iteration, the final element, 102 is already where it belongs.\nFigure 12.5.: Example execution of Selection Sort.\n223 12. Searching & Sorting\nn\u22121\n(cid:88) n(n\u22121)\ni =\n2\ni=1\nAnother way to analyze the code is to count the number of comparisons with respect\nto the for loop index variables. In particular, there is one comparison made on line 4.\nLine 4 itself is executed once for each time the inner for loop on line 3 executes which\nexecutes for j running from i+1 up to n. Line 3 and the entire inner for loop executes\nonce for each time the outer for loop executes, that is for i running from 1 up to n\u22121.\nThis gives us the following summation.\nn\u22121 n\n(cid:88) (cid:88)\n1\ni=1 j=i+1\n(cid:124)(cid:123)(cid:122)(cid:125)\nline4\n(cid:124) (cid:123)(cid:122) (cid:125)\nline3\n(cid:124) (cid:123)(cid:122) (cid:125)\nline1\nSolving this summation gives us:\nn\u22121 n n\u22121\n(cid:88) (cid:88) (cid:88)\n1 = n\u2212i\ni=1 j=i+1 i=1\nn\u22121 n\u22121\n(cid:88) (cid:88)\n= n\u2212 i\ni=1 i=1\nn(n\u22121)\n= n(n\u22121)\u2212\n2\nn(n\u22121)\n=\n2\nThis illustrates that Selection Sort is a quadratic sorting algorithm, requiring roughly n2\ncomparisons to sort an array of n elements. We analyze this further below.\n12.2.2. Insertion Sort\nAnother basic sorting algorithm is Insertion Sort which works slightly differently than\nSelection Sort. Rather than finding a minimal element and swapping with the \u201ccurrent\u201d\nelement, the current element is inserted in the list where it belongs.\nIf we consider just the first element, the collection is sorted by definition. Now consider\nthe second element: either its greater than the first element and so is already sorted,\nor it is less than the first element and needs to be swapped. In either case, the first\n224 12.2. Sorting\ntwo elements are now sorted. If we continue this, then on the i-th iteration, the first i\nelements, a ,...,a are sorted (just as with Selection Sort). Now consider the (i+1)-th\n1 i\nelement: we will insert it amongst the elements a ,...,a where it needs to be.\n1 i\nWe insert the \u201ccurrent\u201d element, a by comparing it to a : if a > a , then we swap\ni+1 i i i+1\nthem. We keep comparing the current element to the one immediately to its left, shifting\nthe current element down the collection until we find an element that is less than or\nequal to the current element at which point we stop. Now the elements a ,...,a are\n1 i+1\nnow sorted. In contrast to Selection Sort, we do need to process the last element as it\nmight not be where it needs to be. The full pseudocode is presented in Algorithm 12.5.\nAn example of an execution of Insertion Sort can be found in Figure12.6.\nInput :A collection A = {a ,...,a }\n1 n\nOutput:An array A(cid:48) containing all elements of A in nondecreasing order\nfor i = 2,...,n do\n1\nx \u2190 a\n2 i\nj \u2190 i\n3\nwhile j > 1 and a > x do\n4 j\u22121\na \u2190 a\n5 j j\u22121\ndecrement j\n6\nend\n7\na \u2190 x\n8 j\nend\n9\nAlgorithm 12.5: Insertion Sort\nAnalysis\nAs we can see in the example run of Insertion Sort, not every iteration needs to make\ncomparisons with all elements in the sorted part of the collection. For example, in\niteration 4 we only had to make one comparison and we were done. In other iterations\nsuch as the last two, we had to make comparisons to every element in the sorted part of\nthe collection. This illustrates that Insertion Sort is adaptive and may have a different\ncomplexity depending on the structure of the collection it sorts.\nLet\u2019s consider the best case in which the number of comparisons is minimized. Suppose,\nfor example, we ran Insertion Sort on a collection that was already sorted. Each iteration\nwould only need one comparison to determine that the element was already where it\nneeded to be. As there are only n\u22121 iterations, in the best case, Insertion Sort makes\nn\u22121 comparisons.\nIn contrast, the worst case would occur if the list was already sorted, but in reverse order.\n225 12. Searching & Sorting\n42 4 9 4 102 34 12 2 0 4 42 9 4 102 34 12 2 0\n(a) First iteration. We insert 4 in front of 42, requiring 1 comparison.\n2\n1\n4 42 9 4 102 34 12 2 0 4 9 42 4 102 34 12 2 0\n(b) Seconditeration. Thefirsttwoelementsaresorted,weinsert9bymaking\ntwo comparisons: to find that it is less than 42, but greater than 4. At the\nend of the iteration, the first three elements are sorted.\n3\n2\n1\n4 9 42 4 102 34 12 2 0 4 4 9 42 102 34 12 2 0\n(c) Third iteration. The first three elements are sorted, we insert the second\nfour by making 3 comparisons.\n1\n4 4 9 42 102 34 12 2 0 4 4 9 42 102 34 12 2 0\n(d) Fourth iteration. Here, only one comparison is necessary to find that 102\nis already sorted.\n3\n2\n1\n4 4 9 42 102 34 12 2 0 4 4 9 34 42 102 12 2 0\n(e) Fifth iteration. Here, 3 comparisons are necessary to insert 34 between 9\nand 42.\n4\n3\n2 1\n4 4 9 34 42 102 12 2 0 4 4 9 12 34 42 102 2 0\n(f) Sixth iteration. Here, 4 comparisons are necessary to insert 12 between 9\nand 34.\n7\n6\n5\n4\n3\n2 1\n4 4 9 12 34 42 102 2 0 2 4 4 9 12 34 42 102 0\n(g) Seventh iteration. Here, the number of comparisons is maximized as we\nshift 2 all the way to the front of the array.\nFigure 12.6.: Example execution of Insertion Sort. Each iteration depicts the comparisons\nto previous elements; the last comparison is dashed indicating a comparison\nwas made, but not a swap. The final iteration is omitted for space, but\nwould require 8 comparisons to insert 0 at the front of the collection.\n226 12.2. Sorting\nThe i-th iteration would require i comparisons to move the current element all the way\nto the front of the collection. Again, this gives us a summation:\nn\u22121\n(cid:88) n(n\u22121)\ni =\n2\ni=1\nmatching the complexity of Selection Sort.\nWe could also analyze Insertion Sort with respect to average case. On average, we would\nexpect to make about 1 of the total possible comparisons on each iteration. That is,\n2\nn\u22121\n(cid:88) i\n2\ni=1\nMoving the constant outside the summation and applying Gauss\u2019s Formula would give\nus an expected number of comparisons to be\nn(n\u22121)\n4\nThis is still a quadratic function, but the constant involved and the fact that Insertion\nSort is more adaptive to the input make Insertion Sort a much better algorithm in\npractice than Selection Sort. In fact, Insertion Sort is very efficient on \u201csmall\u201d arrays in\npractice and is used in many hybrid algorithm implementations (see Section 12.2.5).\n12.2.3. Quick Sort\nSelectionSortandInsertionSortaresimplealgorithms, butinefficient, makingaquadratic\nnumber of comparisons in even the average case. A more sophisticated and efficient\nalgorithm is Quick Sort, first developed by Tony Hoare in the early 1960s [17, 18]. Quick\nSort is a divide-and-conquer style algorithm that attempts to solve the sorting problem\nby splitting a collection up into two parts, then recursively sorting each part.\nThe basic idea is as follows. First, choose a pivot element p in the collection. We will\nthen partition all the elements in the collection around this pivot element by placing all\nelements less than p in the \u201cleft\u201d partition and all elements greater than p in the \u201cright\u201d\npartition. This concept is similar to binary search. After partitioning all the elements,\nwe place p between them so that p is where it needs to be. We then repeat this process\non the two partitions recursively. The recursion stops when the size of the sub-collection\nis trivially sorted (it is empty or consists of a single element).\nQuick Sort is presented as Algorithm 12.6 with a partitioning subroutine presented in\nAlgorithm 12.7. The partitioning chooses the first element in the sub-collection as the\npivot element. Further, the partitioning is done in-place: we maintain two index variables,\n227 12. Searching & Sorting\ni,j and increment\/decrement them respectively to find a pair that are both in the wrong\npartitions, swapping them. The partitioning continues until the two index variables meet\neach other. As a final step, the pivot element is placed between the two partitions and\nthe index at which it is placed is returned to the main QuickSort routine so that it\ncan make two recursive calls on the two partitions.\nWe depict a few examples of the partitioning algorithm. Figure 12.7 depicts the first\npartitioning on the same example array while Figures 12.8 and 12.9 depict subsequent\n228 12.2. Sorting\npartitioning operations on subarrays as part of the recursion.\nInput :A collection A = {a ,...,a }, indices l,r\n1 n\nOutput:A, sorted in ascending order\nif l < r then\n1\np \u2190 Partition(A,l,r)\n2\nQuickSort(A,l,p\u22121)\n3\nQuickSort(A,p+1,r)\n4\nend\n5\nAlgorithm 12.6: QuickSort\nInput :A collection A = {a ,...,a }, indices l,r\n1 n\nOutput:An index s such that the sub-collection A from l to r has been\npartitioned around s so that all elements a ,...a are less than a\nl s\u22121 s\nand all elements a ,...,a are greater than a\ns+1 r s\npivot \u2190 a\n1 l\ni \u2190 (l+1)\n2\nj \u2190 r\n3\nwhile i < j do\n4\nwhile i < j Anda \u2264 pivot do\n5 i\ni \u2190 (i+1)\n6\nend\n7\nwhile i < j Anda \u2265 pivot do\n8 j\nj \u2190 (j \u22121)\n9\nend\n10\nswap a , a\n11 i j\nend\n12\n\/\/Swap the pivot\nif a \u2264 pivot then\n13 i\nswap pivot, a\n14 i\noutput i\n15\nelse\n16\nswap pivot, a\n17 i\u22121\noutput (i\u22121)\n18\nend\n19\nAlgorithm 12.7: In-Place Partition\n229 12. Searching & Sorting\n42 4 9 4 102 34 12 2 0 42 4 9 4 0 34 12 2 102\nswap i j\nj\ni\n(a) First iteration. 42 is chosen as the pivot element. The index variable\ni moves over to 102, the first element that is greater than 42 and on the\n\u201cwrong\u201d side of the partition. The j index variable does not move as 0 is less\nthan the pivot element and on the wrong side; these are swapped.\n42 4 9 4 0 34 12 2 102 2 4 9 4 0 34 12 42 102\nj s\ni\n(b) Second iteration. The index variable i moves all the way to the right\nas all remaining elements are less than the pivot, 42. The index variable j\nremains at 102 as i is now equal to j. The pivot, 42 is placed between the\ntwo partitions and its resulting index, s is returned.\nFigure 12.7.: Example execution of the Partition subroutine in Quick Sort. A total\nof 8 comparisons are made, 9 if you count the last swap outside the while\nloop. The partition returns s as the pivot position; the right-partition is\nsorted as it only consists of 1 element.\n2 4 9 4 0 34 12 2 0 9 4 4 34 12\nswap i j\ni j\n(a) Firstiteration. Inthispartitioning,2isthepivotelement.\nThe index variable i is not incremented as 4 is larger than\nthe pivot. The index variable j decrements to 0 and they are\nswapped.\n2 0 9 4 4 34 12 0 2 9 4 4 34 12\ns\ni,j\n(b) Second iteration. The index variable i is incremented\nonce, while j is decremented to meet it. After the while loop\nthe second case applies as a = 9 > 2 = pivot, and so we\ni\nswap a =2 with the pivot.\ni\u22121\nFigure 12.8.: Example execution of the Partition subroutine in Quick Sort on the first\nrecursive call on the left partition. A total of 6 comparisons are made, 7 if\nyou count the last swap outside the while loop. The partition returns s as\nthe pivot position; in this case the left-partition is sorted as it only consists\nof 1 element.\n230 12.2. Sorting\n9 4 4 34 12 4 4 9 34 12\ns\ni,j\n(a) First (and only) iteration. In this parti-\ntioning, 9 is the pivot. The index variable i\nis incremented to 34 while j decrements to\nmatch. 34 is swapped with itself. After this\niteration, the second condition applies and\nthe pivot is swapped with a =4\ni\u22121\nFigure 12.9.: Example execution of the Partition subroutine in Quick Sort on the\nsecond recursive call on the right partition. A total of 5 comparisons are\nmade, 6 if you count the last swap outside the while loop. The partition\nreturns s as the pivot position.\nAnalysis\nWe can easily analyze how many comparisons are made by the Partition subroutine.\nSuppose that we are given a (sub)array of n elements. Since the pivot element must be\ncompared to every other element in the (sub)array, it must make n\u22121 comparisons to\npartition the elements around the pivot. If we count the last comparison to determine\nwhere to place the pivot, it would be n comparisons (but the difference is trivial).\nThe analysis of Quick Sort itself is a bit more involved and is highly dependent on how\nwell the Partition subroutine splits the array. In the worst case, our pivot choice\nwill always partition the array into one \u201cempty\u201d subarray and one subarray with n\u22121\nelements (we do not count the pivot element). One such example of this would be if our\ncollection is already sorted. In this case, one of the recursive calls would result in no\ncomparisons and the other would result in n\u22121 comparisons. This lopsided recursion\nwould result in the following number of comparisons:\nn+(n\u22121)+(n\u22122)+\u00b7\u00b7\u00b7+3+2+1\nwhich is exactly Gauss\u2019s Formula, meaning that Quick Sort would perform\nn(n+1)\n2\nin the worst case.\nHowever, in the sorting scenario, we cannot always assume the worst case. If we are given\nrandom data, then the likelihood that we will always have such an extremely lopsided\npartitioning is extremely small. A more reasonable analysis would involve the average\ncase: where each partition is roughly an equal size, about n. This happens when our\n2\npivot choice is the median (or close to the median) element.\n231 12. Searching & Sorting\nTo analyze the number of comparisons in this case, we can setup a recurrence relation:\n(cid:16)n(cid:17)\nC(n) = 2C +n\n2\nHere, C(n) represents the number of comparisons made by Quick Sort on an array of size\nn. The first term on the right hand side represents the fact that we make 2 recursive calls\non subarrays of size (roughly) n. The second term captures the number of comparisons\n2\nwe make in the Partition subroutine. Solving this recurrence is a bit beyond the scope\nof the current discussion. However, it can be shown that this is roughly equivalent to\nnlog(n)\ncomparisons in the best case.\nThe difference between the best and worst case scenarios is in our pivot choice. Though\nthe ideal pivot choice is the median element, to find the median the usual strategy is to\nsort the collection first. This puts the cart before the horse. If the data we are sorting\nis in more-or-less random order, then the choice of the first element as a pivot is good\nenough as it is unlikely that we will always have a bad paritioning. However, there are\nother strategies.\nOne strategy is to randomly choose a pivot element. A random choice would make the\nworst-case scenario very unlikely over many runs of the algorithm. Another strategy\nis to choose the median of three elements (either fixed or randomized), ensuring that\nneither partition will ever be empty. This strategy can be taken further to find the\nmedian-of-three amongst each third of the array and then take the median of these (or the\n\u201cninther\u201d). The more effort you put into finding the median the more the performance\ndegradesinpractice.7 Amoresophisticatedanalysisofthesestrategiesyieldsacomplexity\nsimilar to the best case [9].\n12.2.4. Merge Sort\nAnother \u201cfast\u201d sorting algorithm is Merge Sort, due to John von Neumann, 1945 (as\nreported by Knuth [27]). The performance is similar to Quick Sort\u2019s best\/average case,\nmaking\nnlog(n)\ncomparisons. However, Merge Sort\u2019s performance does not depend on the structure of the\ninput array or a pivot choice, guaranteeing this performance in the best\/average\/worst\ncase.8\n7For example, there does exist a median-finding algorithm that runs in linear time which would\nguaranteethetheoreticallybestrunningtime,butthealgorithmisrecursiveandhasalargeoverhead,\nmaking its use slow in practice.\n8Still, Quick Sort is still more common in practice because it has less memory requirements and the\npivot choice strategies can mitigate the risk of the worst-case scenario.\n232 12.2. Sorting\nMerge Sort works by first dividing the list into two (roughly) equal partitions. It then\nrecursively sorts each partition. The recursion stops when the subarray is of size \u2264 1 just\nas with Quick Sort. The difference, however, is what Merge Sort does after the recursion.\nAfter having sorted the left partition, L and the right partition R, Merge Sort merges\nthe two sorted partitions into one.\nThe Merge subroutine works by maintaining two index variables, i,j, one for each\npartition. Suppose that the index variables correspond to the elements L and R in\ni j\nthe left\/right partition. If L \u2264 R , we add L to the end of a temporary array and\ni j i\nincrement i. Otherwise we place R into the temporary array and increment j. We\nj\ncontinue until we have examined every element in one or both partitions (if one partition\nstill has elements in it, we can simply copy the rest over in order). This merge operation\nworks because each subarray is sorted.\nMerge Sort is presented as Algorithm 12.8 with the Merge subroutine as Algorithm\n12.9.\nInput :A (sub)collection A = {a ,...,a }, indices l,r\nl r\nOutput:A collection A(cid:48) which is A sorted\nif l < r then\n1\nm \u2190 (cid:98)l+r(cid:99)\n2\n2\nL \u2190 MergeSort(A,l,m)\n3\nR \u2190 MergeSort(A,m+1,r)\n4\noutput Merge(L,R)\n5\nelse\n6\noutput A\n7\nend\n8\nAlgorithm 12.8: MergeSort\n233 12. Searching & Sorting\nInput :Two sorted collections, L, R of size n,m respectively.\nOutput:A sorted collection A consisting of all elements of L and R\nA \u2190 a new, empty collection\n1\ni \u2190 1\n2\nj \u2190 1\n3\n4 k \u2190 1 \/\/index variable for A\n5\nwhile i \u2264 nAndj \u2264 m do\n6\nif L \u2264 R then\n7 i i\nA \u2190 L\n8 k i\ni \u2190 (i+1)\n9\nelse\n10\nA \u2190 L\n11 k j\nj \u2190 (j +1)\n12\nend\n13\nk \u2190 (k +1)\n14\nend\n15\n\/\/At least one collection is empty, we can blindly copy the other\nwhile i \u2264 n do\n16\nA \u2190 L\n17 k i\ni \u2190 (i+1)\n18\nk \u2190 (k +1)\n19\nend\n20\nwhile j \u2264 m do\n21\nA \u2190 R\n22 k j\nj \u2190 (j +1)\n23\nk \u2190 (k +1)\n24\nend\n25\noutput A\n26\nAlgorithm 12.9: Merge\nWe present an example run of Merge Sort in Figure 12.10 (here, we have made the\ncollection of size 8 to emphasize the even split). An example run of the Merge\nsubroutine on the last merge operation of this algorithm is presented in Figure 12.11.\n234 12.2. Sorting\n42 4 9 4 102 34 12 2\n42 4 9 4 102 34 12 2\n42 4 9 4 102 34 12 2\n42 4 9 4 102 34 12 2\nmerge merge merge merge\n4 42 4 9 34 102 2 12\nmerge merge\n4 4 9 42 2 12 34 102\nmerge\n2 4 4 9 12 34 42 102\nFigure 12.10.: Illustration of Merge Sort\u2019s recursion and merge operations.\n235 12. Searching & Sorting\n4 4 9 42 2 12 34 102 4 4 9 42 2 12 34 102\ni j i j\n2 2 4\nk k\n(a) Iteration One. L = 4 > R = 2, so (b) Iteration Two. Now the element in\n1 1\ntheelementintherightpartitioniscopied the left partition is lesser and is copied,\ninto A . Both j,k are incremented. incrementing i,k\n1\n4 4 9 42 2 12 34 102 4 4 9 42 2 12 34 102\ni j i j\n2 4 4 2 4 4 9\nk k\n(c) Iteration Three. Again the element in (d) Iteration Four. And so on.\nthe left partition is less.\n4 4 9 42 2 12 34 102 4 4 9 42 2 12 34 102\ni j i j\n2 4 4 9 12 2 4 4 9 12 34\nk k\n(e) Iteration Five (f) Iteration Six\n4 4 9 42 2 12 34 102 4 4 9 42 2 12 34 102\ni j j\n2 4 4 9 12 34 42 2 4 4 9 12 34 42 102\nk k\n(g) Iteration Seven (h) Final Copy. After one sub-collection\nhas been exhausted the rest (in this case\nonly one) of the elements in the other are\nblindly copied over.\nFigure 12.11.: Demonstration of the merge operation in Merge Sort. Here we depict the\nfinal Merge subroutine invocation from the previous example.\n236 12.2. Sorting\nAnalysis\nBecause Merge Sort divides the list first, an even split is guaranteed. After the recursion,\nthe Merge subroutine requires at most n\u22121 comparisons to merge the two collections.\nThis leads to a recurrence relation similar to Quick Sort,\n(cid:16)n(cid:17)\nC(n) = 2C +(n\u22121)\n2\nA similar analysis yields a complexity of nlog(n).\n12.2.5. Other Sorts\nThere are dozens of other sorting algorithms and many more variations on sorting\nalgorithms, each with some unique properties and advantages. For example, Heap Sort,\ndue to J. W. J. Williams, 1964 [38], uses a data structure called a heap. A heap stores\nelements in a tree structure and offers efficient insertion of elements and retrieval of the\nminimal (or maximal for a \u201cmax-heap\u201d) element. The sorting algorithm then simply\ninserts each element into the heap, and retrieves each element out of the heap. Because\nof the the heap data structure, elements come out of the heap in order.\nOther sorting algorithms are variations on those we\u2019ve already seen or hybrid sorting\nalgorithms. For example, we\u2019ve already noted that Insertion Sort is efficient on \u201csmall\u201d\narrays. One common technique is to use a fast sorting algorithm such as Quick Sort or\nMerge Sort, but then switch over to Insertion Sort at some point in the recursion rather\nthan recursing to the point that the collection is of size 1 (or 0). This switch point is\nusually tuned using empirical experiments.\nA more recent sorting algorithm is Tim Sort, due to Tim Peters in 2002 [34] who\noriginally developed it as the default sorting algorithm for the Python language. It has\nsince been adopted in Java (version 7 for arrays of non-primitive types). Tim Sort is a\nsort of \u201cbottom-up\u201d Merge Sort\/Insertion Sort hybrid. Instead of recursing, it looks for\nsubsequences of elements that are already in order or nearly in order, then merges them.\nIt was designed to have many of the desirable properties of a sorting algorithm including\nstability (see Section 12.3.6).\n12.2.6. Comparison & Summary\nTo illustrate just how much more efficient an nlog(n) sorting algorithm is over a naive\nn2 algorithm consider the same scenarios as with searching. Suppose we want to sort a\nhuge collection of 1 trillion, 1012, elements. Doing so with Selection Sort or Insertion\nSort would require about\nn2 = (1012)2 = 1024\n237 12. Searching & Sorting\nor 1 septillion comparisons. The same sorting operation using either Quick Sort or Merge\nSort would require only\nnlog(n) = 1012log1012 \u2248 4\u00d71013\nor just under 40 trillion comparisons. This is 25 billion times fewer operations.\nAs another example, suppose that we sort a collection with n elements and then want to\ndouble the size of our collection to 2n. How do each of these types of algorithms perform?\nFor the slow, n2 algorithms we have\n(2n)2 = 4n2\nDoubling the input size quadruples the number of operations Selection Sort and Insertion\nSort perform. However, for Quick Sort and Merge Sort, we only have\n2nlog(2n) = 2n(log(2)+log(n)) = 2nlog(n)+2n\nThat is, only about twice as many operations (with an additive term of 2n). Table 12.2\ngives a summary of the complexity and other properties of the sorting algorithms we\u2019ve\nseen.\nComplexity\nAlgorithm Stable? Notes\nBest Average Worst\nSelection Sort \u223c n2 \u223c n2 \u223c n2 No\nInsertion Sort \u223c n \u223c n2 \u223c n2 Yes Best in practice for\nsmall collections\nQuick Sort \u223c nlogn \u223c nlogn \u223c n2 No Performance depends\non pivot choices\nMerge Sort \u223c nlogn \u223c nlogn \u223c nlogn Yes Requires extra space\nTable 12.2.: Summary of Sorting Algorithms. See Section 12.3.6 for a discussion on\nstability.\n12.3. Searching & Sorting In Practice\n12.3.1. Using Libraries and Comparators\nIn practice you do not write your own searching and sorting algorithm implementations.\nInstead, you use the functionality provided by the language, a framework, or a library.\nFirst, there is rarely a good reason to \u201creinvent the wheel\u201d and write your own if the\nfunctionality already exists. Second, the algorithms and code provided by a language\nor library are typically optimized and have been well-tested. Established libraries have\n238 12.3. Searching & Sorting In Practice\nbeen developed with thousands of man-hours and have proven themselves over millions\nof computing hours.\nTypically, searching and sorting functions in a language are made to be generic: they\ndon\u2019t just search a collection of numbers or strings. Instead, they accept collections of\nany type. The basic algorithms for searching and sorting are generic themselves (after all\nwe presented them as pseudocode). The only real difference between an implementation\nfor, say, numbers versus a sorting algorithm for strings is how pairs of elements are\ncompared and ordered.\nThis genericness extends to objects. It would be extremely inefficient, development-wise,\nto have to rewrite Quick Sort for a collection of student objects to sort them by name,\nthen another to sort them by GPA, then another for ID, and repeat them all again for a\nreversed ordering. Instead, a single, generic sorting algorithm is implemented that can\nbe configured by passing in a comparator.\nA comparator is a function or object that provides functionality to determine how to\norder two elements. In general, a comparator takes two arguments, a,b which are the\nelements to be compared and returns an integer value with the following \u201ccontract.\u201d It\nreturns:\n\u2022 something negative, < 0 if a comes before b, a < b\n\u2022 zero if a and b are equivalent, a = b\n\u2022 something positive, > 0 if a comes after b, a > b\nWe\u2019ve previously seen this type of functionality when comparing strings in Chapter 8.\nUsing comparators allows us to reuse the generic search and sorting algorithms. Now for\neach sorting that we want, we only need to create a comparator to define the ordering\nrather than reimplementing the whole algorithm every single time. This relationship is\ndepicted in Figure 12.12.\n12.3.2. Preventing Arithmetic Errors\nRecall that in binary search, we need to compute the index of the middle element.9 Given\na left l and right r index variable, we computed the middle index as\n(cid:22) (cid:23)\nl+r\nm \u2190\n2\nThough mathematically correct, when implementing an expression like this, care must\nbe taken. We may initially translate this pseudocode into a line that looks something\nlike the following.\n9Some implementations of Quick Sort will do something similar when choosing the \u201cmiddle\u201d element\nas a pivot.\n239 12. Searching & Sorting\nSorting\narray sorted array\nInput Algorithm Output\n\uf8f1\n< 0 if a < b\n\uf8f2\na,b order = 0 if a = b\n\uf8f3 > 0 if a > b\nComparator\nFigure 12.12.: Generalized Sorting with a Comparator. A sorting algorithm doesn\u2019t\nneed to know what it is sorting or how they are ordered as long as it has\naccess to a comparator that does know how to order elements. By using a\ncomparator, the sorting function can be kept general and generic so that\none implementation can be used for any type of data.\nint middle_index = (left + right) \/ 2;\nHowever, this is prone to arithmetic errors in certain situations, particularly when dealing\nwith large arrays. If the variables left and right have a sum that exceeds the\nmaximum value that a signed 32-bit integer can hold (231 \u22121 = 2,147,483,647), then\noverflow will occur before the division by 2, leading to a (potentially) negative index\nvalue and thus an invalid out-of-bounds error or exception.\nOne solution would be to use a variable type that supports larger values. For example,\na 64-bit signed integer would be able to handle arrays of 9.223 quintillion elements.\nHowever, depending on the language, you may not be able to use such variable types as\nindex values. Another solution is to use operations that do not introduce this potential\nfor overflow. For example,\nl+r (r\u2212l)\n= l+\n2 2\nbut the expression on the right hand side will not be prone to overflow. Thus the code,\nint middle_index = left + (right - left) \/ 2;\nwould be safer to use. In fact, this bug is quite common [32] and was in the Java\nimplementation of binary search, unreported for nearly a decade [10].\n240 12.3. Searching & Sorting In Practice\n12.3.3. Avoiding the Difference Trick\nAnother issue related to arithmetic overflow is a common \u201ctrick\u201d used in comparators\nwhen ordering integer values. Consider the following example: we want to order integer\nvalues in ascending order, the basic logic would look something like the following.\nif a < b then\n1\noutput \u22121\n2\nelse if a = b then\n3\noutput 0\n4\nelse\n5\noutput +1\n6\nend\n7\nFor example, if a = 5 and b = 10 then our comparator would output \u22121. If the values\nwere a = 10,b = 5 it would output +1, and if they were equal, a = b = 10 then it would\noutput zero. A common \u201ctrick\u201d is to instead compute the difference between these values,\na\u2212b. Observe:\na b a\u2212b\n5 10 \u22125\n10 5 5\n5 5 0\nThe sign of the difference in each of these examples matches the logic of our if-else-if\nstatement. The lazy programmer may be tempted to write a one liner, \u201coutput (a\u2212b)\u201d\ninstead of the if-else-if statement. However, this would fail for certain values of a and b.\nSuppose both of them are 32-bit 2s complement integers. And suppose that a = 231 \u22121,\nthe maximum representable value, and b = \u221210. In the logic above, b would come before\na and so we would expect a positive result. However, our arithmetic trick would give the\nfollowing result:\n(231 \u22121)\u2212(\u221210) = 231 +9\nwhich, mathematically, is positive, but exceeds the maximum representable value, leading\nto overflow. In most systems, the result of this arithmetic is \u22122,147,483,639, a negative\nvalue. There are many other input values that could cause arithmetic overflow. Only if\nyou are absolutely sure that no arithmetic overflow is possible should you even consider\nusing this \u201ctrick.\u201d\nAnother issue with this trick is when comparing floating point values. GPAs for example:\nsuppose that a = 4.0 and b = 3.9. Their difference would be a\u2212b = 0.1. However, a\ncomparator returns an integer value. In some languages this result would be casted to\n241 12. Searching & Sorting\nan integer, truncating the fractional value, so that 0.1 \u2192 0, meaning that a GPA of 3.9\nis \u201cequivalent\u201d to the 4.0. Given the potential for errors, it is best to avoid this trick\naltogether.\n12.3.4. Importance of a Total Order\nIn many applications it is important to design your comparator to provide a total order.\nFor example, suppose we have students \u201cGary Busey\u201d with an ID of 1234 and another\nstudent with the same name, \u201cGary Busey\u201d but with an ID of 4321. It is entirely possible\n(and common) for different people to have the same names. However, a comparator that\nordered student objects based only on the name fields would interpret these as the same\nperson.\nThe distinction is especially important when using a comparator in a sorted collection\n(such as a Binary Search Tree, or Ordered Hash Map data structure) that maintains\nan ordering on the elements. Many of these data structures do not allow \u201cduplicate\u201d\nelements where duplication is determined by the comparator. Attempting to insert both\nof these students will likely result in only one of them being in the collection as the\nsecond will be interpreted as a a duplicate. In such scenarios it is important to design\nyour comparator to break ties by using some unique data field of an object such as an ID.\n12.3.5. Artificial Ordering\nMany languages recognize what is called a \u201cnatural ordering\u201d on certain elements. For\nexample, numbers have a natural ordering: from least to greatest. Strings also have a\nnatural ordering: lexicographic ordering. However, we often wish to order elements in\nan artificial ordering. For example, suppose we wish to include the year of a student,\nFreshman, Sophomore, Junior, or Senior. If we modeled these as strings, the natural\nordering would be alphabetical:\nFreshman,Junior,Senior,Sophomore\nHowever, if we order students by year, we would want the artificial order of Freshman,\nSophomore, Junior, or Senior.\nTo do this, we might have a whole series of if-else-if statements to order these elements\n242 12.3. Searching & Sorting In Practice\nInput :Two student objects, a,b\nif a.year = b.year then\n1\noutput 0\n2\nelse if a.year = \u201cFreshman(cid:48)(cid:48) then\n3\noutput \u22121\n4\nelse if b.year = \u201cFreshman(cid:48)(cid:48) then\n5\noutput 1\n6\nelse if a.year = \u201cSophomore(cid:48)(cid:48) then\n7\noutput \u22121\n8\n...\n9\nHowever, this logic is complex and does not provide a good solution if we want to then\nadd support for \u201cPre-freshman\u201d or \u201cGraduate\u201d, etc.\nAnother solution would be to model the year using a data type that has a natural\nordering. For example, we could define an enumerated type and associate each of the\nyears with 0, 1, 2, 3; giving them a natural ordering. Alternatively, we could use a data\nstructure, such as a map, to model the artificial ordering. For example, we could map\n\u201cFreshman\u201d to 0, \u201cSophomore\u201d to 1, etc. Then, when we wanted to order two elements,\nwe could look up the \u201cnatural value\u201d via the map and use their natural ordering to order\nour elements.\n12.3.6. Sorting Stability\nOne desirable property of sorting algorithms is stability. A sorting algorithm is stable if\nthe relative order of \u201cequal\u201d elements is preserved. For example, suppose we have the\nfollowing integer values:\n10,2 ,5,2\na b\nThe subscripts on the two 2 values are for demonstration purposes only. A stable sorting\nalgorithm would sort the elements as:\n2 ,2 ,5,10\na b\npreserving the relative ordering of the two 2 elements. The element 2 came before 2\na b\nprior to sorting and remains so after sorting. However, an unstable sorting algorithm\nmay instead produce\n2 ,2 ,5,10\nb a\nThe collection is still sorted, but the two equal elements have been reversed from their\noriginal ordering.\n243 12. Searching & Sorting\nSorting stability is often desirable for data presentation. A user can typically sort table\ndata by clicking on a column header. Suppose we sorted a table of students first by GPA\nthen by year. We would expect that all Freshman would be grouped together and within\nthat group, would be ordered by GPA (because the first ordering would be preserved).\nAn unstable sorting algorithm would result in all Freshman being grouped together, but\nwithin that grouping, the students would not necessarily be ordered by GPA.\nAs indicated in Table 12.2, some algorithms (as presented) are stable and others are not.\nFor example, Selection Sort is not stable. Consider the following input:\n2 ,2 ,1,5\na b\nIn the first iteration, 1 and 2 would be swapped, resulting in a sorted collection and no\na\nfurther swaps, but with 2 preceding 2 .\nb a\nInsertion Sort, however, is stable: it only moves an element down the collection if it is\nstrictly less than its adjacent element. Likewise, Merge Sort is stable since we \u201cprefer\u201d\nelements from the left partition when equal.\nQuick Sort is not stable as the partitioning can easily place things out of their original\nrelative ordering. Usually, sorting algorithms can be made to be stable by doing some\nextra work, but it may impact the performance.\n12.4. Exercises\nExercise 12.1. Give an input example input demonstrating that the Quick Sort al-\ngorithm, as presented, is unstable. Run through the algorithm to demonstrate how it\nresults in an unstable sort.\nExercise 12.2. Implement the sorting algorithms described in this chapter in the\nprogramming language of your choice. Then setup experiments: run each on randomly\nordered collections many times to get an average run time. Graph these empirical results\nand see if they match the theoretical results of our analysis. Be sure to also include any\nbuilt-in sorting functionality your language provides as a benchmark.\nExercise 12.3. Ternary search is similar to binary search in that it searches a sorted\narray. However, instead of splitting the array in two, it splits it into three partitions\nand makes two comparisons to determine which third the element lies in (if it is in\nthe collection). Implement ternary search and benchmark it against a binary search\nimplementation.\nExercise 12.4. Data has a \u201cnatural\u201d ordering: numbers are ordered in nondecreasing\norder, strings are ordered lexicographically (according to the ASCII text table). However,\nin many situations, the natural ordering isn\u2019t the expected ordering. For example, class\n244 12.4. Exercises\nyears are usually ordered Freshman, Sophomore, Junior, Senior whereas the natural\nordering would order them Freshman, Junior, Senior, Sophomore.\nWrite a program to sort a collection of strings according to an arbitrary artificial ordering.\nThat is, instead of the A\u2013Z alphabetic ordering, we will order them according to an\nalternative ordering of the English alphabet. As an example, one possible ordering would\nbe:\nn e d c r h a l g k m z f w j o b v x q y i p u s t\nYour job will be to sort a list of English language words using this artificial ordering of\nthe English alphabet. Specifically, you will read in an input file in the following format.\nThe first line is the new ordering of English letters, each separated by a space. Each line\nafter that contains a single string. You will read in this file, process it and produce a\nreordered list of the words sorted according to the new ordering.\nAn example input:\nn e d c r h a l g k m z f w j o b v x q y i p u s t\nvcawufotrb\nlaencfuesw\ngvtkwekfom\nvrsfqictqc\nwmcvmjmtet\nqetegyqelu\nnewaxdtjlt\nnfrfrwkknj\nfzqrvgblov\ngkkmgwwwpa\nThe result ordering:\nArtificial Ordering:\nnewaxdtjlt\nnfrfrwkknj\nlaencfuesw\ngkkmgwwwpa\ngvtkwekfom\nfzqrvgblov\nwmcvmjmtet\nvcawufotrb\nvrsfqictqc\n245 12. Searching & Sorting\nqetegyqelu\nFor simplicity, you can assume that all words will be lower case and no non-alphabetic\ncharacters are used. However, you may not assume that all words will be the same length.\nWords of a shorter length that are a prefix of another word should be ordered first. For\nexample, \u201cnewax\u201d should come before \u201cnewaxn\u201d in the ordering above.\nExercise 12.5. Write comparators for all the member fields of the album object in\nExercise 10.2.\nExercise 12.6. Write comparators for all the member fields of the savings account\nobject in Exercise 10.3.\nExercise 12.7. Write comparators for all the member fields of the stadium object in\nExercise 10.4.\nExercise 12.8. Write comparators for all the member fields of the network device object\nin Exercise 10.5.\nExercise 12.9. Write comparators for all the member fields of the airport object in\nExercise 10.6.\n246 13. Graphical User Interfaces & Event\nDriven Programming\nThis chapter may appear in a future version.\n247  14. Introduction to Databases &\nDatabase Connectivity\nThis chapter may appear in a future version.\n249  Part I.\nThe C Programming Language\n251  15. Basics\nThe C programming language is a relatively old language, but still widely used. It is\nuniversal in that nearly every system, platform, and operating system has a C compiler\nthatproducesmachinecodeforthatsystem. Cisusedextensivelyinsystemsprogramming\nforoperatingsystemkernels, embeddedsystems, microcontrollers, andsupercomputers. It\nis generally an \u201cimperative\u201d language which is a paradigm that characterizes computation\nin terms of executable statements and functions that change a program\u2019s state (variable\nvalues). C has been highly influential in the design and syntax of other languages\nincluding C++, Objective-C, C#, Java, and PHP, among many others. Many languages\nhave adopted the basic syntactic elements and structured programming approach of the\nC language.\nC was originally developed by Dennis Ritchie while at AT&T Bell Labs 1969\u20131972. C\nwas born out of the need for a new language for the PDP-11 minicomputer that used\nthe Unix operating system (written by Ken Thompson). From its inception, C has had\na close relation to Unix; in fact the operating system was subsequently rewritten in C,\nmaking it the first OS to be written in a language other than assembly. The language\nwas dubbed \u201cC\u201d as its predecessor was named \u201cB,\u201d a simplified version of BCPL (Basic\nCombined Programming Language). The first formal specification was published as The\nC Programming Language by Kernighan and Ritchie (1978) [26] often referred to as\n\u201cThe K&R Book\u201d which would later become the American National Standards Institute\n(ANSI) C standard.\nC gained in popularity and directly influenced object-oriented variations of it. Bjarne\nStroustrup developed C++ while at Bell Labs from 1979\u20131983. Brad Cox and Tom\nLove developed Objective-C from 1981\u20131983 at their company Stepstone. Subsequent\nstandards of the C language have added and extended features. In 1990, the International\nOrganization for Standardization (ISO)\/IEC 9899:1990 standard, referred to as C89\nor C90, was adopted. About every 10 years since, a new standard has been adopted;\nISO\/IEC 9899:1999 (referred to as C99) in 1999 and ISO\/IEC 9899:2011 (C11) in 2011.\n15.1. Getting Started: Hello World\nThe hallmark of an introduction to a new programming language is the Hello World!\nprogram. It consists of a simple program whose only purpose is to print out the message\n253 15. Basics\n#include<stdlib.h>\n1\n#include<stdio.h>\n2\n3\n\/**\n4\n* Basic Hello World program in C\n5\n* Prints \"Hello World\" to the standard output and exits\n6\n*\/\n7\nint main(int argc, char **argv) {\n8\n9\nprintf(\"Hello World\\n\");\n10\n11\nreturn 0;\n12\n}\n13\nCode Sample 15.1.: Hello World Program in C\n\u201cHello World!\u201d to the user in some manner. The simplicity of the program allows the focus\nto be on the basic syntax of the language. It is also typically used to ensure that your\ndevelopment environment, compiler, runtime environment, etc. are functioning properly\nwith a Minimum Working Example (MWE). The Hello World! program is generally\nattributed to Brian Kernighan who used it as an example of programming in C in 1974\n[25]. A basic Hello World! program in C can be found in Code Sample 15.1.\nWe will not focus on any particular development environment, code editor, or any\nparticularoperatingsystem,compiler,orancillarystandardsinourpresentation. However,\nas a first step, you should be able to write, compile, and run the above program on\nthe environment you intend to use for the rest of this book. This may require that you\ndownload and install a basic C compiler\/development environment (such as GCC, the\nGNU Compiler Collection on OSX\/Unix\/Linux, cygwin or MinGW for Windows) or a\nfull IDE (such as Xcode for OSX, or Code::Blocks, http:\/\/www.codeblocks.org\/ for\nWindows).\n15.2. Basic Elements\nUsing the Hello World! program as a starting point, we will now examine the basic\nelements of the C language.\n254 15.2. Basic Elements\n15.2.1. Basic Syntax Rules\nC is a highly influential programming language. Many modern programming languages\nhave adopted syntactic elements that originated in C. Usually such languages are referred\nto as \u201cC-style syntax\u201d languages. These elements include the following.\n\u2022 C is a statically typed language so variables must be declared along with their\ntypes before using them.\n\u2022 Strings are delimited with double quotes. Single characters, including special\nescaped characters are delimited by single quotes; \"this is a string\", and\nthese are characters: 'A', '4', '$' and '\\n'\n\u2022 Executable statements are terminated by a semicolon, ;\n\u2022 Code blocks are defined by using opening and closing curly brackets, { ... }.\nMoreover, code blocks can be nested: code blocks can be defined within other code\nblocks.\n\u2022 Variables are scoped to the code block in which they are declared and are only\nvalid within that code block.\n\u2022 In general, whitespace between coding elements is ignored.\nThough not a syntactic requirement, the proper use of whitespace is important for good,\nreadable code. Code inside code blocks is indented at the same indentation level. Nested\ncode blocks are indented further. Think of a typical table of contents or the outline of a\nformal paper or essay. Sections and subsections or points and subpoints all follow proper\nindentation with elements at the same level at the same indentation. This convention is\nused to organize code and make it more readable.\n15.2.2. Preprocessor Directives\nThe lines,\n#include<stdlib.h>\n1\n#include<stdio.h>\n2\nare preprocessor directives. Preprocessor directives are instructions to the compiler to\nmodify the source code before it starts to compile it. These particular lines are \u201cincluding\u201d\nstandard libraries of functions so that the program can use functionality that has already\n255 15. Basics\nbeen implemented for us.\nThe first, stdlib.h represents the C standard (std) library (lib). This library is so\nessential that many compilers will automatically include it even if you do not explicitly\ndo so in your program. Still, it is best practice to include it in your code.\nThe second, stdio.h is the standard (std) input\/output (io) library which contains\nbasic input\/output (I\/O) functions that we can use. In particular, the standard output\nfunction printf() is part of this library.\nFailure to include a library means that you will not be able to use the functions it\nprovides in your program. Using the functions without including the library may result in\na compiler error. The .h in the library names stands for \u201cheader\u201d; function declarations\nare typically contained in a header file while their definitions are placed in a source file\nof the same name. We\u2019ll explore this convention in detail when we look at functions in C\n(Chapter 18).\nThere are many other important standard libraries that we\u2019ll touch on as needed; of\nimmediate interest is the standard mathematics library, math.h. It includes many\nuseful functions to compute common mathematical functions such as the square root and\nnatural logarithm. Table 15.1 highlights several of these functions. To use them you\u2019d\ninclude the math library in your source file #include<math.h> and then \u201ccall\u201d them\nby providing input and assigning the output value to a variable. For example:\ndouble x = 1.5;\n1\ndouble y, z;\n2 \u221a \u221a\ny = sqrt(x); \/\/y now has the value x = 1.5\n3\nz = sin(x); \/\/z now has the value sin(x) = sin(1.5)\n4\nIn both of the function calls above, the value of the variable x is \u201cpassed\u201d to the math\nfunction which computes and \u201creturns\u201d the result which then gets assigned to another\nvariable.\nMacros\nAnother preprocessor directive establishes macros using the #define keyword. A macro\nis a single instruction that specifies a more complex set of instructions. The macro can\nbe used to define constants to be used throughout your program. To illustrate, consider\nthe following example.\n256 15.2. Basic Elements\nFunction Description\nabs(x) Absolute value for int variables, |x|a\nfabs(x) Absolute value for double variables\nceil(x) Ceiling function, (cid:100)46.3(cid:101) = 47.0\nfloor(x) Floor function, (cid:98)46.3(cid:99) = 46.0\ncos(x) Cosine functionb\nsin(x) Sine functionb\ntan(x) Tangent functionb\nexp(x) Exponential function, ex, e = 2.71828...\nlog(x) Natural logarithm, ln(x)c\nlog10(x) Logarithm base 10, log (x)c\n10\npow(x,y) The power function, computes xy\nsqrt(x) Square root functionc\nTable 15.1.: Several functions defined in the C standard math library. aThe absolute value\nfunction is actually in the standard library, stdlib.h. ball trigonometric\nfunctions assume input is in radians, not degrees. cInput is assumed to be\npositive, x > 0.\n257 15. Basics\n#define MILES_PER_KM 1.609\n1\nThe macro defines an \u201calias\u201d for the MILES_PER_KM identifier as the value 1.609. Essen-\ntially, the C preprocessor will go through the code and any instance of MILES_PER_KM\nwill be replaced with 1.609. The advantage of using a macro like this is that we can use\nthe identifier MILES_PER_KM throughout our program instead of magic numbers whose\nmeaning and intent may not be immediately clear. Moreover, if we want to change the\ndefinition (say make it more precise, using 1.60934 instead) then we only need to change\nthe macro instead of making the same change throughout our program.\nAs a stylistic note: macro constants in C are usually associated with uppercase underscore\ncasing as in our example. Also, the math standard library defines several macros for\n\u221a\ncommon mathematical constants such as \u03c0, e, and 2 (M_PI, M_E, and M_SQRT2\nrespectively) among others.\n15.2.3. Comments\nComments can be written in a C program either as a single line using two forward\nslashes, \/\/comment or as a multiline comment using a combination of forward slash\nand asterisk: \/* comment *\/ . With a single line comment, everything on the line\nafter the forward slashes is ignored. With a multiline comment, everything between the\nforward slash\/asterisk is ignored. Comments are ultimately ignored by the compiler so\nthe amount of comments do not have an effect on the final executable code. Consider\nthe following example.\n\/\/this is a single line comment\n1\nint x; \/\/this is also a single line comment, but after some code\n2\n3\n\/*\n4\nThis is a comment that can\n5\nspan multiple lines to format the comment\n6\nmessage more clearly\n7\n*\/\n8\ndouble y;\n9\nMost code editors and IDEs will present comments in a special color or font to distinguish\nthem from the rest of the code (just as our example above does). Failure to close a\n258 15.2. Basic Elements\nmultiline comment will likely result in a compiler error but with color-coded comments\nits easy to see the mistake visually.\n15.2.4. The main() Function\nEvery executable program starts its execution somewhere. In C, the starting point is the\nmain() function. When a program is compiled to an executable and the program is\ninvoked, the code in the main() function starts executing. In our example, the code\nbetween the two curly brackets defines the main() function. At the end of the function\nwe have a return statement. We\u2019ll examine return statements in detail when we\nexamine functions. The program is \u201creturning\u201d a zero value to the operating system.\nThe convention in C is that zero indicates \u201cno error occurred\u201d while a non-zero value\nis used to indicate that \u201csome\u201d error occurred (the value used is determined by system\nstandards such as the Portable Operating System Interface (POSIX) standard).\nIn addition, our main() function has two arguments: argc and argv which serve to\ncommunicate any command line arguments provided to the program (review Section\n2.4.4 for details). The first, argc is an integer that indicates the number of arguments\nprovided including the executable file name itself. The second, argv actually stores\nthe arguments as strings. We will understand the syntax later on, but for now we can\nat least understand how we might convert these arguments to different types such as\nintegers and floating point numbers.\nRecall that argv is the argument vector: it is an array (see Chapter 20) of the command\nline arguments. To access them, you can index them starting at zero, the first being\nargv[0], the second argv[1], etc. (the last one of course would be at argv[argc-1]).\nThe first one is always the name of the executable file being run. The remaining are the\ncommand line arguments provided by the user.\nTo convert them you can use two different functions, atoi() and atof() which are\nshort for alphanumeric to integer and floafing-point number respectively. An example:\n\/\/prints the first command line argument:\n1\nprintf(\"%s\\n\", argv[0]);\n2\n\/\/converts the \"second\" command line argument to an integer\n3\nint x = atoi(argv[1]);\n4\n\/\/converts the \"third\" command line argument to a double:\n5\ndouble y = atof(argv[2]);\n6\n259 15. Basics\n15.3. Variables\nAs previewed, the three primary primitive types supported in C are int, double, and\nchar which support integers, floating point numbers, and single ASCII characters.\nInteger (int) types are only guaranteed to \u201cbe at least\u201d 16 bytes by the C standard but\nare usually 32-bit signed integers on most modern systems.1 With a 32-bit signed int we\ncan represent integers in the range \u22122,147,483,648 to 2,147,483,647. Doubles (double)\ntypes are double-precision floating point numbers as per the IEEE 754 standard and\nprovide about 16 digits of precision.\nC provides a float (single precision floating point number) type and there are various\nmodifiers such as short, long, unsigned and signed that can be used, but these\nare either system-dependent or rely on later versions of the C standard (such as C99).\nWe will restrict our focus to more portable, interoperable code and stick with the basic\nint and double types in our code.\nFinally, the char type is typically a single byte that represents a single ASCII character.\nFor all intents and purposes a char can be treated as an integer in the range 0 to 127\n(or 255) as defined by the ASCII text table (see Table 2.4).\n15.3.1. Declaration & Assignment\nC is a statically typed language meaning that all variables must be declared before you\ncan use them or refer to them. In addition, when declaring a variable, you must specify\nboth its type and its identifier. For example:\nint numUnits;\n1\ndouble costPerUnit;\n2\nchar firstInitial;\n3\nEach declaration specifies the variable\u2019s type followed by the identifier and ending with\na semicolon. The identifier rules are fairly standard: a name can consist of lower and\nuppercase alphabetic characters, numbers, and underscores but may not begin with a\nnumeric character. We adopt the modern camelCasing naming convention for variables\nin our code.\nThe assignment operator is a single equal sign, = and is a right-to-left assignment. The\n1You may have to deal with 16-bit int types in legacy systems\/compilers or in modern embedded\nsystems.\n260 15.3. Variables\nvariable that we wish to assign the value to appears on the left-hand-side while the value\n(literal, variable or expression) is on the right-hand-size. Using our variables from before,\nwe can assign them values:\nnumUnits = 42;\n1\ncostPerUnit = 32.79;\n2\nfirstInitial = 'C';\n3\nAn important thing to understand and to keep in mind is: if you declare a variable but\ndo not assign it a value, its value is undefined. If we code something like int a;, the\nvalue of the variable a is not necessarily zero; depending on the system, it could contain\na special value that indicates \u201cuninitialized memory\u201d or it could contain garbage, or it\ncould have the value zero. The C standard does not specify default values for variables.\nThe default value of variables is highly system dependent\u2013on the compiler, the libraries,\nand even the operating system. You should not make any assumptions on the initial or\ndefault values of variables. If you need such assumptions, then values must be assigned.\nFor brevity, C allows you to declare a variable and immediately assign it a value on the\nsame line. Our example could be written more compactly written as follows.\nint numUnits = 42;\n1\ndouble costPerUnit = 32.79;\n2\nchar firstInitial = 'C';\n3\nAs another shorthand, we can declare multiple variables on the same line by delimiting\nthem with a comma. However, they must be of the same type. We can also use an\nassignment with them.\nint numOrders, numUnits = 42, numCustomers = 10, numItems;\n1\ndouble costPerUnit = 32.79, salesTaxRate;\n2\nAnother convenient keyword is const, short for \u201cconstant.\u201d We can apply it to any\nvariable to indicate that it is a read-only variable. Of course, we must assign it a value\nat declaration. For example:\n261 15. Basics\nconst int secret = 42;\n1\nconst double salesTaxRate = 0.075;\n2\nAny attempt to reassign the values of const variables will result in a compiler error.\n15.4. Operators\nC supports the standard arithmetic operators for addition, subtraction, multiplication,\nand division using +, -, *, and \/ respectively. Each of these operators is a binary\noperator that acts on two operands which can be literals, variables or expressions and\nfollow the usual rules of arithmetic when it comes to order of precedence (multiplication\nand division before addition and subtraction).\nint a = 10, b = 20, c = 30, d;\n1\nd = a + 5;\n2\nd = a + b;\n3\nd = a - b;\n4\nd = a + b * c;\n5\nd = a * b;\n6\nd = a \/ b; \/\/integer division and truncation! See below\n7\n8\ndouble x = 1.5, y = 3.4, z = 10.5, w;\n9\nw = x + 5.0;\n10\nw = x + y;\n11\nw = x - y;\n12\nw = x + y * z;\n13\nw = x * y;\n14\nw = x \/ y;\n15\n16\n\/\/you can do arithmetic with both types:\n17\nw = a + x;\n18\nd = b + y; \/\/truncation also occurs here!\n19\nSpecial care must be taken when dealing with int types. For all four operators, if\nboth operands are integers, the result will be an integer. For addition, subtraction, and\nmultiplication this isn\u2019t a big deal, but for division it means that when we divide, say\n262 15.5. Basic I\/O\n10 \/ 20, the result is not 0.5 as expected. The number 0.5 is a floating point number.\nAs such, the fractional part gets truncated (cut off and thrown out) leaving only zero. In\nthe code above, d = a \/ b; the variable d ends up getting the value zero because of\nthis.\nSimilarly, attempting to assign a floating point number to an integer also results in\ntruncationbecausean int typecannothandlethefractionalpart. Intheline d = b + y\nabove, b + y correctly evaluates as 20+3.4 = 23.4, but when assigned to the int\nvariable d the .4 gets truncated and d is assigned the value 23. Assigning an int\nvalue to a double variable is not a problem as the integer 2 implicitly becomes the\nfloating point number 2.0.\nA solution to this problem is to use explicit type casting to force at least one of the\noperands in an integer division to become a double type. For example:\nint a = 10, b = 20;\n1\ndouble x;\n2\n3\nx = (double) a \/ b;\n4\nresults in x getting the \u201ccorrect\u201d value of 0.5. This works because the (double) code\nforces the int variable a to temporarily be treated as a double variable (in this case\n10.0) for the purposes of division (so that truncation does not occur).\nC also supports the integer remainder operator using the % symbol. This operator gives\nthe remainder of the result of dividing two integers. Examples:\nint x;\n1\n2\nx = 10 % 5; \/\/x is 0\n3\nx = 10 % 3; \/\/x is 1\n4\nx = 29 % 5; \/\/x is 4\n5\n15.5. Basic I\/O\nThe standard I\/O library (stdio.h) contains many functions that facilitate input and\noutput including printf() for standard output and scanf() (scan formatted input)\n263 15. Basics\nfor standard input.\nThe printf() function works exactly as discussed in Section 2.4.3. The scanf()\nfunction works using similar placeholders as printf(). To illustrate how it works,\nconsider the following lines of code:\nint a;\n1\nprintf(\"Please enter a number: \");\n2\nscanf(\"%d\", &a);\n3\nThe printf() statement prompts the user for an input. The scanf() then executes\nand the program waits for the user to enter input. The user is free to start typing. When\nthe user is done, they hit the enter key at which point the program resumes and reads\nthe input from the standard input buffer, converts the value entered by the user into\nan integer and places the result in the variable a where it can now be used by the\nremainder of the program.\nA few points of interest. First, the same placeholder as printf() was used, %d for\nint values. However, when we \u201cpassed\u201d the variable a to scanf() we placed an\nampersand, & in front of it. This is passing the variable by reference and we\u2019ll explore\nthat concept further in Chapter 18, but for now just know that when using variables\nwith scanf(), an ampersand is required. Failure to place an ampersand in front of\na variable with scanf() will likely result in a segmentation fault (an illegal memory\naccess).\nYou can use the same placeholder, %c with scanf() to read in a single character as\nwell. However, for floating point numbers, in particular double types, the placeholder\n%lf must be used (which stands for long float, a double precision number). Failure to\nuse the correct placeholder may result in garbage results as the input will be interpreted\nincorrectly. Another example:\ndouble x;\n1\nprintf(\"Please enter a fractional number: \");\n2\nscanf(\"%lf\", &x);\n3\nAnother potential problem is that scanf() expects a certain format (thus its name).\nIf we prompt the user for a number but they just start mashing the keyboard giving\nnon-numerical input, we may get incorrect results. scanf() will interpret the input as\nzero. It may be very difficult to distinguish between the case of a user actually entering\n264 15.6. Examples\nin zero as a legitimate input versus bad input. In general, scanf() is not a good\nmechanism for reading input (and in fact can be very dangerous), but it does provide a\ngood starting point.\n15.6. Examples\n15.6.1. Converting Units\nLet\u2019s write a program that will prompt the user to enter a temperature in degrees\nFahrenheit and convert it to degrees Celsius using the formula\n5\nC = (F \u221232)\u00b7\n9\nWe begin with the basic program outline which will include preprocessor directives to\nbring in the standard library and the standard input\/output library (we\u2019ll need to prompt\nfor input and print the result as output to the user). Further, we want our program\nto be executable, so we need to put our code into the main() function. Finally, we\u2019ll\ndocument our program to indicate its purpose.\n#include<stdlib.h>\n1\n#include<stdio.h>\n2\n3\n\/**\n4\n* This program converts Fahrenheit temperatures to\n5\n* Celsius\n6\n*\/\n7\nint main(int argc, char **argv) {\n8\n9\n\/\/TODO: implement this\n10\n11\nreturn 0;\n12\n}\n13\nIt is common for programmers to use a comment along with a TODO note to themselves\nas a reminder of things that they still need to implement in a program.\nLet\u2019s first outline the basic steps that our program will go through:\n1. We\u2019ll first prompt the user for input, asking them for a temperature in Fahrenheit\n265 15. Basics\n2. Next we\u2019ll read the user\u2019s input, likely into a floating point number as degrees can\nbe fractional\n3. Once we have the input, we can calculate the degrees Celsius by using the formula\nabove\n4. Lastly, we will want to print the result to the user to inform them of the value\nSometimes its helpful to write an outline of such a program directly in the code using\ncomments to provide a step-by-step process. For example:\n#include<stdlib.h>\n1\n#include<stdio.h>\n2\n3\n\/**\n4\n* This program converts Fahrenheit temperatures to\n5\n* Celsius\n6\n*\/\n7\nint main(int argc, char **argv) {\n8\n9\n\/\/TODO: implement this\n10\n\/\/1. Prompt the user for input in Fahrenheit\n11\n\/\/2. Read the Fahrenheit value from the standard input\n12\n\/\/3. Compute the degrees Celsius\n13\n\/\/4. Print the result to the user\n14\n15\nreturn 0;\n16\n}\n17\nAs we read each step it becomes apparent that we\u2019ll need a couple of variables: one to\nhold the Fahrenheit (input) value and one for the Celsius (output) value. It also makes\nsense that each of these should be double variables as we want to support fractional\nvalues. So at the top of our main() function, we\u2019ll add the variable declarations:\ndouble fahrenheit, celsius;\nEach of the steps is now straightforward; we\u2019ll use a printf() statement in the first\nstep to prompt the user for input:\nprintf(\"Please enter degrees in Fahrenheit: \");\nIn the second step, we\u2019ll use the standard input to read the fahrenheit variable value\nfrom the user. Recall that we use the placeholder %lf for reading double values and\n266 15.6. Examples\nuse an ampersand when using scanf():\nscanf(\"%lf\", &fahrenheit);\nWe can now compute celsius using the formula provided:\ncelsius = (fahrenheit - 32) * (5 \/ 9);\nFinally, we use printf() again to output the result to the user:\nprintf(\"%f Fahrenheit is %f Celsius\\n\", fahrenheit, celsius);\nTry typing and running the program as defined above and you\u2019ll find that you don\u2019t\nget correct answers. In fact, you\u2019ll find that no matter what values you enter, you get\nzero. This is because of the calculation using 5 \/ 9: recall what happens with integer\ndivision: truncation! This will always end up being zero.\nOne way we could fix it would be to pull out our calculators and find that 5 = 0.55555...\n9\nand replace 5\/9 with 0.555555. But, how many fives? It may be difficult to tell how\naccurate we can make this floating point number by hardcoding it ourselves. A much\nbetter approach would be to let the compiler take care of the optimal computation for us\nby making at least one of the numbers a double to prevent integer truncation. That is,\nwe should instead use 5.0 \/ 9. The full program can be found in Code Sample 15.2.\n15.6.2. Computing Quadratic Roots\nSome programs require the user to enter multiple inputs. The prompt-input process can\nbe repeated. In this example, consider asking the user for the coefficients, a,b,c to a\nquadratic polynomial,\nax2 +bx+c\nand computing its roots using the quadratic formula,\n\u221a\n\u2212b\u00b1 b2 \u22124ac\nx =\n2a\nAs before, we can create a basic program with a main() function and start filling in\nthe details. In particular, we\u2019ll need to prompt for the input a, then read it in; then\nprompt for b, read it in and repeat for c. We\u2019ll also need several variables: three for the\ncoefficients a,b,c and two more; one for each root. Thus, we have\ndouble a, b, c, root1, root2;\n1\n2\nprintf(\"Please enter a: \");\n3\nscanf(\"%lf\", &a);\n4\n267 15. Basics\n#include<stdlib.h>\n1\n#include<stdio.h>\n2\n3\n\/**\n4\n* This program converts Fahrenheit temperatures to\n5\n* Celsius\n6\n*\/\n7\nint main(int argc, char **argv) {\n8\n9\ndouble fahrenheit, celsius;\n10\n11\n\/\/1. Prompt the user for input in Fahrenheit\n12\nprintf(\"Please enter degrees in Fahrenheit: \");\n13\n14\n\/\/2. Read the Fahrenheit value from the standard input\n15\nscanf(\"%lf\", &fahrenheit);\n16\n17\n\/\/3. Compute the degrees Celsius\n18\ncelsius = (fahrenheit - 32) * 5.0\/9;\n19\n20\n\/\/4. Print the result to the user\n21\nprintf(\"%f Fahrenheit is %f Celsius\\n\", fahrenheit, celsius);\n22\n23\nreturn 0;\n24\n}\n25\nCode Sample 15.2.: Fahrenheit-to-Celsius Conversion Program in C\nprintf(\"Please enter b: \");\n5\nscanf(\"%lf\", &b);\n6\nprintf(\"Please enter c: \");\n7\nscanf(\"%lf\", &c);\n8\nNow to compute the roots: we need to take care that we correctly adapt the formula so\nit accurately reflects the order of operations. We also need to use the standard math\nlibrary\u2019s square root function (unless you want to write your own!2 Carefully adapting\n2We will write several square root methods as exercises later!\n268 15.6. Examples\nthe formula leads to\nroot1 = (-b + sqrt(b*b - 4*a*c) ) \/ (2*a);\n1\nroot2 = (-b - sqrt(b*b - 4*a*c) ) \/ (2*a);\n2\nFinally, we print the output using printf(). The full program can be found in Code\nSample 15.3.\n#include<stdlib.h>\n1\n#include<stdio.h>\n2\n#include<math.h>\n3\n4\n\/**\n5\n* This program computes the roots to a quadratic equation\n6\n* using the quadratic formula.\n7\n*\/\n8\nint main(int argc, char **argv) {\n9\n10\ndouble a, b, c, root1, root2;\n11\n12\nprintf(\"Please enter a: \");\n13\nscanf(\"%lf\", &a);\n14\nprintf(\"Please enter b: \");\n15\nscanf(\"%lf\", &b);\n16\nprintf(\"Please enter c: \");\n17\nscanf(\"%lf\", &c);\n18\n19\nroot1 = (-b + sqrt(b*b - 4*a*c) ) \/ (2*a);\n20\nroot2 = (-b - sqrt(b*b - 4*a*c) ) \/ (2*a);\n21\n22\nprintf(\"The roots of %fx^2 + %fx + %f are: \\n\", a, b, c);\n23\nprintf(\" root1 = %f\\n\", root1);\n24\nprintf(\" root2 = %f\\n\", root2);\n25\nreturn 0;\n26\n}\n27\nCode Sample 15.3.: Quadratic Roots Program in C\nThis program was interactive. As an alternative, we could have read all three of the\n269 15. Basics\ninputs as command line arguments, converting them to floating point numbers. Lines\n12\u201317 in the program could have been changed to\na = atof(argv[1]);\n1\nb = atof(argv[2]);\n2\nc = atof(argv[3]);\n3\nFinally, think about the possible inputs a user could provide that may cause problems\nfor this program. For example:\n\u2022 What if the user entered zero for a?\n\u2022 What if the user entered some combination such that b2 < 4ac?\n\u2022 What if the user entered non-numeric values?\n\u2022 For the command line argument version, what if the user provided less than three\narguments? Or more?\nHow might we prevent the consequences of such bad inputs? How might we handle the\nevent that a user enters bad input and how do we communicate these errors to the user?\nTo begin to resolve these issues, we\u2019ll need conditionals.\n270 16. Conditionals\nC supports the basic if, if-else, and if-else-if conditional structures as well as switch\nstatements. Logical statements are built using the standard logical operators for numeric\ncomparisons as well as logical operators such as negation, And, and Or. However, there\nare a few idiosyncrasies that need to be understood.\n16.1. Logical Operators\nC has no built-in Boolean type, nor does it have any keywords associated with true and\nfalse. Instead, C uses numeric types as implicit Boolean types with the convention that\nzero is associated with false and any non-zero value is associated with true. So the values\n1, 2.5, and even negatives, \u22121, \u2212123.2421, etc. are all interpreted as true when used in\nlogical statements.\nThe standard numeric comparison operators are also supported. Consider the following\ncode snippet:\nint a = 10;\n1\nint b = 20;\n2\nint c = 10;\n3\nint d = 0;\n4\nThe six standard comparison operators are presented in Table 16.1 using these variables\nas examples. The comparison operators are the same when used with double types as\nwell and int types can be compared with each other without type casting. The three\nbasic logical operators are also supported as described in Table 16.2 using the same code\nsnippet variable values as examples.\n271 16. Conditionals\nName Operator Syntax Examples Value\nEquals == a == 10 true\nb == 10 false\na == b false\na == c true\nNot Equals != a != 10 false\nb != 10 true\na != b true\na != c false\nStrictly Less Than < a < 15 true\na < 5 false\na < b true\na < c false\nLess Than Or Equal To <= a <= 15 true\na <= 5 false\na <= b true\na <= c true\nStrictly Greater Than > a > 15 false\na > 5 true\na > b false\na > c false\nGreater Than Or Equal To >= a >= 15 false\na >= 5 true\na >= b false\na >= c true\nTable 16.1.: Comparison Operators in C\nOperator Operator Syntax Examples Values\nNegation ! !a false\n!d true\nAnd && a && b true\na && d false\nOr || a || b true\n!a || d false\nTable 16.2.: Logical Operators in C\n272 16.1. Logical Operators\nOperator(s) Associativity Notes\nHighest ++, -- left-to-right increment operators\n-, ! right-to-left unary negation operator, logical\nnot\n*, \/, % left-to-right\n+, - left-to-right addition, subtraction\n<, <=, >, >= left-to-right comparison\n==, != left-to-right equality, inequality\n&& left-to-right logical And\n|| left-to-right logical Or\nLowest =, +=, -=, *=, \/= right-to-left assignment and compound assign-\nment operators\nTable 16.3.: Operator Order of Precedence in C. Operators on the same level have\nequivalent order and are performed in the associative order specified.\n16.1.1. Order of Precedence\nAt this point it is worth summarizing the order of precedence of all the operators that\nwe\u2019ve seen so far including assignment, arithmetic, comparison, and logical. Since all of\nthese operators could be used in one statement, for example,\n(b*b < 4*a*c || a == 0 || argc != 4)\nit is important to understand the order in which each one gets evaluated. Table 16.3\nsummarizestheorderofprecedencefortheoperatorsseensofar. Thisisnotanexhaustive\nlist of C operators.\n16.1.2. Comparing Strings and Characters\nThe comparison operators in Table 16.1 can also be used for single characters because\nof the nature of the ASCII text table (see Table 2.4). Each alphanumeric character,\nincluding the various symbols and whitespace characters, is associated with an integer 0\u2013\n127. We can therefore write statements like ('A' < 'a'), which is true since uppercase\nletters are ordered before lowercase letters in the ASCII table ('A' is 65 and 'a' is 97\nand so 65 < 97 is true). Several more examples can be found in Table 16.4.\nNumeric comparison operators cannot be used to compare strings in C. For example,\nwe could write (\"aardvark\" < \"zebra\") which would be valid C, and it would even\nhave a result. However, that result wouldn\u2019t necessarily be true or false. The reason for\nthis is that strings in C are actually represented as arrays, which in turn are represented\nas memory locations. We\u2019ll explore these issues in greater depth later on, but for now\n273 16. Conditionals\nComparison Example Result\n('A' < 'a') true\n('A' == 'a') false\n('A' < 'Z') true\n('0' < '9') true\n('\\n' < 'A') true\n(' ' < '\\n') false\nTable 16.4.: Character comparisons in C\nunderstand that you can write this code, it will compile, and it will even run. However,\nthe results will not be as expected.\n16.2. If, If-Else, If-Else-If Statements\nConditional statements in C utilize the keywords if, else, and else if. Condi-\ntions are placed inside parentheses immediately after the if and else if keywords.\nExamples of all three can be found in Code Sample 16.1.\nSome observations about the syntax: the statement, if(x < 10) does not have a\nsemicolon at the end. This is because it is a conditional statement that determines\nthe flow of control and not an executable statement. Therefore, no semicolon is used.\nSuppose we made a mistake and did include a semicolon:\nint x = 15;\n1\nif(x < 10); {\n2\nprintf(\"x is less than 10\\n\");\n3\n}\n4\nSome compilers may give a warning, but this is valid C; it will compile and it will run.\nHowever, it will end up printing x is less than 10, even though x = 15! Recall that\na conditional statement binds to the executable statement or code block immediately\nfollowing it. In this case, we\u2019ve provided an empty executable statement ended by the\nsemicolon. The code is essentially equivalent to\nint x = 15;\n1\nif(x < 10) {\n2\n}\n3\n274 16.2. If, If-Else, If-Else-If Statements\n\/\/example of an if statement:\n1\nif(x < 10) {\n2\nprintf(\"x is less than 10\\n\");\n3\n}\n4\n5\n\/\/example of an if-else statement:\n6\nif(x < 10) {\n7\nprintf(\"x is less than 10\\n\");\n8\n} else {\n9\nprintf(\"x is 10 or more \\n\");\n10\n}\n11\n12\n\/\/example of an if-else-if statement:\n13\nif(x < 10) {\n14\nprintf(\"x is less than 10\\n\");\n15\n} else if(x == 10) {\n16\nprintf(\"x is equal to ten\\n\");\n17\n} else {\n18\nprintf(\"x is greater than 10\\n\");\n19\n}\n20\nCode Sample 16.1.: Examples of Conditional Statements in C\n275 16. Conditionals\nprintf(\"x is less than 10\\n\");\n4\nThis is obviously not what we wanted. The semicolon ended up binding to the empty\nexecutable statement. The code block containing the print statement immediately\nfollowed, but it was not bound to the conditional statement which is why the print\nstatement executed regardless of the value of x.\nAnother convention that we\u2019ve used in our code is where we have placed the curly brackets.\nFirst, if a conditional statement is bound to only one statement, the curly brackets are\nnot necessary. However, it is best practice to include them even if they are not necessary\nand we\u2019ll follow this convention. Second, the opening curly bracket is on the same line as\nthe conditional statement while the closing curly bracket is indented to the same level\nas the start of the conditional statement. Moreover, the code inside the code block is\nindented. If there were more statements in the block, they would have all been at the\nsame indentation level.\n16.3. Examples\n16.3.1. Computing a Logarithm\nThe logarithm of x is the exponent that some base must be raised to get x. The most\ncommon logarithm is the natural logarithm, ln(x) which is base e = 2.71828.... But\nlogarithms can be in any base b > 1.1 What if we wanted to compute log (x)? Or\n2\nlog (x)? Let\u2019s write a program that will prompt the user for a number x and a base b\n\u03c0\nand computes log (x).\nb\nArbitrary bases can be computed using the change of base formula:\nlog (x)\nlog (x) = a\nb log (b)\na\nIf we can compute some base a, then we can compute any base b. Fortunately we have\nsuch a solution. Recall that the standard library provides a function to compute the\nnatural logarithm, log()). This is one of the fundamentals of problems solving: if a\nsolution already exists, use it. In this case, a solution exists for a different, but similar\nproblem (computing the natural logarithm), but we can adapt the solution using the\nchange of base formula. In particular, if we have variables b (base) and x, we can\ncompute log (x) using\nb\n1Bases can also be 0<b<1, but we\u2019ll restrict our attention to increasing functions only.\n276 16.3. Examples\nlog(x) \/ log(b)\nBut wait: we have a problem similar to the examples in the previous section. The user\ncould enter invalid values such as b = \u221210 or x = \u22122.54 (logarithms are undefined\nfor non-positive values in any base). We want to ensure that b > 1 and x > 0. With\nconditionals, we can now do this. Once we have read in the input from the user we can\nmake a check for good input using an if statement.\nif(x <= 0 || b <= 1) {\n1\nprintf(\"Error: bad input!\\n\");\n2\nexit(1);\n3\n}\n4\nThis code has something new: exit(1). The exit() function immediately terminates\nthe program regardless of the rest of the code that it may remain. The argument passed\nto exit is an integer that represents an error code. The convention is that zero indicates\n\u201cno error\u201d while non-zero values indicate some error. This is a simple way of performing\nerror handling: if the user provides bad input, we inform them and quit the program,\nforcing them to run it again and provide good input. By prematurely terminating the\nprogram we avoid any illegal operation that would give a bad result.\nAlternatively, we could have split the conditions into two statements and given more\ndescriptive error messages. We use this design in the full program which can be found in\nCode Sample 16.2. The program also takes the input as command line arguments. Now\nthat we have conditionals, we can actually check that the correct number of arguments\nwas provided by the user and quit in the event that they don\u2019t provide the correct\nnumber.\n16.3.2. Life & Taxes\nLet\u2019s adapt the conditional statements we developed in Section 3.6.4 into a full C program.\nThe first thing we need to do is establish the variables we\u2019ll need and read them in from\nthe user. At the same time we can check for bad input (negative values) for both the\ninputs.\ndouble income, baseTax, numChildren, credit, totalTax;\n1\n2\nprintf(\"Please enter your Adjusted Gross Income: \");\n3\nscanf(\"%lf\", &income);\n4\n5\n277 16. Conditionals\nprintf(\"How many children do you have?\");\n6\nscanf(\"%d\", &numChildren);\n7\n8\nif(income < 0 || numChildren < 0) {\n9\nprintf(\"Invalid inputs\");\n10\nexit(1);\n11\n}\n12\nNext, we can code a series of if-else-if statements for the income range. By placing the\nranges in increasing order, we only need to check the upper bounds just as in the original\nexample.\nif(income <= 18150) {\n1\nbaseTax = income * .10;\n2\n} else if(income <= 73800) {\n3\nbaseTax = 1815 + (income - 18150) * .15;\n4\n} else if(income <= 148850) {\n5\n...\n6\n} else {\n7\nbaseTax = 127962.50 + (income - 457600) * .396;\n8\n}\n9\nNext we compute the child tax credit, taking care that it does not exceed $3,000. A\nconditional based on the number of children suffices as at this point in the program we\nalready know it is zero or greater.\nif(numChildren <= 3) {\n1\ncredit = numChildren * 1000;\n2\n} else {\n3\ncredit = 3000;\n4\n}\n5\nFinally, we need to ensure that the credit does not exceed the total tax liability (the\ncredit is non-refundable, so if the credit is greater, the tax should only be zero, not\nnegative).\n278 16.3. Examples\nif(baseTax - credit >= 0) {\n1\ntotalTax = baseTax - credit;\n2\n} else {\n3\ntotalTax = 0;\n4\n}\n5\nThe full program is presented in Code Sample 16.3.\n16.3.3. Quadratic Roots Revisited\nLet\u2019sreturntothequadraticrootsprogramwepreviouslydesignedthatusesthequadratic\nequation to compute the roots of a quadratic polynomial by reading coefficients a,b,c\nin from the user. One of the problems we had previously identified is if the user enters\n\u201cbad\u201d input: if a = 0, we would end up dividing by zero; if b2 \u22124ac < 0 then we would\nhave complex roots. With conditionals, we can now check for these issues and exit with\nan error message.\nAnother potential case we might want to handle differently is when there is only one\ndistinct root (b2 \u22124ac = 0). In that case, the quadratic formula simplifies to \u2212b and we\n2a\ncan print a different, more specific message to the user. The full program can be found\nin Code Sample 16.4.\n279 16. Conditionals\n#include<stdlib.h>\n1\n#include<stdio.h>\n2\n#include<math.h>\n3\n4\n\/**\n5\n* This program computes the logarithm base b (b > 1)\n6\n* of a given number x > 0\n7\n*\/\n8\nint main(int argc, char **argv) {\n9\n10\ndouble b, x, result;\n11\nif(argc != 3) {\n12\nprintf(\"Usage: %s b x \\n\", argv[0]);\n13\nexit(1);\n14\n}\n15\n16\nb = atof(argv[1]);\n17\nx = atof(argv[2]);\n18\n19\nif(x <= 0) {\n20\nprintf(\"Error: x must be greater than zero\\n\");\n21\nexit(1);\n22\n}\n23\nif(b <= 1) {\n24\nprintf(\"Error: base must be greater than one\\n\");\n25\nexit(1);\n26\n}\n27\n28\nresult = log(x) \/ log(b);\n29\nprintf(\"log_(%f)(%f) = %f\\n\", b, x, result);\n30\nreturn 0;\n31\n}\n32\nCode Sample 16.2.: Logarithm Calculator Program in C\n280 16.3. Examples\n1 #include<stdlib.h>\n2 #include<stdio.h>\n3\n4 int main(int argc, char **argv) {\n5\n6 double income, baseTax, credit, totalTax;\n7 int numChildren;\n8\n9 \/\/prompt for income from the user\n10 printf(\"Please enter your Adjusted Gross Income: \");\n11 scanf(\"%lf\", &income);\n12\n13 \/\/prompt for children\n14 printf(\"How many children do you have?\");\n15 scanf(\"%d\", &numChildren);\n16\n17 if(income < 0 || numChildren < 0) {\n18 printf(\"Invalid inputs\");\n19 exit(1);\n20 }\n21\n22 if(income <= 18150) {\n23 baseTax = income * .10;\n24 } else if(income <= 73800) {\n25 baseTax = 1815 + (income -18150) * .15;\n26 } else if(income <= 148850) {\n27 baseTax = 10162.50 + (income - 73800) * .25;\n28 } else if(income <= 225850) {\n29 baseTax = 28925.00 + (income - 148850) * .28;\n30 } else if(income <= 405100) {\n31 baseTax = 50765.00 + (income - 225850) * .33;\n32 } else if(income <= 457600) {\n33 baseTax = 109587.50 + (income - 405100) * .35;\n34 } else {\n35 baseTax = 127962.50 + (income - 457600) * .396;\n36 }\n37\n38 if(numChildren <= 3) {\n39 credit = numChildren * 1000;\n40 } else {\n41 credit = 3000;\n42 }\n43\n44 if(baseTax - credit >= 0) {\n45 totalTax = baseTax - credit;\n46 } else {\n47 totalTax = 0;\n48 }\n49\n50 printf(\"AGI: $%10.2f\\n\", income);\n51 printf(\"Tax: $%10.2f\\n\", baseTax);\n52 printf(\"Credit: $%10.2f\\n\", credit);\n53 printf(\"Tax Liability: $%10.2f\\n\", totalTax);\n54\n55 return 0;\n56 }\nCode Sample 16.3.: Tax Program in C\n281 16. Conditionals\n#include<stdlib.h>\n1\n#include<stdio.h>\n2\n#include<math.h>\n3\n4\n\/**\n5\n* This program computes the roots to a quadratic equation\n6\n* using the quadratic formula.\n7\n*\/\n8\nint main(int argc, char **argv) {\n9\n10\ndouble a, b, c, root1, root2;\n11\n12\nif(argc !=4) {\n13\nprintf(\"Usage: %s a b c\\n\", argv[0]);\n14\nexit(1);\n15\n}\n16\n17\na = atof(argv[1]);\n18\nb = atof(argv[2]);\n19\nc = atof(argv[3]);\n20\n21\nif(a == 0) {\n22\nprintf(\"Error: a cannot be zero\\n\");\n23\nexit(1);\n24\n} else if(b*b < 4*a*c) {\n25\nprintf(\"Error: cannot handle complex roots\\n\");\n26\nexit(1);\n27\n} else if(b*b == 4*a*c) {\n28\nroot1 = -b \/ (2*a);\n29\nprintf(\"Only one distinct root: %f\\n\", root1);\n30\n} else {\n31\nroot1 = (-b + sqrt(b*b - 4*a*c) ) \/ (2*a);\n32\nroot2 = (-b - sqrt(b*b - 4*a*c) ) \/ (2*a);\n33\n34\nprintf(\"The roots of %fx^2 + %fx + %f are: \\n\", a, b, c);\n35\nprintf(\" root1 = %f\\n\", root1);\n36\nprintf(\" root2 = %f\\n\", root2);\n37\n}\n38\nreturn 0;\n39\n}\n40\nCode Sample 16.4.: Quadratic Roots Program in C With Error Checking\n282 17. Loops\nC supports while loops, for loops, and do-while loops using the keywords while, for,\nand do (along with another while). Continuation conditions for loops are enclosed\nin parentheses, (...) and the blocks of code associated with the loop are enclosed in\ncurly brackets.\n17.1. While Loops\nCode Sample 17.1 contains an example of a basic while loop in C. Just as with conditional\nstatements, our code styling places the opening curly bracket on the same line as the\nwhile keyword and continuation condition. The inner block of code is also indented\nand all lines in the block are indented to the same level.\nIn addition, the continuation condition does not contain a semicolon since it is not an\nexecutable statement. Just as with an if-statement, if we had placed a semicolon it would\nhave led to unintended results. Consider the following:\nwhile(i <= 10); {\n1\n\/\/perform some action\n2\ni++; \/\/iteration\n3\n}\n4\nint i = 1; \/\/Initialization\n1\nwhile(i <= 10) { \/\/continuation condition\n2\n\/\/perform some action\n3\ni++; \/\/iteration\n4\n}\n5\nCode Sample 17.1.: While Loop in C\n283 17. Loops\nint i = 1;\n1\nint flag = 1;\n2\nwhile(flag) {\n3\n\/\/perform some action\n4\ni++; \/\/iteration\n5\nif(i>10) {\n6\nflag = 0;\n7\n}\n8\n}\n9\nCode Sample 17.2.: Flag-controlled While Loop in C\nA similar problem occurs: the while keyword and continuation condition bind to\nthe next executable statement or code block. As a consequence of the semicolon, the\nexecutable statement that gets bound to the while loop is empty. What happens is\neven worse: the program will enter an infinite loop. To see this, the code is essentially\nequivalent to the following:\nwhile(i <= 10) {\n1\n}\n2\n{\n3\n\/\/perform some action\n4\ni++; \/\/iteration\n5\n}\n6\nIn the while loop, we never increment the counter variable i, the loop does nothing,\nand so the computation will continue on forever! Some compilers may warn you about\nthis, others will not. It is valid C and it will compile and run, but obviously won\u2019t work\nas intended. Avoid this problem by using proper syntax and good style.\nAnother common use case for a while loop is a flag-controlled loop in which we use a\nBoolean flag rather than an expression to determine if a loop should continue or not.\nRecall that in C, zero is treated as false and any non-zero numeric value is treated as\ntrue. We can thus create an implicit Boolean flag by using an integer variable and setting\nit to 1 for true and 0 for false (when we want the loop to terminate). An example can\nbe found in Code Sample 17.2.\n284 17.2. For Loops\n17.2. For Loops\nFor loops in C use the familiar syntax of placing the initialization, continuation condition,\nand iteration on the same line as the keyword for. An example can be found in Code\nSample 17.3.\nint i;\n1\nfor(i=1; i<=10; i++) {\n2\n\/\/perform some action\n3\n}\n4\nCode Sample 17.3.: For Loop in C\nSemicolons are placed at the end of the initialization and continuation condition, but not\nthe iteration statement. Just as with while loops, the opening curly bracket is placed on\nthe same line as the for keyword. Code within the loop body is indented, all at the\nsame indentation level.\nAnother observation is that we declared the index variable i prior to the for loop.\nSome languages allow you to declare the index variable in the initialization statement,\nfor example for(int i=1; i<=10; i++). Doing so scopes the index variable to the\nloop and so i would be out-of-scope before and after the loop body. This is a nice\nconvenience and is generally good practice. However, C89 and prior standards do not\nallow you to do this; the variable must be declared prior to the loop structure. C99 and\nnewer standards do allow you to do this and some compilers will be somewhat forgiving\nwhen you use the newer syntax (by supporting their own non-standard extensions to C).\nFor maximum portability, we\u2019ll follow the older convention.\n17.3. Do-While Loops\nC supports do-while loops. Recall that the difference between a while loop and a do-while\nloop is when the continuation condition is checked. For a while loop it is prior to the\nbeginning of the loop body and in a do-while loop it is at the end of the loop. This\nmeans that a do-while always executes at least once. An example can be found in Code\nSample 17.4.\nNote the syntax and style: the opening curly bracket is again on the same line as the\nkeyword do. The while keyword and continuation condition are on the same line\nas the closing curly bracket. In a slight departure from prior syntax, a semicolon does\n285 17. Loops\nint i;\n1\ndo {\n2\n\/\/perform some action\n3\ni++;\n4\n} while(i<=10);\n5\nCode Sample 17.4.: Do-While Loop in C\nappear at the end of the continuation condition even though it is not an executable\nstatement.\n17.4. Other Issues\nC does not support a traditional foreach loop. When iterating over a collection like an\narray, you iterate an index variable, typically with a for loop. However, there are some\nsyntactic tricks that you can use to get the same effect. Some of this will be a preview of\nChapter 20 where we discuss arrays in C, but in short, you can assign a variable to an\nelement in an array in iteration statement:\ndouble arr[] = {1.41, 2.71, 3.14};\n1\nint n = 3;\n2\nint i = 0;\n3\ndouble x;\n4\nfor(x=arr[0]; i<n; x=arr[++i]) {\n5\n\/\/x now holds the i-th element in arr\n6\n}\n7\nThe initialization sets the variable x to the first element in the array, arr[0]. The\nloop continues for as many elements as there are in the array, n. The iteration does two\nthings: it assigns x to the next element in the array while at the same time incrementing\nthe index variable using the prefix increment operator (see Section 2.3.6).\n286 17.5. Examples\n17.5. Examples\n17.5.1. Normalizing a Number\nLet\u2019srevisittheexamplefromSection4.1.1inwhichwenormalize anumberbycontinually\ndividing it by 10 until it is in the range [1,10). The code in Code Sample 17.5 specifically\nrefers to the value 32145.234 but would work equally well with any non-negative value of\nx.\ndouble x = 32145.234;\n1\nint k = 0;\n2\nwhile(x > 10) {\n3\nx = x \/ 10; \/\/or: x \/= 10;\n4\nk++;\n5\n}\n6\nCode Sample 17.5.: Normalizing a Number with a While Loop in C\n17.5.2. Summation\nLet\u2019s revisit the example from Section 4.2.1 in which we computed the sum of integers\n1+2+\u00b7\u00b7\u00b7+10. The code is presented in Code Sample 17.6\nint i;\n1\nint sum = 0;\n2\nfor(i=1; i<=10; i++) {\n3\nsum += i;\n4\n}\n5\nCode Sample 17.6.: Summation of Numbers using a For Loop in C\nOf course we could easily have generalized the code somewhat. Instead of computing a\nsum up to a particular number, we could have written it to sum up to another variable\nn, in which case the for loop would instead look like the following.\n287 17. Loops\nfor(i=1; i<=n; i++) {\n1\nsum += i;\n2\n}\n3\n17.5.3. Nested Loops\nRecall that you can write loops within loops. The inner loop will execute fully for each\niteration of the outer loop. An example of two nested of loops in C can be found in Code\nSample 17.7.\nint i, j;\n1\nint n = 10;\n2\nint m = 20;\n3\nfor(i=0; i<n; i++) {\n4\nfor(j=0; j<m; j++) {\n5\nprintf(\"(i, j) = (%d, %d)\\n\", i, j);\n6\n}\n7\n}\n8\nCode Sample 17.7.: Nested For Loops in C\nThe inner loop executes for j = 0,1,2,...,19 < m = 20 for a total of 20 itera-\ntions. However, it executes 20 times for each iteration of the outer loop. Since\nthe outer loop executes for i = 0,1,2,...,9 < n = 10, the total number of times\nthe printf() statement execute is 10 \u00d7 20 = 200. In this example, the sequence\n(0,0),(0,1),(0,2),...,(0,19),(1,0),...,(9,19) will be printed.\n17.5.4. Paying the Piper\nLet\u2019s adapt the solution for the loan amortization schedule we developed in Section 4.7.3.\nFirst, we\u2019ll read the principle, terms, and interest as command line inputs. Adapting the\nformula for the monthly payment and using the standard math library\u2019s pow() function,\nwe get\n288 17.5. Examples\ndouble monthlyPayment = (monthlyInterestRate * principle) \/\n1\n(1 - pow( (1 + monthlyInterestRate), -n));\n2\nHowever, recall that we may have problems due to accuracy. The monthly payment\ncould come out to be a fraction of a cent, say $43.871. For accuracy, we need to ensure\nthat all of the figures for currency are rounded to the nearest cent. The standard math\nlibrary does have a round() function, but it only rounds to the nearest whole number,\nnot the nearest 100th.\nHowever, we can adapt the \u201coff-the-shelf\u201d solution to fit our needs. If we take the number,\nmultiply it by 100, we get (say) 4387.1 which we can now round to the nearest whole\nnumber, giving us 4387. We can then divide by 100 to get a number that has been\nrounded to the nearest 100th! In C, we could simply do the following.\nmonthlyPayment = round(monthlyPayment * 100.0) \/ 100.0;\nWe can use the same trick to round the monthly interest payment and any other number\nexpected to be whole cents. To output our numbers, we use printf() and take care\nto align our columns to make it look nice. To finish our adaptation, we handle the\nfinal month separately to account for an over\/under payment due to rounding. The full\nsolution can be found in Code Sample 17.8.\n289 17. Loops\n1 #include<stdio.h>\n2 #include<stdlib.h>\n3 #include<math.h>\n4\n5 int main(int argc, char **argv) {\n6\n7 if(argc != 4) {\n8 printf(\"Usage: %s principle apr terms\\n\", argv[0]);\n9 exit(1);\n10 }\n11\n12 double principle = atof(argv[1]);\n13 double apr = atof(argv[2]);\n14 int n = atoi(argv[3]);\n15\n16 double balance = principle;\n17 double monthlyInterestRate = apr \/ 12.0;\n18 int i;\n19\n20 \/\/monthly payment\n21 double monthlyPayment = (monthlyInterestRate * principle) \/\n22 (1 - pow( (1 + monthlyInterestRate), -n));\n23 \/\/round to the nearest cent\n24 monthlyPayment = round(monthlyPayment * 100.0) \/ 100.0;\n25\n26 printf(\"Principle: $%.2f\\n\", principle);\n27 printf(\"APR: %.4f%%\\n\", apr*100.0);\n28 printf(\"Months: %d\\n\", n);\n29 printf(\"Monthly Payment: $%.2f\\n\", monthlyPayment);\n30\n31 \/\/for the first n-1 payments in a loop:\n32 for(i=1; i<n; i++) {\n33 \/\/ compute the monthly interest, rounded:\n34 double monthlyInterest =\n35 round( (balance * monthlyInterestRate) * 100.0) \/ 100.0;\n36 \/\/ compute the monthly principle payment\n37 double monthlyPrinciplePayment = monthlyPayment - monthlyInterest;\n38 \/\/ update the balance\n39 balance = balance - monthlyPrinciplePayment;\n40 \/\/ print i, monthly interest, monthly principle, new balance\n41 printf(\"%d\\t$%10.2f $%10.2f $%10.2f\\n\", i, monthlyInterest,\n42 monthlyPrinciplePayment, balance);\n43 }\n44\n45 \/\/handle the last month and last payment separately\n46 double lastInterest = round( (balance * monthlyInterestRate) * 100.0) \/ 100.0;\n47 double lastPayment = balance + lastInterest;\n48\n49 printf(\"Last payment = $%.2f\\n\", lastPayment);\n50\n51 return 0;\n52 }\n290 Code Sample 17.8.: Loan Amortization Program in C 18. Functions\nAsaprocedural-stylelanguage,functionsareessentialinCprogramming. Aswe\u2019vealready\nseen, C provides a large library of standard functions to perform basic input\/output,\nmath, and many other functions. C also provides the ability to define and use your own\nfunctions.\nWhen you define functions in C, careful thought must be made as to the naming of your\nfunctions. This is because C does not support function overloading. When you name a\nfunction, that is the only function that can have that name. Consequently, you cannot,\nin general, use the same function names as defined in the standard libraries or any other\n3rd party library that you would like to use in your programs.\nC supports both call by value and call by reference using pointers (see Section 18.2). C\nalso supports vararg functions (printf() being a prime example) and allows you to\ndefine vararg functions, but we will not cover them in depth here. Finally, parameters\nare not, in general, optional. For modern versions of C the omission of parameters is a\nsyntax error. For older versions, complex rules dictate what happens when arguments\nare omitted, but doing so usually results in garbage.\n18.1. Defining & Using Functions\nFor modern C, defining functions is a two step process. First, you declare a function and\nits signature using a prototype. Then you define the function by providing a function\nbody that defines what the function does.\n18.1.1. Declaration: Prototypes\nJust as with variables, functions in C must be declared before they can be used. The\nmodern way to declare a function in C is to use a prototype declaration which specifies\nthe function\u2019s signature including its return type, identifier, and parameters. However, a\nprototype does not include the actual body of function. Instead, the function\u2019s definition,\nwhich includes the function body is included later in the program. Consequently, a\nprototype always ends with a semicolon.\n291 18. Functions\nTypically, the documentation for functions is included with the prototype but is not\nrepeated with the function definition. This is a principle known as Don\u2019t Repeat Yourself\n(DRY). Consider the following examples. In these examples we use a commenting style\nknown as \u201cdoc comments.\u201d This style was originally developed for Java but has since\nbeen adopted by many other languages.\n\/**\n1\n* Computes the sum of the two arguments.\n2\n*\/\n3\nint sum(int a, int b);\n4\n5\n\/**\n6\n* Computes the Euclidean distance between the 2-D points,\n7\n* (x1,y1) and (x2,y2).\n8\n*\/\n9\ndouble getDistance(double x1, double y1, double x2, double y2);\n10\n11\n\/**\n12\n* Computes a monthly payment for a loan with the given\n13\n* principle at the given APR (annual percentage rate) which\n14\n* is to be repaid over the given number of terms (usually\n15\n* months).\n16\n*\/\n17\ndouble getMonthlyPayment(double principle, double apr, int terms);\n18\nIn each of these, the return type is the first thing specified. The function identifier (name)\nis then specified. Function names must follow the same naming rules as variables: they\nmust begin with an alphabetic character and may contain alphanumeric characters as\nwell as underscores. Using modern coding conventions we usually name functions using\nlower camel casing.\nEach prototype ends with a semicolon. Further, prototypes do not specify what the\nfunction does, they only specify its signature. Later in the program, we can provide\nthe actual definition of each function by using the following syntax. We repeat the\nsignature, but instead of using a semicolon, we provide a code block, enclosed using\nopening\/closing curly brackets, that specifies the function body. Here are the definitions\nfrom the prototype examples above:\nint sum(int a, int b) {\n1\nreturn (a + b);\n2\n}\n3\n292 18.1. Defining & Using Functions\n4\ndouble getDistance(double x1, double y1, double x2, double y2) {\n5\ndouble xDiff = (x1-x2);\n6\ndouble yDiff = (y1-y2);\n7\nreturn sqrt( xDiff * xDiff + yDiff * yDiff);\n8\n}\n9\n10\ndouble getMonthlyPayment(double principle, double apr, int terms) {\n11\ndouble rate = (apr \/ 12.0);\n12\ndouble payment = (principle * rate) \/ (1-pow(1+rate, -terms));\n13\nreturn payment;\n14\n}\n15\nThe keyword return is used to specify the value that is returned to the calling function.\n18.1.2. Void Functions\nThe keyword void can be used in C to indicate a function does not return a value,\nin which case it is called a \u201cvoid function.\u201d Though it is not necessary, it is still good\npractice to include a return statement.\n\/\/prototype:\n1\nvoid printCopyright();\n2\n3\n\/\/definition:\n4\nvoid printCopyright() {\n5\nprintf(\"(c) Bourke 2015\\n\");\n6\nreturn;\n7\n}\n8\nIn the example above, we\u2019ve also illustrated how to define a function that has no inputs.\nSome sources may include an explicit void keyword as a parameter to indicate the\nfunction takes no parameters as in void printCopyright(void);.\n293 18. Functions\n18.1.3. Organizing Functions\nThe separation of a function declaration (prototype) and a function definition provides a\nnatural way to organize functions in C. We place prototypes into a header file which has\na file extension .h and then place the corresponding function definitions into a source\nfile with the file extension, .c.\nWe\u2019ve seen this before with the standard libraries: we use #include<math.h> to\n\u201cinclude\u201d the math library\u2019s header file in our code. This essentially brings in the math\nlibrary function prototypes so that we can write calls to functions like sqrt() or sin().\nOnly when we compile do we actually need to link our code to the function definitions.\nWhen we separate prototypes into header files and definitions into source files we also\nneed to \u201cinclude\u201d the prototypes in our source file just as we would need to include them\nin any other file in which we use one of the functions. Suppose our functions above have\ntheir prototypes in a file named utils.h and their definitions in a file named utils.c.\nIn the utils.c source file we would typically use the following syntax to include the\nheader file:\n#include \"utils.h\"\nWeusethedoublequotesyntaxwithuser-definedlibrarieswhiletheusualless-than\/greater-\nthan syntax is used with standard libraries. With the less-than\/greater-than syntax, the\ncompiler will attempt to look for the header file(s) in a specified system directory which\nit will fail to find if it is a user-defined library. Furthermore, other elements are usually\nincluded in header files such as preprocessor directives and other declarations (such as\nenumerated types and structures which we introduce later).\n18.1.4. Calling Functions\nOnce a function has been defined, or at least a prototype has been brought into scope\nvia an #include statement, you can write code to call your function(s). The syntax\nfor doing so is to simply provide the function name followed by parentheses containing\nvalues or variables to pass to the function. Some examples:\nint a = 10, b = 20;\n1\nint c = sum(a, b); \/\/c contains the value 30\n2\n3\n\/\/invoke a function with literal values:\n4\ndouble dist = getDistance(0.0, 0.0, 10.0, 20.0);\n5\n6\n\/\/invoke a function with a combination:\n7\ndouble p = 1500.0;\n8\n294 18.2. Pointers\ndouble r = 0.05;\n9\ndouble monthlyPayment = getMonthlyPayment(p, r, 60);\n10\nBy default, all primitive types including int, double, and char are passed by value.\nTo be able to pass arguments by reference, we need to use pointers.\n18.2. Pointers\nConsider the following line of C code.\nint a = 10;\nThis line creates an integer variable and sets it equal to 10. In more detail, this line\ncreates a spot in memory (typically 32 bits) and stores a binary representation of the\nvalue 10 at that location. In many instances, we don\u2019t care where the variable is stored\nin memory. However, we may have need to communicate that memory location to other\nfunctions. To do so, we can use pointers.\nA pointer in C is a reference to a memory location. Because different types (int,\ndouble, char) take a different amount of memory, it is necessary to have a pointer for\neach type. That is, a pointer that points to a memory location that stores an int or a\npointer that points to a memory location that stores a double, etc.\nThe syntax for declaring a pointer is to use an asterisk.\n\/\/regular variable declarations\n1\nint a;\n2\ndouble b;\n3\n4\n\/\/pointer variable declarations\n5\nint *ptrA;\n6\ndouble *ptrB;\n7\nIf ptrA represents a memory location, what values can it take on? A memory location\nis just a number, so you could do something like the following.\nptrA = 10;\n295 18. Functions\nThough syntactically this makes sense (and generally the compiler will let you do this with\nat most a warning), it is not really what you want. This assigns to the pointer variable\nptrA the value 10, which will be interpreted as the memory address 10. This memory\naddress may not belong to your program, or it may not even exist as a valid memory\naddress. Attempts to access the value stored at an arbitrary memory location may be\nillegal and may result in the operating system killing the program with a segmentation\nfault or similar error.\nThere are many reasons why a program should not be allowed access to arbitrary memory\nlocations, but one of the prime reasons is security. Imagine if the operating system\nallowed a program access to any part of memory; in particular memory that contained\nsensitive information such as passwords or secret Secure Sockets Layer (SSL) keys. To\nprevent this, operating systems generally only allow a program to access its own memory.\nReferencing Operator\nSo how do we assign a valid value to a pointer? We do so using a referencing operator.\nGiven a normal variable as above, we place an ampersand in front of it to get the memory\naddress of the variable. For example:\nptrA = &a;\n1\nptrB = &b;\n2\nThe operation &a results in the memory address of the variable a and we can assign it\nto a pointer value. The pointer type and variable type should match; an integer pointer\nshould point to an int, a double pointer should point to a double. Making a double\npointer point to an int variable type such as\nptrB = &a;\nis valid syntax, but since the two types use different amounts of memory you may get\ngarbage results.\nThere is a special value used in C called NULL which is a (case-sensitive) keyword used\nfor an uninitialized, undefined, empty or otherwise invalid or meaningless value. In the\ncontext of memory locations, NULL \u201cpoints\u201d to nothing. As with regular variables, its\nbest practice to initialize pointer values to NULL. For example,\nint *ptrA = NULL;\nWithout an initialization, the pointer may point to a random memory address which may\nbe dangerous to attempt to access. You can also test whether or not a pointer points to\n296 18.2. Pointers\nNULL using the usual equality operator.\nint *ptrA = NULL;\n1\n...\n2\nif(ptrA == NULL) {\n3\nprintf(\"Error: invalid memory location\\n\");\n4\n}\n5\nDereferencing Operator\nOnce we have a valid pointer to a memory location, we may want to manipulate the\ncontents of the memory it references. To do this we use the inverse operation, the\ndereferencing operator which again uses an asterisk. Given a pointer variable ptrA, we\napply an asterisk in front of it to turn it into a regular variable. Consider the following\nexample.\n\/\/declare a normal integer variable\n1\nint a = 10;\n2\n\/\/declare a pointer and initialize it to NULL\n3\nint *ptrA = NULL;\n4\n5\n\/\/point ptrA to a's memory location\n6\nptrA = &a;\n7\n8\n\/\/change the value of the variable a using its pointer\n9\n*ptrA = 20;\n10\n11\n\/\/now the variable a has a value of 20:\n12\nprintf(\"a = %d\\n\", a); \/\/prints \"a = 20\"\n13\nFigure 18.1 depicts how these lines of code operate in memory.\n18.2.1. Passing By Reference\nNow that we have the ability to reference a memory location using pointers, we can write\nfunctions that pass variables by reference. To do so, we use the same asterisk syntax\n297 18. Functions\nAddress Contents Address Contents\n0xc260ec88 0xc260ec88\nptrA 0xf289fb18 NULL ptrA 0xf289fb18 0xc260ec84\n0xf289fb14 0xf289fb14\n... ...\nptrA = &a;\n0xc260ec88 0xc260ec88\na 0xc260ec84 10 a 0xc260ec84 10\n0xc260ec80 0xc260ec80\n(a) After the first two lines memory (b) Making ptrA point to the variable a\u2019s\nhasbeendedicatedforthevariable a memory location. The value stored in the vari-\nand the pointer variable ptrA and able ptrA is a memory address.\ntheir values have been initialized.\nAddress Contents\n0xc260ec88\nptrA 0xf289fb18 0xc260ec84\n0xf289fb14\n...\n*ptrA = 20;\n0xc260ec88\na 0xc260ec84 20\n0xc260ec80\n(c) Dereferencing ptrA and assigning a value\nchanges the value stored at what it points to.\nFigure 18.1.: Pointer Operations. Pointers can be made to point to other variable\u2019s\nmemory locations. You can manipulate\/access values of variables via their\npointers using dereferencing.\n298 18.2. Pointers\nused with pointer variables.\n\/\/prototypes\n1\n\/**\n2\n* This function sums the first two variables (passed by\n3\n* value) and places the result into the third variable\n4\n* (passed by reference).\n5\n*\/\n6\nvoid sum(int a, int b, int *c);\n7\n8\n\/**\n9\n* This function swaps the values stored in the\n10\n* two variables passed by reference.\n11\n*\/\n12\nvoid swap(int *a, int *b);\n13\nIn the function definitions, we can use the dereferencing operator to access or modify the\nvalue stored in the variable pointed to by the pointer.\nvoid sum(int a, int b, int *c) {\n1\nint x = a + b;\n2\n*c = x;\n3\nreturn;\n4\n}\n5\n6\nvoid swap(int *a, int *b) {\n7\nint temp = *a;\n8\n*a = *b;\n9\n*b = temp;\n10\nreturn;\n11\n}\n12\nTo invoke these functions, we need to pass pointers to the functions appropriately. We\ncould do this by creating pointer variables or using the referencing operator directly.\nint x = 10;\n1\nint y = 20;\n2\nint c;\n3\n299 18. Functions\nint *ptrC = &c;\n4\nsum(x, y, ptrC);\n5\n\/\/at this point c contains the value 30\n6\n7\nswap(&x, &y);\n8\n\/\/at this point, the values in x and y have been swapped\n9\n\/\/ x contains 20 and y contains 10\n10\nThis should look familiar. We saw this same syntax when we used scanf() to read input\nfrom the standard input. We needed to place an ampersand in front of each variable in\norder to pass the variable by reference so that scanf() could place the results into the\nrespective memory locations. If the variables had been passed by value, then scanf()\nwould not have been able to manipulate their values.\nYou can also specify functions to return pointers which we discuss in detail in Chapter\n20.\n18.2.2. Function Pointers\nFunctions are just pieces of code that reside somewhere in memory just as variables do.\nSince we can create pointers that point to variables, it makes sense to be able to create\nvariables that point to functions too! These are referred to as function pointers.\nThe syntax for declaring function pointers is similar to variable pointers. However, since\na function\u2019s signature involves a return type and parameter list, these need to be specified.\nFor example, suppose we wanted to create a function pointer that could point to the\nmath library\u2019s sqrt() function which takes a single double parameter and returns a\ndouble value.\ndouble (*ptrToSqrt)(double) = NULL;\nThe above line creates a function pointer that can point to any function that takes\na single double parameter and returns a double value. As is good practice, we\u2019ve\ninitialized it to point to NULL. The function pointer itself is named ptrToSqrt. To\nmake it point to the sqrt() function we can use the following syntax.\nptrToSqrt = sqrt;\nThis is because a function\u2019s identifier acts as a pointer as well! Once we have a pointer\nto a function, we can invoke the function via its pointer as we would any other function\ncall.\n300 18.3. Examples\ndouble x = ptrToSqrt(2.0);\nSome more examples:\n\/\/this pointer can point any function that takes\n1\n\/\/three arguments: an int, double, and a char\n2\n\/\/and returns an int value\n3\nint (*ptrToFunc)(int, double, char)= NULL;\n4\n5\ndouble x;\n6\ndouble (*ptr)(double) = NULL;\n7\n\/\/we can make it point to sqrt:\n8\nptr = sqrt;\n9\nx = ptr(2.0); \/\/x contains 1.4142...\n10\n\/\/or we can make it point to fabs\n11\nptr = fabs;\n12\nx = ptr(-10.5); \/\/x contains 10.5\n13\nYou generally want to create and use function pointers when passing and returning\nfunctions as arguments to other functions as callbacks. We discuss this in further detail\nin Chapter 25.\n18.3. Examples\n18.3.1. Generalized Rounding\nRecall that the standard math library provides a round() function that rounds a number\nto the nearest whole number. We\u2019ve had need to round to cents as well. We now have\nthe ability to write a function to do this for us. Before we do, however, let\u2019s think more\ngenerally. What if we wanted to round to the nearest tenth? Or what if we wanted to\nround to the nearest 10s or 100s place? Let\u2019s write a general purpose rounding function\nthat allows us to specify which decimal place to round to.\nThe most natural input values would be to specify the place using an integer exponent.\nThat is, if we wanted to round to the nearest tenth, then we would pass it \u22121 as\n0.1 = 10\u22121, \u22122 if we wanted to round to the nearest 100th, etc. In the other direction,\npassing in 0 would correspond to the usual round function, 1 to the nearest 10s spot,\nand so on. Moreover, we could demonstrate good code reuse (as well as procedural\nabstraction) by scaling the input value and reusing the functionality already provided\n301 18. Functions\nin the math library\u2019s round() function. We could further define a roundToCents()\nfunction that used our generalized round function.\nLet\u2019s also think about organization. We could place the prototypes into a round.h\nheader file and the corresponding definitions in a round.c source file. The contents of\nthese two files are presented here:\n\/**\n1\n* Rounds to the nearest digit specified by the place\n2\n* argument. In particular to the (10^place)-th digit\n3\n*\/\n4\ndouble roundToPlace(double x, int place);\n5\n6\n\/**\n7\n* Rounds to the nearest cent\n8\n*\/\n9\ndouble roundToCents(double x);\n10\n#include<math.h>\n1\n#include \"round.h\"\n2\n3\ndouble roundToPlace(double x, int place) {\n4\ndouble scale = pow(10, -place);\n5\ndouble rounded = round(x * scale) \/ scale;\n6\nreturn rounded;\n7\n}\n8\n9\ndouble roundToCents(double x) {\n10\nreturn roundToPlace(x, -2);\n11\n}\n12\nObserve that neither of these files contains a main() function. By themselves they\nwould not be able to be compiled into an executable program. We\u2019ve essentially built a\nsmall library of rounding functions. We could compile them though into a binary object\nfile using gcc (something like gcc -c round.c). We could then link into the object file\nwhen compiling an executable program that uses these functions.\n302 18.3. Examples\n18.3.2. Quadratic Roots\nAnother advantage of passing variables by reference is that we can \u201creturn\u201d multiple\nvalues with one function call. Functions are limited in that they can only return at most\none value. But if we pass multiple parameters by reference, the function can manipulate\nthe contents of them, thereby communicating (though not strictly returning) multiple\nvalues.\nConsider again the problem of computing the roots of a quadratic equation,\nax2 +bx+c = 0\nusing the quadratic formula,\n\u221a\n\u2212b\u00b1 b2 \u22124ac\n2a\nSince there are two roots, we may have to write two functions, one for the \u201cplus\u201d root\nand one for the \u201cminus\u201d root both of which take the coefficients, a,b,c as arguments.\nHowever, if we wrote a single function that took the coefficients as parameters by value\nas well as two other parameters by reference, we could compute both root values and\nplace each one in two pass by reference variables.\nvoid quadraticRoots(double a, double b, double c,\n1\ndouble *root1, double *root2) {\n2\ndouble discriminant = sqrt(b*b - 4*a*c);\n3\n*root1 = (-b + discriminant) \/ (2*a);\n4\n*root2 = (-b - discriminant) \/ (2*a);\n5\nreturn;\n6\n}\n7\nBy using pass by reference variables, we avoid multiple functions. We also note that the\nreturn value in this case is unused since we are \u201creturning\u201d the root values in the two\npass by reference variables. This frees up the return value to be used to communicate\nerrors to the calling function. Recall that there could be several \u201cbad\u201d inputs to this\nfunction. The roots could be complex values, the coefficient a could be zero, etc. And\nnow that we are dealing with pointers, the pointers could be invalid (point to NULL). In\nthe next chapter, we examine how we can use the return value to communicate different\nerrors to the calling function, letting it handle those errors.\n303  19. Error Handling\nThe C language does not support exceptions or exception handling. Instead, the usual\nmethod of error handling is done through defensive programming. As a user, it is your\nresponsibility to write code that checks for invalid or unsafe operations before executing\nthem and handle the error appropriately.\nOne way that we\u2019ve already seen to handle errors in C is to use the exit() function in\nthe standard library. This function immediately terminates the execution of our program\nand \u201creturns\u201d an integer valued \u201cexit code.\u201d This exit code can be used to communicate\nerrors between different processes. The process that executed the program can use it to\ndetermine if the program exited with or without an error. By convention, 0 indicates an\nerror while a non-zero value indicates an error. Using the exit() function should only\nbe done when an error should be considered fatal or severe enough that the program\nshould immediately terminate.\n19.1. Language Supported Error Codes\nIn the standard libraries, some functions are designed to indicate an error by returning\na special \u201cflag\u201d value such as \u22121 or NULL. In general, though, the standard library\nfunctions communicate an error code represented as an integer value. As previously\nmentioned, C uses the convention that 0 indicates \u201cno error\u201d while a non-zero value\nindicates an error.\nError codes are communicated through a special global variable called errno which is\ndefined in the errno.h standard header file. This header file also defines several macros\nthat are identified with various error codes. The C standard actually only requires the\nfollowing three error codes to be supported.\n\u2022 EDOM indicates an error in the domain of a function; that is, an error with respect\nto the function\u2019s input value(s). For example, calling the math library\u2019s sqrt(-1)\non a negative value results in an EDOM error as C does not support complex\nnumbers.\n\u2022 ERANGE indicates an error in the range of a function; that is, an error with respect\nto the function\u2019s output value(s). For example, calling the math library\u2019s log(0)\n305 19. Error Handling\nwith a zero value results in an ERANGE error as C does not support \u2212\u221e as an\nactual number.\n\u2022 EILSEQ indicates an illegal byte sequences in characters on systems that use\nUTF-8.\nAll three of these are defined in the errno.h header file. Depending on the system,\nadditional error codes may also be defined and supported (see POSIX Error Codes\nbelow).\nWhen an error occurs, a function will set the global variable errno to one of these error\ncode values. Upon returning from a function, you can check for these error codes. Since\nthese error codes are represented as integers, you simply use the numerical comparison\noperator, ==. You can check for no error by making a comparison to zero.\nIn addition, the standard string library, defined in the header file, string.h provides a\nfunction, char * strerror(errno) that can be used to map the value in errno to a\nhuman-readable error message. We discuss strings in detail later on, but we can see how\nto use this function in Code Sample 19.1. The output of this program is as follows.\nresult: 1.4142, error: 0\nresult: -nan, error: 33\nit was an EDOM error\nError Message: Numerical argument out of domain\nresult: -inf, error: 34\nit was an ERANGE error\nError Message: Numerical result out of range\nFor this particular system, the EDOM and ERANGE error codes were associated with the\ninteger values 33 and 34 respectively. These numbers are not necessarily the same on all\nsystems so comparisons must be made against the macro names for portability.\n19.1.1. POSIX Error Codes\nPOSIX is an IEEE set of standards for maintaining compatibility between various\noperating systems. It defines several rules and expectations that operating systems must\nadhere to in order to be POSIX compliant. Such standards allow developers to develop\ncode that should be interoperable among a collection of different operating systems,\nreducing the need for rewrites and reimplementations for different systems.\nIn particular, POSIX compliant systems define many other error codes (see [3]) that\n306 19.1. Language Supported Error Codes\n#include<stdio.h>\n1\n#include<stdlib.h>\n2\n#include<math.h>\n3\n#include<string.h>\n4\n#include<errno.h>\n5\n6\nint main(int argc, char **argv) {\n7\n8\ndouble a = -1, b = 2, c = 0.0;\n9\ndouble x;\n10\n11\n\/\/okay\n12\nx = sqrt(b);\n13\nprintf(\"result: %.4f, error: %d\\n\", x, errno);\n14\n15\n\/\/NaN and EDOM error...\n16\nx = sqrt(a);\n17\nprintf(\"result: %.4f, error: %d\\n\", x, errno);\n18\n19\n\/\/make a comparison\n20\nif(errno == EDOM) {\n21\nprintf(\"it was an EDOM error\\n\");\n22\n}\n23\n24\n\/\/error messages can be accessed via:\n25\nchar *errMsg = strerror(errno);\n26\nprintf(\"Error Message: %s\\n\", errMsg);\n27\n28\n\/\/ERANGE error\n29\nx = log(c);\n30\nprintf(\"result: %.4f, error: %d\\n\", x, errno);\n31\n32\nif (errno == ERANGE) {\n33\nprintf(\"it was an ERANGE error\\n\");\n34\n}\n35\n36\n\/\/error messages can be accessed via:\n37\nerrMsg = strerror(errno);\n38\nprintf(\"Error Message: %s\\n\", errMsg);\n39\n40\nreturn 0;\n41\n42\n}\n43\nCode Sample 19.1.: Using the errno.h library\n307 19. Error Handling\ncan be used beyond the three mentioned above. For example, the ENOENT error code\ncorresponds to \u201cNo such file or directory\u201d and EACCES corresponds to a \u201cPermission\ndenied\u201d error.\n19.2. Error Handling By Design\nIn our own code we could communicate errors to calling functions by setting the errno\nvariable, however, we may run into compatibility issues with the standard error codes\nor POSIX error codes. Instead, it may be more appropriate to do error handling by\nutilizing the return value of a function to communicate an error code. We could design\nour functions to always return an int value to indicate an error: 0 for no error and some\nnon-zero value to indicate various different types of errors. Of course, as a consequence\nany value that needs to be \u201creturned\u201d to the calling function would need to be done so\nvia a pass by reference variable.\nAs an example, let\u2019s revisit the quadratic roots example in Section 18.3.2. By returning\nthetwooutputvaluesviapassbyreferencevariables, wefreedupthereturnvalue. Wecan\nnow modify our function to return an integer indicating an error code instead. Previously\nwe had identified several different types of errors: division by zero (if a = 0), complex\nroots (if b2 \u2212 4ac < 0) and a NULL pointer error if the variables passed by reference\nwere NULL. We can now modify our function to check for these errors and return an\nappropriate error code. We return zero in the event that no error was encountered.\nint quadraticRoots(double a, double b, double c,\n1\ndouble *root1, double *root2) {\n2\nif(a == 0) {\n3\nreturn 1;\n4\n} else if( b*b - 4*a*c < 0 ) {\n5\nreturn 2;\n6\n} else if(root1 == NULL || root2 == NULL) {\n7\nreturn 3;\n8\n}\n9\ndouble discriminant = sqrt(b*b - 4*a*c);\n10\n*root1 = (-b + discriminant) \/ (2*a);\n11\n*root2 = (-b - discriminant) \/ (2*a);\n12\nreturn 0;\n13\n}\n14\nNow when a function invokes our quadraticRoots() it can check to see what kind of\n308 19.3. Enumerated Types\nerror code it returned and handle the error in whatever way it wants.\nThere is still an issue, however. The usage of the integers 1, 2, 3 to indicate the various\nerrors was arbitrary. These are essentially magic numbers that the calling function\nwould have to deal with by making comparisons with various integers. The numbers\nthemselves are meaningless and someone using them would need to constantly refer to\ndocumentation to understand which integer corresponded to which error condition.\nIt would be much better if we could follow the strategy of the errno and define human-\nreadable identifiers for each error code. We could accomplish this by defining macros,\nbut another solution is to use an enumerated type.\n19.3. Enumerated Types\nC allows you to define enumerated types which allow you to define a fixed list of possible\nvalues. For example, the days of the week or months of the year are possible values used\nin a date. However, they are more-or-less fixed (no one will be adding a new day of the\nweek or month any time soon). An enumerated type allows us to define these values\nusing human-readable keywords (much like the #define macro).\nTo declare an enumerated type we use the keywords typedef enum (short for type\ndefinition and enumeration). We then provide a comma delimited list of keywords inside\na code block. At the end of the code block we provide the type\u2019s identifier. That is, the\nname of the type itself. For example, the names of integer and floating-point types in C\nare int and double respectively. This identifier gives our type a name that we can\nlater use to declare variables of that type. Consider the following example.\ntypedef enum {\n1\nSUNDAY,\n2\nMONDAY,\n3\nTUESDAY,\n4\nWEDNESDAY,\n5\nTHURSDAY,\n6\nFRIDAY,\n7\nSATURDAY\n8\n} DayOfWeek;\n9\nIn this example we\u2019ve defined an enumeration of the days of the week. The name of the\ntype itself is DayOfWeek and we can now declare variables of this type. The possible\n309 19. Error Handling\nvalues it can take are SUNDAY, MONDAY, etc. and we can use these keywords in our\nprogram. For example,\nDayOfWeek today = MONDAY;\n1\n2\nif(today == SUNDAY || today == SATURDAY) {\n3\nprintf(\"It is the weekend!\\n\");\n4\n}\n5\nNote the modern naming conventions: the type identifier uses upper camel casing while\nthe enumerated values follow an uppercase underscore convention. Though our example\ndoes not contain a value with multiple words, if it had, we would have used an underscore\nto separate them. Furthermore, enumerated type declarations are usually placed in\nseparate header files along with function prototype declarations.\nCaremustbetakenwhenusingenumeratedtypes,however. Internally,Csimplyassociates\nintegers with the values. Thus, in our example, SUNDAY is actually 0, MONDAY is 1,\nand SATURDAY is 6. When we do assignments or equality comparisons, we\u2019re actually\njust comparing integers. Consequently, a DayOfWeek variable may be assigned values\nthat do not correspond to our enumeration. For example,\nDayOfWeek today = 1000;\nis valid code and will not (in general) result in any compiler errors or warnings, even\nthough it is assigning an invalid value to the variable. You should only assign valid values\nto an enumerated type variable. Proper error checking should also be done.\nDespite this limitation, using enumerated types in C provides an obvious advantage.\nWithout an enumerated type we\u2019d be forced to use a collection of magic numbers to\nindicate values. Even for something as simple as the days of the week we\u2019d be constantly\ntrying to remember: which day is Wednesday again? I forget, does our week start with\nMonday or Sunday? Etc. By using an enumerated type these questions are mostly moot\nas we can use the more human-readable keywords and eliminate the guess work.\n19.4. Using Enumerated Types for Error Codes\nLet\u2019s apply enumerated types to our quadraticRoots() function example from before.\nFirst, we define our enumerated type which includes all types of errors including a\nNO_ERROR type. Note that we start with NO_ERROR as its value will be zero following\nour convention.\n310 19.4. Using Enumerated Types for Error Codes\ntypedef enum {\n1\nNO_ERROR,\n2\nDIV_BY_ZERO_ERROR,\n3\nCOMPLEX_ROOT_ERROR,\n4\nNULL_POINTER_ERROR\n5\n} ErrorCode;\n6\nNow in the quadraticRoots() function, we can return the appropriate error code as\nan enumerated type value.\nErrorCode quadraticRoots(double a, double b, double c,\n1\ndouble *root1, double *root2) {\n2\nif(a == 0) {\n3\nreturn DIV_BY_ZERO_ERROR;\n4\n} else if( b*b - 4*a*c < 0 ) {\n5\nreturn COMPLEX_ROOT_ERROR;\n6\n} else if(root1 == NULL || root2 == NULL) {\n7\nreturn NULL_POINTER_ERROR;\n8\n}\n9\ndouble discriminant = sqrt(b*b - 4*a*c);\n10\n*root1 = (-b + discriminant) \/ (2*a);\n11\n*root2 = (-b - discriminant) \/ (2*a);\n12\nreturn NO_ERROR;\n13\n}\n14\n311  20. Arrays\nC allows you to declare and use arrays. Since C is statically typed, arrays must also\nbe typed when they are declared and may only hold that particular type of element. C\nsupports the use of both static arrays and dynamic arrays through standard library calls.\n20.1. Basic Usage\nTo declare a static array, you use syntax similar to declaring a regular variable, but you\nuse square brackets to designate the variable as an array. Within the square brackets\nyou indicate the size (number of elements) in the array. For example,\nint arr[5];\n1\ndouble values[10];\n2\nThe two declarations above create arrays of size 5 and 10 respectively. The array types\nare also defined using the usual keywords. In this case, arr can only hold int values\nand values can only hold double values. Arrays follow the same naming rules and\nconventions as regular variables. Many times, identifiers are made plural as an array\nnaturally holds more than one value.\nAnother way to declare an array is to use the compound declaration and assignment\nsyntax whereby you can initialize an array to hold a certain list of values.\nint a[] = { 2, 3, 5, 7, 11 };\n1\nUsing this syntax we do not need to specify the size of the array as the compiler is smart\nenough to count the number of elements we\u2019ve provided. The elements themselves are\ndenoted inside curly brackets and delimited with commas.\n313 20. Arrays\nVariable Length Arrays\nC99 introduced Variable Length Arrays (VLAs, which are also supported in GNU C89)\nwhich allow you to declare a static array whose size is determined by a variable. For\nexample,\nint n = 5;\n1\nint arr[n];\n2\nor within a function,\nvoid foo(int n) {\n1\nint arr[n];\n2\n...\n3\n}\n4\nIn either case, care must be taken as static arrays are allocated on the stack. The stack\nis generally small and allocating even a moderately large array on the stack may lead to\na stack overflow. In addition, VLAs are not supported in any C++ standard and should\nbe avoided if portable code is desired.\nIndexing\nOnce an array has been created, its elements can be accessed using indexing. C uses the\nstandard 0-indexing scheme so the first element is at index 0, the second at index 1, etc.\nIndexing an element involves using the square bracket notation and providing an index.\nOnce indexed, an array element can be treated as a normal variable and can be used\nwith other operators such as the assignment operator or comparison operators.\narr[0] = 42;\n1\nif(arr[4] < 0) {\n2\nprintf(\"negative!\\n\");\n3\n}\n4\nprintf(\"arr[1] = %d\\n\", arr[1]);\n5\n314 20.1. Basic Usage\nRecall that an index is actually an offset. The compiler and system know exactly how\nmany bytes each int element takes and so an index i calculates exactly how many\nbytes from the first element the i-th element is located at. Consequently it is possible\nto index elements that are beyond the range of the array. For example, arr[-1] or\narr[5] would attempt to access an element immediately before the first element and\nimmediately after the last element. Obviously, these elements are not part of the array.\nIf these out-of-bound elements represent a memory space that does not belong to our\nprogram, then it is likely that a segmentation fault will occur and terminate our program.\nHowever, it is also likely that the memory space surrounding our array does belongs to\nour program. Still, accessing those blocks of memory may not give us meaningful values\nand modifying them could corrupt other variable values or generally lead to undefined\nbehavior. It is our responsibility as programmers to write code that does not go beyond\nthe bounds of an array.\nHow can we keep track of the size of the array so that we do not access elements after the\nlast element? With C the responsibility again falls to us. We must always have secondary\nvariables that store the size of an array. If we pass an array to a function (see below), we\nmust also pass a \u201csize\u201d parameter so that the function knows how big the array is.\nIteration\nC provides no foreach loop to iterate over an array. Instead, the most natural way to\niterate over the elements is a normal for loop that increments an index variable.\nint i, n = 10;\n1\nint arr[n];\n2\nfor(i=0; i<n; i++) {\n3\narr[i] = 5 * i;\n4\n}\n5\nThe for loop above initializes the variable i to zero, corresponding to the first element\nin the array. The continuation condition is specifies that the loop continues while i is\nstrictly less than the size of the array. This iteration for loop is idiomatic when dealing\nwith arrays. An alternative was presented in Section 17.4.\n315 20. Arrays\n20.2. Dynamic Memory\nRecall that static arrays have many shortcomings (see Section 7.2). In general they\nshould be avoided since stack space is limited and they cannot be returned from functions.\nFortunately, C provides several standard library functions that facilitate the creation\nand management of dynamically allocated arrays.\nThe primary function to allocate memory is the memory allocation function, malloc():\nvoid * malloc(size_t size);\nwhich takes a single parameter, the number of bytes that you wish to allocate. The type,\nsize_t is an alias for an unsigned integer type, so you can think of it as an integer.\nThus, malloc(200) would allocate 200 bytes and return a pointer to the memory space.\nIn some instances, the allocation may fail. For example, if the program or system has\nrun out of available memory or you simply request too much. In the event of a failure,\nmalloc() returns a NULL pointer. The returned value can thus be checked to see if\nthe allocation was successful or not.\nWe don\u2019t have to manually calculate how many bytes we need for an array of a particular\nsize. The macro sizeof() can be used to determine the number of bytes any type of\nvariable requires on a system. For example, sizeof(int) gives the number of bytes an\nint takes while sizeof(double) gives the number of bytes for a double, etc. Thus,\nif we want to allocate an array of 100 integers, we could call malloc() as\nmalloc(100 * sizeof(int));\nUsing sizeof() is actually preferable as some systems may use a different number of\nbytes for various types.\nFinally, note the return type of malloc(): it is a void pointer. The malloc() function\nsimply allocates chunks of memory. It doesn\u2019t care that you intend to use the memory to\nstore integers or floating-point numbers. Thus, malloc() returns a \u201cgeneric\u201d pointer,\nsimply an address in memory. Once we have that pointer we can treat it as an integer\npointer, int * or a floating-point pointer, double * depending on what we want to\nstore.\nOne way of doing this is to explicitly cast the void pointer as the pointer that we want.\nSome examples:\nint *arr = NULL;\n1\ndouble *values = NULL;\n2\n3\narr = (int *) malloc(sizeof(int) * 10);\n4\n316 20.2. Dynamic Memory\nvalues = (double *) malloc(sizeof(double) * 100);\n5\nThe pointer cast is just like when we casted int types as double types so that we\ncould perform division without truncation. In this case, we convert the returned generic\nvoid pointer into a int pointer and double pointer respectively.1\nOnce created, a dynamic array can be used just like a static array. You use the array\u2019s\nidentifier as well as an index to access or modify each element. The same rules and\npitfalls apply, so care must be taken to not access elements outside the bounds of the\narray. Finally, when using malloc() it is important to understand that the memory\nthat is allocated is uninitialized. Just as with variables you cannot make any assumptions\nas to the contents of the memory space that is allocated. It may contain garbage values,\nit may contain the contents that occupied the memory last time it was used, etc. A full\nexample:\nint n = 100;\n1\nint *arr = NULL;\n2\narr = (int *) malloc(sizeof(int) * n);\n3\nif(arr == NULL) {\n4\nfprintf(stderr, \"unable to allocate memory!\\n\");\n5\nexit(1);\n6\n}\n7\nfor(i=0; i<n; i++) {\n8\narr[i] = (i+1) * 10;\n9\nprintf(\"a[%d] = %d\\n\", i, arr[i]);\n10\n}\n11\nThere are other functions that can be used to allocate memory in C. For example,\ncalloc() is similar to malloc() but initializes the contents to zero (null bytes).\nrealloc() can be used to resize an existing memory space (though it may fail if it\ncannot be expanded).\n1PerforminganexplicitpointercastisactuallynotnecessaryinCasthetypesystemwilldoanimplicit\ncast for us. Whether explicit or implicit types casts are \u201cbetter\u201d can evoke debates akin to nerd\nholy wars. Though there are advantages and disadvantages to both [15], we perform explicit pointer\ncasts in this book as clarity and intent is more important than brevity. Even more important is that\nexplicit pointer casts are necessary in C++ so doing so in our C code makes our code more portable.\n317 20. Arrays\nDeallocation\nOnce dynamically allocated memory is no longer needed, we should release it so that\nit can be reused by the program or the operating system. The free() function in the\nstandard library does this for us. All we need to do is provide the pointer to free()\nand it deallocates the memory block.\nfree(arr);\n1\nOnce freed, accessing old memory pointed to by the arr pointer is undefined behavior\nand may lead to unexpected or fatal results.\n20.3. Using Arrays with Functions\nSince arrays are represented using pointers, we can pass and return arrays to and from\nfunctions simply by passing in a pointer. When passing an array to a function, we also\nneed to make sure that we communicate to the function the size of the array as there is\nno reliable way for the function to determine this. By passing both a pointer and an\ninteger representing the size, we are implicitly indicating that we are passing an array\nand not just a single value.\nAs an example, the following function takes an array of integers and computes their sum.\n\/**\n1\n* This function computes the sum of elements in the\n2\n* given array which contains n elements\n3\n*\/\n4\nint computeSum(int *arr, int n) {\n5\nint i;\n6\nint sum = 0;\n7\nfor(i=0; i<size; i++) {\n8\nsum += arr[i];\n9\n}\n10\nreturn sum;\n11\n}\n12\n318 20.4. Multidimensional Arrays\nIn this example we had no need to make changes to any of the elements in the array.\nHowever, the array was still passed by reference, meaning we could have. When passing\narrays, we can use the keyword const (short for constant) to explicitly indicate that no\nchanges will be made to the array elements. For example,\nint computeSum(const int *arr, int n)\nThis is enforced by the compiler: if we do attempt to make changes to a const array, it\nwill be a compiler error.\nWe can also create an array in a function and return it as a value. As previously discussed,\nwewill needtodosobycreatingadynamicallyallocatedarray. Forexample, thefollowing\nfunction creates a deep copy of the given integer array. That is, a completely new array\nthat is a distinct copy of the old array. In contrast, a shallow copy would be if we simply\nmade one reference point to another reference.\n\/**\n1\n* This function creates a new copy of the given integer\n2\n* array which contains n elements and returns a pointer\n3\n* to the new copy.\n4\n*\/\n5\nint * makeCopy(const int *a, int n) {\n6\nint *copy = (int *)malloc(sizeof(int) * n);\n7\nint i;\n8\nfor(i=0; i<n; i++) {\n9\ncopy[i] = a[i];\n10\n}\n11\nreturn copy;\n12\n}\n13\nThe function returns an integer pointer. Here we have a similar problem with respect to\nthe size of the array. We only have one return value, which must be the pointer. In this\nparticular example the calling function knows how big the array is because it specified\nthe size by passing in n. In general we could have communicated the size of the returned\narray through another pass by reference integer variable.\n20.4. Multidimensional Arrays\nC supports multidimensional arrays both static and dynamically allocated; though we\u2019ll\nonly focus on dynamically allocated 2-dimensional arrays. Conceptually, a 2-dimensional\n319 20. Arrays\narray of, say, integers can be modeled as an array of pointers that point to an array of\nintegers. That is, a pointer to pointers, for example, int **. The initial pointer points\nto an array of integer pointers, int * and each integer pointer points to an array of\nint variables.\nTo understand this better, let\u2019s look at the details of allocation. Consider the following\ncode.\nint i;\n1\nint **myMatrix = NULL;\n2\nmyMatrix = (int **)malloc(n * sizeof(int*));\n3\nfor(i=0; i<n; i++) {\n4\nmyMatrix[i] = (int *)malloc(n * sizeof(int));\n5\n}\n6\nLine 3 invokes malloc() to create an array of n integer pointers, that is int * types.\nWe then go into a loop to iterate over each of these pointers and invoke malloc()\nagain to setup each array. This process is visualized in Figure 20.1. Note the syntax:\nwhen we invoke malloc() to create an array of pointers, we use sizeof(int*) to\ndetermine how many bytes each integer pointer takes. We also do an explicit type cast\nof (int **) to match our pointer-to-pointer(s) variable myMatrix.\nOnce the allocation has completed, we can treat myMatrix as a normal 2-dimensional\narray and index each element with two index variables.\nint i, j;\n1\nfor(i=0; i<n; i++) {\n2\nfor(j=0; j<n; j++) {\n3\nmyMatrix[i][j] = 0;\n4\n}\n5\n}\n6\nTo deallocate and free multidimensional arrays, we need to work backwards. If we imme-\ndiately freed the pointer-to-pointers, free(myMatrix);, we would lose all references to\nthe individual array \u201crows\u201d and would not be able to free them, resulting in a memory\nleak. We need to free up each row first, then we can free the pointer-to-pointers.\n320 20.4. Multidimensional Arrays\n**myMatrix\n*myMatrix[0] ?\n*myMatrix[1] ?\n*myMatrix[2] ?\n...\n*myMatrix[n-1] ?\n(a) Initialization of the pointer-to-pointers. The first invocation of malloc() sets up an\narray of integer pointers, int * that are uninitialized (where they point to is undefined).\n**myMatrix\n*myMatrix[0] myMatrix[0][0] myMatrix[0][1] myMatrix[0][2] \u00b7\u00b7\u00b7 myMatrix[0][n-1]\n*myMatrix[1] ?\n*myMatrix[2] ?\n...\n*myMatrix[n-1] ?\n(b) Initialization of the first pointer. On the first iteration of the for loop when i = 0, the\nfirst \u201crow\u201d is initialized when malloc() is invoked.\n**myMatrix\n*myMatrix[0] myMatrix[0][0] myMatrix[0][1] myMatrix[0][2] \u00b7\u00b7\u00b7 myMatrix[0][n-1]\n*myMatrix[1] myMatrix[1][0] myMatrix[1][1] myMatrix[1][2] \u00b7\u00b7\u00b7 myMatrix[1][n-1]\n*myMatrix[2] ?\n...\n*myMatrix[n-1] ?\n(c) Initialization of the second pointer. On the second iteration of the for loop when i = 1,\nthe second \u201crow\u201d is initialized.\n**myMatrix\n*myMatrix[0] myMatrix[0][0] myMatrix[0][1] myMatrix[0][2] \u00b7\u00b7\u00b7 myMatrix[0][n-1]\n*myMatrix[1] myMatrix[1][0] myMatrix[1][1] myMatrix[1][2] \u00b7\u00b7\u00b7 myMatrix[1][n-1]\n*myMatrix[2] myMatrix[2][0] myMatrix[2][1] myMatrix[2][2] \u00b7\u00b7\u00b7 myMatrix[2][n-1]\n...\n*myMatrix[n-1] myMatrix[n-1][0] myMatrix[n-1][1] myMatrix[n-1][2] \u00b7\u00b7\u00b7 myMatrix[n-1][n-1]\n(d) After the termination of the for loop, each row has been initialized and the pointer-to-\npointers can be treated like a 2-dimensional array.\nFigure 20.1.: The process of dynamically allocating a 2-dimensional array of integers\nusing malloc() in a for-loop.\n321 20. Arrays\nfor(i=0; i<n; i++) {\n1\nfree(myMatrix[i]);\n2\n}\n3\nfree(myMatrix);\n4\n20.4.1. Contiguous 2-D Arrays\nThe example depicted in Figure 20.1 constructs a two dimensional array. However, each\n\u201crow\u201d of the array was created using an independent call to malloc() which may result\nin non-contiguous memory blocks (each row may not be located in the memory address\nimmediately following the previous row). In general, this is not a problem for most\nsituations (we can expect most implementations of malloc() to be efficient). However,\nit might be better in some scenarios if the two dimensional array were all one big block\nof contiguous memory.\nWe can achieve this by a single call to malloc() and some clever pointer manipulation.\nWe do this very similar to the previous example. Our first call to malloc() to set up\nthe pointer-to-pointers is the same. However, instead of calling malloc() over and over\nin a for loop, we make one single call asking for a number of bytes to accommodate the\nentire n\u00d7m array. We then store the result at the \u201cbeginning\u201d of the array (at index\nzero). In the following example, we will create a 4\u00d73 sized matrix.\nint **m = (int **) malloc(sizeof(int *) * 4);\n1\nm[0] = (int *) malloc(sizeof(int) * (4 * 3));\n2\nWe\u2019re not done yet, however. We still need to initialize all of the other pointers. To do\nso, we dereference the array (once) to get the address of the start of the memory block\nand then compute an offset from this beginning on where the next \u201crow\u201d should be.\nSince each row has 3 elements, this arithmetic is simple.\nfor(i=1; i<4; i++) {\n1\narr[i] = (*arr + (3 * i));\n2\n}\n3\n322 20.4. Multidimensional Arrays\nNow we can treat the array like we would any other two dimensional array by specifying\ntwo indices.\nfor(i=0; i<4; i++) {\n1\nfor(j=0; j<3; j++) {\n2\narr[i][j] = 10 * i + j;\n3\n}\n4\n}\n5\nWhich would result in an array that, conceptually, looks something like the following.\n[ 0 1 2 ]\n[ 10 11 12 ]\n[ 20 21 22 ]\n[ 30 31 32 ]\nWhich are all stored in one large chunk of memory. To see this, we can print out the\nmemory address of each \u201crow\u201d during a particular run of the program:\narr[0] = 0x7fe51b403270\narr[1] = 0x7fe51b40327c\narr[2] = 0x7fe51b403288\narr[3] = 0x7fe51b403294\nNote that each hexadecimal value differs by 0x0c (that is, 12 bytes):\n0x...70 + 0x0c = 0x...7c\n0x...7c + 0x0c = 0x...88\n0x...88 + 0x0c = 0x...94\nThis is exactly how many bytes the 3 integers (4 bytes each) take in memory in each\n\u201crow.\u201d The pointer setup is depicted in Figure 20.2.\n323 20. Arrays\n**m\nm[0] m[1] m[2] m[3]\nm[0][0] m[0][1] m[0][2] m[1][0] m[1][1] m[1][2] m[2][0] m[2][1] m[2][2] m[3][0] m[3][1] m[3][2]\nFigure 20.2.: Contiguous Two Dimensional Array. The initial pointer-to-pointers m is\ninitialized to an array of pointers, m[0]..m[3]. A 4\u00d73 contiguous array\nis created and each of the pointers is initialized to the proper location so it\ncan be treated as a two-dimensional array.\n20.5. Dynamic Data Structures\nThe C standard library does not provide a variety of advanced, dynamic data structures\nsuch as linked lists or sets. As of C89 and POSIX.1 the C standard library does provide\nhashtablesandbinarysearchtrees,butdoesnotrequireimplementationsofotherdynamic\ndata structures. Instead, you must either implement your own or utilize a third-party\nlibrary such as glibc, the GNU C library (http:\/\/www.gnu.org\/software\/libc\/).\n324 21. Strings\nC has no built-in string type. Instead, strings are represented as arrays of char elements.\nThey differ from, say arrays of int or double types, however, in that they are null\nterminated arrays. The end of the string must always be denoted with a null-terminating\ncharacter, '\\0' (the 0 valued character in the ASCII table). Failure to properly\nnull-terminate a string may lead to undefined behavior or fatal errors.\nC provides a good variety of functions in its standard string library (included in the\nstring.h header). All of these functions operate under the assumption that the strings\npassedtoitarenull-terminated. Itisyourresponsibilitytoensurethattheyare. Moreover,\nsome of the functions that operate on strings will inset the null-terminating character for\nus, but others will not. It is important to understand the expectations and guarantees of\neach function.\n21.1. Character Arrays\nWe\u2019ve previously used string literals when using the standard input and output functions,\nprintf() and scanf(). You can also create static strings (as static arrays) using the\nstandard assignment operator. Some examples:\nchar firstName[] = \"Tom\";\n1\nchar lastName[] = \"Waits\";\n2\nindex 0 1 2 3 4 5 6 7 8 9\nchar *s H e l l o \\0 ? ? ? ?\nFigure 21.1.: A string in C is achieved by using a char array. However, the string is\nterminated by a null-terminating character, \\0. Though an array may have\nspace for additional characters, they are irrelevant if the null terminator\nprecedes them.\n325 21. Strings\nThis syntax can only be used when creating static strings (they are allocated on the\nstack and locally scoped). The compiler is able to scan the string literal and determine\nhow many characters are needed and even inserts the null-terminating character for us.\nThus, the length of the two strings in the example are 3 and 5 respectively, but the array\nsize created for them will be 4 and 6 respectively to accommodate the null-terminating\ncharacter.\nStatic strings have the same limitations as static arrays. Since they are allocated on the\nstack, they cannot be returned from a function. Just as with int and double types,\nhowever, we can dynamically allocate memory to hold char types using malloc(). The\nimportant difference being that we need to always allocate at least one more character\nto accommodate the null-terminating character.\nchar *fullName = NULL;\n1\nfullName = (char *) malloc(sizeof(char) * 10);\n2\nThisexamplecreatesadynamicallyallocated char arraythatisabletohold9 characters\n(since one will be needed for the null-terminating character). However, once we have\ncreated the array, we cannot simply assign an entire string to it using the usual assignment\noperator.\n\/\/THIS IS *WRONG*:\n1\nfullName = \"Tom Waits\";\n2\nThis will compile, but doesn\u2019t give us what we want. Recall that fullName is a character\npointer. Using the assignment operator simply makes it point to the static, literal string\n\"Tom Waits\". In fact, we lose our reference to the dynamically allocated array that\nwas created with malloc(), resulting in a memory leak.\nInstead, we need to use a function in the standard library to copy a string. The function\nin the standard library that allows you to copy strings is as follows.\nchar *strcpy(char *dest, const char *src);\nThe name, strcpy is short for \u201cstring copy.\u201d1 Both arguments are character pointers.\nIn keeping with the use of the assignment operator, the second argument (\u201csource\u201d)\nis copied into the first, \u201cdestination\u201d (just as with an assignment operator, the value\n1The abbreviations are mostly historic: in the 70s and 80s when memory was measured in kilobytes,\nsaving a few characters made a significant difference.\n326 21.2. String Library\non the right-hand-side is copied into the variable on the left-hand-side). Moreover, the\nsecond argument has been marked as const indicating that it will not be changed.\nThe contents of the first argument will be changed since we are copying a string into\nit, erasing whatever contents it had prior. Finally, the function returns a pointer to the\ndest argument, mostly so that it can be used in nested function calls (though we\u2019ll\navoid such confusingly terse \u201ctricks\u201d). From our example:\n\/\/\"assign\" (copy) \"Tom Waits\" into the string fullName:\n1\nstrcpy(fullName, \"Tom Waits\");\n2\nIn addition, we can access and modify individual characters in a string using the usual\nindexing and assignment operator with char literals.\n\/\/access individual characters:\n1\nchar firstInitial = fullName[0]; \/\/'T'\n2\nchar lastInitial = fullName[4]; \/\/'W'\n3\n4\n\/\/printing:\n5\nprintf(\"First Initial: %c\\n\", fullName[0]);\n6\n7\n\/\/modifying:\n8\nfirstInitial[0] = 't';\n9\nfirstInitial[4] = 'w';\n10\n\/\/fullName is now \"tom waits\"\n11\n21.2. String Library\nThe standard string library provides many other convenient functions that allow you to\nprocess and modify strings. We highlight a few of the more common ones here. A full\nlist of supported functions can be found in standard documentation.\nLength\nAs with regular arrays, we are responsible for ensuring that we do not access characters\noutside the character array of a string. Since a string is null-terminated, there is a nice\n327 21. Strings\nfunction provided by the string library to determine its length,\nsize_t strlen(const char *s);\nRecall that size_t can essentially be treated as an integer, indicating the number of\nbytes in the passed string. Since a character is a single byte, this function tells us how\nmany character are in the given string not including the null-terminating string. This\nfunction is an abbreviation for \u201cstring length.\u201d Using this function we can easily iterate\nover each character in a string.\nint i;\n1\nfor(i=0; i<strlen(fullName); i++) {\n2\nprintf(\"fullName[%d] = %c\\n\", i, fullName[i]);\n3\n}\n4\nConcatenation\nA concatenation function is provided that allows you to append one string to the end of\nanother.\nchar *strcat(char *dest, const char *src);\nSimilar to the strcpy() function, strcat() appends the \u201csource\u201d (src) string to\nthe end of the \u201cdestination\u201d (dest) string. It is your responsibility to ensure that the\ndestination string is large enough to accommodate the source string. If it is not, then it\ncould lead to undefined behavior as strcat() overwrites memory after the end of the\ndestination string. Further, strcat() will copy the null-terminating character for you\nso that the resulting string (now stored in dest) is a valid null-terminated string.\nchar *formattedName = (char *)malloc(11 * sizeof(char));\n1\n\/\/copy \"Waits\" into formattedName\n2\nstrcpy(formattedName, lastName);\n3\n\/\/append a \", \" to formattedName\n4\nstrcat(formattedName, \", \");\n5\n\/\/append the firstName to the formattedName\n6\nstrcat(formattedName, firstName);\n7\n\/\/formattedName now contains \"Waits, Tom\"\n8\n328 21.2. String Library\nByte-Limited Versions\nC also provides several byte-limited versions of the copy and concatenation functions:\nchar *strncpy(char *dest, const char *src, size_t n);\nchar *strncat(char *dest, const char *src, size_t n);\nThey work similarly in that they copy\/concatenate the source, src string into the\ndestination, dest string. However, there is a third parameter, n which specifies at\nmost how many bytes to copy\/concatenate. The parameter, n allows you to limit the\nnumber of characters that the operation uses. If either of these functions encounters the\nnull-terminating character before n bytes have been copied\/concatenated, they stop and\ncopy the null-terminating character for us.\nHowever, these functions do not always handle the null-terminating character for us. If\nthe null-terminating character appears in the first n bytes, it will be copied for us, but\nif it is not, we need to be sure to handle it ourselves. For example,\nchar email[] = \"twaits@cse.unl.edu\";\n1\nchar *login = (char *) malloc(7 * sizeof(char));\n2\n3\n\/\/only copy the first 6 characters:\n4\nstrncpy(login, email, 6);\n5\n\/\/at this point, login contains \"twaits\" but is\n6\n\/\/not null-terminated, so we manually terminate it\n7\nlogin[6] = '\\0';\n8\nComputing a Substring\nThe byte-limited versions of the copy function can be used to compute a substring of\nanother string. The parameter n can be used to limit the length of the string, but how\nmight we specify where the substring should start?\nFor example, in the string \"Thomas Alan Waits\" we may want to get the substring\nrepresenting his middle name, \"Alan\". The length is 4 and we can specify that the\ncopying should start by using an index. In this case, we want the copying to start at\nindex 7, the 8th character. If the string is stored in an array named name, this would\nbe name[7]. However, indexing an array like this results in a single character and\nstrncpy() expects a string (a character pointer). Fortunately, we know how to do this:\n329 21. Strings\nusing the referencing operator, we can turn the 8th character into a character pointer,\n&name[7]. A full example:\nchar name[] = \"Thomas Alan Waits\";\n1\nchar *middleName = (char *) malloc(sizeof(char) * 5);\n2\nstrncpy(middleName, &name[7], 5);\n3\nmiddleName[4] = '\\0';\n4\n\/\/middleName now holds \"Alan\"\n5\nInthecallto malloc(), weincludedspaceforanull-terminatingcharacter. Furthermore,\nstrncpy() does not insert the null-terminating character for us in this case. In line 4\nwe manually insert it.\n21.3. Arrays of Strings\nWe often need to deal with collections of strings. An array of strings can be viewed as a\n2-dimensional character array. Indeed, we\u2019ve seen this before. In the typical C program\u2019s\nmain() function, command line arguments are passed as the second parameter:\nint main(int argc, char **argv)\nwhich is represented as a double character pointer, char **. Conceptually, each row\nis a string, char *. The first parameter, argc indicates how many rows there are.\nThe main() function doesn\u2019t need to be told how big each \u201crow\u201d is since strings are\nnull-terminated.\nWe can create our own arrays of strings similar to how we created 2-dimensional arrays\nof int and double types.\n\/\/create an array that can hold 5 strings\n1\nchar **names = (char **) malloc(5 * sizeof(char*));\n2\nint i;\n3\nfor(i=0; i<5; i++) {\n4\n\/\/each string can hold at most 19 characters\n5\nnames[i] = (char *) malloc(sizeof(char) * 20);\n6\n}\n7\nstrcpy(names[0], \"Margaret Hamilton\");\n8\nstrcpy(names[1], \"Ada Lovelace\");\n9\nstrcpy(names[2], \"Grace Hopper\");\n10\n330 21.4. Comparisons\nstrcpy(names[3], \"Marie Curie\");\n11\nstrcpy(names[4], \"Hedy Lamarr\");\n12\n21.4. Comparisons\nWhen comparing strings in C, we cannot use the numerical comparison operators such\nas ==, or <. Because strings are represented as arrays, using these operators actually\ncompares the variable\u2019s memory addresses.\nchar *a = (char *) malloc(sizeof(char) * 13);\n1\nchar *b = (char *) malloc(sizeof(char) * 13);\n2\nstrcpy(a, \"Hello World!\");\n3\nstrcpy(b, \"Hello World!\");\n4\n5\nif(a == b) {\n6\nprintf(\"strings match!\\n\");\n7\n}\n8\nThe code above will not print anything even though the strings a and b have the\nsame content. This is because a == b is comparing the memory address of the two\nvariables. Since they point to different memory addresses (created by two separate calls\nto malloc()) they are not equal.\nThe C string library provides a standard comparator function to compare strings based\non their content:\nint strcmp(const char *a, const char *b);\nThe function takes two strings and returns an integer based on the lexicographic ordering\nof a and b. If a precedes b, strcmp() returns something negative. It returns zero if\na and b have the same content. Otherwise it returns something positive if b precedes\na. Some examples:\nint x;\n1\nx = strcmp(\"apple\", \"banana\"); \/\/x is negative\n2\nx = strcmp(\"zelda\", \"mario\"); \/\/x is positive\n3\n331 21. Strings\nx = strcmp(\"Hello\", \"Hello\"); \/\/x is zero\n4\n5\n\/\/shorter strings precede longer strings:\n6\nx = strcmp(\"apple\", \"apples\"); \/\/x is negative\n7\n\/\/uppercase precede lowercase:\n8\nx = strcmp(\"Apple\", \"apple\"); \/\/x is negative\n9\nIn the last example, \"Apple\" precedes \"apple\" since uppercase letters are ordered\nbefore lowercase letters according to the ASCII table. We can also make comparisons\nignoring case if we need to using the alternative:\nint strcasecmp(const char *s1, const char *s2);\nwhich is a case-insensitive version. Here, strcasecmp(\"Apple\", \"apple\") will return\nzero as the two strings are the same ignoring the cases.\nThe comparison functions also have byte-limited versions,\nint strncmp(const char *s1, const char *s2, size_t n);\nand\nint strncasecmp(const char *s1, const char *s2, size_t n);\nBoth will only makecomparisons inthe first n bytes ofthe strings. Thus, the comparison,\nstrncmp(\"apple\", \"apples\", 5) will result in zero as the two strings are equal in\nthe first 5 bytes.\n21.5. Conversions\nWe\u2019ve previously examined the functions atoi() and atof() that allow you to convert\nstrings that hold numeric values to int and double values respectively. Another way to\nconvert strings to numbers is to use a function similar to the familiar scanf() function\nwhich reads its string from the standard input. The sscanf() function reads its \u201cinput\u201d\nfrom a string instead of the standard input.\nchar s[] = \"103212.3214\";\n1\ndouble x;\n2\nsscanf(s, \"%lf\", &x);\n3\n\/\/x now has the value 103212.3214\n4\n332 21.6. Tokenizing\nThe sscanf() function differs in its first argument: the string that contains the value\nyou want to parse. Otherwise, the second two arguments are as in scanf(): the format\n(as a string) and the variable(s) that the results should be stored in (passed by reference).\nLikewise, there is a companion sprintf() which is similar to the printf() function,\nbut instead of printing to the standard output, it \u201cprints\u201d to the string. That is, the\nresult is placed in a string.\nint x = 10;\n1\ndouble y = 3.14;\n2\nchar *s = (char *) malloc(sizeof(char) * 50);\n3\nsprintf(s, \"The value of x is %d, y = %f.\", x, y);\n4\n\/\/s now contains \"The value of x is 10, y = 3.140000.\"\n5\n21.6. Tokenizing\nRecall that tokenizing is the process of splitting up a string along some delimiter. For\nexample, the comma delimited string, \"Smith,Joe,12345678,1985-09-08\" contains\nfour pieces of data delimited by a comma. Our aim is to split this string up into four\nseparate strings so that we can process each one. The C string library provides a\ntokenizing function:\nchar *strtok(char *str, const char *delim);\nwhich works as follows. The first argument is the string that you want to tokenize and\nthe second contains the delimiter that you want to split along. The second argument is\nactually a string and allows you to specify more than one delimiter, but we\u2019ll restrict our\nattention to single character delimiters. The function returns a pointer to the first token\nin the string. To get the second and all subsequent tokens, we call strtok() again, but\nwe pass it NULL as the first argument to continue parsing the same string.\nIf we pass a new string as the first argument to strtok() the tokenization process\nwill start over on the new string. Note that the first argument does not have the\nconst keyword. This is because strtok() will make changes to the string during\nthe tokenization process. If the string needs to be preserved, tokenization should be\nperformed on a deep copy of the string.\nWhen there are no more tokens in the string, strtok() returns NULL to indicate no\n333 21. Strings\nmore tokens are in the string. This logic can be used to write a while loop to iterate over\neach token. Consider the following example.\nchar data[] = \"Smith,Joe,12345678,1985-09-08\";\n1\nchar *token = NULL;\n2\n\/\/make the initial call to strtok:\n3\ntoken = strtok(data, \",\");\n4\nwhile(token != NULL) {\n5\nprintf(\"token: %s\\n\", token);\n6\n\/\/get the next token:\n7\ntoken = strtok(NULL, \",\");\n8\n}\n9\nThis outputs the following:\ntoken: Smith\ntoken: Joe\ntoken: 12345678\ntoken: 1985-09-08\nIt should be noted that strtok() is not reentrant. It can only work on one string at a\ntime. In a multithreaded application, two threads cannot both use strtok() or they\nwould end up processing each other\u2019s strings. Even in a non-threaded application, we\nneed to be careful. For example, we cannot process a string using strtok() in one\nfunction and then call another function that does the same. C does provide a reentrant\nversion, strtok_r() that can be used.\n334 22. File I\/O\nC provides several functions to manipulate and process files. Like other I\/O functions,\nthese are all defined in the standard input\/output library, stdio.h. Writing binary\nor plaintext data is determined by which functions you use. Whether or not a file\ninput\/output stream is buffered or unbuffered is determined by the system configuration.\nThere are some ways in which this can be changed, but we will not cover them in detail.\n22.1. Opening Files\nFiles are represented in C by a FILE * pointer type defined in the standard input\/output\nlibrary. As a pointer, it essentially points to the file stored in memory. To open a file,\nyou use the fopen() function (short for file open) which takes two arguments and\nreturns a FILE * pointer:\nFILE *fopen(const char *path, const char *mode);\nThe first argument is the file path\/name that you want to open for processing. The\nsecond argument is a string representing the \u201cmode\u201d that you want to open the file in.\nThere are several supported modes, but the two we will be interested in are reading, in\nwhich case you pass it \"r\" and writing in which case you pass it \"w\". The path can\nbe an absolute path, relative path, or may be omitted if the file is in the current working\ndirectory.\n\/\/open a file for reading (input):\n1\nFILE *input = fopen(\"\/user\/apps\/data.txt\", \"r\");\n2\n\/\/open a file for writing (output):\n3\nFILE *output = fopen(\".\/results.txt\", \"w\");\n4\n5\nif(input == NULL) {\n6\nfprintf(stderr, \"Unable to open input file\");\n7\nexit(1);\n8\n}\n9\n10\nif(output == NULL) {\n11\n335 22. File I\/O\nfprintf(stderr, \"Unable to open output file\");\n12\nexit(1);\n13\n}\n14\nThe two checks above check that the file opened successfully. If the file opening failed,\nfopen() returns NULL. Opening a file can fail for a number of reasons. On POSIX\nsystems for example, additional information can be obtained by accessing the standard\nerror number, errno (see Section 19.1). Some errors that can result:\n\u2022 ENOENT \u2013 No such file or directory\n\u2022 EACCES \u2013 Permission denied\n\u2022 ENOMEM \u2013 Insufficient storage space is available\namong many other possibilities. These error codes can be used to implement more specific\nerror handling code if desired.\n22.2. Reading & Writing\nWhen a file is opened, the file pointer returned by fopen() initially points to the\nbeginning of the file. As you read from it or write to it, the pointer advances through\nthe file content.\n22.2.1. Plaintext Files\nTo process a plaintext file we use two functions, fprintf() for output and fscanf()\nfor input. These two functions should look familiar. They work almost exactly the same\nas printf() and scanf() that work with the standard output and standard input\nrespectively. In fact, the standard in\/out are both files so it makes sense that they can\nbe read from\/written to. The f prefixed versions are simply generalizations that can be\nused for any file. The only difference is that the first argument for these two functions is\nthe file you want to output to or read from.\nint x = 10;\n1\ndouble y = 3.14;\n2\n3\n\/\/write to a plaintext file\n4\n336 22.2. Reading & Writing\nfprintf(output, \"Hello World!\\n\");\n5\nfprintf(output, \"x = %d, y = %f\\n\", x, y);\n6\n7\n\/\/read from a plaintext file\n8\nfscanf(input, \"%d\", &x);\n9\nfscanf(input, \"%lf\", &y);\n10\n11\n\/\/these are equivalent to printf, scanf:\n12\nfprintf(stdout, \"Please enter an integer:\");\n13\nfscanf(stdin, \"%d\", &x);\n14\nUsing fscanf() for arbitrary string input is potentially dangerous as there is limited\nbounds checking. We must store the input value from the file into a string (character\narray), but if the file or line contains more characters than the array can accommodate\nwe may have a buffer overflow.\nA better way to read input is to use fgets() which allows us to limit the number of\nbytes that are read.\nchar *fgets(char *s, int size, FILE *stream);\nThe first argument is the string that the input data will be read into. The second\nparameter is how we limit the number of characters that will be read. It actually reads\nin one fewer character, size-1 to account for the null-terminating character which\nfgets() automatically inserts for us. The last argument is the file pointer that we wish\nto read from.\nThe behavior of fgets() is that it reads up to size-1 characters from the input\nfile and places the results into s. If fgets() encounters either an EOF symbol or\nan endline character, '\\n' it stops reading. In the case of an endline character, it is\nincluded in the result and may need to be chomped out (that is, removed).\nThe fgets() function can be used to process a file line by line until the end of the\nfile is reached. Each line can be processed (perhaps tokenized) individually to extract\nparticular pieces of data. This is typically how a CSV or similar file may be processed.\nTo determine if the end of the file has been reached, you can use the return value of the\nfunction: it returns NULL when no more characters have been read.\nFILE *input = fopen(\"data.txt\", \"r\");\n1\n\/\/this assumes that no line is more than 999 characters\n2\nchar line[1000];\n3\n337 22. File I\/O\n\/\/read the first line\n4\nchar *s = fgets(line, 1000, input);\n5\nwhile(s != NULL) {\n6\n7\n\/\/chomp the endline character from line:\n8\nline[strlen(line)-1] = '\\0';\n9\n10\n\/\/process the current buffer\n11\n\/\/for demonstration, we simply print it:\n12\nprintf(\"line = %s\\n\", line);\n13\n14\n\/\/read the next line\n15\ns = fgets(line, 1000, input);\n16\n}\n17\nA similar function, int fgetc(FILE *stream) allows us to get a single character from\nthe input file (returned as an int) if we prefer to read character by character.\n22.2.2. Binary Files\nTo read and write binary data to files we use two different functions:\nsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);\nfor reading from a file and\nsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\nto write to a file. Both functions have the exact same arguments:\n1. ptr is a pointer to the item that is being read\/written (possibly an array of\nelements)\n2. size is the number of bytes that each element stored at ptr take, usually\ndetermined by using sizeof()\n3. nmemb is the number of elements to be written\/read\n4. stream is the file stream to be read from\/written to\nThese functions allow you to read\/write an arbitrary amount of binary data. When\nreading, it is your responsibility, as usual, to ensure that the ptr is large enough to\n338 22.3. Closing Files\naccommodate the data you are reading into it.\nint x = 10;\n1\n2\nFILE *binaryOutputFile = fopen(\"demo.bin\", \"w\");\n3\n4\n\/\/write a single int to a file:\n5\nfwrite(&x, sizeof(int), 1, binaryOutputFile);\n6\n7\nFILE *binaryInputFile = fopen(\"input.bin\", \"r\");\n8\n9\n\/\/read a single int from the file:\n10\nfread(&x, sizeof(int), 1, binaryInputFile);\n11\n12\n\/\/read an entire array from the file:\n13\nint *a = (int *) malloc(10 * sizeof(int));\n14\nfread(a, sizeof(int), 10, binaryInputFile);\n15\n22.3. Closing Files\nOnce you are done processing a file, you should close it using the fclose() function:\nint fclose(FILE *fp);\nwhich takes a single argument, the FILE pointer of the file you wish to close. Closing\nan invalid file may result in an error or segmentation fault. In any case, after a file has\nbeen closed, it cannot be read from or written to, doing so is undefined behavior. Failure\nto close a file may result in a corrupted file.\n339  23. Structures\nStrictly speaking, C is not an object-oriented programming language, it is an imperative\n(or, relatedly a structured or procedural) programming language. This means that C can\nbe characterized as a language that changes a program\u2019s state through statements and\nthe use of function calls. Though C does not have objects, it does support a \u201cweak\u201d form\nof encapsulation through the use of structures. Structures are a user-defined type that\ncollects multiple pieces of data together into one logical unit. Once defined, structures\ncan be used in a program just like any other variable type; structure variables can be\ndeclared, passed and returned from functions, pointers to structures can be used, etc.\nStructures form a \u201cweak\u201d form of encapsulation in that they only provide the grouping of\ndata. The protection of data through visibility keywords is not supported. The grouping\nof functions that act on that data is also not readily supported.1 However, even this\nweak form provides a very useful and convenient way to collect related pieces of ?ata.\n23.1. Defining Structures\nTo define a structure, we use the keyword struct along with the previously introduced\nkeyword typedef. To motivate an example, let\u2019s reconsider a student entity, which has\nan ID (integer), first and last name (strings), and a GPA (a floating point number). Each\nof these pieces of data can be encapsulated into a structure as follows.\ntypedef struct {\n1\nint id;\n2\nchar *firstName;\n3\nchar *lastName;\n4\ndouble gpa;\n5\n} Student;\n6\nNote the syntax and naming conventions:\n1You can define a structure with function pointers as elements, so structures could technically include\n\u201cmethods\u201dbutthisisnotreallywhatmostpeoplethinkofwhenconsideringobject-orientedparadigms.\n341 23. Structures\n\u2022 The elements of the structure (also referred to as components or members) are\nincluded inside curly brackets, delimited using semicolons (in contrast to an enu-\nmerated type which is a list, these elements do not constitute a list).\n\u2022 A structure may contain any number of elements of any type.\n\u2022 Thename(identifier)ofthestructureisprovidedattheend, endedwithasemicolon.\n\u2022 We use a modern naming convention: each element is named using lower camel\ncasing while the name of the structure itself uses upper camel casing.\nIn addition, structure declarations are generally placed in a header file along with any\nany function prototypes that use the structure as a parameter or a return type. Once\nyou have defined a structure you can use it as you would a built-in variable type. For\nexample,\nStudent s;\ndeclares a Student structure with the variable name s.\n23.1.1. Alternative Declarations\nIn some examples and code bases you may find an alternative way of declaring a structure\nthat looks like the following.\nstruct Student {\n1\n...\n2\n};\n3\nThis syntax omits the keyword typedef and places the structure name at the beginning.\nThe difference is a bit technical (the original syntax creates an anonymous structure with\nthe Student identifier placed in the global namespace, while this declaration places the\nStudent identifier in the structure namespace), but one of the consequences of using\nthis type of declaration is that the Student identifier is not in the global scope, so to\ndeclare a variable of the type Student you need to further specify that it is a structure\nusing the following syntax.\nstruct Student s;\nFurther, you may also see another style,\n342 23.1. Defining Structures\ntypedef struct Student {\n1\n...\n2\n} Student;\n3\nWhich places the Student identifier in both the global space and in the \u201cstructure\u201d\nspace. Which style of declaration you use depends on several factors, but for simplicity\nwe\u2019ll stick with the first style.\nIn addition, you may see some older naming conventions use lowercase underscore\nnaming for structure names. In particular, POSIX systems use names that end with\n_t (indicating a structure type). You should avoid such naming conventions to avoid\nconflicts.\nFinally, though C does not provide a mechanism for the protection of data, many\nlibraries and code bases will begin certain member variables with underscore(s) to\nindicate that they are \u201cinternal\u201d variables used by the library and should not be accessed\nor modified. For example, _someVariable or __anotherVariable would indicate\n\u201cprivate\u201d variables that should not be tampered with. The C language itself would still\nallow you access and modify the variables, but doing so may violate assumptions and\nexpectations of the library code, leading to undefined behavior.\n23.1.2. Nested Structures\nConsider adding another member variable to the Student structure to model a student\u2019s\ndate of birth. How might we model a date? Unix systems model time as a single\ninteger value that represents the number of milliseconds that have passed since the\nUnix epoch, January 1st, 1970 (also known as Coordinated Universal Time (UTC)).\nFor example, the New Horizons space probe was launched on January 19th, 2006 at\n19:00:00 UTC. This corresponds to 1,137,697,200, roughly 1.137 billion milliseconds since\nthe epoch. Another way to model time is as a string. There are several standards for\ntime representations, but the most common is ISO standard 8601 [22] which specifies\ntime using a format that includes a date, time and an offset from Greenwich Mean\nTime (GMT). For example, the New Horizons launch date\/time would be represented as\n\"2006-01-19T19:00:00+00:00\".\nTo keep things simple, we\u2019ll model our date using three numbers: a year, a month and\na date. But how should we implement this? Conceptually, a date is a single entity,\nseparating these three numbers doesn\u2019t make much sense. This is a perfect opportunity\nto define another structure.\n343 23. Structures\ntypedef struct {\n1\nint id;\n2\nchar *firstName;\n3\nchar *lastName;\n4\ndouble gpa;\n5\nDate dateOfBirth;\n6\n} Student;\n7\nCode Sample 23.1.: A Student structure declaration\ntypedef struct {\n1\nint year;\n2\nint month;\n3\nint date;\n4\n} Date;\n5\nOnce we have defined a structure we can use it as we would a normal variable, so it\nmakes sense that we could include it in another structure.\nThis is a good illustration of a form of composition where one structure may be composed\nof other structures. Since the Student structure \u201cowns\u201d an instance of the Date\nstructure, it is necessary to ensure that the Date structure is declared before the\nStudent structure (just as we need to declare variables before we use them.\n23.2. Usage\n23.2.1. Declaration & Initialization\nOnce we have defined a structure (and included the header file it has been defined in),\nwe can create instances using the usual syntax.\nStudent s;\n1\nStudent t;\n2\n344 23.2. Usage\nThese static declarations will allocate enough space on the stack to hold all of the data\nassociated with the structures (the two char * pointers, int, and double and the\nthree int variables in the Date structure). However, the values stored in each of the\nstructure\u2019s member variables are undefined. With this style of declaration, C does not\ndefine default values.\nAnother way to declare instances of our structures is to use the following syntax.\nStudent s = {};\n1\nStudent t = {\n2\n12345678,\n3\n\"Grace\",\n4\n\"Hopper\",\n5\n4.0,\n6\n{\n7\n1906,\n8\n1,\n9\n1\n10\n}\n11\n};\n12\nThe first declaration creates a Student structure with default values (zero for any\nnumeric types, null for any pointers). The second creates a Student structure\ninitialized with the values provided in the curly brackets. The order matters here and\nwill match the ordering of the original structure declaration. Since the dateOfBirth\nis a structure itself, a nested set of values within curly brackets is necessary. One draw\nback to this type of declaration is that the character pointers are statically declared. The\nstrings \"Grace\" and \"Hopper\" are initialized in a read-only segment of memory, any\nattempts to change the contents of these strings are undefined behavior. The pointers\nthemselves, however, can be reassigned.\nThis static declaration allocates the structure on the stack. Since structures consist of\nmultiple pieces of data, their memory footprint is larger. Allocating larger and larger\nstructures on the stack runs the risk of running out of stack memory resulting in a stack\noverflow. To solve this, we can instead use dynamically allocated structures.\nTo dynamically allocate a structure, we use a pointer to a structure and a call to\nmalloc() to allocate enough space for the structure. Even though our structure is\nuser-defined, we can still use the sizeof() macro to determine the number of bytes\nrequired by the structure. The compiler and macro are \u201csmart\u201d enough to look at the\nstructure declaration and determine the size of each of its variables and add up the total\nnumber of bytes required.\n345 23. Structures\nStudent *s = (Student *) malloc(sizeof(Student) * 1);\nThe multiplication by 1 in this example is not strictly necessary, but emphasizes the fact\nthat we are allocating space for one structure and not an array of structures. Initializing\na dynamically allocated structure like this does not initialize any of its variables as\nthere are no default values defined by C. Moreover, it does not initialize memory for any\npointer member variables. For example the firstName and lastName pointers need\nto be manually initialized with additional malloc() calls.\n23.2.2. Selection Operators\nOnce we have a declared structure, we need to access its member variables and perhaps\nupdate them. If we have a statically declared structure, such as\nStudent s;\nwe can use the direct component selector operator, which is simply just a period followed\nby the member variable we wish to access. Commonly, this is referred to simply as the\ndot operator.\nStudent s;\n1\n2\n\/\/set values:\n3\ns.id = 87654321;\n4\ns.gpa = 3.9;\n5\n6\n\/\/access values:\n7\nprintf(\"Name: %s, %s\\n\", s.lastName, s.firstName);\n8\nprintf(\"GPA: %.2f\\n\", s.gpa);\n9\nWhen structures are nested, we can use the dot operator multiple times to access members\nvariables of member variables.\ns.dateOfBirth.year = 2525;\n1\ns.dateOfBirth.month = 12;\n2\ns.dateOfBirth.date = 25;\n3\nWhen we have a pointer to a structure, we cannot directly use the dot operator. Instead,\n346 23.2. Usage\nwe have to change the pointer into a \u201cnormal\u201d structure by dereferencing it, then we can\nuse the dot operator. However, the dot operator has a higher order of precedence than\nthe dereferencing operator, thus parentheses are required:\nStudent *s = ...;\n1\n(*s).id = 87654321;\n2\nThis can be a bit unwieldy, so C provides a convenience operator, the indirect component\nselector operator, or more commonly, the arrow operator that allows us to select a member\nvariable with a single operator that resembles a right-pointing arrow.\nStudent *s = (Student *) malloc(sizeof(Student));\n1\n2\n\/\/set values:\n3\ns->id = 87654321;\n4\ns->gpa = 3.9;\n5\n6\n\/\/initialize the string variables:\n7\ns->firstName = (char *) malloc(sizeof(char) * 6);\n8\nstrcpy(s->firstName, \"Grace\");\n9\ns->lastName = (char *) malloc(sizeof(char) * 7);\n10\nstrcpy(s->lastName, \"Hopper\");\n11\n12\n\/\/access values:\n13\nprintf(\"Name: %s, %s\\n\", s->lastName, s->firstName);\n14\nprintf(\"GPA: %.2f\\n\", s->gpa);\n15\n16\ns->dateOfBirth.year = 2525;\n17\nNote the last line: the dateOfBirth member variable was another structure, but not a\npointertoastructure, soweusethedotoperatortoaccessthe year membervariable. Al-\nternatively, we could have defined dateOfBirth to be a pointer, Date *dateOfBirth;\nin the Student structure. If we had, then to access the year member variable using\ntwo arrow operators, s->dateOfBirth->year.\n347 23. Structures\n23.3. Arrays of Structures\nJust as we can create arrays of built-in types such as integers, we can also create arrays of\nour user-defined structures. As an example, the following creates an array of 10 Student\nstructures. Once created, we can treat them like any other array.\nStudent *roster = (Student *) malloc(sizeof(Student) * 10);\n1\n2\n...\n3\n4\ndouble sum = 0.0;\n5\nfor(i=0; i<10; i++) {\n6\nsum += roster[i].gpa;\n7\n}\n8\ndouble averageGpa = sum \/ 10;\n9\nAs in the example, we can index each element in the array, roster. Once indexed, each\nelement is a regular structure and so we use the dot operator to access each of its member\nvariables. As with any other array, each element takes up a number of bytes, equal to\nsizeof(Student). We can swap and reassign each element just like any other variable.\nFor example, the following code swaps the first two elements using a temporary variable.\nStudent temp = roster[0];\n1\nroster[0] = roster[1];\n2\nroster[1] = temp;\n3\nEach of these operations copies over every byte that makes up the structure. For small\nstructures, this isn\u2019t that big of a deal. However, for larger structures, this may become\nan issue, especially if we do this often or pass structures around to functions.\nAs an alternative, we could instead deal indirectly with structures by creating an array\nof pointers to structures. Swapping elements then involves only copying pointer values\nrather than every byte that makes up the structure. To do this, we use the familiar\npointer-to-pointer syntax.\nStudent **roster = (Student **) malloc(sizeof(Student *) * 10);\n1\nfor(i=0; i<10; i++) {\n2\n348 23.3. Arrays of Structures\nroster[i] = (Student *) malloc(sizeof(Student) * 1);\n3\n}\n4\n5\n\/\/access each as pointers and use the arrow operator\n6\nroster[0]->id = 87654321;\n7\nroster[0]->gpa = 4.0;\n8\n9\n\/\/swap the first two *pointers*:\n10\nStudent *temp = roster[0];\n11\nroster[0] = roster[1];\n12\nroster[1] = temp;\n13\nAs in the example above, if each element in the array is a pointer to a structure, then we\nuse the arrow operator to access each member variable.\nThe differences between these two approaches is illustrated in Figures 23.1 and 23.2. As\npresented, each Student structure takes 40 bytes.2 With the first approach (as in Figure\n23.1, each structure instance is stored contiguously in memory. Swapping two records\ninvolves copying entire blocks of 40 bytes. In contrast, using pointers to structures as in\nFigure 23.2 means that structures may be stored non-contiguously in different memory\nlocations. Swapping two structures is done indirectly by swapping pointers (only 8 bytes).\nThe difference in this particular example is not that great (8 vs. 40 bytes), but with\nlarger structures it can become an issue. Each approach has its own advantages and\ndisadvantages and one may be more appropriate than the other in different situations.\nHybrid Approach\nIt is also possible to take a \u201chybrid\u201d approach to storing structures in arrays that stores\nthem both contiguously, but also allows you to reference them indirectly through a pointer\narray. This is essentially what we did in Section 20.4.1 when we created a contiguous\n2-dimensional array of integers. We made a single call to malloc and then had to setup\nthe pointers to each \u201crow.\u201d To do this with structures, we can do something similar.\nFirst, we declare and allocate a dynamic array as before.\nint n = 10;\n1\nStudent *rosterData = (Student *) malloc(n * sizeof(Student));\n2\n2This is just an estimate and may vary on different systems and compilers. Usually, compilers use\nalignment and may pad structures with extra bytes in order to make it more efficient to store in\nmemory.\n349 23. Structures\nStudent *roster roster[0] 40bytes\n(Student)\nroster[1] 40bytes\n(Student)\nroster[2] 40bytes\n(Student)\n...\nroster[n-1] 40bytes\n(Student)\nFigure 23.1.: An array of structures. Each record is stored in a contiguous manner one\nafter the other.\nStudent\n(40bytes)\nroster[0]\nStudent **roster\n(Student*)\nStudent\nroster[1]\n(40bytes)\n(Student*)\nroster[2]\n(Student*)\nStudent\n...\n(40bytes)\nroster[n-1]\n(Student*)\nStudent\n(40bytes)\nFigure 23.2.: An array of structure pointers. Each record is a pointer that refers to a\nstructure which may be stored non-contiguously in completely different\nmemory locations.\n350 23.4. Using Structures With Functions\nThen, we can declare an array of Student pointers as well.\nStudent **roster = (Student **) malloc(n * sizeof(Student *));\n1\nButnowweneedtomakeeach roster[i] pointerpointtothei-threcordin rosterData.\nEach record, rosterData[i] is a regular structure, but we need a pointer to it. In\norder to get a pointer, we use the referencing operator, &rosterData[i] and make each\npointer point to it.\nfor(i=0; i<n; i++) {\n1\nroster[i] = &rosterData[i];\n2\n}\n3\nThis approach is illustrated in Figure 23.3. Now we can indirectly reference each record\nin rosterData via a pointer in the roster array.\nroster[0]->nuid = 12345678;\n1\nIf we wanted to \u201cswap\u201d two records, we simply swap their pointers instead of their data.\nIndeed, care must be taken not to swap the data in rosterData otherwise the pointers\nwould become invalid and out-of-synch with the data array.\n23.4. Using Structures With Functions\nAs with built-in types, we can use structures as parameters to functions as well as the\nreturn type of functions. Consider the following examples.\nvoid foo(Student s);\n1\nStudent bar();\n2\n351 23. Structures\nStudent *rosterData\nroster[0] 40bytes\n(Student)\nroster[0]\nStudent **roster\n(Student*)\nroster[1] roster[1] 40bytes\n(Student*) (Student)\nroster[2]\n(Student*) roster[2] 40bytes\n(Student)\n...\nroster[n-1]\n...\n8bytes\n(Student*)\nroster[n-1] 40bytes\n(Student)\nFigure 23.3.: Hybrid Array of Structures. The rosterData is an array of contiguous\nstructures. The roster array is an array of pointers that refer to each\nrecord. Accessing elements in rosterData is done indirectly through a\npointer in roster\nIn the first prototype, we would pass a Student structure by value to the function. As\nwe\u2019ve already seen, this would mean that every byte of the structure would be copied\nonto the stack. For larger structures, we risk a stack overflow while for even smaller\nstructures this can be very inefficient. Likewise, the second prototype would return a\nstructure. When assigned to a variable, every byte is copied. A better solution is to use\ndynamically allocated structures, passing them by reference to functions, and returning\npointers to dynamically allocated instances as return types. For example, the functions\nabove would be better implemented as follows.\nvoid foo(const Student *s);\n1\nStudent * bar();\n2\nIn the first example, we\u2019ve used the const keyword which prevents any changes to\nthe structure\u2019s values (we may omit this if we need to design a function that changes\nits values). We will now consider several idiomatic examples of using structure with\nfunctions.\n352 23.4. Using Structures With Functions\n23.4.1. Factory Functions\nProperly creating and initializing structure instances can be a complex and tedious\ntask. However, it is likely that we will need to repeat this operation over and over. We\ncan simplify our task if we write a utility function that creates a structure instance\nfor us. We provide the function the values we want initialized to. Such functions are\nsometimes referred to as factory functions as they can be used to manufacture as many\ninstances as we want (in object-oriented programming languages, such methods are called\nconstructors).\nWe will need to take care that we make deep copies of any dynamically allocated elements\nsuch as strings. Shallow copies where references are shared may lead to unexpected\nbehavior as changes to one string may affect multiple structures.\n\/**\n1\n* This function creates a new student structure with the\n2\n* given values.\n3\n*\/\n4\nStudent * createStudent(const char *firstName,\n5\nconst char *lastName,\n6\nint id,\n7\ndouble gpa) {\n8\n9\nStudent *s = NULL;\n10\ns = (Student *) malloc(sizeof(Student) * 1);\n11\n12\n\/\/make a deep copy of the strings\n13\ns->firstName = (char *)malloc(sizeof(char)*(strlen(firstName)+1));\n14\nstrcpy(s->firstName, firstName);\n15\ns->lastName = (char *)malloc(sizeof(char)*(strlen(lastName)+1));\n16\nstrcpy(s->lastName, lastName);\n17\n18\ns->id = id;\n19\ns->gpa = gpa;\n20\n21\nreturn s;\n22\n}\n23\nAnother common operation is to create a copy of a given structure. We will want to\nagain ensure that everything is a deep copy so that the two structures are not sharing\nreferences. We can easily do this by reusing the functionality we just wrote in the factory\n353 23. Structures\nfunction.\n\/**\n1\n* This function creates a new, deep copy of a Student\n2\n* structure .\n3\n*\/\n4\nStudent * copyStudent(const Student *s) {\n5\nreturn createStudent(s->firstName, s->lastName, s->id, s->gpa);\n6\n}\n7\n23.4.2. To String Functions\nAnother common operation with structures is to output their data as a human-readable\nstring representation. We could write a function that output a structure\u2019s member\nvariables to the standard output using printf(). However, it would more useful if we\ncreated a general function that returned a string representation of the structure. That\nway, we could decide what to do with the string: output it to the standard output, to a\nfile, etc. Not all structure instances will require the same length string. Some students\nfor example may have long names, while others have short. We can handle this by first\ncalculating the length of the string necessary for whatever formatting we\u2019ve chosen.\n\/**\n1\n* Returns a string representation of the given\n2\n* Student structure.\n3\n*\/\n4\nchar * studentToString(const Student *s) {\n5\n6\nint n = strlen(s->firstName) +\n7\nstrlen(s->lastName) +\n8\n8 + \/\/id, assumed to always be at most 8 digits\n9\n4 + \/\/gpa, assumed to be 0.0 - 4.0\n10\n19; \/\/other formatting characters\n11\n12\nchar *str = (char *) malloc(sizeof(char) * n);\n13\n14\nsprintf(str, \"%s, %s, ID = %d (GPA = %.2f)\",\n15\ns->lastName, s->firstName, s->id, s->gpa);\n16\n17\nreturn str;\n18\n354 23.4. Using Structures With Functions\n}\n19\nHere, we\u2019ve utilized a variation on the familiar printf() function, sprintf() which\n\u201cprints\u201d the result not to the standard output or a file, but to a string, specified as the\nfirst argument. This function would end up returning a string similar to the following for\nour previous example: \"Hopper, Grace, ID = 87654321 (GPA = 3.90)\"\n23.4.3. Passing Arrays of Structures\nWe often also have need to pass arrays of structures to functions. As an example, consider\npassing an entire roster of students to a function in order to compute the average GPA.\nIf we have an array of structures, we would have a function that looked something like\nthe following.\n\/**\n1\n* Computes the average GPA of the Student structures in\n2\n* the given roster (which is of size n).\n3\n*\/\n4\ndouble computeAverageGpa(const Student *roster, int n) {\n5\ndouble sum = 0.0;\n6\nint i;\n7\nfor(i=0; i<n; i++) {\n8\nsum += roster[i].gpa;\n9\n}\n10\nreturn sum \/ n;\n11\n}\n12\nWhen we pass in the array of structures, it is not passed by value. That is, the total\nnumber of bytes for each student is not copied onto the call stack. Nevertheless, as we\u2019ve\npreviously seen it is sometimes preferable to maintain an array of pointers to structures.\nIf we had an array of pointers, we would have a function that looks something like the\nfollowing.\n\/**\n1\n* Computes the average GPA of the Student structures in\n2\n* the given roster (which is of size n).\n3\n355 23. Structures\n*\/\n4\ndouble computeAverageGpa(const Student **roster, int n) {\n5\ndouble sum = 0.0;\n6\nint i;\n7\nfor(i=0; i<n; i++) {\n8\nsum += roster[i]->gpa;\n9\n}\n10\nreturn sum \/ n;\n11\n}\n12\nThe only difference here is in how we access the gpa member variable using the arrow\noperator instead of the dot operator.\n356 24. Recursion\nC supports recursion with no special syntax necessary. However, as a structured,\nprocedural language, recursion is generally expensive and iterative or other non-recursive\nsolutions are generally preferred. We present a few examples to demonstrate how to\nwrite recursive functions in C.\nThe first example of a recursive function we gave was the toy count down example. In C\nit could be implemented as follows.\nvoid countDown(int n) {\n1\nif(n==0) {\n2\nprintf(\"Happy New Year!\\n\");\n3\n} else {\n4\nprintf(\"%d\\n\", n);\n5\ncountDown(n-1);\n6\n}\n7\n}\n8\nAs another example that actually does something useful, consider the following recursive\nsummation function that takes an array, its size and an index variable. The recursion\nworksasfollows: iftheindexvariablehasreachedthesizeofthearray, itstopsandreturns\nzero (the base case). Otherwise, it makes a recursive call to recSum(), incrementing\nthe index variable by 1. When the function returns, it adds its result to the i-th element\nin the array. To invoke this function we would call it with an initial value of 0 for the\nindex variable: recSum(arr, n, 0).\nint recSum(const int *arr, int size, int i) {\n1\nif(i == size) {\n2\nreturn 0;\n3\n} else {\n4\nreturn recSum(arr, size, i+1) + arr[i];\n5\n}\n6\n}\n7\n357 24. Recursion\nThis example was not tail-recursive as the recursive call was not the final operation (the\nsum was the final operation). To make this function tail recursive, we can carry the\nsummation through to each function call ensuring that the summation is done prior to\nthe recursive function call.\nint recSumTail(const int *arr, int size, int i, int sum) {\n1\nif(i == size) {\n2\nreturn sum;\n3\n} else {\n4\nreturn recSumTail(arr, size, i+1, sum + arr[i]);\n5\n}\n6\n}\n7\nAs a final example, consider the following C implementation of the naive recursive\nFibonacci sequence. An additional condition has been included to check for \u201cinvalid\u201d\nnegative values of n for which zero is returned.\nint fibonacci(int n) {\n1\nif(n < 0) {\n2\nreturn 0;\n3\n} else if(n <= 1) {\n4\nreturn 1;\n5\n} else {\n6\nreturn fibonacci(n-1) + fibonacci(n-2);\n7\n}\n8\n}\n9\nC is not a language that provides implicit memoization. Instead, we need to explicitly\nkeep track of values using a table. In the following example, the table is passed to the\nfunction as an argument.\nint fibonacciMemoization(int n, int *table) {\n1\nif(n < 0) {\n2\nreturn 0;\n3\n} else if(n <= 1) {\n4\nreturn 1;\n5\n358 } else if(table[n] > 0) {\n6\nreturn table[n];\n7\n} else {\n8\nint a = fibonacciMemoization(n-1, table);\n9\nint b = fibonacciMemoization(n-2, table);\n10\nint result = (a + b);\n11\ntable[n] = result;\n12\nreturn result;\n13\n}\n14\n}\n15\nIt is the responsibility of the calling function to ensure that the table array is large\nenough to accommodate all values. In this case should be at least of size (n + 1) to\ncompute the n-th Fibonacci number.\n359  25. Searching & Sorting\nThe standard C library provides several functions to search and sort arrays of any type of\nelement including int, double, or even user-defined structures such as our Student\nexample from Chapter 23. These functions are able to operate on any type of array\nbecause they take generic void * pointers. However, these functions still need a way to\norder the generic elements. To understand how this all works we need to understand\nboth comparator functions and function pointers.\n25.1. Comparator Functions\nLet\u2019s consider a \u201cgeneric\u201d Quick Sort algorithm as was presented in Algorithm 12.6. The\nalgorithm itself specifies how to sort elements, but it doesn\u2019t specify how they are ordered.\nThe difference is subtle but important. Essentially, Quick Sort needs to know when two\nelements, a,b are in order, out of order, or equivalent in order to decide which partition\neach element goes in. However, it doesn\u2019t \u201cknow\u201d anything about the elements a and b\nthemselves. They could be numbers, they could be strings, they could be user-defined\nobjects.\nA sorting algorithm still needs to be able to determine the proper ordering in order to sort.\nIn C this is achieved through a comparator function, which is a function that is responsible\nfor comparing two elements and determining their proper order. A comparator function\nhas the following signature and behavior:\nint cmp(const void *a, const void *b);\n\u2022 The function takes two generic void * pointers which refer to the elements being\ncompared.\n\u2022 Moreover, the const keyword is used to indicate that no changes will be made to\nthe elements.\n\u2022 The function returns an integer indicating the relative ordering of the two elements:\n\u2013 It returns something negative, < 0 if a comes before b (that is, a < b)\n\u2013 It returns zero if a and b are equal (a = b)\n361 25. Searching & Sorting\n\u2013 It returns something positive, > 0 if a comes after b (that is, a > b)\nNotethatthereisnoguaranteeonthevalue\u2019smagnitude, itdoesnot necessarilyreturn\u22121\nor +1; it just returns something negative or positive. We\u2019ve previously seen this pattern\nwhen comparing strings. The standard string library provides a function, strcmp()\nthat has the same basic contract: it takes two strings and returns something negative,\nzero or something positive depending on the lexicographic ordering of the two strings.\nStrictly speaking, however, strcmp() is not a comparator function. It is defined to take\ntwo const char * parameters, not const void * pointers.\nThe C language (and thus the compiler) \u201cknows\u201d how to compare built-in primitive types\nlike int and double using the built-in comparison operators. However, to generalize\nthe comparison operation, we use void * pointers so that we can write and use general\ncomparator functions that can be used in generic searching and sorting functions. As an\nexample, let\u2019s write a comparator function that orders integers in ascending order. We\u2019ll\ncall our function cmpInt() and use the signature above.\nint cmpInt(const void *a, const void *b) {\n1\n2\n}\n3\nBut how might we implement this function? Obviously we want to compare the values\nstored in the pointer variables, so we need to dereference them. However, the comparison,\n(*a < *b) for example is not comparing integer values. The variables a and b are\nvoid pointers, not int pointers. In general, you cannot dereference a void pointer.\nDereferencing an int * or double * is possible because the compiler knows how many\nbytes each type takes. However, the number of bytes a void type takes is undefined.\nThus, the first step is to make them int pointers by doing an explicit type cast:\nconst int *x = (const int *) a;\n1\nconst int *y = (const int *) b;\n2\nNow the variables x and y are int pointers which can be dereferenced and compared\n(we preserve the keyword const to ensure we do not make changes to the variables).\nint cmpInt(const void *a, const void *b) {\n1\nconst int *x = (const int *) a;\n2\nconst int *y = (const int *) b;\n3\n362 25.1. Comparator Functions\nif(*x < *y) {\n4\nreturn -1;\n5\n} else if(*x == *y) {\n6\nreturn 0;\n7\n} else {\n8\nreturn 1;\n9\n}\n10\n}\n11\nWhat if we wanted to order integers in the opposite order? We could write another\ncomparator in which the comparisons or values are reversed. Even simpler, we could\nreuse the comparator above and \u201cflip\u201d the sign by multiplying by \u22121 (the purpose of\nwriting functions is code reuse, after all). Even simpler, we could flip the arguments we\npass to cmpInt() to reverse the order.\nint cmpIntDesc(const void *a, const void *b) {\n1\nreturn cmpInt(b, a);\n2\n}\n3\nThe examples above illustrate the standard implementation pattern of comparator\nfunctions:\n1. Make the general const void * pointers into a const pointer to the specific\ntype you want to compare by making an explicit type cast.\n2. Use the state of the type (one or more components if you are comparing structures)\nto determine their order.\n3. Return an integer that expresses the desired order of elements.\nThe cautious observer may be asking: what happens if I call a comparator and pass it\npointers to mismatched elements? For example, what if I pass two double pointers to\ncmpInt()? Obviously, the code will not work as intended (it will end up comparing the\nupper 32 bits of the double values, which leads to unintended behavior). A comparator\nfunction is designed with certain expectations. Namely, that a user will always pass it\nvalid pointers to int values. If a user violates these expectations, it is their fault, not\nours. This is no different from many other functions in the standard library. Passing\nnon-null terminated strings to most string functions for example is undefined behavior.\nTo illustrate some more examples, consider the Student structure we defined in Code\n363 25. Searching & Sorting\nSample 23.1. The following code samples demonstrate various ways of ordering Student\nstructures based on one or more of their components.\n\/**\n1\n* A comparator function to order Student structures by\n2\n* last name\/first name in alphabetic order\n3\n*\/\n4\nint studentByNameCmp(const void *s1, const void *s2) {\n5\nconst Student *a = (const Student *)s1;\n6\nconst Student *b = (const Student *)s2;\n7\nint result = strcmp(a->lastName, b->lastName);\n8\nif(result == 0) {\n9\nreturn strcmp(a->firstName, b->firstName);\n10\n} else {\n11\nreturn result;\n12\n}\n13\n}\n14\n\/**\n1\n* A comparator function to order Student structures by\n2\n* last name\/first name in reverse alphabetic order\n3\n*\/\n4\nint studentByNameCmpDesc(const void *s1, const void *s2) {\n5\nreturn studentByNameCmp(s2, s1);\n6\n}\n7\n\/**\n1\n* A comparator function to order Student structures by\n2\n* id in ascending numerical order\n3\n*\/\n4\nint studentIdCmp(const void *s1, const void *s2) {\n5\nconst Student *a = (const Student *)s1;\n6\nconst Student *b = (const Student *)s2;\n7\nif(a->nuid < b->nuid) {\n8\nreturn -1;\n9\n} else if(a->nuid == b->nuid) {\n10\nreturn 0;\n11\n364 25.2. Function Pointers\n} else {\n12\nreturn 1;\n13\n}\n14\n}\n15\n\/**\n1\n* A comparator function to order Student structures by\n2\n* GPA in descending order\n3\n*\/\n4\nint studentGpaCmp(const void *s1, const void *s2) {\n5\nconst Student *a = (const Student *)s1;\n6\nconst Student *b = (const Student *)s2;\n7\nif(a->gpa > b->gpa) {\n8\nreturn -1;\n9\n} else if(a->gpa == b->gpa) {\n10\nreturn 0;\n11\n} else {\n12\nreturn 1;\n13\n}\n14\n}\n15\n25.2. Function Pointers\nNow that we have comparator functions to order elements, we need a way of passing a\ncomparator to a generic search or sort function so that it can be used by that function.\nTo achieve this in C, we use function pointers.\nRecall that a pointer is simply a reference to some memory location. As we\u2019ve already\nseen, pointers can point to variables of simple data types such as int or double,\narrays of these types or even user-defined structures. We\u2019ve also seen that pointers can\nbe generic using the void keyword. The malloc() function for example, returned a\ngeneric void pointer, void *, to allow it to be used to allocate memory for any type.\nGeneric void pointers simply point to the start of a memory block, not necessarily to\na memory location of any particular type of variable. As we\u2019ve also already seen, the\nprogram code itself lives in memory (the stack). It thus makes sense that we could\n365 25. Searching & Sorting\nreference a memory location that, instead of containing variables, contains executable\ncode, in particular a function. This is what a function pointer does: it points to a memory\nlocation where the code for the function is stored.\nTo declare a function pointer, we need to specify more information than a typical int *\nor double * pointer. Since it points to a function, we need to specify the function\u2019s\nsignature: its return type and parameter list. Consider the following example:\nint (*ptrToFunc)(int, double, char) = NULL;\nIn this declaration, we\u2019ve created a function pointer named ptrToFunc. This pointer\nis capable of pointing to any function whose return type is int (indicated by the first\nkeyword) and which takes three parameters: an int, a double and a char. The\nassignment operation has initialized this pointer to NULL.\nConsider another example: let\u2019s declare a function pointer that is capable of pointing to\nthe math library\u2019s sqrt() function. The sqrt() function returns a double and takes\na single double parameter. Adapting the syntax above, we would create this pointer as\nfollows.\ndouble (*ptrToSqrt)(double) = NULL;\nAgain, we have initialized it to NULL; it does not yet reference the sqrt() function.\nTo make it reference this function, we need to assign it a value. Recall that to get the\nmemory location of a regular variable, say int x;, we use the referencing operator, &x.\nSimilarly, with functions we can use the referencing function, in this case &sqrt to get\nthe memory address of the sqrt() function, however this is not necessary. Similar to\narrays, the identifier (name) of a function serves as its memory address! The identifier\nsqrt itself is the memory location of the function. Thus to assign ptrToSqrt to point\nto sqrt(), we simply need to do the following:\nptrToSqrt = sqrt;\nNote the difference: usually we invoke sqrt() by writing parentheses and providing an\nargument. When referencing the function itself, we omit the parentheses. Additional\nexamples of this syntax can be found in Code Sample 25.1.\nCallbacks\nThe main use for function pointers is so that references to functions can be passed\nas parameters to other functions. The passed function is known as a callback. This\ngives us the ability to write a more abstract and generic function. For example, in GUI\nprogramming, we frequently need to associate a particular function with a particular\n366 25.2. Function Pointers\nevent. Suppose we create a button; we need to be able to specify what happens when\nthat button gets clicked. We do so by providing a function as a callback to a registration\nfunction that associates the \u201cclick\u201d event with the provided function. Thus, whenever a\nuser clicks the button, the callback is invoked (\u201ccalled back\u201d).\nLet\u2019s illustrate some syntax usage with another example. Suppose we want to create a\ngetMax() function. We could write one function for arrays of integers, another for arrays\nof doubles, another for Student arrays that gets the student with the maximum GPA,\nthen another for the ID, then another for the name and so on. Or, we could program\na generic getMax() function that could be used for any type by taking a comparator\nfunction as a callback. To illustrate, consider the following non-generic function for\nintegers.\nint getMax(const int *arr, int n) {\n1\nint i, maxIndex = 0;\n2\nfor(i=1; i<n; i++) {\n3\nif(arr[maxIndex} < arr[i] {\n4\n\/\/we've found something larger, update the maxIndex:\n5\nmaxIndex = i;\n6\n}\n7\n}\n8\nreturn maxIndex;\n9\n}\n10\nThis simple function iterates through the array, keeping track of the maximum value\nfound \u201cso far\u201d and updating it when it finds something larger. Because we\u2019ve specified\nthat arr is an array if int values, we can use the less-than comparison operator (line\n4). Now let\u2019s make it more generic: rather than taking an array of int values, it will\nnow take a generic void array. Further, we will pass a function pointer to this function\nthat references a generic comparator function that can be used to replace the less-than\ncomparison operator.\nint getMax(const void *arr, int n,\n1\nint(*cmp)(const void *, const void *)) {\n2\nint i, maxIndex = 0;\n3\nfor(i=1; i<n; i++) {\n4\n...\n5\n}\n6\nreturn maxIndex;\n7\n}\n8\n367 25. Searching & Sorting\nThere are a couple of issues here that we have to deal with. When working with generic\nvoid * pointers in C and using arrays, you cannot simply index using the usual 0, 1,\n2, etc. indices. Recall that when elements are stored in an array, the index represents\nan offset of a memory address. If the array is an array of integers or double or some\nother built-in type, the compiler knows how large each one is and is able to compute the\nappropriate offset given the usual 0, 1, 2, etc. indices.\nHowever, when dealing with void * elements, a function must be told how many bytes\neach element takes. C uses an unsigned integer type, size_t to indicate a size in bytes,\nso we\u2019ll use it as well. We modify the function signature above to pass in a size_t size\nparameter.\nWe now need a way to access each element in the array. The array itself is generic. We\ncannot simply use indices such as arr[i] to access elements. Since it is a void *\npointer, we cannot simply dereference it using an index. The compiler doesn\u2019t know how\nmany bytes each element takes, so it cannot compute an offset using the index variable\ni. Instead, we need to do the pointer arithmetic ourselves.\nWe could use the size parameter, say arr[i*size] to compute the offset of the i-th\nelement, but this still dereferences a void pointer, which we generally do not want to\ndo. Instead, we can use the pointer arr and do some simple arithmetic; arr is the\nstarting memory location, so if we simply add i*size to it, that gives us the memory\nlocation of the i-th element as a void pointer!\nvoid *first = arr + 0 * size; \/\/first element\n1\nvoid *second = arr + 1 * size; \/\/second element\n2\nvoid *third = arr + 2 * size; \/\/third element\n3\n...\n4\nvoid *x = arr + i * size; \/\/i-th element\n5\nWe can use this in our getMax() function to iterate over each element in the array\nand pass it to our comparator. The comparator expects generic void pointers, and that\nis what our pointer arithmetic is computing. Passing two memory addresses to the\ncomparator determines which is the larger of two elements in the array. To do this, we\ncall the comparator on the maximum element we\u2019ve found so far and the i-th element\nin the loop. If it returns something negative, then we know that the \u201cmax\u201d element is\nless than the i-th element and so update our maxIndex variable. Making these changes\nresults in the this final version.\n368 25.2. Function Pointers\nint getMax(const void *arr, int n, size_t size,\n1\nint(*cmp)(const void *, const void *)) {\n2\nint i, maxIndex = 0;\n3\nfor(i=1; i<n; i++) {\n4\nif(cmp(arr + maxIndex * size, arr + i * size) < 0) {\n5\n\/\/we've found something larger, update the max_index:\n6\nmaxIndex = i;\n7\n}\n8\n}\n9\nreturn maxIndex;\n10\n}\n11\nSuppose we have an array of integers and the cmpInt() comparator function above.\nWe can use our getMax() function as follows.\nint arr[] = {8, 2, 9, 10, 4, 2, 2, 5, 6, 7};\n1\nint maxIndex = getMax(arr, 10, sizeof(int), cmpInt);\n2\nprintf(\"maximum value: %d\\n\", arr[maxIndex]);\n3\nIn this example, the getMax() function would return the index 3 and print the maximum\nvalue stored there, 10. The getMax() function returns the index corresponding to\nthe \u201cmaximum\u201d element according to the comparator used. If instead we had used\ncmpIntDesc() the \u201cmaximum\u201d element would have been the least element, (2 in the\nexample above) because it would have been the element ordered \u201clast\u201d by the descending\ncomparator.\nConsider another example with our Student structure.\nint n = 10;\n1\nStudent *roster = (Student *) malloc(sizeof(Student) * n);\n2\n...\n3\nint maxIndex = getMax(roster, n, sizeof(Student), studentByNameCmp);\n4\nSince studentByNameCmp() orders by lexicographic ordering, a student with the last\nname \u201cZadora\u201d would have been \u201clarger\u201d than someone with a last name \u201cAnderson.\u201d\n369 25. Searching & Sorting\nThusthecodeabovewillreturnanindexcorrespondingtothelast studentinlexicographic\nordering of their name. Similarly, if we had used the studentGpaCmp() comparator\ninstead, getMax() would have returned an index for the student with the lowest GPA\nas this comparator ordered highest to lowest.\nAnother variation on this function would be to return a pointer to the maximum element\nrather than an index. The same logic would have applied, but the return type would be\na void * pointer and the return statement would return the memory address of the\nmaximum element instead. To avoid warnings, in the final return statement we cast arr\nas a void pointer (instead of a const void pointer) to make the return value compatible\nwith the return type.\nvoid * getMax(const void *arr, int n, size_t size,\n1\nint(*cmp)(const void *, const void *)) {\n2\nint i, maxIndex = 0;\n3\nfor(i=1; i<n; i++) {\n4\nif(cmp(arr + maxIndex * size, arr + i * size) < 0) {\n5\n\/\/we've found something larger, update the max_index:\n6\nmaxIndex = i;\n7\n}\n8\n}\n9\nreturn (void *)arr + maxIndex * size;\n10\n}\n11\n370 25.2. Function Pointers\n1 #include<stdio.h>\n2 #include<stdlib.h>\n3\n4 int function01(int a, double b);\n5 void function02(double x, char y);\n6\n7 void runAFunction(int (*theFunc)(int, double));\n8\n9 int main(int argc, char **arg) {\n10\n11 int i = 5;\n12 double d = 3.14;\n13 char c = 'Q';\n14\n15 \/\/calling a function normally...\n16 int j = function01(i, d);\n17 function02(d, c);\n18\n19 \/\/function pointer declaration\n20 int (*pt2Func01)(int, double) = NULL;\n21 void (*pt2Func02)(double, char) = NULL;\n22\n23 \/\/assignment\n24 pt2Func01 = function01;\n25 \/\/or:\n26 pt2Func01 = &function01;\n27 pt2Func02 = &function02;\n28\n29 \/\/you can invoke a function using a pointer to it:\n30 j = pt2Func01(i, d);\n31 pt2Func02(d, c);\n32\n33 \/\/alternatively, you can invoke a function by dereferencing it:\n34 j = (*pt2Func01)(i, d);\n35 (*pt2Func02)(d, c);\n36\n37 \/\/With function pointers, you can now pass entire functions as arguments to another function!\n38 printf(\"Calling runAFunction...\\n\");\n39 runAFunction(pt2Func01);\n40 \/\/we should not pass in the second pointer as it would not match the signature:\n41 \/\/syntactically okay, compiler warning, undefined behavior\n42 \/\/runAFunction(pt2Func02);\n43 }\n44\n45 void runAFunction(int (*theFunc)(int, double)) {\n46\n47 printf(\"calling within runAfunction...\\n\");\n48 int result = theFunc(20, .5);\n49 printf(\"the result was %d\\n\", result);\n50\n51 return;\n52 }\n53\n54 int function01(int a, double b) {\n55 printf(\"You called function01 on a = %d, b = %f\\n\", a, b);\n56 return a + 10;\n57 }\n58\n59 void function02(double x, char y) {\n60\n61 printf(\"You called function02 on x = %f, y = %c\\n\", x, y);\n62\n63 }\nCode Sample 25.1.: C Function Pointer Syntax Examples\n371 25. Searching & Sorting\n25.3. Searching & Sorting\nWe now turn our attention to the search and sorting functions provided by the standard\nlibrary. Each function is a generic implementation that takes advantage of function\npointers and comparator functions.\n25.3.1. Searching\nLinear Search\nThe C search library, search.h provides a linear search function to search arrays, named\nlfind() (linear find). This function does not require that the array be sorted and\nperforms a linear search algorithm, returning a pointer to the first element such that\nthe comparator returns 0 (indicating equality). The full signature of the function is as\nfollows.\nvoid *lfind(const void *key,\n1\nconst void *base,\n2\nsize_t *nmemb,\n3\nsize_t size,\n4\nint(*compar)(const void *, const void *));\n5\nEach argument represents:\n\u2022 key \u2013 a \u201cdummy\u201d structure instance matching the element you are searching for.\nFor example, if you are searching for a Student with the last name \"Smith\"\nthen you can construct an instance with the same last name, ignoring the value of\nall other components.\n\u2022 base \u2013 a pointer to the array to be searched\n\u2022 nmemb \u2013 the size of the array (number of \u201cmembers\u201d)\n\u2022 size \u2013 the size, in bytes, of each element in the array (generally you use use\nsizeof() to determine this)\n\u2022 compar \u2013 a pointer to a comparator function to use in the search.\nAs with our getMax() example, lfind() returns a pointer to the element it finds. If\nno such element is found, this function will return NULL.\n372 25.3. Searching & Sorting\nIn the same library, there is another linear search function:\nvoid *lsearch(const void *key,\n1\nvoid *base,\n2\nsize_t *nmemb,\n3\nsize_t size,\n4\nint(*compar)(const void *, const void *));\n5\nIt differs in that if it does not find a matching element, it still returns NULL but also\nattempts to insert the element being searched for at the end of the array. The function\nwill assume there is enough room at the end of the array to accommodate the inserted\nelement (if not, the behavior is undefined). This behavior is hinted at by the fact that\nbase is not const. Moreover, nmemb is passed by reference. If the function inserts\nthe element, it will also increment nmemb variable to reflect this new element. It is your\nresponsibility to ensure that there is enough valid memory to accommodate any inserts\nwhen using lsearch().\nBinary Search\nIn the standard library (stdlib.h) there is an additional binary search function that\ncan be used to more efficiently search a sorted array. The prototype:\nvoid *bsearch(const void *key,\n1\nconst void *base,\n2\nsize_t nmemb,\n3\nsize_t size,\n4\nint (*compar)(const void *, const void *));\n5\nAll parameters are exactly as with lfind() as is the behavior: it returns a pointer to\nthe first element that it finds (though first does not necessarily mean the first in the order\nof the array) and NULL if no matching element is found. It is an essential requirement\nthat the array be sorted with the same comparator as was used to sort the array or NULL\nmay be returned erroneously.\n373 25. Searching & Sorting\n25.3.2. Sorting\nThe standard library also provides a generic sorting function, qsort(). Though the\nname suggests a Quick Sort implementation, it does not necessarily have to be (it was\nwhen the function was originally designed). Modern implementations of qsort() may\nimplement alternatives such as Merge Sort or non-recursive hybrid Quick Sort algorithms.\nThe prototype and parameters are similar to the search functions but do not include\na key. The array is also not const indicating that it will be changed (which is the\nwhole point of calling the function). The function will sort elements in ascending order\naccording to the provided comparator function.\nvoid qsort(void *base,\n1\nsize_t nmemb,\n2\nsize_t size,\n3\nint(*compar)(const void *, const void *))\n4\n\u2022 base \u2013 pointer an array of elements\n\u2022 nmemb \u2013 the size of the array (number of members)\n\u2022 size \u2013 the size (in bytes) of each element (use sizeof())\n\u2022 compar \u2013 a comparator function used to order elements\nThe advantages to using qsort() (as well as lfind() and bsearch()) should be\nclear. There is no need to write a new function that reimplements the same algorithm for\nevery possible ordering of every possible user-defined structure. We need only to create a\ncomparator function and pass it to qsort(). There is less code, and less chance of bugs.\nThe qsort() function is well-designed, optimized, and most importantly well-tested\nand proven.\nThese functions represent a sort of \u201cweak\u201d form of polymorphic behavior found in\nmore modern object-oriented programming languages and other languages that support\n\u201cgeneric programming.\u201d Polymorphism is the characteristic that the same code can be\nexecuted on different types, greatly reducing the need for duplicate code.\n25.3.3. Examples\nWe illustrate the usage of these functions in Code Samples 25.2 and 25.3.\n374 25.3. Searching & Sorting\n1 #include<stdio.h>\n2 #include<stdlib.h>\n3 #include<search.h>\n4\n5 #include \"student.h\"\n6\n7 int main(int argc, char **argv) {\n8\n9 int n = 0;\n10 Student *roster = loadStudents(\"student.data\", &n);\n11 int i;\n12 size_t numElems = n;\n13\n14\n15 printf(\"Roster: \\n\");\n16 printStudents(roster, n);\n17\n18 \/* Searching *\/\n19 Student *castro = NULL;\n20 Student *castroKey = NULL;\n21 Student *sandberg = NULL;\n22 char *str = NULL;\n23\n24 castro = linearSearchStudentByNuid(roster, 10, 131313);\n25 str = studentToString(castro);\n26 printf(\"castro: %s\\n\", str);\n27 free(str);\n28\n29 \/\/create a key that will match according to the NUID\n30 int nuid = 23232323;\n31 Student * key = createEmptyStudent();\n32 key->nuid = nuid;\n33\n34 \/\/use lfind to find the first such instance:\n35 \/\/sandberg =\n36 sandberg = lfind(key, roster, &numElems, sizeof(Student), studentIdCmp);\n37 str = studentToString(sandberg);\n38 printf(\"sandberg: %s\\n\", str);\n39 free(str);\n40\n41 \/\/create a key with only the necessary fields\n42 castroKey = createStudent(\"Starlin\", \"Castro\", 0, 0.0);\n43 \/\/sort according to a comparator function\n44 qsort(roster, n, sizeof(Student), studentLastNameCmp);\n45\n46 castro = bsearch(castroKey, roster, n, sizeof(Student), studentLastNameCmp);\n47 str = studentToString(castro);\n48 printf(\"castro (via binary search): %s\\n\", str);\n49 free(str);\n50\n51 \/\/create a key with only the necessary fields\n52 castroKey = createStudent(NULL, NULL, 131313, 0.0);\n53 \/\/sort according to a comparator function\n54 qsort(roster, n, sizeof(Student), studentIdCmp);\n55\n56 castro = bsearch(castroKey, roster, n, sizeof(Student), studentIdCmp);\n57 str = studentToString(castro);\n58 printf(\"castro (via binary search): %s\\n\", str);\n59 free(str);\n60\n61 return 0;\n62 }\n.\nCode Sample 25.2.: C Search Examples\n375 25. Searching & Sorting\n#include<stdio.h>\n1\n#include<stdlib.h>\n2\n3\n#include \"student.h\"\n4\n5\n6\nint main(int argc, char **argv) {\n7\n8\nint n = 0;\n9\nStudent *roster = loadStudents(\"student.data\", &n);\n10\nint i;\n11\nsize_t numElems = n;\n12\n13\nprintf(\"Roster: \\n\");\n14\nprintStudents(roster, n);\n15\n16\nprintf(\"\\n\\n\\nSorted by last name\/first name: \\n\");\n17\nqsort(roster, numElems, sizeof(Student), studentLastNameCmp);\n18\nprintStudents(roster, n);\n19\n20\nprintf(\"\\n\\n\\nSorted by ID: \\n\");\n21\nqsort(roster, numElems, sizeof(Student), studentIdCmp);\n22\nprintStudents(roster, n);\n23\n24\nprintf(\"\\n\\n\\nSorted by ID, descending: \\n\");\n25\nqsort(roster, numElems, sizeof(Student), studentIdCmpDesc);\n26\nprintStudents(roster, n);\n27\n28\nprintf(\"\\n\\n\\nSorted by GPA: \\n\");\n29\nqsort(roster, numElems, sizeof(Student), studentGPACmp);\n30\nprintStudents(roster, n);\n31\n32\nreturn 0;\n33\n}\n34\n.\nCode Sample 25.3.: C Sort Examples\n376 25.4. Other Considerations\n25.4. Other Considerations\n25.4.1. Sorting Pointers to Elements\nRecall that it is sometimes preferable to maintain an array of pointers to structures\nrather than an array of structures. Sorting is a scenario where this is particularly true.\nWhen sorting an array of structure elements, the entire structure is copied back and forth\nas elements are swapped. Depending on the number of bytes of a structure, this can be\nquite expensive. It is generally more efficient to sort an array of pointers to structures\ninstead. A prime example of this is sorting an array of strings.\nAn array of strings can be thought of as a 2-dimensional array of chars. Specifically,\nan array of strings is a char ** type. That is, an array of pointers to pointers of\nchars. We may be tempted to use strcmp() in the standard string library, passing it\nto qsort(). Unfortunately this will not work. qsort() requires two const void *\ntypes, while strcmp() takes two const char * types. This difference is subtle but\nimportant.1 The recommended way of doing this is to define a different comparator\nfunction as in Code Sample 25.4.\n\/* compare strings via pointers *\/\n1\nint pstrcmp(const void *p1, const void *p2)\n2\n{\n3\nreturn strcmp(*(char * const *)p1, *(char * const *)p2);\n4\n}\n5\nCode Sample 25.4.: C Comparator Function for Strings\nObserve the behavior of this function: it uses the standard strcmp() function, but\nmakes the proper explicit type casting before doing so. The *(char * const *) casts\nthe generic void pointers as pointers to strings (or pointers to pointers to characters),\nthen dereferences it to be compatible with strcmp().\nAnother case is when we wish to sort user-defined structures. The Student structure\npresented earlier is \u201csmall\u201d in that it only has a few fields. When structures are stored\nin an array and sorted, there may be many swaps of individual elements which involves\na lot of memory copying. If the structures are small this is not too bad, but for \u201clarger\u201d\nstructures this could be potentially expensive. Instead, it may be preferred to have\nan array of pointers to structures. Swapping elements involves only swapping pointers\n1A full discussion can be found on the c-faq, http:\/\/c-faq.com\/lib\/qsort1.html.\n377 25. Searching & Sorting\ninstead of the entire structure. This is far cheaper as a memory address is likely to be\nfar smaller than the actual structure it points to. This is essentially equivalent to the\nstring scenario: we have an array of pointers to be sorted, our comparator function then\nneeds to deal with pointers to pointers.2 An example appears in Code Sample 25.5.\n\/**\n1\n* Orders two Student pointers according to the last name\/first name\n2\n*\/\n3\nint studentPtrLastNameCmp(const void *s1, const void *s2) {\n4\n\/\/we receive a pointer to an individual element in the array\n5\n\/\/but individual elements are POINTERS to students thus we cast\n6\n\/\/them as (const Student **) then dereference to get a pointer\n7\n\/\/to a Student!\n8\nconst Student *a = *(const Student **)s1;\n9\nconst Student *b = *(const Student **)s2;\n10\nint result = strcmp(a->lastName, b->lastName);\n11\nif(result == 0) {\n12\nreturn strcmp(a->firstName, b->firstName);\n13\n} else {\n14\nreturn result;\n15\n}\n16\n}\n17\n18\n19\n20\nStudent **roster = (Student **) malloc(sizeof(Student *) * n);\n21\n...\n22\nqsort(roster, n, sizeof(Student *), studentPtrLastNameCmp);\n23\nCode Sample 25.5.: Sorting Structures via Pointers\nAnother issue when sorting arrays of pointers is that we may now have to deal with NULL\nelements. When sorting arrays of elements this is not an issue as a properly initialized\narray will contain non-null elements (though elements could still be uninitialized, the\nmemory space will be valid).\nHow we handle NULL pointers is more of a design decision. We could ignore it and any\nattempt to access a NULL structure will result in undefined behavior (or segmentation\nfaults, etc.). Or we could give NULL values an explicit ordering with respect to other\n2Again, a full discussion can be found on c-faq, http:\/\/c-faq.com\/lib\/qsort2.html.\n378 25.4. Other Considerations\nelements. That is, we could order all NULL pointers before non-NULL elements (and\nconsider all NULL pointers to be equal). An example with respect to our Student\nstructure is given in Code Snippet 25.6.\nint studentPtrLastNameCmpWithNulls(const void *s1, const void *s2) {\n1\nconst Student *a = *(const Student **)s1;\n2\nconst Student *b = *(const Student **)s2;\n3\nif(a == NULL && b == NULL) {\n4\nreturn 0;\n5\n} else if(a == NULL && b != NULL) {\n6\nreturn -1;\n7\n} else if (a != NULL && b == NULL) {\n8\nreturn 1;\n9\n}\n10\nint result = strcmp(a->lastName, b->lastName);\n11\nif(result == 0) {\n12\nreturn strcmp(a->firstName, b->firstName);\n13\n} else {\n14\nreturn result;\n15\n}\n16\n}\n17\nCode Sample 25.6.: Handling Null Values\n379  Part II.\nThe Java Programming Language\n381  26. Basics\nThe Java programming language was developed in the early 1990s at Sun Microsystems\nby James Gosling, Mike Sheridan, and Patrick Naughton. Its original intention was\nto enable cable box sets to be more interactive. By the mid-90s, Java was retargeted\ntoward the WWW. The first public release came on May 23, 1995 with the first Java\nDevelopment Kit (JDK), Java 1.0 on January 23rd, 1996. A new, updated release has\ncome about every other year. As of 2014, Java 8 is the current stable version.\nToday, Java is one of the most popular programming languages, consistently ranked\nas one of the top 2 languages (see http:\/\/www.tiobe.com). It is now owned and\nmaintained by Oracle, but there are many open source tools, compilers and runtime\nenvironments available. Java is used in everything from mobile devices (Android) and\ndesktop applications to enterprise application servers.\nFrom its inception, Java was designed with 5 basic principles:\n1. Simple, Object-oriented, familiar\n2. Robust and secure\n3. Architecture-neutral and portable\n4. High performance\n5. Interpreted, threaded and dynamic\nJava offers many key features that have made it popular. It is unique in that it is\nnot entirely compiled nor interpreted. Instead, Java source code is compiled into an\nintermediate form, called Java bytecode. This bytecode is not directly runnable on\na processor. Instead, a JVM, an application that was written and compiled for a\nparticular system, interprets the bytecode and runs the application. This added layer\nof abstraction means that Java source code can be written once (and compiled once)\nand then run anywhere on any device that has a JVM. The added layer of abstraction\nmakes development easier, but comes at a cost in performance. However, the most recent\nJVMs have offered performance that is comparable to native machine code in many\napplications.\nAnother key feature is that Java has its own automated garbage collection. Some\nlanguages require manual memory management, meaning that requesting, managing,\n383 26. Basics\npackage unl.cse; \/\/package declaration\n1\n2\n\/\/imports would go here\n3\n4\n\/**\n5\n* A basic hello world program in Java\n6\n*\/\n7\npublic class HelloWorld {\n8\n9\n\/\/static main method\n10\npublic static void main(String args[]) {\n11\nSystem.out.println(\"Hello World!\");\n12\n}\n13\n14\n}\n15\nCode Sample 26.1.: Hello World Program in Java\nand freeing memory is part of the code that you write as a developer. Failure to handle\nmemory management properly can lead to wasted resources (memory leaks), poor or\nunstable performance, and even more serious security issues (buffer overflows). In Java,\nthere is no manual memory management. The JVM handles the allocation and clean up\nof memory automatically.\nIn following with the five design principles, Java is similar in syntax to C (called \u201cC-style\nsyntax\u201d). Executable statements are terminated by semicolons, code blocks are defined\nby opening\/closing curly brackets, etc. Java is also fundamentally a class-based OOP\nlanguage. With the exception of a few primitive types, in Java everything is a class or\nbelongs to an class.\n26.1. Getting Started: Hello World\nThe hallmark of an introduction to a new programming language is the Hello World!\nprogram. It consists of a simple program whose only purpose is to print out the message\n\u201cHello World!\u201d to the user. The simplicity of the program allows the focus to be on the\nbasic syntax of the language. It is also typically used to ensure that your development\nenvironment, compiler, runtimeenvironment, etc.arefunctioningproperlywithaminimal\nexample. A basic Hello World! program in Java can be found in Code Sample 26.1.\n384 26.2. Basic Elements\nWe will not focus on any particular development environment, code editor, or any\nparticularoperatingsystem,compiler,orancillarystandardsinourpresentation. However,\nas a first step, you should be able to write, compile, and run the above program\non the environment you intend to use for the rest of this book. This may require\nthat you download and install a JDK and IDE. Eclipse (http:\/\/eclipse.org\/) is the\nindustry standard, though IntelliJ (https:\/\/www.jetbrains.com\/idea\/) and NetBeans\n(https:\/\/netbeans.org\/) are also popular.\n26.2. Basic Elements\nUsing the Hello World! program as a starting point, we will now examine the basic\nelements of the Java language.\n26.2.1. Basic Syntax Rules\nJava\u2019s syntax is adopted from C, referred to as \u201cC-style syntax.\u201d These elements include\nthe following.\n\u2022 Java is a statically typed language so variables must be declared along with their\ntypes before using them.\n\u2022 Strings are delimited with double quotes. Single characters, including special\nescaped characters are delimited by single quotes; \"this is a string\", and\nthese are characters: 'A', '4', '$' and '\\n'\n\u2022 In addition, Java uses Unicode (UTF-16 encoding) to represent characters. This is\nfully back-compatible with ASCII, but also allows you to specify Unicode characters\nusingspecialescapesequencesandhexadecimalencodings. Forexample, '\\u4FFA'\nrepresents a Japanese character:\nThe string \"\\u4FFA\\u306F\\u6700\\u9AD8\\u3060\\u305C\\uFF01\" represents the\nphrase\n\u2022 Executable statements are terminated by a semicolon, ;\n\u2022 Code blocks are defined using opening and closing curly brackets, { ... }. More-\nover, code blocks can be nested: code blocks can be defined within other code\n385 26. Basics\nblocks.\n\u2022 Variables are scoped to the code block in which they are declared and are only\nvalid within that code block.\n\u2022 In general, whitespace between coding elements is ignored.\nThough not a syntactic requirement, the proper use of whitespace is important for good,\nreadable code. Code inside code blocks is indented at the same indentation. Nested\ncode blocks are indented further. Think of a typical table of contents or the outline of a\nformal paper or essay. Sections and subsections or points and subpoints all follow proper\nindentation with elements at the same level at the same indentation. This convention is\nused to organize code and make it more readable.\n26.2.2. Program Structure\nClasses\nIn Java, everything is a class or belongs to a class. A class is an extensible program or\nblueprint for creating objects. Objects are an integral part of OOP that we\u2019ll explore later.\nHowever, to start out our programs will be simple enough that they can be contained in\na single class. To declare a class, you use the following syntax.\npublic class HelloWorld { ... }\nwhere the contents of the class are placed between the opening\/closing curly brackets.\nIn addition, a class must be placed in a Java source file with the same name. In our\nprevious example, the class must be in a file named HelloWorld.java.\nWhennamingclasses, themostcommonlyacceptednamingconventionistouseuppercase\ncamel casing (also called PascalCase) in which each word in the name is capitalized\nincluding the first, Employee, SavingsAccount, ImageFile, etc. Class names (as\nwell as their source file names) are case sensitive.\nPackages\nJava code is organized into modules called packages. Packages are essentially directories\n(or folders) which follow a directory tree structure which allows subdirectories and\nseparate directories at the same level. It all starts at the root directory called the\n\u201cdefault\u201d package.\nWithin a source file, we declare which package the file belongs to using the keyword\npackage followed by a fully qualified package declaration which is essentially just the\n386 26.2. Basic Elements\nnames of the directories that the file is located in, separated by a period. The declaration\nis terminated by a semicolon. For example, the package declaration,\npackage unl.cse;\nwould indicate that the file belongs in the directory cse which is a subdirectory of the\ndirectory unl. The absence of a package declaration will mean that the file is associated\nwith the default directory.\nPackages allow you to organize source files and code functionality. Mathematics related\nclasses can be placed in one package while image related classes can be placed in another,\netc. It also provides separate name spaces for classes. There could be 3 or 4 different\nclasses named List for example. They could not be located in the same directory; if\nyou wanted to use one which one would you be referring to? By separating them into\npackages, they can all exist without conflict. When we want to use a particular one, we\nimport that class with its fully qualified package name.\nImports\nAn import statement essentially \u201cbrings in\u201d another class so that its methods and\nfunctionality can be used. For example, there is a class named Scanner (located in\nthe package java.util) that makes it easy to read input from the standard input. To\ninclude it in our program so that we can use its functionality, we would need1 to import\nit:\nimport java.util.Scanner;\nClasses in the package java.lang (such as String and Math) are considered standard\nand are imported by default without an explicit import statement.\nYou may see some code that uses a wildcard like import java.util.*; which ends\nup importing every class in that package. This is generally considered bad practice. In\ngeneral, code should be intentional and specific, importing every class even if they are\nnot used goes against this principle.\nWhennamingpackages,youmustfollowthegeneralnamingrulesforidentifiers(seebelow).\nPackagenamescannotbeginwithanumber,nowhitespace,etc. Moreover,thegeneralcon-\nvention for package names is to use lowercase underscore casing, here_is_an_example.\nMoreover, packages and subpackages follow the same convention as directories: the top\nmost directory is the most general and subdirectories are more and more specific.\nIn many of our examples we\u2019ll use unl.cse (UNL, University of Nebraska\u2013Lincoln; CSE,\n1You can still use it without importing it, but you\u2019d need to use a fully qualified path name at\ndeclaration\/instantiation.\n387 26. Basics\nFunction Description\nMath.abs(x) Absolute value function, |x|a\nMath.ceil(x) Ceiling function, (cid:100)46.3(cid:101) = 47.0\nMath.floor(x) Floor function, (cid:98)46.3(cid:99) = 46.0\nMath.cos(x) Cosine functionb\nMath.sin(x) Sine functionb\nMath.tan(x) Tangent functionb\nMath.exp(x) Exponential function, ex, e = 2.71828...\nMath.log(x) Natural logarithm, ln(x)c\nMath.log10(x) Logarithm base 10, log (x)c\n10\nMath.pow(x,y) The power function, computes xy\nMath.sqrt(x) Square root functionc\nTable 26.1.: SeveralmethodsdefinedintheJava Math library. aThereareseveralversions\nof the absolute value method, one for each numeric type but all with the\nsame name. ball trigonometric functions assume input is in radians, not\ndegrees. cInput is assumed to be positive, x > 0.\nDepartment of Computer Science & Engineering) which illustrates this general-to-specific\norganization.\nThere are many other important classes and packages provided by the standard JDK\nthat we\u2019ll examine as needed. Of immediate interest is the Math class and its library\nof common mathematical functions such as the square root and the natural logarithm.\nTable 26.1 highlights several of these functions. To use them you\u2019d need to invoke them\nby using the class name and dot operator. For example:\ndouble x = 1.5;\n1\ndouble y, z;\n2 \u221a \u221a\ny = Math.sqrt(x); \/\/y now has the value x = 1.5\n3\nz = Math.sin(x); \/\/z now has the value sin(x) = sin(1.5)\n4\nIn both of the method calls above, the value of the variable x is \u201cpassed\u201d to the math\nfunction which computes and \u201creturns\u201d the result which then gets assigned to another\nvariable.\n388 26.2. Basic Elements\n26.2.3. The main() Method\nEvery executable program has to have a beginning: a point at which the program starts\nto execute. In Java, a class may contain many variables and methods, but a class is only\nexecutable if it contains a main() method. When a Java class is compiled and the JVM\nis started, the JVM loads the class into memory and starts executing code contained in\nthe main() method.\nIn addition, our main() method takes an array of String types which serve to\ncommunicate any command line arguments provided to the program (review Section 2.4.4\nfor details). The array, args stores the arguments as strings. The number of arguments\nprovided can be determined using the length property of the array. Specifically,\nargs.length is an integer indicating how many arguments were provided. This does\nnot include the name of the program (class) itself as that is already be known to the\nprogrammer.\nTo access any one argument, it will be necessary to index the array. The index for the\nfirst argument is zero, thus the first argument is args[0], the second is args[1], etc.\nThe last one would be at args[args.length-1].\nIf a user is expected to provide numbers as input, they\u2019ll need to be converted as the\nargs array are only String types. To convert the arguments you can use parsing\nmethods provided by the Integer and Double classes. An example:\n\/\/converts the \"first\" command line argument to an integer\n1\nint x = Integer.parseInt(args[0]);\n2\n\/\/converts the \"third\" command line argument to a double:\n3\ndouble y = Double.parseDouble(args[1]);\n4\n26.2.4. Comments\nComments can be written in a Java program either as a single line using two forward\nslashes, \/\/comment or as a multiline comment using a combination of forward slash and\nasterisk: \/* comment *\/ . With a single line comment, everything on the line after the\nforward slashes is ignored. With a multiline comment, everything in between the forward\nslash\/asterisk is ignored. Comments are ultimately ignored so the amount of comments\ndo not have an effect on the final executable code. Consider the following example.\n389 26. Basics\n\/\/this is a single line comment\n1\nint x; \/\/this is also a single line comment, but after some code\n2\n3\n\/*\n4\nThis is a comment that can\n5\nspan multiple lines to format the comment\n6\nmessage more clearly\n7\n*\/\n8\ndouble y;\n9\nMost code editors and IDEs will present comments in a special color or font to distinguish\nthem from the rest of the code (just as our example above does). Failure to close a\nmultiline comment will likely result in a compiler error but with color-coded comments\nits easy to see the mistake visually.\nAnother common comment style convention is the Javadoc (Java Documentation) style\nof comments. Javadoc style comments are multiline comments that begin with \/**.\nThe Javadoc framework allows you to markup your comments with tags and links so that\ndocumentation can be automatically generated and published. We will sometimes use\nthis style, but we will not cover the details.\n26.3. Variables\nJava has 8 built-in primitive types supporting numbers (integers and floating point\nnumbers), Booleans, and characters. Table 26.2 contains a complete description of these\ntypes. Each of these primitive types also has a corresponding wrapper class defined in\nthe java.lang package. Wrapper classes provide object versions of each of these classes.\nThe object versions have many utility methods that can be used in relation to their type.\nFor example, the aforementioned Integer.parseInt() method is part of the Integer\nwrapper class.\nThe wrapper classes, however, are different. These are objects, so when a reference is\ndeclared for them, by default, that reference refers to null. The keyword null is used\nto indicate a special memory address that represents \u201cnothing.\u201d In fact, the default value\nfor any object type is null. Care must be taken when mixing primitive types and their\nwrapper classes (see below) as null references may result in a NullPointerException.\nFinally, instances of the wrapper classes are immutable. Once they are created, they\ncannot be changed. References can be made to refer to a different object, but the object\u2019s\nvalue cannot be changed.\n390 26.3. Variables\nType Description Wrapper Class\nbyte 8-bit signed 2s complement integer Byte\nshort 16-bit signed 2s complement integer Short\nint 32-bit signed 2s complement integer Integer\nlong 64-bit signed 2s complement integer Long\nfloat 32-bit IEEE 754 floating point number Float\ndouble 64-bit floating point number Double\nboolean may be set to true or false Boolean\nchar 16-bit Unicode (UTF-16) character Character\nTable 26.2.: Primitive types in Java\n26.3.1. Declaration & Assignment\nJava is a statically typed language meaning that all variables must be declared before\nyou can use them or refer to them. In addition, when declaring a variable, you must\nspecify both its type and its identifier. For example:\nint numUnits;\n1\ndouble costPerUnit;\n2\nchar firstInitial;\n3\nboolean isStudent;\n4\nEach declaration specifies the variable\u2019s type followed by the identifier and ending with a\nsemicolon. The identifier rules are fairly standard: a name can consist of lowercase and\nuppercase alphabetic characters, numbers, and underscores but may not begin with a\nnumeric character. We adopt the modern camelCasing naming convention for variables\nin our code. In general, variables must be assigned a value before you can use them in\nan expression. You do not have to immediately assign a value when you declare them\n(though it is good practice), but some value must be assigned before they can be used or\nthe compiler will issue an error.2\nThe assignment operator is a single equal sign, = and is a right-to-left assignment. That\nis, the variable that we wish to assign the value to appears on the left-hand-side while\nthe value (literal, variable or expression) is on the right-hand-size. Using our variables\nfrom before, we can assign them values:\n2Instance variables, that is variables declared as part of an object do have default values. For objects,\nthe default is null, for all numeric types, zero is the default value. For the boolean type, false\nis the default, and the default char value is \\0, the null-terminating character (zero in the ASCII\ntable).\n391 26. Basics\nnumUnits = 42;\n1\ncostPerUnit = 32.79;\n2\nfirstInitial = 'C';\n3\nisStudent = true;\n4\nFor brevity, Java allows you to declare a variable and immediately assign it a value on\nthe same line. So these two code blocks could have been more compactly written as:\nint numUnits = 42;\n1\ndouble costPerUnit = 32.79;\n2\nchar firstInitial = 'C';\n3\nboolean isStudent = true;\n4\nAs another shorthand, we can declare multiple variables on the same line by delimiting\nthem with a comma. However, they must be of the same type. We can also use an\nassignment with them.\nint numOrders, numUnits = 42, numCustomers = 10, numItems;\n1\ndouble costPerUnit = 32.79, salesTaxRate;\n2\nAnother useful keyword is final. Though it has several uses, when applied to a variable\ndeclaration, it makes it a read-only variable. After a value has been assigned to a final\nvariable, its value cannot be changed.\nfinal int secret = 42;\n1\nfinal double salesTaxRate = 0.075;\n2\nAny attempt to reassign the values of final variables will result in a compiler error.\n392 26.4. Operators\n26.4. Operators\nJava supports the standard arithmetic operators for addition, subtraction, multiplication,\nand division using +, -, *, and \/ respectively. Each of these operators is a binary\noperator that acts on two operands which can either be literals or other variables and\nfollow the usual rules of arithmetic when it comes to order of precedence (multiplication\nand division before addition and subtraction).\nint a = 10, b = 20, c = 30, d;\n1\nd = a + 5;\n2\nd = a + b;\n3\nd = a - b;\n4\nd = a + b * c;\n5\nd = a * b;\n6\nd = a \/ b; \/\/integer division and truncation! See below\n7\n8\ndouble x = 1.5, y = 3.4, z = 10.5, w;\n9\nw = x + 5.0;\n10\nw = x + y;\n11\nw = x - y;\n12\nw = x + y * z;\n13\nw = x * y;\n14\nw = x \/ y;\n15\n16\n\/\/you can do arithmetic with both types:\n17\nw = a + x;\n18\n19\n\/\/however you CANNOT assign a double to an integer:\n20\nd = b + y; \/\/compilation error\n21\n\/\/but you can do so with an explicit type cast:\n22\nd = (int) (b + y); \/\/though truncation occurs, d is 23\n23\nIn addition, you can mix the wrapper classes with their primitive types. You must be\ncareful though. The wrapper classes are object references which can be null. If a null\nreference is used in an arithmetic expression, it will result in a NullPointerException\nwhich can be caught and handled (see Chapter 30). If not caught, it will end up being a\nfatal error. Some examples:\nint a = 10, c;\n1\nInteger b = 20;\n2\n393 26. Basics\n3\n\/\/int and Integer can be mixed:\n4\nc = a + b;\n5\n6\ndouble x = 3.14, z;\n7\nDouble y = 2.71;\n8\n\/\/double and Double can be mixed:\n9\nz = x + y;\n10\n11\n\/\/all types can be mixed:\n12\ndouble u = a + x + b + y;\n13\n14\n\/\/Be careful:\n15\nInteger d = null;\n16\nc = a + d; \/\/NullPointerException\n17\nThis works because of a mechanism called autoboxing (or autounboxing in this case). The\nwrapper class is acting like a \u201cbox\u201d: it is an object that stores the value of a primitive\ntype. When it gets used in an arithmetic expression, it gets \u201cunboxed\u201d and converted to\na primitive type so that the arithmetic operation is performed on compatible primitive\ntypes. This is all done by the compiler and is completely transparent to us. However,\nthat is the reason that we may get a NullPointerExcpetion. Our code actually gets\nconverted from c = a + d; to c = a +d.doubleValue();. The doubleValue()\nmethod returns a double primitive value. However, if d is null, you can\u2019t call a\nmethod on it; thus the NullPointerException is thrown as a consequence.\nSpecial care must be taken when dealing with int types. For all four operators, if\nboth operands are integers, the result will be an integer. For addition, subtraction, and\nmultiplication this isn\u2019t an issue, but for division it means that when we divide, say\n(10 \/ 20), the result is not 0.5 as expected. The number 0.5 is a floating point number.\nAs such, the fractional part gets truncated (cut off and thrown out) leaving only zero. In\nthe code above, d = a \/ b; the variable d ends up getting the value zero because of\nthis.\nA solution to this problem is to use explicit type casting to force at least one of the\noperands in an integer division to become a double type. For example:\nint a = 10, b = 20;\n1\ndouble x;\n2\n3\nx = (double) a \/ b;\n4\n394 26.5. Basic I\/O\nAssigning a floating point number to an integer is not allowed in Java and attempting to\ndo so will be treated as a compiler error. This is because Java does not support implicit\ntype casts. However, you can do so if you provide an explicit type cast as in the code\nabove,\nd = (int) (b + y);\nIn this code, b + y is correctly computed as 20+3.4 = 23.4, but the explicit type cast\n(down to an integer) results in truncation. The .4 gets cutoff and d gets the value 23.\nAssigning an int value to a double variable is not a problem as the integer 2 becomes\nthe floating point number 2.0.\nJava also supports the integer remainder operator using the % symbol. This operator\ngives the remainder of the result of dividing two integers. Examples:\nint x;\n1\n2\nx = 10 % 5; \/\/x is 0\n3\nx = 10 % 3; \/\/x is 1\n4\nx = 29 % 5; \/\/x is 4\n5\n26.5. Basic I\/O\nJava provides several ways to perform input and output operations with the standard\ninput\/output as part of the System class. The System class contains a standard output\nstream which can be accessed using System.out. It also has a standard input stream\nwhich can be accessed using System.in.\nForoutput,thereareseveralmethodsthatcanbeusedbutwe\u2019llfocuson System.out.println()\nand System.out.printf(). The first is for printing strings on a single line. The ln\nat the end indicates that the method will insert an endline character, \\n for you. The\nsecond is a printf-style output method that takes placeholders like %d and %f (review\nSection 2.4.3 for details).\nThe easiest way to read input is through the Scanner class. You can create a new\ninstanceofthe Scanner classandassociateitwiththestandardinputusingthefollowing\n395 26. Basics\nScanner s = new Scanner(System.in);\n1\nint a;\n2\nSystem.out.println(\"Please enter a number: \");\n3\na = s.nextInt();\n4\nSystem.out.printf(\"Great, you entered %d\\n\", a);\n5\nCode Sample 26.2.: Basic Input\/Output in Java\ncode.\nScanner s = new Scanner(System.in);\nThe variable s is now active and can be read from. You can get specific values\nfrom the Scanner by calling various methods such as s.nextInt() to get an int,\ns.nextDouble() to get a double, etc. When these methods are called, the program\nblocks until the user enters her input and presses the enter\/return key. The conversion to\nthe type you requested is automatic. A full example is depicted in Code Sample 26.2.\nOne potential problem with using Scanner is that the methods cannot force a user to\nenter good input. In the example above, if the user, instead of entering a number, entered\n\"Hello\",theconversiontoanumberwouldfailandresultina InputMismatchException.\n26.6. Examples\n26.6.1. Converting Units\nLet\u2019s write a program that will prompt the user to enter a temperature in degrees\nFahrenheit and convert it to degrees Celsius using the formula\n5\nC = (F \u221232)\u00b7\n9\nWebeginwiththebasicprogramoutlinewhichwillincludeapackageandclassdeclaration.\nWe\u2019ll also need to read from the standard input, so we\u2019ll import the Scanner class.\nWe\u2019ll want want our class to be executable, so we need to put a main() method in our\nclass. Finally, we\u2019ll document our program to indicate its purpose.\n396 26.6. Examples\npackage unl.cse;\n1\n2\nimport java.util.Scanner;\n3\n4\n\/**\n5\n* This program converts Fahrenheit temperatures to\n6\n* Celsius\n7\n*\/\n8\npublic class TemperatureConverter {\n9\n10\npublic static void main(String args[]) {\n11\n12\n\/\/TODO: implement this\n13\n14\n}\n15\n}\n16\nIt is common for programmers to use a comment along with a TODO note to themselves\nas a reminder of things that they still need to do with the program.\nLet\u2019s first outline the basic steps that our program will go through:\n1. We\u2019ll first prompt the user for input, asking them for a temperature in Fahrenheit\n2. Next we\u2019ll read the user\u2019s input, likely into a floating point number as degrees can\nbe fractional\n3. Once we have the input, we can calculate the degrees Celsius by using the formula\nabove\n4. Lastly, we will want to print the result to the user to inform them of the value\nSometimes it is helpful to write an outline of such a program directly in the code using\ncomments to provide a step-by-step process. For example:\npackage unl.cse;\n1\n2\nimport java.util.Scanner;\n3\n4\n\/**\n5\n* This program converts Fahrenheit temperatures to\n6\n* Celsius\n7\n397 26. Basics\n*\/\n8\npublic class TemperatureConverter {\n9\n10\npublic static void main(String args[]) {\n11\n12\n\/\/TODO: implement this\n13\n\/\/1. Prompt the user for input in Fahrenheit\n14\n\/\/2. Read the Fahrenheit value from the standard input\n15\n\/\/3. Compute the degrees Celsius\n16\n\/\/4. Print the result to the user\n17\n18\n}\n19\n}\n20\nAs we read each step it becomes apparent that we\u2019ll need a couple of variables: one to\nhold the Fahrenheit (input) value and one for the Celsius (output) value. It also makes\nsense that each of these should be double variables as we want to support fractional\nvalues. At the top of our main() method, we\u2019ll add the variable declarations:\ndouble fahrenheit, celsius;\nWe\u2019ll also need a Scanner, initialized to read from the standard input:\nScanner s = new Scanner(System.in);\nEach of the steps is now straightforward; we\u2019ll use a System.out.println() statement\nin the first step to prompt the user for input:\nSystem.out.println(\"Please enter degrees in Fahrenheit: \");\nIn the second step, we\u2019ll use our Scanner to read in a value from the user for the\nfahrenheit variable. Recall that we use the method s.nextDouble() to read a\ndouble value from the user.\nfahrenheit = s.nextDouble();\nWe can now compute celsius using the formula provided:\ncelsius = (fahrenheit - 32) * (5 \/ 9);\nFinally, we use System.out.printf() to output the result to the user:\nSystem.out.printf(\"%f Fahrenheit is %f Celsius\\n\", fahrenheit, celsius);\n398 26.6. Examples\nTry typing and running the program as defined above and you\u2019ll find that you don\u2019t get\ncorrect answers. In fact, you\u2019ll find that no matter what values you enter, you get zero.\nThis is because of the calculation using (5 \/ 9): recall what happens with integer\ndivision: truncation! This will always end up being zero.\nOne way we could fix it would be to pull out our calculators and find that 5 = 0.55555...\n9\nand replace (5 \/ 9) with 0.555555. But, how many fives? It may be difficult to tell\nhow accurate we can make this floating point number by hardcoding it ourselves. A much\nbetter approach would be to let the compiler take care of the optimal computation for us\nby making at least one of the numbers a double to prevent integer truncation. That is,\nwe should instead use 5.0 \/ 9. The full program can be found in Code Sample 26.3.\npackage unl.cse;\n1\n2\nimport java.util.Scanner;\n3\n4\npublic class TemperatureConverter {\n5\n6\npublic static void main(String args[]) {\n7\n8\ndouble fahrenheit, celsius;\n9\nScanner s = new Scanner(System.in);\n10\n11\n\/\/1. Prompt the user for input in Fahrenheit\n12\nSystem.out.println(\"Please enter degrees in Fahrenheit: \");\n13\n14\n\/\/2. Read the Fahrenheit value from the standard input\n15\nfahrenheit = s.nextDouble();\n16\n17\n\/\/3. Compute the degrees Celsius\n18\ncelsius = (fahrenheit - 32) * 5.0 \/ 9;\n19\n20\n\/\/4. Print the result to the user\n21\nSystem.out.printf(\"%f Fahrenheit is %f Celsius\\n\",\n22\nfahrenheit, celsius);\n23\n24\n}\n25\n}\n26\nCode Sample 26.3.: Fahrenheit-to-Celsius Conversion Program in Java\n399 26. Basics\n26.6.2. Computing Quadratic Roots\nSome programs require the user to enter multiple inputs. The prompt-input process can\nbe repeated. In this example, consider asking the user for the coefficients, a,b,c to a\nquadratic polynomial,\nax2 +bx+c\nand computing its roots using the quadratic formula,\n\u221a\n\u2212b\u00b1 b2 \u22124ac\nx =\n2a\nAs before, we can create a basic program with a main() method and start filling in\nthe details. In particular, we\u2019ll need to prompt for the input a, then read it in; then\nprompt for b, read it in and repeat for c. We\u2019ll also need several variables: three for the\ncoefficients a,b,c and two more; one for each root.\ndouble a, b, c, root1, root2;\n1\nScanner s = new Scanner(System.in);\n2\n3\nSystem.out.println(\"Please enter a: \");\n4\na = s.nextDouble();\n5\nSystem.out.println(\"Please enter b: \");\n6\nb = s.nextDouble();\n7\nSystem.out.println(\"Please enter c: \");\n8\nc = s.nextDouble();\n9\nNow to compute the roots: we need to adapt the formula so it accurately reflects the\norder of operations. We also need to use the standard math library\u2019s square root method.\nroot1 = (-b + Math.sqrt(b*b - 4*a*c) ) \/ (2*a);\n1\nroot2 = (-b - Math.sqrt(b*b - 4*a*c) ) \/ (2*a);\n2\nFinally, we print the output using System.out.printf(). The full program can be\nfound in Code Sample 26.4.\nThis program was interactive. As an alternative, we could have read all three of the\ninputs as command line arguments, taking care that we need to convert them to floating\npoint numbers. Lines 16\u201321 in the program could have been changed to\n400 26.6. Examples\na = Double.parseDouble(args[0]);\n1\nb = Double.parseDouble(args[1]);\n2\nc = Double.parseDouble(args[2]);\n3\nFinally, think about the possible inputs a user could provide that may cause problems\nfor this program. For example:\n\u2022 What if the user entered zero for a?\n\u2022 What if the user entered some combination such that b2 < 4ac?\n\u2022 What if the user entered non-numeric values?\n\u2022 For the command line argument version, what if the user provided less than three\narguments? Or more?\nHow might we prevent the consequences of such bad input? How might we handle the\nevent that a user enters bad input and how do we communicate these errors to the user?\nTo start to resolve these issues, we\u2019ll need conditionals.\n401 26. Basics\npackage unl.cse;\n1\n2\nimport java.util.Scanner;\n3\n4\n\/**\n5\n* This program computes the roots to a quadratic equation\n6\n* using the quadratic formula.\n7\n*\/\n8\npublic class QuadraticRoots {\n9\n10\npublic static void main(String args[]) {\n11\n12\ndouble a, b, c, root1, root2;\n13\nScanner s = new Scanner(System.in);\n14\n15\nSystem.out.println(\"Please enter a: \");\n16\na = s.nextDouble();\n17\nSystem.out.println(\"Please enter b: \");\n18\nb = s.nextDouble();\n19\nSystem.out.println(\"Please enter c: \");\n20\nc = s.nextDouble();\n21\n22\nroot1 = (-b + Math.sqrt(b*b - 4*a*c) ) \/ (2*a);\n23\nroot2 = (-b - Math.sqrt(b*b - 4*a*c) ) \/ (2*a);\n24\n25\nSystem.out.printf(\"The roots of %fx^2 + %fx + %f are: \\n\",\n26\na, b, c);\n27\nSystem.out.printf(\" root1 = %f\\n\", root1);\n28\nSystem.out.printf(\" root2 = %f\\n\", root2);\n29\n30\n}\n31\n32\n}\n33\nCode Sample 26.4.: Quadratic Roots Program in Java\n402 27. Conditionals\nJava supports the basic if, if-else, and if-else-if conditional structures as well as switch\nstatements. Java has Boolean types and logical statements are built using the standard\nlogical operators for numeric comparisons as well as logical operators such as negations,\nAnd, and Or that can be used with Boolean types.\n27.1. Logical Operators\nRecall thatJava has Booleantypes built-in tothe languageusing either the primitive type,\nboolean or its wrapper class Boolean. Moreover, the keywords true and false\ncan be used to assign and check values. Because Java has Boolean types, it does not\nallow you to mix logical operators with numeric types. That is, code like the following is\ninvalid.\nint a = 10;\n1\nboolean b = true;\n2\nboolean result = (a || b); \/\/compilation error\n3\nThe standard numeric comparison operators are also supported. Consider the following\ncode snippet:\nint a = 10;\n1\nint b = 20;\n2\nint c = 10;\n3\nboolean x = true;\n4\nboolean y = false;\n5\nThe six standard comparison operators are presented in Table 27.1 using these variables\nas examples. The comparison operators are the same when used with double types as\n403 27. Conditionals\nName Operator Syntax Examples Value\nEquals == a == 10 true\nb == 10 false\na == b false\na == c true\nNot Equals != a != 10 false\nb != 10 true\na != b true\na != c false\nStrictly Less Than < a < 15 true\na < 5 false\na < b true\na < c false\nLess Than Or Equal To <= a <= 15 true\na <= 5 false\na <= b true\na <= c true\nStrictly Greater Than > a > 15 false\na > 5 true\na > b false\na > c false\nGreater Than Or Equal To >= a >= 15 false\na >= 5 true\na >= b false\na >= c true\nTable 27.1.: Comparison Operators in Java\nwell and int types and can be compared with each other without type casting.\nFurthermore, because of autoboxing and unboxing, the wrapper classes for numeric types\ncan be compared using the same operators. For example:\nint a = 10;\n1\nInteger b = 20;\n2\nDouble x = 3.14;\n3\nboolean r;\n4\nr = (a < b);\n5\nr = (a >= b);\n6\nr = (x == 2.71);\n7\n404 27.1. Logical Operators\nOperator Operator Syntax Examples Values\nNegation ! !x false\n!y true\nAnd && x && true true\nx && y false\nOr || x || false true\nx || y true\n!x || y false\nTable 27.2.: Logical Operators in Java with x = true and y = false both being\nBoolean variables.\nOperator(s) Associativity Notes\nHighest ++, -- left-to-right postfix increment operators\n-, ! right-to-left unary negation operator, logical\nnot\n*, \/, % left-to-right\n+, - left-to-right addition, subtraction\n<, <=, >, >= left-to-right comparison\n==, != left-to-right equality, inequality\n&& left-to-right logical And\n|| left-to-right logical Or\nLowest =, +=, -=, *=, \/= right-to-left assignment and compound assign-\nment operators\nTable 27.3.: Operator Order of Precedence in Java. Operators on the same level have\nequivalent order and are performed in the associative order specified.\nThe three basic logical operators are also supported as described in Table 27.2.\n27.1.1. Order of Precedence\nAt this point it is worth summarizing the order of precedence of all the operators that\nwe\u2019ve seen so far including assignment, arithmetic, comparison, and logical. Since all of\nthese operators could be used in one statement, for example,\n(b*b < 4*a*c || a == 0 || args.length != 4)\nIt is important to understand the order in which each one gets evaluated. Table 27.3\nsummarizestheorderofprecedencefortheoperatorsseensofar. Thisisnotanexhaustive\nlist of Java operators.\n405 27. Conditionals\n27.1.2. Comparing Strings and Characters\nThe comparison operators in Table 27.1 can also be used for single characters because\nof the nature of the ASCII text table (see Table 2.4). Each alphanumeric character,\nincluding the various symbols and whitespace characters, is associated with an integer 0\u2013\n127. We can therefore write statements like ('A' < 'a'), which is true since uppercase\nletters are ordered before lowercase letters in the ASCII table ('A' is 65 and 'a' is 97\nand so 65 < 97 is true). Several more examples can be found in Table 27.4.\nComparison Example Result\n('A' < 'a') true\n('A' == 'a') false\n('A' < 'Z') true\n('0' < '9') true\n('\\n' < 'A') true\n(' ' < '\\n') false\nTable 27.4.: Character comparisons in Java\nNumeric comparison operators cannot be used to compare strings in Java. For example,\nwe could not code something like (\"aardvark\" < \"zebra\"). The Java compiler would\nnot allow you to do this because the comparison operator is for numeric types only.\nHowever, the following code would compile and run:\nString s = \"aardvark\";\n1\nString t = \"zebra\";\n2\nboolean b = (s == t);\n3\nbut it wouldn\u2019t necessarily give you what you want. To understand why this is okay,\nrecall that a String is an object; the s and t variables are references to that object\nin memory. When we use the equality comparison, == we\u2019re asking if s and t are\nthe same memory address. In this case, likely they are not and so the result is false.\nHowever, similar code,\nString s = new String(\"liger\");\n1\nString t = new String(\"liger\");\n2\nboolean b = (s == t);\n3\n406 27.2. If, If-Else, If-Else-If Statements\n\/\/example of an if statement:\n1\nif(x < 10) {\n2\nSystem.out.println(\"x is less than 10\");\n3\n}\n4\n5\n\/\/example of an if-else statement:\n6\nif(x < 10) {\n7\nSystem.out.println(\"x is less than 10\");\n8\n} else {\n9\nSystem.out.println(\"x is 10 or more\");\n10\n}\n11\n12\n\/\/example of an if-else-if statement:\n13\nif(x < 10) {\n14\nSystem.out.println(\"x is less than 10\");\n15\n} else if(x == 10) {\n16\nSystem.out.println(\"x is equal to ten\");\n17\n} else {\n18\nSystem.out.println(\"x is greater than 10\");\n19\n}\n20\nCode Sample 27.1.: Examples of Conditional Statements in Java\nwould also result in false because s and t represent different strings in memory,\neven though they have the same sequence of characters. We\u2019ll explore how to properly\ncompare strings later. For now, avoid using the equality operators with strings.\n27.2. If, If-Else, If-Else-If Statements\nConditional statements in Java utilize the keywords if, else, and else if. Condi-\ntions are placed inside parentheses immediately after the if and else if keywords.\nExamples of all three can be found in Code Sample 27.1.\nThe statement, if(x < 10) does not have a semicolon at the end. This is because it\nis a conditional statement that determines the flow of control and not an executable\nstatement. Therefore, no semicolon is used. Suppose we made a mistake and did include\na semicolon:\n407 27. Conditionals\nint x = 15;\n1\nif(x < 10); {\n2\nSystem.out.println(\"x is less than 10\");\n3\n}\n4\nSome compilers may give a warning, but this is valid Java; it will compile and it will run.\nHowever, it will end up printing x is less than 10, even though x = 15! Recall that\na conditional statement binds to the executable statement or code block immediately\nfollowing it. In this case, we\u2019ve provided an empty executable statement ended by the\nsemicolon. The code is essentially equivalent to\nint x = 15;\n1\nif(x < 10) {\n2\n}\n3\nSystem.out.println(\"x is less than 10\");\n4\nWhich is obviously not what we wanted. The semicolon ended up binding to the empty\nexecutable statement, and the code block containing the print statement immediately\nfollowed, butwasnot boundtotheconditionalstatementwhichiswhytheprintstatement\nexecuted regardless of the value of x.\nAnother convention that we\u2019ve used in our code is where we have placed the curly brackets.\nFirst, if a conditional statement is bound to only one statement, the curly brackets are\nnot necessary. However, it is best practice to include them even if they are not necessary\nand we\u2019ll follow this convention. Second, the opening curly bracket is on the same line as\nthe conditional statement while the closing curly bracket is indented to the same level\nas the start of the conditional statement. Moreover, the code inside the code block is\nindented. If there were more statements in the block, they would have all been at the\nsame indentation level.\n27.3. Examples\n27.3.1. Computing a Logarithm\nThe logarithm of x is the exponent that some base must be raised to get x. The most\ncommon logarithm is the natural logarithm, ln(x) which is base e = 2.71828.... But\n408 27.3. Examples\nlogarithms can be in any base b > 1.1 What if we wanted to compute log (x)? Or\n2\nlog (x)? Let\u2019s write a program that will prompt the user for a number x and a base b\n\u03c0\nand computes log (x).\nb\nArbitrary bases can be computed using the change of base formula:\nlog (x)\nlog (x) = a\nb log (b)\na\nIf we can compute some base a, then we can compute any base b. Fortunately we have\nsuch a solution. Recall that the standard library provides a function to compute the\nnatural logarithm, Math.log(). This is one of the fundamentals of problems solving: if\na solution already exists, use it. In this case, a solution exists for a different, but similar\nproblem (computing the natural logarithm), but we can adapt the solution using the\nchange of base formula. In particular, if we have variables b (base) and x, we can\ncompute log (x) using\nb\nMath.log(x) \/ Math.log(b)\nHowever, we have a problem similar to the examples in the previous section. The user\ncould enter invalid values such as b = \u221210 or x = \u22122.54 (logarithms are undefined\nfor non-positive values in any base). We want to ensure that b > 1 and x > 0. With\nconditionals, we can now do this. Once we have read in the input from the user we can\nmake a check for good input using an if statement.\nif(x <= 0 || b <= 1) {\n1\nSystem.out.println(\"Error: bad input!\");\n2\nSystem.exit(1);\n3\n}\n4\nThis code has something new: System.exit(1). The exit() function immediately\nterminates the program regardless of the rest of the code that it may remain. The\nargument passed to exit() is an integer that represents an error code. The convention\nis that zero indicates \u201cno error\u201d while non-zero values indicate some error. This is a\nsimple way of performing error handling: if the user provides bad input, we inform\nthem and quit the program, forcing them to run it again and provide good input. By\nprematurely terminating the program we avoid any illegal operation that would give a\nbad result.\nAlternatively, we could have split the conditions into two statements and given a more\ndescriptive error message. We use this design in the full program which can be found in\n1Bases can also be 0<b<1, but we\u2019ll restrict our attention to increasing functions only.\n409 27. Conditionals\nCode Sample 27.2. The program also takes the input as command line arguments. Now\nthat we have conditionals, we can actually check that the correct number of arguments\nwas provided by the user and quit in the event that they don\u2019t provide the correct\nnumber.\n27.3.2. Life & Taxes\nLet\u2019s adapt the conditional statements we developed in Section 3.6.4 into a full Java\nprogram. The first thing we need to do is establish the variables we\u2019ll need and read\nthem in from the user. At the same time we can check for bad input (negative values)\nfor both the inputs.\nScanner s = new Scanner(System.in);\n1\ndouble income, baseTax, numChildren, credit, totalTax;\n2\n3\nSystem.out.println(\"Please enter your Adjusted Gross Income: \");\n4\nincome = s.nextDouble();\n5\n6\nSystem.out.println(\"How many children do you have?\");\n7\nnumChildren = s.nextDouble();\n8\n9\nif(income < 0 || numChildren < 0) {\n10\nSystem.out.println(\"Invalid inputs\");\n11\nSystem.exit(1);\n12\n}\n13\nNext, we can code a series of if-else-if statements for the income range. By placing the\nranges in increasing order, we only need to check the upper bounds just as in the original\nexample.\nif(income <= 18150) {\n1\nbaseTax = income * .10;\n2\n} else if(income <= 73800) {\n3\nbaseTax = 1815 + (income - 18150) * .15;\n4\n} else if(income <= 148850) {\n5\n...\n6\n} else {\n7\nbaseTax = 127962.50 + (income - 457600) * .396;\n8\n}\n9\n410 27.3. Examples\nNext we compute the child tax credit, taking care that it does not exceed $3,000. A\nconditional based on the number of children should suffice as at this point in the program\nwe already know it is zero or greater.\nif(numChildren <= 3) {\n1\ncredit = numChildren * 1000;\n2\n} else {\n3\ncredit = 3000;\n4\n}\n5\nFinally, we need to ensure that the credit does not exceed the total tax liability (the\ncredit is non-refundable, so if the credit is greater, the tax should only be zero, not\nnegative).\nif(baseTax - credit >= 0) {\n1\ntotalTax = baseTax - credit;\n2\n} else {\n3\ntotalTax = 0;\n4\n}\n5\nThe full program is presented in Code Sample 27.3.\n27.3.3. Quadratic Roots Revisited\nLet\u2019sreturntothequadraticrootsprogramwepreviouslydesignedthatusesthequadratic\nequation to compute the roots of a quadratic polynomial by reading coefficients a,b,c\nin from the user. One of the problems we had previously identified is if the user enters\n\u201cbad\u201d input: if a = 0, we would end up dividing by zero; if b2 \u22124ac < 0 then we would\nhave complex roots. With conditionals, we can now check for these issues and exit with\nan error message.\nAnother potential case we might want to handle differently is when there is only one\ndistinct root (b2 \u22124ac = 0). In that case, the quadratic formula simplifies to \u2212b and we\n2a\ncan print a different, more specific message to the user. The full program can be found\nin Code Sample 27.4.\n411 27. Conditionals\n\/**\n1\n* This program computes the logarithm base b (b > 1)\n2\n* of a given number x > 0\n3\n*\/\n4\npublic class Logarithm {\n5\n6\npublic static void main(String args[]) {\n7\n8\ndouble b, x, result;\n9\nif(args.length != 2) {\n10\nSystem.out.println(\"Usage: b x\");\n11\nSystem.exit(1);\n12\n}\n13\n14\nb = Double.parseDouble(args[0]);\n15\nx = Integer.parseInt(args[1]);\n16\n17\nif(x <= 0) {\n18\nSystem.out.println(\"Error: x must be greater than zero\");\n19\nSystem.exit(1);\n20\n}\n21\nif(b <= 1) {\n22\nSystem.out.println(\"Error: base must be greater than one\");\n23\nSystem.exit(1);\n24\n}\n25\n26\nresult = Math.log(x) \/ Math.log(b);\n27\nSystem.out.printf(\"log_(%f)(%f) = %f\\n\", b, x, result);\n28\n29\n}\n30\n31\n}\n32\nCode Sample 27.2.: Logarithm Calculator Program in Java\n412 27.3. Examples\n1 import java.util.Scanner;\n2\n3 public class Taxes {\n4\n5 public static void main(String args[]) {\n6\n7 Scanner s = new Scanner(System.in);\n8 double income, baseTax, totalTax, numChildren, credit;\n9\n10 System.out.println(\"Please enter your Adjusted Gross Income: \");\n11 income = s.nextDouble();\n12\n13 System.out.println(\"How many children do you have?\");\n14 numChildren = s.nextDouble();\n15\n16 if(income < 0 || numChildren < 0) {\n17 System.out.println(\"Invalid inputs\");\n18 System.exit(1);\n19 }\n20\n21 if(income <= 18150) {\n22 baseTax = income * .10;\n23 } else if(income <= 73800) {\n24 baseTax = 1815 + (income -18150) * .15;\n25 } else if(income <= 148850) {\n26 baseTax = 10162.50 + (income - 73800) * .25;\n27 } else if(income <= 225850) {\n28 baseTax = 28925.00 + (income - 148850) * .28;\n29 } else if(income <= 405100) {\n30 baseTax = 50765.00 + (income - 225850) * .33;\n31 } else if(income <= 457600) {\n32 baseTax = 109587.50 + (income - 405100) * .35;\n33 } else {\n34 baseTax = 127962.50 + (income - 457600) * .396;\n35 }\n36\n37 if(numChildren <= 3) {\n38 credit = numChildren * 1000;\n39 } else {\n40 credit = 3000;\n41 }\n42\n43 if(baseTax - credit >= 0) {\n44 totalTax = baseTax - credit;\n45 } else {\n46 totalTax = 0;\n47 }\n48\n49 System.out.printf(\"AGI: $%10.2f\\n\", income);\n50 System.out.printf(\"Tax: $%10.2f\\n\", baseTax);\n51 System.out.printf(\"Credit: $%10.2f\\n\", credit);\n52 System.out.printf(\"Tax Liability: $%10.2f\\n\", totalTax);\n53\n54 }\n55\n56 }\nCode Sample 27.3.: Tax Program in Java\n413 27. Conditionals\n\/**\n1\n* This program computes the roots to a quadratic equation\n2\n* using the quadratic formula.\n3\n*\/\n4\npublic class Roots {\n5\n6\npublic static void main(String args[]) {\n7\ndouble a, b, c, root1, root2;\n8\n9\nif(args.length != 3) {\n10\nSystem.err.println(\"Usage: a b c\\n\");\n11\nSystem.exit(1);\n12\n}\n13\n14\na = Double.parseDouble(args[0]);\n15\nb = Double.parseDouble(args[1]);\n16\nc = Double.parseDouble(args[2]);\n17\n18\nif(a == 0) {\n19\nSystem.err.println(\"Error: a cannot be zero\");\n20\nSystem.exit(1);\n21\n} else if(b*b < 4*a*c) {\n22\nSystem.err.println(\"Error: cannot handle complex roots\\n\");\n23\nSystem.exit(1);\n24\n} else if(b*b == 4*a*c) {\n25\nroot1 = -b \/ (2*a);\n26\nSystem.out.printf(\"Only one distinct root: %f\\n\", root1);\n27\n} else {\n28\nroot1 = (-b + Math.sqrt(b*b - 4*a*c) ) \/ (2*a);\n29\nroot2 = (-b - Math.sqrt(b*b - 4*a*c) ) \/ (2*a);\n30\n31\nSystem.out.printf(\"The roots of %fx^2 + %fx + %f are: \\n\",\n32\na, b, c);\n33\nSystem.out.printf(\" root1 = %f\\n\", root1);\n34\nSystem.out.printf(\" root2 = %f\\n\", root2);\n35\n}\n36\n}\n37\n38\n}\n39\nCode Sample 27.4.: Quadratic Roots Program in Java With Error Checking\n414 28. Loops\nJava supports while loops, for loops, and do-while loops using the keywords while, for,\nand do (along with another while). Continuation conditions for loops are enclosed\nin parentheses, (...) and the blocks of code associated with the loop are enclosed in\ncurly brackets.\n28.1. While Loops\nCode Sample 28.1 contains an example of a basic while loop in C. Just as with conditional\nstatements, our code styling places the opening curly bracket on the same line as the\nwhile keyword and continuation condition. The inner block of code is also indented\nand all lines in the block are indented to the same level.\nIn addition, the continuation condition does not have a semicolon since it is not an\nexecutable statement. Just as with an if-statement, if we had included a semicolon it\nwould have led to unintended results. Consider the following:\nwhile(i <= 10); {\n1\n\/\/perform some action\n2\ni++; \/\/iteration\n3\n}\n4\nint i = 1; \/\/Initialization\n1\nwhile(i <= 10) { \/\/continuation condition\n2\n\/\/perform some action\n3\ni++; \/\/iteration\n4\n}\n5\nCode Sample 28.1.: While Loop in Java\n415 28. Loops\nint i = 1;\n1\nboolean flag = true;\n2\nwhile(flag) {\n3\n\/\/perform some action\n4\ni++; \/\/iteration\n5\nif(i>10) {\n6\nflag = false;\n7\n}\n8\n}\n9\nCode Sample 28.2.: Flag-controlled While Loop in Java\nA similar problem occurs: the while keyword and continuation condition bind to\nthe next executable statement or code block. As a consequence of the semicolon, the\nexecutable statement that gets bound to the while loop is empty. What happens is\neven worse: the program will enter an infinite loop. To see this, the code is essentially\nequivalent to the following:\nwhile(i <= 10) {\n1\n}\n2\n{\n3\n\/\/perform some action\n4\ni++; \/\/iteration\n5\n}\n6\nIn the while loop, we never increment the counter variable i, the loop does nothing,\nand so the computation will continue on forever! Some compilers will warn you about\nthis, others will not. It is valid Java and it will compile and run, but obviously won\u2019t\nwork as intended. Avoid this problem by using proper syntax.\nAnother common use case for a while loop is a flag-controlled loop in which we use a\nBoolean flag rather than an expression to determine if a loop should continue or not. An\nexample can be found in Code Sample 28.2.\n416 28.2. For Loops\n28.2. For Loops\nFor loops in Java use the familiar syntax of placing the initialization, continuation\ncondition, and iteration on the same line as the keyword for. An example can be found\nin Code Sample 28.3.\nfor(int i=1; i<=10; i++) {\n1\n\/\/perform some action\n2\n}\n3\nCode Sample 28.3.: For Loop in Java\nSemicolons are placed at the end of the initialization and continuation condition, but not\nthe iteration statement. Just as with while loops, the opening curly bracket is placed on\nthe same line as the for keyword. Code within the loop body is indented, all at the\nsame indentation level.\nAnother observation: the declaration of the counter variable i was done in the initializa-\ntion statement. This scopes the variable to the loop itself. The variable i is valid inside\nthe loop body, but will be out-of-scope after the loop body. It is possible to declare the\nvariable prior to the loop, but the variable i would have a much larger scope. It is best\npractice to limit the scope of variables only to where they are needed. Thus, we will\nwrite our loops as above.\n28.3. Do-While Loops\nFinally, Java supports do-while loops. Recall that the difference between a while loop\nand a do-while loop is when the continuation condition is checked. For a while loop it is\nprior to the beginning of the loop body and in a do-while loop it is at the end of the\nloop. This means that a do-while always executes at least once. An example can be\nfound in Code Sample 28.4.\nThe opening curly bracket is again on the same line as the keyword do. The while\nkeyword and continuation condition are on the same line as the closing curly bracket.\nIn a slight departure from previous syntax, a semicolon does appear at the end of the\ncontinuation condition even though it is not an executable statement.\n417 28. Loops\nint i;\n1\ndo {\n2\n\/\/perform some action\n3\ni++;\n4\n} while(i <= 10);\n5\nCode Sample 28.4.: Do-While Loop in Java\n28.4. Enhanced For Loops\nJava also supports foreach loops (which were introduced in JDK 1.5.0) which Java refers\nto as \u201cEnhanced For Loops.\u201d Foreach loops allow you to iterate over each element in a\ncollection without having to define an index variable or otherwise \u201cget\u201d each element.\nWe\u2019ll revisit these concepts in detail in Chapter 31, but let\u2019s take a look at a couple of\nexamples.\nAn enhanced for loop in Java still uses the keyword for but uses different syntax for\nits control. The example in Code Sample 28.5 illustrates this syntax: (int a : arr).\nThe last element of this syntax is a reference to the collection that we want to iterate\nover. The first part is the type and local reference variable that the loop will use.\nint arr[] = {10, 20, 8, 42};\n1\nint sum = 0;\n2\nfor(int a : arr) {\n3\nsum += a;\n4\n}\n5\nCode Sample 28.5.: Enhanced For Loops in Java Example 1\nThe code (int a : arr) should be read as \u201cfor each integer element a in the collection\narr...\u201d Within the enhanced for loop, the variable a will be automatically updated for\nyou on each iteration. Outside the loop body, the variable a is out-of-scope.\nJava allows you to use an enhanced for loop with any array or collection (technically,\nanything that implements the Iterable interface). One example is a List, an ordered\ncollection of elements. Code Sample 28.6 contains an example.\n418 28.5. Examples\nList<Integer> list = Arrays.asList(10, 20, 8, 42);\n1\nint sum = 0;\n2\nfor(Integer a : list) {\n3\nsum += a;\n4\n}\n5\nCode Sample 28.6.: Enhanced For Loops in Java Example 2\n28.5. Examples\n28.5.1. Normalizing a Number\nLet\u2019srevisittheexamplefromSection4.1.1inwhichwenormalize anumberbycontinually\ndividing it by 10 until it is less than 10. The code in Code Sample 28.7 specifically refers\nto the value 32145.234 but would work equally well with any value of x.\ndouble x = 32145.234;\n1\nint k = 0;\n2\nwhile(x > 10) {\n3\nx = x \/ 10; \/\/or: x \/= 10;\n4\nk++;\n5\n}\n6\nCode Sample 28.7.: Normalizing a Number with a While Loop in Java\n28.5.2. Summation\nLet\u2019s revisit the example from Section 4.2.1 in which we computed the sum of integers\n1+2+\u00b7\u00b7\u00b7+10. The code is presented in Code Sample 28.8\nWe could have easily generalized the code somewhat. Instead of computing a sum up to\na particular number, we could have written it to sum up to another variable n, in which\ncase the for loop would instead look like the following.\n419 28. Loops\nint sum = 0;\n1\nfor(int i=1; i<=10; i++) {\n2\nsum += i;\n3\n}\n4\nCode Sample 28.8.: Summation of Numbers using a For Loop in Java\nfor(int i=1; i<=n; i++) {\n1\nsum += i;\n2\n}\n3\n28.5.3. Nested Loops\nRecall that you can write loops within loops by nesting them. The inner loop will execute\nfully for each iteration of the outer loop. An example of two nested of loops in Java can\nbe found in Code Sample 28.9.\nint i, j;\n1\nint n = 10;\n2\nint m = 20;\n3\nfor(i=0; i<n; i++) {\n4\nfor(j=0; j<m; j++) {\n5\nSystem.out.printf(\"(i, j) = (%d, %d)\\n\", i, j);\n6\n}\n7\n}\n8\nCode Sample 28.9.: Nested For Loops in Java\nThe inner loop execute for j = 0,1,2,...,19 < m = 20 for a total of 20 iterations. How-\never, it executes 20 times for each iteration of the outer loop. Since the outer loop execute\nfor i = 0,1,2,...,9 < n = 10, the total number of times the System.out.printf()\nstatement execute is 10\u00d720 = 200. In this example, the sequence\n(0,0),(0,1),(0,2),...,(0,19),(1,0),...,(9,19)\nwill be printed.\n420 28.5. Examples\n28.5.4. Paying the Piper\nLet\u2019s adapt the solution for the loan amortization schedule we developed in Section 4.7.3.\nFirst, we\u2019ll read the principle, terms, and interest as command line inputs. Adapting the\nformula for the monthly payment and using the math library\u2019s Math.pow() function,\nwe have the following.\ndouble monthlyPayment = (monthlyInterestRate * principle) \/\n1\n(1 - pow( (1 + monthlyInterestRate), -n));\n2\nHowever, recall that we may have problems due to accuracy. The monthly payment\ncould come out to be a fraction of a cent, say $43.871. For accuracy, we need to ensure\nthat all of the figures for currency are rounded to the nearest cent. The standard math\nlibrary does have a Math.round() function, but it only rounds to the nearest whole\nnumber, not the nearest 100th.\nHowever, we can adapt the \u201coff-the-shelf\u201d solution to fit our needs. If we take the number,\nmultiply it by 100, we get 4387.1 which we can now round to the nearest whole number,\ngiving us 4387. We can then divide by 100 to get a number that has been rounded to\nthe nearest 100th! In Java, we could simply do the following.\nmonthlyPayment = Math.round(monthlyPayment * 100.0) \/ 100.0;\nWe can use the same trick to round the monthly interest payment and any other number\nexpected to be whole cents. To output our numbers, we use System.out.printf() and\ntake care to align our columns to make make it look nice. To finish our adaptation, we\nhandle the final month separately to account for an over\/under payment due to rounding.\nThe full solution can be found in Code Sample 28.10.\n421 28. Loops\n1 public class LoanAmortization {\n2\n3 public static void main(String args[]) {\n4\n5 if(args.length != 4) {\n6 System.err.println(\"Usage: principle apr terms\");\n7 System.exit(1);\n8 }\n9\n10 double principle = Double.parseDouble(args[0]);\n11 double apr = Double.parseDouble(args[1]);\n12 int n = Integer.parseInt(args[2]);\n13\n14 double balance = principle;\n15 double monthlyInterestRate = apr \/ 12.0;\n16\n17 \/\/monthly payment\n18 double monthlyPayment = (monthlyInterestRate * principle) \/\n19 (1 - Math.pow( (1 + monthlyInterestRate), -n));\n20 \/\/round to the nearest cent\n21 monthlyPayment = Math.round(monthlyPayment * 100.0) \/ 100.0;\n22\n23 System.out.printf(\"Principle: $%.2f\\n\", principle);\n24 System.out.printf(\"APR: %.4f%%\\n\", apr*100.0);\n25 System.out.printf(\"Months: %d\\n\", n);\n26 System.out.printf(\"Monthly Payment: $%.2f\\n\", monthlyPayment);\n27\n28 \/\/for the first n-1 payments in a loop:\n29 for(int i=1; i<n; i++) {\n30 \/\/ compute the monthly interest, rounded:\n31 double monthlyInterest =\n32 Math.round( (balance * monthlyInterestRate) * 100.0) \/ 100.0;\n33 \/\/ compute the monthly principle payment\n34 double monthlyPrinciplePayment = monthlyPayment - monthlyInterest;\n35 \/\/ update the balance\n36 balance = balance - monthlyPrinciplePayment;\n37 \/\/ print i, monthly interest, monthly principle, new balance\n38 System.out.printf(\"%d\\t$%10.2f $%10.2f $%10.2f\\n\", i, monthlyInterest,\n39 monthlyPrinciplePayment, balance);\n40 }\n41\n42 \/\/handle the last month and last payment separately\n43 double lastInterest = Math.round(\n44 (balance * monthlyInterestRate) * 100.0) \/ 100.0;\n45 double lastPayment = balance + lastInterest;\n46\n47 System.out.printf(\"Last payment = $%.2f\\n\", lastPayment);\n48\n49 }\n50\n51 }\nCode Sample 28.10.: Loan Amortization Program in Java\n422 29. Methods\nAs an object-oriented programming language, functions in Java are usually referred to\nas methods and are essential to writing programs. The distinction is that a function is\nusually a standalone element while methods are functions that are members of a class.\nIn Java, since everything is a class or belongs to a class, standalone functions cannot be\ndefined.\nIn Java you can define your own methods, but they need to be placed within a class.\nUsually methods that act on data in the class (or instances of the class, see Chapter 34)\nor have common functionality are placed into one class. For example, all the basic math\nmethods are part of the java.lang.Math class. It is not uncommon to place similar\nmethods together into one \u201cutility\u201d class.\nJava supports method overloading, so within the same class you can define multiple\nmethods with the same name as long as they differ in either the number (also called\narity) or type of parameters. For example, in the java.lang.Math class, there are\n3 versions of the absolute value method, abs(), one that takes\/returns an int, one\nthat takes\/returns a double and one for float types. Naming conflicts can easily be\nsolved by ensuring that you place your methods in a class\/package that is unique to your\napplication.\nIn Java, the 8 primitive types (int, double, char, boolean, etc.) are always passed\nby value. All object types, however, such as the wrapper classes Integer, Double as\nwell as String, etc. are passed by reference. That is, the memory address in the JVM\nis passed to the method. This is done for efficiency. For objects that are \u201clarge\u201d it would\nbe inefficient to copy the entire object into the call stack in order to pass it to a method.\nThough object types are passed by reference, the method cannot necessarily change\nthem. Recall that the wrapper classes Integer, Double and the String class are all\nimmutable, meaning that once created they cannot be modified. Though they are passed\nby reference, the method that receives them cannot change them.\nThere are many mutable objects in Java. The StringBuilder class for example is a\nmutable object. If you pass a StringBuilder instance to a method, that method is free\nto invoke mutator methods on the object such as .append() that change the object\u2019s\nstate. Since it is the same object as in the calling method, the calling method can \u201csee\u201d\nthose changes.\n423 29. Methods\nAs of Java 5, you can write and use vararg methods. The System.out.printf()\nmethod is a prime example of this. However, we will not discuss in detail how to do this.\nInstead, refer to standard Java documentation. Finally, parameters are not optional in\nJava. This is because Java supports method overloading. You can write multiple versions\nof the same method that each take a different number of arguments. You can even design\nthem so that the more specific versions (with fewer arguments) invoke the more general\nversions (with more arguments), passing in sensible \u201cdefaults.\u201d\n29.1. Defining Methods\nDefining methods is fairly straightforward. First you create a class to place them in.\nThen you provide the method signature along with the body of the method. In addition,\nthere are several modifiers that you can place in the method signature to specify its\nvisibility and whether or not the method \u201cbelongs\u201d to the class or to instances of the\nclass. This is a concept we\u2019ll explore in Chapter 34. For now, we\u2019ll only focus on what is\nneeded to get started.\nTypically, the documentation for methods is included with the method definition using\n\u201cJavadoc\u201d style comments. Consider the following examples.\n\/**\n1\n* Computes the sum of the two arguments.\n2\n* @param a\n3\n* @param b\n4\n* @return the sum, <code>a + b<\/code>\n5\n*\/\n6\npublic static int sum(int a, int b) {\n7\nreturn (a + b);\n8\n}\n9\n10\n\/**\n11\n* Computes the Euclidean distance between the 2-D points,\n12\n* (x1,y1) and (x2,y2).\n13\n* @param x1\n14\n* @param y1\n15\n* @param x2\n16\n* @param y2\n17\n* @return\n18\n*\/\n19\npublic static double getDistance(double x1, double y1,\n20\ndouble x2, double y2) {\n21\ndouble xDiff = (x1-x2);\n22\n424 29.1. Defining Methods\ndouble yDiff = (y1-y2);\n23\nreturn Math.sqrt( xDiff * xDiff + yDiff * yDiff);\n24\n}\n25\n26\n\/**\n27\n* Computes a monthly payment for a loan with the given\n28\n* principle at the given APR (annual percentage rate) which\n29\n* is to be repaid over the given number of terms.\n30\n* @param principle - the amount borrowed\n31\n* @param apr - the annual percentage rate\n32\n* @param terms - number of terms (usually months)\n33\n* @return\n34\n*\/\n35\npublic static double getMonthlyPayment(double principle,\n36\ndouble apr, int terms) {\n37\ndouble rate = (apr \/ 12.0);\n38\ndouble payment = (principle * rate) \/ (1-Math.pow(1+rate, -terms));\n39\nreturn payment;\n40\n}\n41\nIn each of the examples above, the first modifier keyword we used was public. This\nmakes the method visible to all other parts of the code base. Any other piece of code can\ninvoke the method and take advantage of the functionality it provides. Alternatively, we\ncould have used the keywords private (which makes it visible only to other methods in\nthe same class) protected or \u201cpackage protected\u201d by omitting the modifier altogether.\nWe will want our methods to be available to other classes, so we\u2019ll make most of them\npublic. The second modifier is static which makes it so that the method belongs\nto the class itself rather than instances of the class. We discuss visibility keywords and\ninstances in detail in Chapter 34. For now, we will make all of our methods static.\nAfter the modifiers, we provide the method signature including the return type, its\nidentifier(name),anditsparameterlist. Methodnamesmustfollowthesamenamingrules\nas variables: they must begin with an alphabetic character and may contain alphanumeric\ncharacters as well as underscores. However, using modern coding conventions we name\nmethods using lower camel casing. Immediately after the signature we provide a method\nbody which contains the code that will be run upon invocation of the method. The\nmethod body is enclosed using opening\/closing curly brackets.\n425 29. Methods\n29.1.1. Void Methods\nThe keyword void can be used in Java to indicate a method does not return a value,\nin which case it is called a \u201cvoid method.\u201d Though it is not necessary, it is still good\npractice to include a return statement.\npublic static void printCopyright()\n1\nSystem.out.println(\"(c) Bourke 2015\");\n2\nreturn;\n3\n}\n4\nIn the example above, we\u2019ve also illustrated how to define a method that has no input\nparameters.\n29.1.2. Using Methods\nOnce a method has been defined in a class, you can make use of the method as follows.\nFirst, you may need to import the class itself depending on where it is. For example,\nsuppose that the examples we\u2019ve presented so far are contained in a class named Utils\n(short for \u201cutilities\u201d) which is in a package named unl.cse. Then in the class in which\nwe want to call some of these functions we would import it using\nimport unl.cse.Utils;\nprior to the class declaration. Once the class has been imported, we can invoke a method\nin the class by first referencing the class and using the dot operator to access one of its\nmethods. For example,\nint a = 10, b = 20;\n1\nint c = Utils.sum(a, b); \/\/c contains the value 30\n2\n3\n\/\/invoke a method with literal values:\n4\ndouble dist = Utils.getDistance(0.0, 0.0, 10.0, 20.0);\n5\n6\n\/\/invoke a method with a combination:\n7\ndouble p = 1500.0;\n8\ndouble r = 0.05;\n9\ndouble monthlyPayment = Utils.getMonthlyPayment(p, r, 60);\n10\n426 29.1. Defining Methods\nThe Utils.methodName() syntax is used because the methods are static\u2013they belong\nto the class and so must be invoked through the class using the class\u2019s name. We\u2019ve\npreviously seen this syntax when using System. or Math. with the standard JDK\nlibrary functions.\n29.1.3. Passing By Reference\nJava does not allow you the ability to specify if a variable is passed by reference or by\nvalue. Instead, all primitive types are passed by value while all object types are passed\nby reference. Moreover, most of the built-in types such as Integer and String are\nimmutable, even though they are passed by reference, any method that receives them\ncannot change them. Only if the passed object is mutable can the method make changes\nto it (by invoking its methods).\nAs an example, consider the following piece of code. The StringBuilder class is a\nmutable string object. You can change the string contents stored in a StringBuilder\nby calling one of its many methods such as append(), which will add whatever string\nyou give it to the end.\nIn the main method, we create two objects, a String and a StringBuilder and\npass it to a method that makes changes to both by appending \" world!\" to them.\nUnderstand what happens here though. The first line in change() actually creates a\nnew string and then changes what the parameter variable s references. The reference\nto the original string, \"Hello\" is lost and replaced with the new string. In contrast,\nthe StringBuilder instance is actually changed via its append() method but is still\nthe same object.\npublic class Mutability {\n1\n2\npublic static void change(String s, StringBuilder sb) {\n3\ns = s + \" world!\";\n4\nsb.append(\" world!\");\n5\n6\nSystem.out.println(\"change: s = \" + s);\n7\nSystem.out.println(\"change: sb = \" + sb);\n8\n}\n9\n10\npublic static void main(String args[]) {\n11\nString a = \"Hello\";\n12\nStringBuilder b = new StringBuilder(\"Hello\");\n13\n14\nSystem.out.println(\"main: s = \" + a);\n15\n427 29. Methods\nSystem.out.println(\"main: b = \" + b);\n16\n17\nchange(a, b);\n18\n19\nSystem.out.println(\"main after: s = \" + a);\n20\nSystem.out.println(\"main after: b = \" + b);\n21\n22\n}\n23\n}\n24\nTo see this, observe the following output. When we return to the main method, the\noriginal string s is unchanged (since it was immutable). However, the StringBuilder\nhas been changed by the method.\nmain: s = Hello\nmain: b = Hello\nchange: s = Hello world!\nchange: sb = Hello world!\nmain after: s = Hello\nmain after: b = Hello world!\n29.2. Examples\n29.2.1. Generalized Rounding\nRecall that the math library provides a Math.round() method that rounds a number\nto the nearest whole number. We\u2019ve had need to round to cents as well. We now have\nthe ability to write a method to do this for us. Before we do, however, let\u2019s think more\ngenerally. What if we wanted to round to the nearest tenth? Or what if we wanted to\nround to the nearest 10s or 100s place? Let\u2019s write a general purpose rounding method\nthat allows us to specify which decimal place to round to.\nThe most natural input would be to specify the place using an integer exponent. That\nis, if we wanted to round to the nearest tenth, then we would pass it \u22121 as 0.1 = 10\u22121,\n\u22122 if we wanted to round to the nearest 100th, etc. In the other direction, passing\nin 0 would correspond to the usual round function, 1 to the nearest 10s spot, and so\n428 29.2. Examples\non. We could demonstrate good code reuse (as well as good procedural abstraction)\nby scaling the input value and reusing the functionality already provided in the math\nlibrary\u2019s Math.round() method. We could further define a roundToCents() method\nthat used our generalized round method. Finally, we could place all of these methods\ninto RoundUtils Java class for good organization.\npackage unl.cse;\n1\n2\n\/**\n3\n* A collection of rounding utilities\n4\n*\n5\n*\/\n6\npublic class RoundUtils {\n7\n8\n\/**\n9\n* Rounds to the nearest digit specified by the place\n10\n* argument. In particular to the (10^place)-th digit\n11\n*\n12\n* @param x the number to be rounded\n13\n* @param place the place to be rounded to\n14\n* @return\n15\n*\/\n16\npublic static double roundToPlace(double x, int place) {\n17\ndouble scale = Math.pow(10, -place);\n18\ndouble rounded = Math.round(x * scale) \/ scale;\n19\nreturn rounded;\n20\n}\n21\n22\n\/**\n23\n* Rounds to the nearest cent (100th place)\n24\n*\n25\n* @param x\n26\n* @return\n27\n*\/\n28\npublic static double roundToCents(double x) {\n29\nreturn RoundUtils.roundToPlace(x, -2);\n30\n}\n31\n32\n}\n33\nObserve that this class does not contain a main() method. That means that this class\n429 29. Methods\nis not executable itself. It only provides functionality to other classes in the code base.\n430 30. Error Handling & Exceptions\nJava supports error handling through the use of exceptions. Java has many different\npredefined types of exceptions that you can use in your own code. It also allows\nyou to define your own exception types by creating new classes that inherit from the\npredefined classes. Java uses the standard try-catch-finally control structure to\nhandle exceptions and allows you to throw your own exceptions.\n30.1. Exceptions\nJava defines a base class named Throwable. There are two majors subtypes of\nThrowable: Error and Exception. The Error class is used primarily for fatal\nerrors such as the JVM running out of memory or some other extreme case that your\ncode cannot reasonably be expected to recover from. There are dozens of types of\nexceptions that are subclasses of the standard Java Exception class defined by the\nJDK including IOException (and its subclasses such as FileNotFoundException) or\nSQLException (when working with Structured Query Language (SQL) databases). An\nimportant subclass of Exception is RuntimeException which represent unchecked\nexceptions that do not need to be explicitly caught (see Section 30.1.4). We\u2019ll mostly\nfocus on this type of exception.\n30.1.1. Catching Exceptions\nTo catch an exception in Java you can use the standard try-catch control block (and\noptionally use the finally block to clean up any resources). Let\u2019s take, for example,\nthe simple task of reading input from a user using Scanner and manually parsing its\nvalue into an integer. If the user enters a non-numeric value, parsing will fail and result\nin a NumberFormatException that we can then catch and handle. For example,\nScanner s = new Scanner(System.in);\n1\nint n = 0;\n2\n3\n431 30. Error Handling & Exceptions\ntry {\n4\nString input = s.next();\n5\nn = Integer.parseInt(input);\n6\n} catch (NumberFormatException nfe) {\n7\nSystem.err.println(\"You entered invalid data!\");\n8\nSystem.exit(1);\n9\n}\n10\nIn this example, we\u2019ve simply displayed an error message to the standard error output\nand exited the program. That is, we\u2019ve made the design decision that this error should\nbe fatal. We could have chosen to handle this error differently in the catch block.\nThe code above could have resulted in other exceptions. For example if the Scanner\nhad failed to read the next token from the standard input, it would have thrown a\nNoSuchElementException. We can add as many catch blocks as we want to handle\neach exception differently.\nScanner s = new Scanner(System.in);\n1\nint n = 0;\n2\n3\ntry {\n4\nString input = s.next();\n5\nn = Integer.parseInt(input);\n6\n} catch (NumberFormatException nfe) {\n7\nSystem.err.println(\"You entered invalid data!\");\n8\nSystem.exit(1);\n9\n} catch (NoSuchElementException nsee) {\n10\nSystem.err.println(\"Input reading failed, using default...\");\n11\nn = 20; \/\/a default value\n12\n} catch(Exception e) {\n13\nSystem.err.println(\"A general exception occurred\");\n14\ne.printStackTrace();\n15\nSystem.exit(1);\n16\n}\n17\nEach catch block catches a different type of exception. Thus, the name of the variable\nthat holds each exception must be different in the chain of catch blocks; nfe, nsee,\ne.\n432 30.1. Exceptions\nNote that the last catch block was written to catch a generic Exception. This last\nblock will essentially catch any other type of exception. Much like an if-else-if\nstatement, the first type of exception that is caught is the block that will be executed\nand they are all mutually exclusive. Thus, a \u201ccatch all\u201d block like this should always be\nthe last catch block. The most specific types of exceptions should be caught first and\nthe most general types should be caught last.\n30.1.2. Throwing Exceptions\nWe can also manually throw an exception. For example, we can throw a generic\nRuntimeException using the following.\nthrow new RuntimeException(\"Something went wrong\");\n1\nBy using a generic RuntimeException, we can attach a message to the exception (which\ncan be printed by code that catches the exception). If we want more fine-grained control\nover the type of exceptions, we need to define our own exceptions.\n30.1.3. Creating Custom Exceptions\nTo create your own exceptions, you need to create a new class to represent the exception\nand make it extend RuntimeException by using the keyword extends. This makes\nyour exception a subclass or subtype of the RuntimeException. This is a concept known\nas inheritance in OOP. Consider the example in the previous chapter of computing\nthe roots of a quadratic polynomial. One possible error situation is when the roots are\ncomplex numbers. We could define a new Java class as follows.\npublic class ComplexRootException extends RuntimeException {\n1\n2\n\/**\n3\n* Constructor that takes an error message\n4\n*\/\n5\npublic ComplexRootException(String errorMessage) {\n6\nsuper(errorMessage);\n7\n}\n8\n}\n9\n433 30. Error Handling & Exceptions\nNow in our code we can throw and catch this new type of exception.\n\/\/throw this exception:\n1\nif( b*b - 4*a*c < 0) {\n2\nthrow new ComplexRootException(\"Cannot Handle complex roots\");\n3\n}\n4\ntry {\n1\nr1 = getComplexRoot01(a, b, c);\n2\n} catch(ComplexRootException cre) {\n3\n\/\/handle the exception here...\n4\n}\n5\n30.1.4. Checked Exceptions\nA checked exception in Java is an exception that must be explicitly caught and han-\ndled. For example, the generic Exception class is a checked exception (others include\nIOException, SQLException, etc.). If a checked exception is thrown within a block of\ncode then it must either be caught and handled within that block of code or the method\nmust be specified to explicitly throw the exception. For example, the method\npublic static void processFile() {\n1\nScanner s = new Scanner(new File(\"data.csv\"));\n2\n}\n3\nwouldnotactuallycompilebecause Scanner throwsachecked FileNotFoundException.\nEither we would have to explicitly catch the exception:\npublic static void processFile() {\n1\nScanner s = null;\n2\ntry {\n3\ns = new Scanner(new File(\"data.csv\"));\n4\n} catch (FileNotFoundException e) {\n5\n434 30.1. Exceptions\n\/\/handle the exception here\n6\n}\n7\n}\n8\nor we would need to specify that the method processFile() explicitly throws the\nexception:\npublic static void processFile() throws FileNotFoundException {\n1\nScanner s = new Scanner(new File(\"data.csv\"));\n2\n}\n3\nDoing this, however, would force any code that called the processFile() method to\nsurround it in a try-catch block and explicitly handle it (or once again, throw it back\nto the calling method).\nThe point of a checked exception is to force code to deal with potential issues that can be\nreasonably anticipated (such as the unavailability of a file). However, from another point\nof view checked exceptions represent the exact opposite goal of error handling. Namely,\nthat a function or code block can and should inform the calling function that an error\nhas occurred, but not explicitly make a decision on how to handle the error. A checked\nexception doesn\u2019t make the full decision for the calling function, but it does eliminate\nignoring the error as an option from the calling function.\nJava also supports unchecked exceptions which do not need to be explicitly caught. For\nexample, NumberFormatException or NullPointerException are unchecked excep-\ntions. If an unchecked exception is thrown and not caught, it bubbles up through the\ncall stack until some piece of code does catch it. If no code catches it, it results in a fatal\nerror and terminates the execution of the JVM.\nThe RuntimeException class and any of its subclasses are unchecked exceptions. In\nour ComplexRootException example above, because we extended RuntimeException\nwe made it an unchecked exception, allowing the calling function to decide not only how\nto handle it, but whether or not to handle it at all. If we had instead decided to extend\nException we would have made our exception a checked exception.\nThere is considerable debate as to whether or not checked exceptions are a good thing\n(andastowhetherornotuncheckedexceptionsareagoodthing). Many1 feelthatchecked\n1The author included.\n435 30. Error Handling & Exceptions\nexceptions were a mistake and their usage should be avoided. The rationale behind\nchecked exceptions is summed up in the following quote from the Java documentation [7].\nHere\u2019s the bottom line guideline: If a client can reasonably be expected to\nrecover from an exception, make it a checked exception. If a client cannot do\nanything to recover from the exception, make it an unchecked exception\nThe problem is that the JDK\u2019s own design violates this principle. For example,\nFileNotFoundException is a checked exception; the reasoning being that a program\ncould reprompt the user for a different file. The problem is the assumption that the\nprogram we are writing is always interactive. In fact most software is not interactive and\nis instead designed to interact with other software. Reprompting is not appropriate or\neven an option in the vast majority of cases.\nAs another example, consider Java\u2019s SQL library which allows you to programmatically\nconnect to an SQL database. Nearly every method in the API explicitly throws a checked\nSQLException. It stretches the imagination to understand how our code or even a user\nwould be able to recover (programmatically at least) from a lost internet connection or a\nbad password, etc. In general, you should use unchecked exceptions.\n30.2. Enumerated Types\nAnother way to prevent errors is by restricting the values of a variable that a programmer\nis allowed to use. Java allows you to define a special class called an enumerated type\nwhich allow you to define a fixed list of possible values. For example, the days of the week\nor months of the year are possible values used in a date. However, they are more-or-less\nfixed (no one will be adding a new day of the week or month any time soon). An\nenumerated class allows us to define these values using human-readable keywords.\nTo create an enumerated type class we use the keyword enum (short for enumeration)\ninstead of class. Since an enumerated type is a class, it must follow the same rules.\nIt must be in a .java source file of the same name. Inside the enum we provide a\ncomma-delimited list of keywords to define our enumeration. Consider the following\nexample.\npublic enum Day {\n1\nSUNDAY,\n2\nMONDAY,\n3\nTUESDAY,\n4\nWEDNESDAY,\n5\nTHURSDAY,\n6\nFRIDAY,\n7\n436 30.2. Enumerated Types\nSATURDAY;\n8\n}\n9\nIn the example, since the name of the enumeration is Day this declaration must be in a\nsource file named Day.java. We can now declare variables of this type. The possible\nvalues it can take are restricted to SUNDAY, MONDAY, etc. and we can use these keywords\nin our program. However these values belong to the class Day and must be accessed\nstatically. For example,\nDay today = Day.MONDAY;\n1\n2\nif(today == Day.SUNDAY || today == Day.SATURDAY) {\n3\nSystem.out.println(\"Its the weekend!\");\n4\n}\n5\nNote the naming conventions: the name of the enumerated type follows the same\nupper camel casing that all classes use while the enumerated values follow an uppercase\nunderscore convention. Though our example does not contain a value with multiple\nwords, if it had, we would have used an underscore to separate them.\nUsing an enumerated type has two advantages. First, it enforces that only a particular\nset of predefined values can be used. You would not be able to assign a value to a\nDay variable that was not already defined by the Day enumeration. Second, without\nan enumerated type we\u2019d be forced to use a collection of magic numbers to indicate\nvalues. Even for something as simple as the days of the week we\u2019d be constantly trying to\nremember: which day is Wednesday again? Do our weeks start with Monday or Sunday?\nBy using an enumerated type these questions are mostly moot as we can use the more\nhuman-readable keywords and eliminate the guess work.\n30.2.1. More Tricks\nEvery enum type has some additional built-in methods that you can use. For example,\nthere is a values() method that can be called on the enum that returns an array of\nthe enum\u2019s values. You can use an enhanced for loop to iterate over them, for example,\n437 30. Error Handling & Exceptions\nfor(Day d : Day.values() {\n1\nSystem.out.println(d.name());\n2\n}\n3\nIn the example above, we used another feature: each enum value has a name() method\nthat returns the value as a String. This example would end up printing the following.\nSUNDAY\nMONDAY\nTUESDAY\nWEDNESDAY\nTHURSDAY\nFRIDAY\nSATURDAY\nOf course, we may want more human-oriented representations. To do this we could\noverride the class\u2019s toString() method to return a better string representation. For\nexample:\npublic String toString() {\n1\nif(this == SUNDAY) {\n2\nreturn \"Sunday\";\n3\n} else if(this == MONDAY) {\n4\nreturn \"Monday\";\n5\n}\n6\n...\n7\n} else {\n8\nreturn \"Saturday\";\n9\n}\n10\n}\n11\nBecause enum types are full classes in Java, many more tricks can be used that leverage\nthe power of classes including using additional state and constructors. We will cover\nthese topics later.\n438 31. Arrays\nJava allows you to declare and use arrays. Since Java is statically typed, arrays must\nalso be typed when they are declared and may only hold that particular type of element.\nSince Java has automated garbage collection, memory management is greatly simplified.\nFinally, inJava, onlylocallyscopedprimitivesandreferencesareallocatedontheprogram\ncall stack. As such, there are no static arrays; all arrays are allocated in the heap space.\n31.1. Basic Usage\nTo declare an array reference, you use syntax similar to declaring a regular variable, but\nyou use square brackets to designate the variable as an array. Arrays for any type of\nvariable can be created including primitives and objects.\nint arr[] = null;\n1\ndouble values[] = null;\n2\nString names[] = null;\n3\nThis example1 only declares 3 references that can refer to an array, it doesn\u2019t actually\ncreate them as the references are all set to null. To create arrays of a particular size,\nwe need to initialize them using the keyword new.\narr = new int[10];\n1\nvalues = new double[20];\n2\nnames = new String[5];\n3\n1You may see code examples that use the alternative notation int[] arr = null;. Both are\nacceptable. Some would argue that this way is more correct because it keeps the brackets with\nthe type, avoiding the type-variable name-type separation in our example. Those preferring the\nint arr[] = null; notation would argue that it is \u201cmore natural\u201d because that is how we\nultimately index the array. Six of one, half-dozen of the other.\n439 31. Arrays\nEach of these initializations creates a new array (allocated on the heap) of the specified\nsize (10, 20, and 5 respectively). These arrays can only hold values of the specified type,\nint, double, and String respectively. The default value for each element in these\nnew arrays will be zero for the numeric types and null for object types. Alternatively,\nyou could use a compound declaration\/assignment syntax to initialize specific values:\nint arr[] = { 2, 3, 5, 7, 11 };\n1\nUsing this syntax we do not need to specify the size of the array as the compiler is smart\nenough to count the number of elements we\u2019ve provided. The elements themselves are\ndenoted inside curly brackets and delimited with commas. For both types of syntax, the\nactual array is always allocated on the heap while the reference variables, arr, values,\nand names are stored in the program call stack.\nIndexing\nOnce an array has been created, its elements can be accessed by indexing them. Java\nuses the standard 0-indexing scheme so the first element is at index 0, the second at index\n1, etc. Indexing an element involves using the square bracket notation and providing\nan integer index. Once indexed, an array element can be treated as a normal variable\nand can be used with other operators such as the assignment operator or comparison\noperators.\narr[0] = 42;\n1\nif(arr[4] < 0) {\n2\nSystem.out.println(\"negative!\");\n3\n}\n4\nSystem.out.println(\"arr[1] = \" + arr[1]);\n5\nRecall that an index is actually an offset. The compiler and system know exactly how\nmany bytes each element takes and so an index i calculates exactly how many bytes\nfrom the first element the i-th element is located at. Consequently it is possible to index\nelements that are beyond the range of the array. For example, arr[-1] or arr[5]\nwould attempt to access an element immediately before the first element and immediately\nafter the last element. Obviously, these elements are not part of the array. If you\nattempt to access an element outside the bounds of an array, the JVM will throw an\nIndexOutOfBoundsException which is an unchecked RuntimeException that you can\n440 31.1. Basic Usage\ncatch and handle if you choose. To prevent such an exception you can write code that\ndoes not exceed the bounds of the array. Java arrays have a special length property that\ngives you the size of the array. You can access the property using the dot operator, so\narr.length would give the value 5 for the example above.\nIteration\nUsing the .length property you can design a for loop that increments an index variable\nto iterate over the elements in an array.\nint arr[] = new int[5];\n1\nfor(int i=0; i<arr.length; i++) {\n2\narr[i] = 5 * i;\n3\n}\n4\nThe for loop above initializes the variable i to zero, corresponding to the first element\nin the array. The continuation condition specifies that the loop continues while i is\nstrictly less than the size of the array denoted using the arr.length property. This for\nloop iteration is idiomatic when processing arrays.\nIn addition, Java (as of version 5) supports foreach loops that allow you to iterate over\nthe elements of an array without using an index variable. Java refers to these loops as\n\u201cenhanced for loops,\u201d but they are essentially foreach loops.\nfor(int a : arr) {\n1\nSystem.out.println(a);\n2\n}\n3\nThe syntax still uses the keyword for, but instead of an index variable, it specifies the\ntype and a the loop-scoped variable identifier followed by a colon and the array that you\nwant to iterate over. Each iteration of the loop updates the variable a to the next value\nin the array.\n441 31. Arrays\n31.2. Dynamic Memory\nThe use of the keyword new dynamically allocates memory space (on the heap) for the\narray. Because Java has automated garbage collection, if the reference to the array goes\nout of scope, it is automatically cleaned up by the JVM. This process is automated and\nessentially transparent to us. There are sophisticated algorithms and heuristics at work\nthat determine the \u201coptimal\u201d time to perform garbage collection.\nint arr[];\n1\n\/\/create a new array of size 10:\n2\narr = new arr[10];\n3\n\/\/lose the reference by explicitly setting it to null:\n4\narr = null;\n5\n\/\/all references to the old memory are now lost and it is\n6\n\/\/eligible for garbage collection\n7\n8\n\/\/we can also allocate new memory:\n9\narr = new arr[20];\n10\n31.3. Using Arrays with Methods\nWe can pass and return arrays to and from methods in Java. We use the same syntax as\nwhen we define them by specifying a type and using square brackets. As an example, the\nfollowing method takes an array of integers and computes its sum.\n\/**\n1\n* This method computes the sum of elements in the\n2\n* given array which contains n elements\n3\n*\/\n4\npublic static int computeSum(int arr[]) {\n5\nint sum = 0;\n6\nfor(int i=0; i<size; i++) {\n7\nsum += arr[i];\n8\n}\n9\nreturn sum;\n10\n}\n11\n442 31.4. Multidimensional Arrays\nIn Java, arrays are always passed by reference. Though we did not make any changes\nto the contents of the passed array in the particular example, in general we could have.\nAny such changes would be realized in the calling method. Unfortunately, there is no\nmechanism by which we can prevent changes to arrays when passed to methods.2\nWe can also create an array in a method and return it as a value. For example, the\nfollowing method creates a deep copy of the given integer array. That is, a completely\nnew array that is a distinct copy of the old array. In contrast, a shallow copy would be if\nwe simply made one reference point to another reference.\n\/**\n1\n* This method creates a new copy of the given array\n2\n* and returns it.\n3\n*\/\n4\npublic static int [] makeCopy(int a[]) {\n5\nint copy[] = new int[a.length];\n6\nfor(int i=0; i<n; i++) {\n7\ncopy[i] = a[i];\n8\n}\n9\nreturn copy;\n10\n}\n11\nThe method returns an integer array. In fact, this method is so useful, that it is already\nprovided as part of the Java Software Development Kit (SDK). The class Arrays\ncontains dozens of utility methods that process arrays. In particular there is a copyOf()\nmethod that allows you to create deep copies of arrays and even allows you to expand or\nshrink their size.\n31.4. Multidimensional Arrays\nJava supports multidimensional arrays, though we\u2019ll only focus on 2-dimensional arrays.\nTo declare and allocate 2-dimensional arrays, we use two square brackets with two\nspecified dimensions.\nint matrix[][] = new int[10][20];\n1\n2The use of the keyword final only prevents us from changing the array reference, not modifying its\ncontents.\n443 31. Arrays\nThis creates a 2-dimensional array of integers with 10 rows and 20 columns. Once created,\nwe can index individual elements by specifying row and column indices.\nfor(int i=0; i<matrix.length; i++) {\n1\nfor(int j=0; j<matrix[i].length; j++) {\n2\nmatrix[i][j] = 10;\n3\n}\n4\n}\n5\n31.5. Dynamic Data Structures\nThe Java SDK provides a rich assortment of dynamic data structures as alternatives to\narrays including lists, sets and maps. The classes that support and implement these data\nstructures are defined in the Collections library under the java.util package. We will\ncover how to use some of these data structures, but we will not go into the details of how\nthey are implemented nor the OOP concepts that underly them.\nThe Java List is an interface that defines a dynamic list data structure. This data\nstructure provides a dynamic collection that can grow and shrink automatically as you\nadd and remove elements from it. It is an interface, so it doesn\u2019t actually provide an\nimplementation, just a specification for the publicly available methods that you can use.\nTwo common implementations are ArrayList, which uses an array to hold elements,\nand LinkedList which stores elements in linked nodes.\nTo create an instance of either of these lists, you use the new keyword and the following\nsyntax.\nList<Integer> a = new ArrayList<Integer>();\n1\nList<String> b = new LinkedList<String>();\n2\nThe first line creates a new instance of an ArrayList that is parameterized to hold\nInteger types. The second creates a new instance of a LinkedList that has been\nparameterized to only hold String types. The parameterization is specified by placing\nthe parameterized type inside the angle brackets. Because of this parameterization, it\n444 31.5. Dynamic Data Structures\nwould be a compiler error to attempt to add anything other than Integers to the first\nlist or anything other than Strings to the second. Once these lists have been created,\nyou can add and remove elements using the add() method.\na.add(42);\n1\na.add(81);\n2\na.add(17);\n3\n4\nb.add(\"Hello\");\n5\nb.add(\"World\");\n6\nb.add(\"Computers!\");\n7\nThe order that you add elements is preserved, so in the first list, the first element would\nbe 42, the second 81, and the last 17. You can remove elements by specifying an index\nof the element to remove. Like arrays, lists are 0-indexed.\na.remove(0);\n1\n2\nb.remove(2);\n3\nb.remove(0);\n4\nAs you remove elements, the indices are \u201cshifted\u201d down, so that after removing the first\nelement in the list a, 81 becomes the new first element. Removing the last then the\nfirst element in the list b leaves it with only one element, \"World\" as the first element\n(at index 0).\nYou can also retrieve elements from a list using 0-indexing and the get() method.\nList<Double> values = new ArrayList<Double>();\n1\nvalues.add(3.14);\n2\nvalues.add(2.71);\n3\nvalues.add(42.0);\n4\n5\ndouble x = values.get(1); \/\/get the second value, 2.71\n6\ndouble y = values.get(2); \/\/get the third value, 42.0\n7\n445 31. Arrays\nAny attempt to access an element that lies outside the bounds of the List, will result\nin an IndexOutOfBoundsException just as with arrays. To stay within bounds you\ncan use the size() method to determine how many elements are in the collection. In\nthis example, values.size() would return an integer value of 3.\nFinally, most collections implement the Iterable interface which allows you iterate\nover the elements using an enhanced for loop just as with arrays.\nfor(Double x : values) {\n1\nSystem.out.println(x);\n2\n}\n3\nThere are dozens of other methods that allow you to insert, remove, and retrieve elements\nfrom a Java List; refer to the documentation for details.\nAnother type of collection supported by the Collections library is a Set. A set differs\nfrom a list in that it is unordered. There is no concept of the first element or last element.\nMoreover, a Set does not allow duplicate elements.3 A commonly used implementation\nof the Set interface is the HashSet.\nSet<String> names = new HashSet<String>();\n1\n2\nnames.add(\"Robin\");\n3\nnames.add(\"Little John\");\n4\nnames.add(\"Marian\");\n5\n6\n\/\/this has no effect since Robin is already part of the set:\n7\nnames.add(\"Robin\");\n8\nSince the elements in a Set are unordered, we cannot use an index-based get() method\nas we did with a List. Fortunately, we can still use an enhanced for loop to iterate over\nthe elements.\nfor(String name : names) {\n1\nSystem.out.println(name);\n2\n3Duplicates are determined by how the equals() and possibly the hashCode() methods are imple-\nmented in your particular objects.\n446 31.5. Dynamic Data Structures\n}\n3\nWhen this code executes we cannot expect any particular order of the three names. Any\npermutation of the three may be printed. If we executed the loop more than once we\nmay even observe a different enumeration of the names!\nFinally, Java also supports a Map data structure which allows you to store key-value\npairs. The keys and values can be any object type and are specified by two parameters\nwhen you create the map. A common implementation is the HashMap.\n\/\/define a map that maps integers (keys) to strings (values):\n1\nMap<Integer, String> numbers = new HashMap<Integer, String>();\n2\n3\n\/\/add key-value pairs:\n4\nnumbers.add(10, \"ten\");\n5\nnumbers.add(20, \"twenty\");\n6\n7\n\/\/retrieve values given a key:\n8\nString name = numbers.get(20); \/\/name equals \"twenty\"\n9\n10\n\/\/invalid mappings result in null:\n11\nname = numbers.get(30); \/\/name is null\n12\nThe Collections library is much more extensive than what we\u2019ve presented here. It\nincludes implementations of stacks, queues, hash tables, balanced binary search trees,\nand many other dynamic data structure implementations.\n447  32. Strings\nAs we\u2019ve previously seen, Java has a String class in the standard JDK. Internally, Java\nstrings are stored as arrays of characters. However, because of the String class, we\nnever directly interact with this representation. Making using strings much easier than\nin other languages. Java strings have also supported Unicode since version 1.\nJava provides many methods as part of the String class that can be used to process\nand manipulate strings. These methods do not change the strings since strings in Java\nare immutable. Instead, these methods operate by returning a new modified string that\ncan then be stored in a variable.\n32.1. Basics\nWe can declare String variables and assign them values using the regular assignment\noperator.\nString firstName = \"Thomas\";\n1\nString lastName = \"Waits\";\n2\n3\n\/\/we can also reassign values\n4\nfirstName = \"Tom\";\n5\nNote that the reassignment in the last line in the example does not change the original\nstring. It just makes the variable firstName point to a new string. If there are no other\nreferences to the old string, it becomes eligible for garbage collection and the JVM takes\ncare of it. Strings can be copied using the String class\u2019s copy constructor:\nString copy = new String(firstName);\nHowever, since strings are immutable, there is rarely reason to create such a deep copy.\nThough you can\u2019t change individual characters in a string, you can access them using the\n449 32. Strings\ncharAt() method and providing an index. Characters in a string are 0-indexed just as\nwith elements in arrays.\nString fullName = \"Tom Waits\";\n1\n\/\/access individual characters:\n2\nchar firstInitial = fullName.charAt(0); \/\/'T'\n3\nchar lastInitial = fullName.charAt(4); \/\/'W'\n4\n5\nif(fullName.charAt(8) == 's') {\n6\n...\n7\n}\n8\n32.2. String Methods\nThe String class provides dozens of convenient methods that allow you to process\nand modify strings. We highlight a few of the more common ones here. A full list of\nsupported functions can be found in standard documentation.\nLength\nWhen accessing individual characters in a string, it is necessary to know the length of\nthe string so that we do not access invalid characters. The length() method returns\nan int that represents the number of characters in the string.\nString s = \"Hello World!\";\n1\nchar last = s.charAt(s.length()-1);\n2\n\/\/last is '!'\n3\nUsing this method we can easily iterate over each character in a string.\nfor(int i=0; i<fullName.length(); i++) {\n1\nSystem.out.printf(\"fullName[%d] = %c\\n\", i, fullName.charAt(i));\n2\n}\n3\n4\n450 32.2. String Methods\n\/\/or we can use toCharArray and an enhanced for loop:\n5\nfor(char c : fullName.toCharArray()) {\n6\nSystem.out.println(c);\n7\n}\n8\nConcatenation\nJava has a concatenation operator built into the language. The familiar plus sign, + can\nbe used to combine one or more strings by appending them to each other. Concatenation\nresults in a new string.\nString firstName = \"Tom\";\n1\nString lastName = \"Waits\";\n2\n3\nString formattedName = lastName + \", \" + firstName;\n4\n\/\/formattedName now contains \"Waits, Tom\"\n5\nConcatenation also works with numeric types and even objects.\nint x = 10;\n1\ndouble y = 3.14;\n2\n3\nString s = \"Hello, x is \" + x + \" and y = \" + y;\n4\n\/\/s contains \"Hello, x is 10 and y = 3.14\"\n5\nWhen used with objects, the concatenation operator internally invokes the object\u2019s\ntoString() method. The plus operator as a concatenation operator is actually syntactic\nsugar. When the code is compiled, it is actually replaced with equivalent code that uses a\nseries of the StringBuilder class\u2019s (a mutable version of the String class) append()\nmethod. The compiler will actually replace the code using the concatenation operator\nwith code that does not use the concatenation operator. The example above would be\nreplaced with something like the following.\n451 32. Strings\nString firstName = \"Tom\";\n1\nString lastName = \"Waits\";\n2\n3\nString formattedName = new StringBuilder(lastName)\n4\n.append(\", \")\n5\n.append(firstName)\n6\n.toString();\n7\nYou can also use the StringBuilder class yourself directly.\nComputing a Substring\nThere are two methods that allow you to compute a substring of a string. The first allows\nyou to specify a beginning index with the entire remainder of the string being included\nin the returned string. The second allows you to specify a beginning index as well as an\nending index. In both cases, the beginning index is inclusive (that is the resulting string\nincludes the character at that index), but in the second, the ending index is exclusive\n(the character at the end index is not included).\nString name = \"Thomas Alan Waits\";\n1\n2\nString firstName = name.substring(0, 6); \/\/\"Thomas\"\n3\nString middleName = name.substring(7, 11); \/\/\"Alan\"\n4\nString lastName = name.substring(12); \/\/\"Waits\"\n5\nThe result of the two argument substring() method will always have length equal to\nendIndex - beginIndex.\n32.3. Arrays of Strings\nWe often need to deal with collections of strings. In Java, we can define arrays of strings.\nIndeed, we\u2019ve seen arrays of strings before. In a Java class\u2019s main() method, command\nline arguments are passed as an array of strings:\npublic static void main(String args[])\n452 32.4. Comparisons\nWe can create our own arrays of strings similar to how we created arrays of int and\ndouble types.\n\/\/create an array that can hold 5 strings\n1\nString names[] = new String[5];\n2\n3\nnames[0] = \"Margaret Hamilton\";\n4\nnames[1] = \"Ada Lovelace\";\n5\nnames[2] = \"Grace Hopper\";\n6\nnames[3] = \"Marie Curie\";\n7\nnames[4] = \"Hedy Lamarr\";\n8\nBetter yet, we can use dynamic collections such as a List or a Set of strings.\nList<String> names = new ArrayList<String>();\n1\n2\nnames.add(\"Margaret Hamilton\");\n3\nnames.add(\"Ada Lovelace\");\n4\nnames.add(\"Grace Hopper\");\n5\nnames.add(\"Marie Curie\");\n6\nnames.add(\"Hedy Lamarr\");\n7\n8\nSystem.out.println(names.get(2)); \/\/prints \"Grace Hopper\"\n9\n32.4. Comparisons\nWhen comparing strings in Java, we cannot use the numerical comparison operators such\nas ==, or <. Because strings are objects, using these operators actually compares the\nvariables\u2019 memory addresses.\nString a = new String(\"Hello World!\");\n1\nString b = new String(\"Hello World!\");\n2\n3\nif(a == b) {\n4\nSystem.out.println(\"strings match!\");\n5\n453 32. Strings\n}\n6\nThe code above will not print anything even though the strings a and b have the same\ncontent. This is because a == b is comparing the memory address of the two variables.\nSince they point to different memory addresses (created by two separate calls to the\nconstructors) they will not be equal.\nInstead, the String class provides a compareTo() method1 that takes another string\nand returns something negative, zero, or something positive depending on the relative\nlexicographic ordering of the strings.\nint x;\n1\nString a = \"apple\";\n2\nString b = \"zelda\";\n3\nString c = \"Hello\";\n4\nx = a.compareTo(\"banana\"); \/\/x is negative\n5\nx = b.compareTo(\"mario\"); \/\/x is positive\n6\nx = c.compareTo(\"Hello\"); \/\/x is zero\n7\n8\n\/\/shorter strings precede longer strings:\n9\nx = a.compareTo(\"apples\"); \/\/x is negative\n10\n11\nString d = \"Apple\";\n12\nx = d.compareTo(\"apple\"); \/\/x is negative\n13\nIn the last example, \"Apple\" precedes \"apple\" since uppercase letters are ordered\nbefore lowercase letters according to the ASCII table. We can also make case-insensitive\ncomparisons using the compareToIgnoreCase() method which works the same way.\nHere, d.compareToIgnoreCase(\"apple\") will return zero as the two strings are the\nsame ignoring the cases.\nNotethatthecommonlyused equals() methodonlyreturns true or false depending\non whether or not two strings are the same or different. They cannot be used to provide\na relative ordering of two strings.\n1This method is part of the String class due to the fact that strings implement the Comparable\ninterface which defines a lexicographic ordering.\n454 32.5. Tokenizing\nString a = \"apple\";\n1\nString b = \"apple\";\n2\nString c = \"Hello\";\n3\n4\nboolean result;\n5\nresult = a.equals(b); \/\/true\n6\nresult = a.equals(c); \/\/false\n7\n32.5. Tokenizing\nRecall that tokenizing is the process of splitting up a string using some delimiter. For\nexample, the comma delimited string, \"Smith,Joe,12345678,1985-09-08\" contains\nfour pieces of data delimited by a comma. Our aim is to split this string up into four\nseparate strings so that we can process each one.\nJava provides a very simple method to do this called split() that takes a string\ndelimiter and returns an array of strings containing the tokens. For example,\nString data = \"Smith,Joe,12345678,1985-09-08\";\n1\n2\nString tokens[] = data.split(\",\");\n3\n\/\/tokens is { \"Smith\", \"Joe\", \"12345678\", \"1985-09-08\" }\n4\n5\nString dateTokens[] = tokens[3].split(\"-\");\n6\n\/\/dateTokens is now { \"1985\", \"09\", \"08\" }\n7\nThe delimiter this method uses is actually a regular expression; a sequence of characters\nthat define a search pattern in which special characters can be used to define complex\npatterns. For example, the complex expression,\n^[+-]?(\\d+(\\.\\d+)?|\\.\\d+)([eE][+-]?\\d+)?$\nwill match any valid numerical value including scientific notation. We will not cover\nregular expressions in depth, but to demonstrate their usefulness, here\u2019s an example by\nwhich you can split a string along any and all whitespace:\n455 32. Strings\nString s = \"Alpha Beta \\t Gamma \\n Delta \\t\\nEpsilon\";\n1\nString tokens[] = s.split(\"[\\\\s]+\");\n2\n\/\/tokens is now { \"Alpha\", \"Beta\", \"Gamma\", \"Delta\", \"Epsilon\" }\n3\n456 33. File I\/O\nJava provides several different classes and utilities that support manipulating and pro-\ncessing files. In general, most file operations may result in an IOException, a checked\nexception that must be caught and handled.\n33.1. File Input\nThough there are several ways that you can do file input, the easiest is to use the\nfamiliar Scanner class. We\u2019ve previously used this class to read from the standard\ninput, System.in, but it can also be used to read from a file using the File class\n(in the java.io package). The File class is just a representation of a file resource\nand does not represent the actual file (it cannot be opened and closed). To initialize a\nScanner to read from a file you can use the following.\nScanner s = null;\n1\ntry {\n2\ns = new Scanner(new File(\"\/user\/apps\/data.txt\"));\n3\n} catch (FileNotFoundException e) {\n4\n\/\/handle the exception here\n5\n}\n6\nWheninitializinga Scanner toreadfromafile,theexception, FileNotFoundException\nmust be caught and handled as it is a checked exception. Otherwise, once created, the\nScanner class does not throw any checked exceptions.\nOnce created, you can use the usual methods and functionality provided by the Scanner\nclass including reading the nextInt(), nextDouble(), next string using next() or\neven the entire nextLine(). This last one can be used in conjunction with hasNext()\nto read an entire file, line-by-line.\n457 33. File I\/O\nString line;\n1\nwhile(s.hasNext()) {\n2\nline = s.nextLine();\n3\n\/\/process the line\n4\n}\n5\nOnce we are done reading the file, we can close the Scanner to free up resources:\ns.close();. We could have placed all this code within one large try-catch block\nwith perhaps a finally block to close the Scanner once were were done to ensure\nthat it would be closed regardless of any exceptions. However, Java 7 introduced a new\nconstruct, the try-with-resources statement.\nThe try-with-resources statement allows us to place the initialization of a \u201ccloseable\u201d\nresource (defined by the AutoCloseable interface) into the try statement. The JVM\nwill then automatically close this resource upon the conclusion of the try-catch block.\nWe can still provide a finally block if we wish, but this relieves us of the need to\nexplicitly close the resource in a finally block. A full example:\nFile f = new File(\"\/user\/apps\/data.txt\");\n1\n\/\/initialize a Scanner in the try statement\n2\ntry (Scanner s = new Scanner(f)) {\n3\nString line;\n4\nwhile(s.hasNext()) {\n5\nline = s.nextLine();\n6\n\/\/process the line\n7\n}\n8\n} catch (Exception e) {\n9\n\/\/handle the exception here\n10\n}\n11\nUsing the Scanner class to do file input offers a more abstract interaction with a file.\nIt also uses a buffered input stream for performance. Binary files can still be read using\nnextByte(). However, when dealing with binary files, the better solution is to use a\nclass that models and abstracts the underlying file. For example, if you are reading or\nwriting an image file, you should use the java.awt.Image class to read and write to\nfiles. The JDK and other libraries offer a wide variety of classes to model all kinds of\ndata.\n458 33.2. File Output\n33.2. File Output\nThere are several ways to achieve file output, but we\u2019ll look at the simplest and most\nusefulway. Javaprovidesa PrintWriter classwhichoffersmanyconvenientmethodsfor\nwriting primitive and String types in a formatted manner. It has the usual print()\nand println() methods that we are familiar with as well as a printf() style method\nfor formatting.\nPrintWriter is also buffered, depending on how you instantiate it, it might \u201cflush\u201d its\nbuffer after every endline character or you may do it manually by invoking the flush()\nmethod.\nint x = 10;\n1\ndouble pi = 3.14;\n2\nPrintWriter pw = null;\n3\ntry {\n4\npw = new PrintWriter(new File(\"data.txt\"));\n5\n} catch(FileNotFoundException fnfe) {\n6\nthrow new RuntimeException(fnfe);\n7\n}\n8\n9\npw.println(\"Hello World!\");\n10\npw.println(x);\n11\npw.printf(\"x = %d, pi = %f\\n\", x, pi);\n12\n13\npw.close();\n14\nThe close() method will conveniently close all the underlying resources and flush the\nbuffer for us, writing any buffered data to the file. In addition, PrintWriter implements\nAutoCloseable and so it can be used in a try-catch-with resources statement.\nAnother \u201cconvenience\u201d of PrintWriter is that is \u201cswallows\u201d exceptions (just as the\nScanner class did). That means we don\u2019t have to deal explicitly with the checked\nIOExceptions that the underlying class(es) throw as the PrintWriter silently catches\nthem (though doesn\u2019t handle them). However, this can also be viewed as a disadvantage\nin that if we want to do error handling, we need to manually check if there was an\nerror (using checkError()). The PrintWriter class is intended mostly for formatted\noutput. It does not provide a way to write binary data to an output file. Just as with\nbinary input, it is best to use a class that abstracts the file type and data so that we\ndon\u2019t have to deal with the low-level details of the binary data.\n459 33. File I\/O\nHowever, if necessary, binary output can be done using a FileOutputStream. Typically,\nyou can load all your data into a byte array and dump it all at once.\nbyte data[] = ...;\n1\ntry (FileOutputStream fos =\n2\nnew FileOutputStream(new File(\"outfile.bin\")) ){\n3\nfos.write(data);\n4\n} catch(IOException ioe) {\n5\nthrow new RuntimeException(ioe);\n6\n}\n7\nThis example uses a try-with-resources statement so the FileOutputStream will auto-\nmatically be closed for us. You could wrap a FileOutputStream in a BufferedWriter,\nbut it will likely not gain you anything in terms of performance. A buffered output\nstream is better if your writes are frequent and \u201csmall.\u201d Here small means smaller than\nthe size of the buffer (BufferedWriter is typically 8KB). Writing several individual\ninteger values for example would be better done by buffering them and writing them\nall at once. In our example, we simply wanted to dump a bunch of data, likely more\nthan 8KB in practice, all at once. Moreover, using a BufferedWriter would lose us\nthe ability to write raw byte data.\n460 34. Objects\nJava is a class-based object-oriented programming language, meaning that it facilitates\nthe creation of objects through the use of classes. Classes are essentially \u201cblueprints\u201d\nfor creating instances of objects. We\u2019ve been implicitly using classes all along since\neverything in Java is a class or belongs to a class. Now, however, we will start using\nclasses in more depth rather than simply using static methods.\nAn object is an entity that is characterized by identity, state and behavior. The identity\nof an object is an aspect that distinguishes it from other objects. The variables and\nvalues that a variable takes on within an object is its state. Typically the variables that\nbelong to an object are referred to as member variables. Finally, an object may also\nhave functions that operate on the data of an object. In the context of object-oriented\nprogramming, a function that belongs to an object is referred to as a member method.\nAs a class-based object-oriented language, Java implements objects using classes. A\nclass is essentially a blueprint for creating instances of the class. A class simply specifies\nthe member variables and member methods that belong to instances of the class. We\ncan create actual instances through the use of special constructor methods. To begin,\nlet\u2019s define a class that models a student by defining member variables to support a first\nname, last name, a unique identifier, and GPA.\nTo declare a class, we use the class keyword. Inside the class (denoted by curly\nbrackets), we place any code that belongs to the class. To declare member variables\nwithin a class, we use the normal variable declaration syntax, but we do so outside any\nmethods.\npackage unl.cse;\n1\n2\npublic class Student {\n3\n4\n\/\/member variables:\n5\nString firstName;\n6\nString lastName;\n7\nint id;\n8\ndouble gpa;\n9\n10\n}\n11\n461 34. Objects\nRecall that a package declaration allows you to organize classes and code within a package\n(directory) hierarchy. Moreover, source code for a class must be in a source file with the\nsame name (and is case sensitive) with the .java extension. Our Student class would\nneed to be in a file named Student.java and would be compiled to a class named\nStudent.class.\n34.1. Data Visibility\nRecall that encapsulation involves not only the grouping of data, but the protection\nof data. To provide for the protection of data, Java defines several visibility keywords\nthat specify what segments of code can \u201csee\u201d the variables. Visibility in this context\ndetermines whether or not a segment of code can access and\/or modify the variable\u2019s\nvalue. Java defines four levels of visibility using they keywords public, protected\nand private (a fourth level is defined by the absence of any of these keywords). Each\nof these keywords can be applied to both member variables and member methods.\n\u2022 public \u2013 This is the least restrictive visibility level and makes the member variable\nvisible to every class.\n\u2022 protected \u2013 This is a bit more restrictive and makes it so that the member\nvariable is only visible to the code in the same class, same package, or any subclass\nof the class.1\n\u2022 No modifier \u2013 the absence of any modifier means that the member variable is visible\nto any class in the same package. This is also referred to as the default or package\nprotected visibility level.\n\u2022 private \u2013 this is the most restrictive visibility level, private member variables\nare only visible to instances of the class itself. As we\u2019ll see later this also means\nthat the member variables are visible between instances. That is, one instance can\nsee another instance\u2019s variables.\nTable 34.1 summarizes these four keywords with respect to their access levels. It is\nimportant to understand that protection in the context of encapsulation and does not\ninvolve protection in the sense of \u201csecurity.\u201d The protection is this context is a design\nprinciple. Limiting the access of variables only affects how the rest of the code base\ninteracts with our class and its data. Encapsulation can easily be \u201cbroken\u201d by other\n1Subclasses are involved with inheritance, another object-oriented programming concept that we will\nnot discuss here).\n462 34.2. Methods\ncode (through reflection2 or other means) and the values of variables can be accessed or\nmodified.\nModifier Class Package Subclass World\npublic Y Y Y Y\nprotected Y Y Y N\nnone (default) Y Y N N\nprivate Y N N N\nTable 34.1.: Java Visibility Keywords & Access Levels\nWe now update our class declaration to incorporate these visibility keywords. In general,\nit is best practice to make member variables private and control access to them via\naccessor and mutator methods (see below) unless there is a compelling design reason to\nincrease their visibility.\npackage unl.cse;\n1\n2\npublic class Student {\n3\n4\n\/\/member variables:\n5\nprivate String firstName;\n6\nprivate String lastName;\n7\nprivate int id;\n8\nprivate double gpa;\n9\n10\n}\n11\n34.2. Methods\nThe third aspect of encapsulation involves the grouping of methods that act on an object\u2019s\ndata (its state). Within a class, we can declare member methods using the syntax we\u2019re\nalready familiar with. We declare a member method by providing a signature and body.\nWe can use the same visibility keywords as with member variables in order to allow or\nrestrict access to the methods. With methods, visibility and access determine whether or\nnot the method may be invoked.\n2Reflection is a mechanism by which you can write code that modifies other code at runtime. It is\nmore of an aspect-oriented programming paradigm.\n463 34. Objects\nIn contrast to the methods we defined in Chapter 29, when defining a member method,\nwe do not use the static keyword. Making a variable or a method static means that\nthe method belongs to the class and not to instances of the class. We add to our example\nby providing two public methods that compute and return a result on the member\nvariables. We also use Javadoc style comments to document each member method.\npackage unl.cse;\n1\n2\npublic class Student {\n3\n4\n\/\/member variables:\n5\nprivate String firstName;\n6\nprivate String lastName;\n7\nprivate int id;\n8\nprivate double gpa;\n9\n10\n\/**\n11\n* Returns a formatted String of the Student's\n12\n* name as Last, First.\n13\n*\/\n14\npublic String getFormattedName() {\n15\nreturn lastName + \", \" + firstName;\n16\n}\n17\n18\n\/**\n19\n* Scales the GPA, which is assumed to be on a\n20\n* 4.0 scale to a percentage.\n21\n*\/\n22\npublic double getGpaAsPercentage() {\n23\nreturn gpa \/ 4.0;\n24\n}\n25\n26\n}\n27\n34.2.1. Accessor & Mutator Methods\nSince we have made all the member variables private, no code outside the class may\naccess or modify their values. It is generally good practice to make member variables\nprivate to restrict access. However, if we still want code outside the object to access\n464 34.2. Methods\nor mutate (that is, change) an instance\u2019s variables, we can define accessor and mutator\nmethods (or just simply getter and setter methods) to facilitate this.\nEach getter method returns the value of the instance\u2019s variable while each setter method\ntakes a value and sets the instance\u2019s variable to the new value. It is common to name\neach getter\/setter by prefixing a get and set to the variable\u2019s name using lower camel\ncasing. For example:\npublic String getFirstName() {\n1\nreturn firstName;\n2\n}\n3\n4\npublic void setFirstName(String firstName) {\n5\nfirstName = firstName;\n6\n}\n7\nIn the setter example, there is a problem: the code has no effect. There are two variables\nnamed firstName: the instance\u2019s member variable and the variable in the method\nparameter. The scoping rules of Java mean that the parameter variable name(s) take\nprecedent. This code has no effect because it is setting the parameter variable to itself.\nIt is essentially doing the following.\nint a = 10;\n1\na = a;\n2\nTo solve this, we use something called open recursion. When an instance of a class is\ncreated, for example,\nStudent s = ...;\nthe reference variable s is how we can refer to it. This variable, however, exists outside\nthe class. Inside the class, we need a way to refer to the instance itself. In Java we use\nthe keyword this to refer to the instance inside the class. For example, the member\nvariables of an instance can be accessed using the this keyword along with the dot\noperator (more below). In our example, this.firstName would refer to the instance\u2019s\nfirstName and not to the parameter variable. Even when it is not necessary to use the\nthis keyword (as in the getter example above) it is still best practice to do so. Our\nupdated getters and setter methods would thus look like the following.\n465 34. Objects\npublic String getFirstName() {\n1\nreturn this.firstName;\n2\n}\n3\n4\npublic void setFirstName(String firstName) {\n5\nthis.firstName = firstName;\n6\n}\n7\nOne advantage to using getters and setters (as opposed to naively making everything\npublic) is that you can have greater control over the values that your variables can\ntake. For example, we may want to do some data validation by rejecting null values or\ninvalid values. For example:\npublic void setFirstName(String firstName) {\n1\nif(firstName == null) {\n2\nthrow new IllegalArgumentException(\"names cannot be null\");\n3\n} else {\n4\nthis.firstName = firstName;\n5\n}\n6\n}\n7\n8\npublic void setGpa(double gpa) {\n9\nif(gpa < 0.0 || gpa > 4.0) {\n10\nthrow new IllegalArgumentException(\"GPAs must be in [0, 4.0]\");\n11\n} else {\n12\nthis.gpa = gpa;\n13\n}\n14\n}\n15\nControlling access of member variables through getters and setters is good encapsulation.\nDoing so makes your code more predictable and more testable. Making your member\nvariables public means that any piece of code can change their values. There is no way\nto do validation or prevent bad values.\nIn fact, it is good practice to not even have setter methods. If the value of member\nvariables cannot be changed, it makes the object immutable. We\u2019ve seen this before with\nthe built-in wrapper classes (Integer, String, etc.). Immutability is a nice property\nbecause it makes instances of the class thread-safe. That is, we can use instances of\n466 34.3. Constructors\nthe class in a multithreaded program without having to worry about threads changing\nthe state of instances on one another. Immutable classes are also safer to use in certain\ncollections such as a Set. Elements in a Set are unique; attempting to add a duplicate\nelement will have no effect on the Set. However, if the elements we add are mutable,\nwe could end up with duplicates (see Section 34.5).\n34.3. Constructors\nIf we make the (good) design decision to make our class immutable, we still need a\nway to initialize the object\u2019s member variables. This is where constructors come in. A\nconstructor is a special method that specifies how an object is constructed. With built-in\nprimitive variables such as an int, the Java language (compiler and JVM) \u201cknow\u201d how\nto interpret and assign a value to such a variable. However, with user-defined objects\nsuch as our Student class, we need to specify how the object is created.\nA constructor method has special syntax. Though it may still one of the visibility\nkeywords, it has no return type and its name is the same as the class. A constructor may\ntake any number of parameters. For example, the following constructor allows someone\nto construct a Student instance and specify all four member variables.\npublic Student(String firstName, String lastName,\n1\nint id, double gpa) {\n2\nthis.firstName = firstName;\n3\nthis.lastName = lastName;\n4\nthis.id = id;\n5\nthis.gpa = gpa;\n6\n}\n7\nJava allows us to define multiple constructors, or even no constructor at all. If we\ndo not specify a constructor, Java provides a default, no argument constructor. This\nconstructor uses default values for all member variables (zero for numerical types, false\nfor boolean types, and null for objects). If we do specify a constructor, this default\nconstructor becomes unavailable. However, we can always \u201crestore\u201d it by explicitly\ndefining it.\npublic Student() {\n1\nthis.firstName = null;\n2\nthis.lastName = null;\n3\nthis.id = 0;\n4\n467 34. Objects\nthis.gpa = 0.0;\n5\n}\n6\nAlternatively, we can define constructors that accept a subset of variable values.\npublic Student(String firstName, String lastName) {\n1\nthis.firstName = firstName;\n2\nthis.lastName = lastName;\n3\nthis.id = 0;\n4\nthis.gpa = 0.0;\n5\n}\n6\nIn both of these examples, we repeated a lot of code. One shortcut is to make all your\nconstructors call the most general constructor. To invoke another constructor, we use\nthe this keyword as a method call. For example:\npublic Student() {\n1\nthis(null, null, 0, 0.0);\n2\n}\n3\n4\npublic Student(String firstName, String lastName) {\n5\nthis(firstName, lastName, 0, 0.0);\n6\n}\n7\nAnother, very useful type of constructor is the copy constructor that allows you to make\na copy of an instance by passing it to a constructor. The following example copies each\nof the member variables of s into this.\npublic Student(Student s) {\n1\nthis(s.firstName, s.lastName, s.id, s.gpa);\n2\n}\n3\n468 34.4. Usage\n34.4. Usage\nOnce we have defined our class and its constructors, we can create and use instances of\nit. Just as with regular variables, we need to declare instances of a class by providing\nthe type and a variable name. For example:\nStudent s = null;\n1\nStudent t = null;\n2\nBoth of these declarations are simply just reference variables. They may refer to an\ninstance of the class Student, but we have initialized them to null. To make these\nvariables refer to valid instances, we invoke a constructor by using the new keyword and\nproviding arguments to the constructor.\nStudent s = new Student(\"Alan\", \"Turing\", 1234, 3.4);\n1\nStudent t = new Student(\"Margaret\", \"Hamilton\", 4321, 3.9);\n2\nThe process of creating a new instance by invoking a constructor is referred to as\ninstantiation. Once instances have been instantiated, they can be used by invoking their\nmethods via the dot operator. The dot operator is used to select a member variable (if\npublic) or member method.\nSystem.out.println(s.getFormattedName());\n1\n2\nif(s.getGpa() < t.getGpa()) {\n3\nSystem.out.println(t.getFirstName() + \" has a better GPA\");\n4\n}\n5\n34.5. Common Methods\nEvery class in Java has several methods that they inherit from the java.lang.Object\nclass. Here, we will highlight three of these important methods.\n469 34. Objects\nThe toString() method returns a String representation of the object. However, the\ndefault behavior that all classes inherit from the Object class is that it returns a string\ncontaining the fully qualified class name (package and class name) along with a hexadeci-\nmal representation of the JVM memory address at which the instance is stored. An exam-\nple with our Student class may produce something like: unl.cse.Student@272d7a10.\nWe can override this functionality and change the behavior of the toString() method\nto return whatever we want. To do so, we simply define the function (with a signature\nthat matches the toString() method in the Object class) in our class.\npublic String toString() {\n1\nreturn String.format(\"%s, %s (ID = %d); %.2f\",\n2\nthis.lastName,\n3\nthis.firstName,\n4\nthis.id,\n5\nthis.gpa);\n6\n}\n7\nThis example would return a String containing something similar to\n\"Hamilton, Margaret (ID = 4321); 3.90\"\nThe toString() method is a very convenient way to print instances of your class.\nTwo other methods, the equals() and the hashCode() method are used extensively\nby other classes such as the Collections library. The equals() method:\npublic boolean equals(Object obj)\ntakes another object obj and returns true or false depending on whether or not\nthe instance is \u201cequal\u201d to obj. Recall that identity is one of the defining characteristics\nof objects. This method is how Java achieves identity; this method allows you to define\nwhat \u201cequality\u201d means. By default, the behavior inherited from the Object class simply\nchecks if the object, this and the passed object, obj are located at the same memory\naddress, essentially (this == obj).\nHowever, conceptually we may want different behavior. For example, two Student\nobjects may be the same if they have the same id value (it is, after all supposed to be\na unique identifier). Alternatively, we may consider two objects to be the same if every\nmember variable holds the same value. Even with only a four member variables, the\nlogic can get quite complicated, especially if we have to account for null values. For\n470 34.5. Common Methods\nthis reason, many IDEs provide functionality to automatically generate such methods.\nThe following example was generated by an IDE.\n1 public boolean equals(Object obj) {\n2 if (this == obj) {\n3 return true;\n4 }\n5 if (obj == null) {\n6 return false;\n7 }\n8 if (!(obj instanceof Student)) {\n9 return false;\n10 }\n11 Student other = (Student) obj;\n12 if (firstName == null) {\n13 if (other.firstName != null) {\n14 return false;\n15 }\n16 } else if (!firstName.equals(other.firstName)) {\n17 return false;\n18 }\n19 if (Double.doubleToLongBits(gpa) !=\n20 Double.doubleToLongBits(other.gpa)) {\n21 return false;\n22 }\n23 if (lastName == null) {\n24 if (other.lastName != null) {\n25 return false;\n26 }\n27 } else if (!lastName.equals(other.lastName)) {\n28 return false;\n29 }\n30 if (nuid != other.nuid) {\n31 return false;\n32 }\n33 return true;\n34 }\nRelated, the hashCode() method,\npublic int hashCode()\nreturns an integer representation of the object. As with the equals() method, the\ndefault behavior is to return a value associated with the memory address of the instance.\nIn general, however, the behavior should be overridden to be based on the entire state\nof the object. A hash is simply a function that maps data to a \u201csmall\u201d set of values.\nIn this context, we are mapping object instances to integers so that they can be used\nin hash table-based data structures such as HashSet or HashMap. The hashCode()\nmethod is used to map an instance to an integer so that it can be used as an index in\nthese data structures. Again, most IDEs will provide functionality to generate a good\nimplementation for the hashCode() method (as the example below is).\nHow ever you design the equals() and hashCode() method, there is a requirement:\n471 34. Objects\nif two instances are equal (that is, equals() returns true) then they must have the\nsame hashCode() value. This requirement is necessary to ensure that hash table-based\ndata structures operate properly. It is okay if unequal objects have equal or unequal\nhash values. This rule only applies when the objects are equal.\npublic int hashCode() {\n1\nfinal int prime = 31;\n2\nint result = 1;\n3\nresult = prime * result + ((firstName == null) ? 0 :\n4\nfirstName.hashCode());\n5\nlong temp;\n6\ntemp = Double.doubleToLongBits(gpa);\n7\nresult = prime * result + (int) (temp ^ (temp >>> 32));\n8\nresult = prime * result + ((lastName == null) ? 0 :\n9\nlastName.hashCode());\n10\nresult = prime * result + nuid;\n11\nreturn result;\n12\n}\n13\n34.6. Composition\nAnother important concept when designing classes is composition. Composition is a\nmechanism by which an object is made up of other objects. One object is said to \u201cown\u201d\nan instance of another object. We\u2019ve already seen this with our Student example: the\nStudent class owns two instances of the String class.\nTo illustrate the importance of composition, we could extend the design of our Student\nclass to include a date of birth. However, a date of birth is also made up of multiple\npieces of data (a year, a month, a date, and maybe even a time and\/or locale). We could\ndesign our own date\/time class to model this, but its generally best to use what the\nlanguage already provides. Java 8 introduced the java.time package in which there\nare many updated and improved classes for dealing with dates and times. The class\nLocalDate for example, could be used to model a date of birth:\nprivate LocalDate dateOfBirth;\n1\n472 34.6. Composition\nWe can take this concept further and design our classes to own collections of other\nclasses. For example, we could define a Course class and then update our Student\nclass to own a collection of Course objects representing a student\u2019s class schedule (this\ntype of collection ownership is sometimes referred to as aggregation rather than strict\ncomposition).\nprivate Set<Course> schedule;\n1\nBoth of these updates beg the question: who is responsible for instantiating the instances\nof dateOfBirth andthe schedule? Shouldweforcethe\u201coutside\u201duserofour Student\nclass to build the LocalDate instance and pass it to a constructor? Should we allow\nthe outside code to simply provide us a date of birth as a string? Both of these design\nchoices have advantages and disadvantages that have to be considered.\nWhat about the course schedule? We could require that a user provide the constructor\nwith a pre-computed Set of courses, but care must be taken. Consider the following\n(partial) example.\npublic Student(..., Set<Course> schedule) {\n1\n...\n2\nthis.schedule = schedule;\n3\n}\n4\nThis is an example of a shallow copy: the instance\u2019s schedule variable is referencing\nthe same collection as the parameter variable. If a change is made, say a course is added,\nvia one of these references, then the change is effectively made for both. If we are going\nto design it this way, it would be better to make a deep copy of the set of courses:\npublic Student(..., Set<Course> schedule) {\n1\n...\n2\nthis.schedule = new HashSet<Course>(schedule);\n3\n}\n4\nThis is the same pattern we described above: almost every data structure in the Java\nCollections library has a (deep) copy constructor.\n473 34. Objects\nAlternatively, we could make our design a bit more flexible by allowing the construction of\na Student instance without having to provide a course schedule. Instead, we could add\na method that allowed the outside code to add a course to the schedule. Something\nlike the following.\npublic void addCourse(Course c) {\n1\nthis.schedule.add(c);\n2\n}\n3\nThis adds some flexibility to our object, but removes the immutability property. Design\nis always a balance and compromise between competing considerations.\n34.7. Example\nWe present the full and completed Student class in Code Sample 34.1.\n474 34.7. Example\npackage unl.cse;\n1\n2\npublic class Student {\n3\n4\nprivate String firstName;\n5\nprivate String lastName;\n6\nprivate int id;\n7\nprivate double gpa;\n8\n9\npublic Student(String firstName, String lastName, int id, double gpa) {\n10\nthis.firstName = firstName;\n11\nthis.lastName = lastName;\n12\nthis.id = id;\n13\nthis.gpa = gpa;\n14\n}\n15\n16\npublic Student() {\n17\nthis(null, null, 0, 0.0);\n18\n}\n19\n20\npublic Student(String firstName, String lastName) {\n21\nthis(firstName, lastName, 0, 0.0);\n22\n}\n23\n24\npublic String getFirstName() {\n25\nreturn firstName;\n26\n}\n27\n28\npublic String getLastName() {\n29\nreturn lastName;\n30\n}\n31\n32\npublic int getId() {\n33\nreturn id;\n34\n}\n35\n36\npublic double getGpa() {\n37\nreturn gpa;\n38\n}\n39\n40\n\/**\n41\n* Returns a formatted String of the Student's\n42\n* name as Last, First.\n43\n*\/\n44\npublic String getFormattedName() {\n45\nreturn lastName + \", \" + firstName;\n46\n475 34. Objects\n}\n47\n48\n\/**\n49\n* Scales the GPA, which is assumed to be on a\n50\n* 4.0 scale to a percentage.\n51\n*\/\n52\npublic double getGpaAsPercentage() {\n53\nreturn gpa \/ 4.0;\n54\n}\n55\n56\n@Override\n57\npublic String toString() {\n58\nreturn String.format(\"%s, %s (ID = %d); %.2f\",\n59\nthis.lastName,\n60\nthis.firstName,\n61\nthis.id,\n62\nthis.gpa);\n63\n}\n64\n65\n@Override\n66\npublic int hashCode() {\n67\nfinal int prime = 31;\n68\nint result = 1;\n69\nresult = prime * result + ((firstName == null) ? 0 : firstName.hashCode());\n70\nlong temp;\n71\ntemp = Double.doubleToLongBits(gpa);\n72\nresult = prime * result + (int) (temp ^ (temp >>> 32));\n73\nresult = prime * result + id;\n74\nresult = prime * result + ((lastName == null) ? 0 : lastName.hashCode());\n75\nreturn result;\n76\n}\n77\n78\n79\n@Override\n80\npublic boolean equals(Object obj) {\n81\nif (this == obj) {\n82\nreturn true;\n83\n}\n84\nif (obj == null) {\n85\nreturn false;\n86\n}\n87\nif (!(obj instanceof Student)) {\n88\nreturn false;\n89\n}\n90\nStudent other = (Student) obj;\n91\nif (firstName == null) {\n92\n476 34.7. Example\nif (other.firstName != null) {\n93\nreturn false;\n94\n}\n95\n} else if (!firstName.equals(other.firstName)) {\n96\nreturn false;\n97\n}\n98\nif (Double.doubleToLongBits(gpa) != Double.doubleToLongBits(other.gpa)) {\n99\nreturn false;\n100\n}\n101\nif (id != other.id) {\n102\nreturn false;\n103\n}\n104\nif (lastName == null) {\n105\nif (other.lastName != null) {\n106\nreturn false;\n107\n}\n108\n} else if (!lastName.equals(other.lastName)) {\n109\nreturn false;\n110\n}\n111\nreturn true;\n112\n}\n113\n114\n115\n116\n}\n117\nCode Sample 34.1.: The completed Java Student class.\n477  35. Recursion\nJava supports recursion with no special syntax necessary. However, as an object-oriented\nlanguage, recursion is generally expensive and iterative or other non-recursive solutions\nare generally preferred. We present a few examples to demonstrate how to write recursive\nmethods in Java. The first example of a recursive method we gave was the toy count\ndown example. In Java it could be implemented as follows.\npublic static void countDown(int n) {\n1\nif(n == 0) {\n2\nSystem.out.println(\"Happy New Year!\");\n3\n} else {\n4\nSystem.out.println(n);\n5\ncountDown(n-1);\n6\n}\n7\n}\n8\nAs another example that actually does something useful, consider the following recursive\nsummation method that takes an array and an index variable. The recursion works as\nfollows: if the index variable has reached the size of the array, it stops and returns zero\n(the base case). Otherwise, it makes a recursive call to recSum(), incrementing the\nindex variable by 1. When the method returns, it adds its result to the i-th element in\nthe array. To invoke this method we would call it with an initial value of 0 for the index\nvariable: recSum(arr, 0).\npublic static int recSum(int arr[], int i) {\n1\nif(i == arr.length) {\n2\nreturn 0;\n3\n} else {\n4\nreturn recSum(arr, i+1) + arr[i];\n5\n}\n6\n}\n7\nThis example was not tail-recursive as the recursive call was not the final operation (the\nsum was the final operation). To make this method tail recursive, we can carry the\nsummation through to each method call ensuring that the summation is done prior to\n479 35. Recursion\nthe recursive method call.\npublic static int recSumTail(int arr[], int i, int sum) {\n1\nif(i == arr.length) {\n2\nreturn sum;\n3\n} else {\n4\nreturn recSumTail(arr, i+1, sum + arr[i]);\n5\n}\n6\n}\n7\nAs another example, consider the following Java implementation of the naive recursive\nFibonacci sequence. An additional condition has been included to check for \u201cinvalid\u201d\nnegative values of n for which an exception is thrown.\npublic static int fibonacci(int n) {\n1\nif(n < 0) {\n2\nthrow new IllegalArgumentException(\"Undefined for n < 0\");\n3\n} else if(n <= 1) {\n4\nreturn 1;\n5\n} else {\n6\nreturn fibonacci(n-1) + fibonacci(n-2);\n7\n}\n8\n}\n9\nJava is not a language that provides implicit memoization. Instead, we need to explicitly\nkeep track of values using a table. In the following example, we use a Map data structure\nto store previously computed values.\npublic static int fibMemoization(int n, Map<Integer, Integer> m) {\n1\nif(n < 0) {\n2\nthrow new IllegalArgumentException(\"Undefined for n < 0\");\n3\n} else if(n <= 1) {\n4\nreturn 1;\n5\n} else {\n6\nInteger result = m.get(n);\n7\nif(result == null) {\n8\nInteger a = fibMemoization(n-1, m);\n9\nInteger b = fibMemoization(n-2, m);\n10\nresult = a + b;\n11\nm.put(n, result);\n12\n}\n13\n480 return result;\n14\n}\n15\n}\n16\nJava provides an arbitrary precision data type, BigInteger that can be used to compute\narbitrarily large integer values. Since Fibonacci numbers grow exponentially, using an\nint we could only represent up to to F . Using BigInteger we can support much\n45\nlarger values. An example:\npublic static BigInteger fibMem(int n, Map<Integer, BigInteger> m) {\n1\nif(n < 0) {\n2\nthrow new IllegalArgumentException(\"Undefined for n < 0\");\n3\n} else if(n <= 1) {\n4\nreturn BigInteger.ONE;\n5\n} else {\n6\nBigInteger result = m.get(n);\n7\nif(result == null) {\n8\nBigInteger a = fibMem(n-1, m);\n9\nBigInteger b = fibMem(n-2, m);\n10\nresult = a.add(b);\n11\nm.put(n, result);\n12\n}\n13\nreturn result;\n14\n}\n15\n}\n16\n481  36. Searching & Sorting\nJava provides several methods to search and sort arrays as well as Lists of elements of\nany type. These methods are able to operate on collections of any type because there are\nseveral overloaded versions of these functions as well as versions that take a Comparator\nobject that specifies how the elements should be ordered.\n36.1. Comparators\nLet\u2019s consider a \u201cgeneric\u201d Quick Sort algorithm as was presented in Algorithm 12.6. The\nalgorithm itself specifies how to sort elements, but it doesn\u2019t specify how they are ordered.\nThe difference is subtle but important. Quick Sort needs to know when two elements, a,b\nare in order, out of order, or equivalent in order to decide which partition each element\ngoes in. However, it doesn\u2019t \u201cknow\u201d anything about the elements a and b themselves.\nThey could be numbers, they could be strings, they could be user-defined objects.\nA sorting algorithm still needs to be able to determine the proper ordering in order to\nsort. In Java this is achieved by using a Comparator object, which is responsible for\ncomparing two elements and determining their proper order. A Comparator<T> is an\ninterface in Java that specifies a single method:\npublic int compare(T a, T b)\n\u2022 A Comparator<T> is parameterized to operate on any type T. The parameteriza-\ntion of T is basically a variable for a type. When you create a Comparator, you\nspecify an actual type just as we did with with ArrayList<Integer>. However,\nthe implementation itself is generic and can operate on any type.\n\u2022 The method takes two instances, a and b whose type matches the parameterized\ntype T\n\u2022 The method returns an integer indicating the relative ordering of the two elements:\n\u2013 It returns something negative, < 0 if a comes before b (that is, a < b)\n\u2013 It returns zero if a and b are equal (a = b)\n\u2013 It returns something positive, > 0 if a comes after b (that is, a > b)\nThere is no guarantee on the value\u2019s magnitude, it does not necessarily return \u22121 or +1;\nit just returns something negative or positive. We\u2019ve previously seen this pattern when\ncomparing strings and other wrapper classes. Each of the standard types implements\n483 36. Searching & Sorting\nsomething similar, the Comparable interface, that specifies a compareTo() method\nwith the same basic contract. Strings for example, are ordered in lexicographic ordering.\nNumeric types such as Integer and Double also have compareTo() methods that\norder elements in ascending order. Java refers to these built-in orderings as \u201cnatural\u201d\norderings.\nFor user-defined classes, however, we need to specify how to order them. We could use the\nComparable<T> interface as the built-in wrapper classes have, but using a Comparator\nis more flexible. Making a class Comparable locks you into one \u201cnatural\u201d ordering. If\nyou wanted a different ordering, you would still have to use a Comparator. Even for the\nwrapper classes, if we wanted a descending order, we would need to use a Comparator.\nAs an example, let\u2019s write a Comparator that orders Integer types in ascending order,\nmatching the \u201cnatural\u201d ordering already defined.\nComparator<Integer> cmpInt = new Comparator<Integer>(){\n1\npublic int compare(Integer a, Integer b) {\n2\nif(a < b) {\n3\nreturn -1;\n4\n} else if(a == b) {\n5\nreturn 0;\n6\n} else {\n7\nreturn 1;\n8\n}\n9\n}\n10\n};\n11\nThisisnewsyntax. Whenwecreatea Comparator inJavawearecreatinganewinstance\nof a class. However, we didn\u2019t define a class. We didn\u2019t use public class... nor did\nwe place it into a .java source file. Instead, this is an anonymous class declaration.\nThe class we\u2019ve created has no name; the cmpInt is the variable\u2019s name, but the class\nitself has no name, its \u201canonymous.\u201d This syntax allows us to define and instantiate a\nclass inline without having to create a separate class source file. This is an advantage\nbecause we generally do not need multiple instances of a Comparator; they would all\nhave the same functionality anyway. An anonymous class allows us to create ad-hoc\nclasses with a one-time (or a single purpose) use.\nAnother issue with this method is that it may not be able to handle null values. When\na and b get unboxed for the comparisons, if they are null, a NullPointerException\nwill be thrown. We discuss how to deal with this below in Section 36.3.2.\nAnotherissuewiththis Comparator isthesecondcasewhereweusetheequalityoperator\n== to compare values. With the less-than operator, the two integers get unboxed and\ntheir values are compared. However, when we use the == operator on object instances,\nit is comparing memory addresses in the JVM, not the actual values. We could solve\n484 36.1. Comparators\nthis issue by rearranging our cases so that the equality is our final case, avoiding the\nuse of the equality operator. Even better, however, we can exploit the built-in natural\nordering of the integers by using the compareTo() method.\nComparator<Integer> cmpInt = new Comparator<Integer>(){\n1\npublic int compare(Integer a, Integer b) {\n2\nreturn a.compareTo(b);\n3\n}\n4\n};\n5\nWhat if we wanted to order integers in the opposite, descending order? We could simply\nwrite another Comparator that reversed the ordering:\nComparator<Integer> cmpIntDesc = new Comparator<Integer>(){\n1\npublic int compare(Integer a, Integer b) {\n2\nreturn b.compareTo(a);\n3\n}\n4\n};\n5\nWe might be tempted to instead reuse the original comparator and write line 3 above\nsimply as\nreturn cmpInt(b, a);\nHowever, Java will not allow you to reference another \u201coutside\u201d variable like this inside a\nComparator object. An anonymous class in Java is a sort-of closure; a function that has\na scope in which variables are bound. In this case, the anonymous class has a reference to\nthe cmpInt variable, but it is not necessarily \u201cbound\u201d as the variable could be reassigned\noutside the Comparator. If we want to do something like this, Java forces us to make\nthe cmpInt variable final so that it cannot be changed.\nTo illustrate some more examples, consider the Student object we defined in Code\nSample34.1. ThefollowingCodeSamplesdemonstratevariouswaysofordering Student\ninstances based on one or more of their member variable values.\n\/**\n1\n* This Comparator orders Student objects by\n2\n* last name\/first name\n3\n*\/\n4\nComparator<Student> byName = new Comparator<Student>() {\n5\n@Override\n6\npublic int compare(Student a, Student b) {\n7\nif(a.getLastName().equals(b.getLastName())) {\n8\n485 36. Searching & Sorting\nreturn a.getFirstName().compareTo(b.getFirstName());\n9\n} else {\n10\nreturn a.getLastName().compareTo(b.getLastName());\n11\n}\n12\n}\n13\n};\n14\n\/**\n1\n* This Comparator orders Student objects by\n2\n* last name\/first name in descending (Z-to-A) order\n3\n*\/\n4\nComparator<Student> byNameDesc = new Comparator<Student>() {\n5\n@Override\n6\npublic int compare(Student a, Student b) {\n7\nif(b.getLastName().equals(a.getLastName())) {\n8\nreturn b.getFirstName().compareTo(a.getFirstName());\n9\n} else {\n10\nreturn b.getLastName().compareTo(a.getLastName());\n11\n}\n12\n}\n13\n};\n14\n\/**\n1\n* This Comparator orders Student objects by\n2\n* id in ascending order\n3\n*\/\n4\nComparator<Student> byId = new Comparator<Student>() {\n5\n@Override\n6\npublic int compare(Student a, Student b) {\n7\nreturn a.getId().compareTo(b.getId());\n8\n}\n9\n};\n10\n\/**\n1\n* This Comparator orders Student objects by\n2\n* GPA in descending order\n3\n486 36.2. Searching & Sorting\n*\/\n4\nComparator<Student> byGpa = new Comparator<Student>() {\n5\n@Override\n6\npublic int compare(Student a, Student b) {\n7\nreturn b.getGpa().compareTo(a.getGpa());\n8\n}\n9\n};\n10\n36.2. Searching & Sorting\nWe now turn our attention to the search and sorting methods provided by the JDK.\nMost of these methods are generic implementations that either sort an array or collection\nusing the natural ordering or take a take a parameterized Comparator<T> to determine\nthe ordering.\n36.2.1. Searching\nLinear Search\nJava Set and List collections provide several linear search methods. Both have a\npublic boolean contains(Object o) method that returns true or false depend-\ning on whether or not an object matching o is in the collection. The List collection has\nan additional public int indexOf(Object o) method that returns the index of the\nfirst matched element and \u22121 if no such element is found (Sets are unordered and have\nno indices, so this method would not apply). All of these functions are equality-based\nand they do not take a Comparator object. Instead, the elements are compared using\nthe object\u2019s equals() (and possibly hashCode()) method. The first element x such\nthat x.equals(o) returns true is the element that is determined to match. For this\nreason, it is important to override both of these methods when designing objects (see\nSection 36.3.3).\nBinary Search\nThe Arrays and Collections classes provide many variations on methods that imple-\nment binary search. All of these methods assume that the array or List being searched\nare sorted appropriately (you cannot use binary search on a Set as it is an unordered\ncollection).\nThe Arrays class provides several binarySearch() methods, one for each primitive\ntype as well as variations that allow you to search within a specified range of elements.\nThe most generally useful version is as follows:\n487 36. Searching & Sorting\npublic static <T> int binarySearch(T[] a, T key, Comparator<T> c)\nThat is, it takes an array of elements as well as key and a Comparator all of the same\ntype T. It returns an integer representing the index at which it finds the first matching\nelement (there is no guarantee that the first element in the sorted list is returned). If\nno match is found, then the method returns something negative.1 Another version has\nthe same behavior but can be called without a Comparator, relying instead on the\nnatural ordering of elements. For this variation, the type of elements must implement\nthe Comparable interface.\nThe Collections class provides a similar method,\npublic static <T> int binarySearch(List<T> list, T key, Comparator<T> c)\nThe only difference is that the method takes a List instead of an array. Otherwise, the\nbehavior is the same. We present several examples in Code Sample 36.1.\n36.2.2. Sorting\nAs with searching, the Arrays and Collections classes provide parameterized sorting\nmethods to sort arrays and Lists. In Java 6 and prior, the implementation was a hybrid\nmerge\/insertion sort. Java 7 switched the implementation to Tim Sort. Here too, there\nare several variations that rely on the natural ordering or allow you to sort a subpart of\nthe collection.\nThe Arrays provides the following method, which sorts arrays of a particular type with\na Comparator for that type.\npublic static <T> void sort(T[] a, Comparator<T> c)\nLikewise, Collections provides the following method.\npublic static <T> void sort(List<T> list, Comparator<T> c)\nSeveral examples of the usage of these methods are presented in Code Sample 36.2.\n36.3. Other Considerations\n36.3.1. Sorted Collections\nThe Java Collections framework also provides several sorted data structures. Though\nan ordered collection such as a List can be sorted calling the Collections.sort()\nmethod, a sorted data structure maintains an ordering. As you add elements to the data\nstructure, they are inserted in the appropriate spot. Such data structures also prevent\nyou from arbitrarily inserting elements in any order.\nJava defines the SortedSet<T> interface for sorted collections with a TreeSet<T>\nimplementation.2 You can construct a TreeSet<T> by providing it a Comparator<T>\n1It actually returns a negative value corresponding to the insertion point at which the element would\nbe if it had existed.\n2As the name implies, the implementation is a balanced binary search tree, in particular a red-black\ntree.\n488 36.3. Other Considerations\nArrayList<Student> roster = ...\n1\n2\nStudent castroKey = null;\n3\nint castroIndex;\n4\n5\n\/\/create a \"key\" that will match according to the\n6\n\/\/ Student.equals() method\n7\ncastroKey = new Student(\"Starlin\", \"Castro\", 131313, 3.95);\n8\ncastroIndex = roster.indexOf(castroKey);\n9\nSystem.out.println(\"at index \" + castroIndex + \": \" +\n10\nroster.get(castroIndex));\n11\n12\n\/\/create a key with only the necessary fields to match\n13\n\/ the comparator\n14\ncastroKey = new Student(\"Starlin\", \"Castro\", 0, 0.0);\n15\n\/\/sort the list according to the comparator\n16\nCollections.sort(roster, byName);\n17\ncastroIndex = Collections.binarySearch(roster, castroKey, byName);\n18\nSystem.out.println(\"at index \" + castroIndex + \": \" +\n19\nroster.get(castroIndex));\n20\n21\n\/\/create a key with only the necessary fields to match\n22\n\/\/ the comparator\n23\ncastroKey = new Student(null, null, 131313, 0.0);\n24\n\/\/sort the list according to the comparator\n25\nCollections.sort(roster, byId);\n26\ncastroIndex = Collections.binarySearch(roster, castroKey, byId);\n27\nSystem.out.println(\"at index \" + castroIndex + \": \" +\n28\nroster.get(castroIndex));\n29\nCode Sample 36.1.: Java Search Examples\nto use to maintain the ordering (alternatively, you may omit the Comparator and the\nTreeSet will use the natural ordering of elements).\nComparator<Integer> cmpIntDesc = new Comparator<Integer>() { ... };\n1\nSortedSet<Integer> sortedInts = new TreeSet<Integer>(cmpIntDesc);\n2\nsortedInts.add(10);\n3\nsortedInts.add(30);\n4\nsortedInts.add(20);\n5\n489 36. Searching & Sorting\nList<Student> roster = ...\n1\nStudent rosterArr[] = ...\n2\nComparator byName = ...\n3\nComparator byGPA = ...\n4\n5\n\/\/sort by name:\n6\nCollections.sort(roster, byName);\n7\nArrays.sort(rosterArr, byName);\n8\n9\n\/\/sort by GPA:\n10\nCollections.sort(roster, byGPA);\n11\nArrays.sort(rosterArr, byGPA);\n12\nCode Sample 36.2.: Using Java Collection\u2019s Sort Method\n\/\/sortedInts has elements 30, 20, 10 in descending order\n6\n7\nSortedSet<Student> sortedStudents = new TreeSet<Student>(byName);\n8\n\/\/add students, they will be sorted by name\n9\nfor(Student s : sortedStudents) {\n10\nSystem.out.println(s);\n11\n}\n12\nWhen using a SortedSet it is important that the Comparator properly orders all\nelements. A SortedSet is still a Set: it does not allow duplicate elements. If the\nComparator you use returns zero for any element that you attempt to insert, it will\nnot be inserted. To demonstrate how this might fail, consider our byName Comparator\nfor Student objects. Suppose two students have the same first name and last name,\n\u201cJohn Doe\u201d and \u201cJohn Doe,\u201d but have different IDs (as they are different people). The\nComparator would return 0 for these two objects because they have the same first\/last\nname, even though they are distinct people. Only one of these objects could exist in the\nSortedSet. To solve this problem, it is important to define Comparators that \u201cbreak\nties\u201d appropriately. In this case, we would want to modify the Comparator to return a\ncomparison of IDs if the first and last name are the same.\n36.3.2. Handling null values\nWhen sorting collections or arrays of objects, we may need to consider the possibility\nof uninitialized null objects. Some collections allow null element(s) while others do\n490 36.3. Other Considerations\nnot. How we handle these is a design decision. We could ignore it, in which case such\nelements would likely result in a NullPointerException and expect the user to prevent\nor handle such instances. This may be the preferable choice in most instances, in fact.\nAlternatively, we could handle null objects in the design of our Comparator. Code\nSample 36.3 presents a Comparator for our Student class that orders null instances\nfirst.\nComparator<Student> byNameWithNulls = new Comparator<Student>() {\n1\n@Override\n2\npublic int compare(Student a, Student b) {\n3\nif(a == null && b == null) {\n4\nreturn 0;\n5\n} else if(a == null && b != null) {\n6\nreturn -1;\n7\n} else if(a != null && b == null) {\n8\nreturn 1;\n9\n} else {\n10\nif(a.getLastName().equals(b.getLastName())) {\n11\nreturn a.getFirstName().compareTo(b.getFirstName());\n12\n} else {\n13\nreturn a.getLastName().compareTo(b.getLastName());\n14\n}\n15\n}\n16\n}\n17\n};\n18\nCode Sample 36.3.: Handling Null Values in Java Comparators\nThis solution only handles null Student values not null values within the Student\nobject. If the getters used in the Comparator return null values, then we could still\nhave NullPointerExceptions.\n36.3.3. Importance of equals() and hashCode() Methods\nRecall that in Chapter 34 we briefly discussed the importance of overloading the\nequals() and hashCode() methods of our objects. We reiterate this in the con-\ntext of searching. Recall that the Set and List collections provide linear search\nmethods that do not require the use of a Comparator. This is because the collections\nuse the object\u2019s equals() to determine when a particular instance has been found. In\nthe case of hash-based data structures such as HashSet, the hashCode() method is\n491 36. Searching & Sorting\nalso important. To illustrate the importance of these methods, consider the following\ncode.\nStudent a = new Student(\"Joe\", \"Smith\", 1234, 3.5);\n1\nStudent b = new Student(\"Joe\", \"Smith\", 1234, 3.5);\n2\n3\nSet<Student> s = new HashSet<Student>();\n4\ns.add(a);\n5\ns.add(b);\n6\nIf we do not override the equals() and hashCode() methods, at the end of this\ncode snippet, the set will contain both of the Student instances even though they are\nconceptually the same object (all of their member variables will have the same values).\nHowever, if we do override the equals() and hashCode() methods as described in\nSection 34.5, then the code snippet above would result in the Set only having one object\n(the first one added). This is because during the attempt to add the second instance, the\nequals() method would have returned true when compared to the first instance and\nthe duplicate element would not have been added to the Set (as Sets do not allow\nduplicates).\nAlso recall that we saw some of the advantages of immutable objects. Again, we point\nout another advantage. Suppose that we properly override the equals() and the\nhashCode() methods in our Student object. Further, suppose that we make our\nStudent class mutable: allowing a user to change the ID via a setter. Consider the\nfollowing code snippet.\nStudent a = new Student(\"Joe\", \"Smith\", 1234, 3.5);\n1\nStudent b = new Student(\"Joe\", \"Smith\", 5679, 3.5);\n2\n3\nSet<Student> s = new HashSet<Student>();\n4\ns.add(a);\n5\ns.add(b);\n6\n\/\/s now contains both students\n7\nb.setId(1234);\n8\nWhen we instantiate the two Student instances, they are distinct as their IDs are\ndifferent. So when we add them to the set, their equals() method returns false and\nthey are both added to the Set. However, when we change the ID using the setter\non the last line, both objects are now identical, violating the no-duplicates property of\nthe Set. This is not a failing of the Set class, just one of the many consequences of\ndesigning mutable objects.\n492 36.3. Other Considerations\n36.3.4. Java 8: Lambda Expressions\nJava 8 introduced a lot of functional-style syntax, including lambda expressions. Lambda\nexpressions are essentially anonymous functions that can be passed around to other\nmethods or objects. One use for lambda expressions is if we want to sort a List with\nrespect to one data field, we need not build a full Comparator. Instead we can use the\nfollowing syntax.\nList<Student> roster = ...\n1\n2\nroster.sort((a, b) -> a.getLastName().compareTo(b.getLastName()));\n3\nThe new syntax is the use of the arrow operator as a lambda expres-\nsion. In this case, it maps a pair, (a, b) to the value of the expression\na.getLastName().compareTo(b.getLastName()) (which takes advantage of the fact\nthat strings implement the Comparable interface). With respect to Comparators, we\ncan use the following syntax to build a more complex ordering.\nComparator<Student> c =\n1\n(a, b) -> a.getLastName().compareTo(b.getLastName());\n2\nc = c.thenComparing( (a, b) ->\n3\na.getFirstName().compareTo(b.getFirstName()));\n4\nc = c.thenComparing( (a, b) -> a.getGpa().compareTo(b.getGpa()));\n5\n6\n\/\/pass the comparator to the sort method:\n7\nroster.sort(c);\n8\nWe can make this even more terse using method references, another new feature in Java\n8.\n\/\/using getters as key extractors\n1\nmyList.sort(\n2\nComparator.comparing(Student::getLastName)\n3\n.thenComparing(Student::getFirstName)\n4\n.thenComparing(Student::getGpa));\n5\nThere are several other convenient methods provided by the updated Comparator\ninterface. For example, the reversed() member method returns a new Comparator\nthat defines the reversed order. The static methods, nullsFirst() and nullsLast()\n493 36. Searching & Sorting\ncan be used to modify a Comparator to order null values.\n494 Part III.\nThe PHP Programming Language\n495  37. Basics\nIn the mid-1990s the World Wide Web was in its infancy but becoming more and more\npopular. For the most part, web pages contained static content: articles and text that\nwas \u201cjust-there.\u201d Web pages were far from the fully interactive and dynamic applications\nthat they\u2019ve become. Rasmus Lerdorf had a home page containing his resume and he\nwanted to track how many visitors were coming to his page. With purely static pages,\nthis was not possible. So, in 1994 he developed PHP\/FI which stood for Personal Home\nPage tools and Forms Interpreter. This was a series of binary tools written in C that\noperated through a web server\u2019s Common Gateway Interface. When a user visited a\nwebpage, instead of just retrieving static content, a script was invoked: it could do a\nnumber of operations and send back HTML formatted as a response. This made web\npages much more dynamic. By serving it through a script, a counter could be maintained\nthat tracked how many people had visited the site. Lerdorf eventually released his source\ncode in 1995 and it became widely used.\nToday, PHP is used in a substantial number of pages on the web and is used in many\nContentManagementSystem(CMS)applicationssuchasDrupalandWordPress. Because\nofitshistory, muchofthesyntaxandaspectsofPHP(nowreferredtoas\u201cPHP:Hypertext\nPreprocessor\u201d) are influenced or inspired by C. In fact, many of the standard functions\navailable in the language are directly from the C language.\nPHP is a scripting language and is not compiled. Instead, PHP code is interpreted by\na PHP interpreter. Though there are several interpreters available, the de facto PHP\ninterpreter is the Zend Engine, a free and open source project that is widely available on\nmany platforms, operating systems, and web servers. Because it was originally intended\nto serve web pages, PHP code can be interleaved with static HTML tags. This allows\nPHP code to be embedded in web pages and dynamically interpreted\/rendered when\na user requests a webpage through a web browser. Though rendering web pages is its\nprimary purpose, PHP can be used as a general scripting language from the command\nline.\nPHP is a dirty, ugly language held together by duct tape, cracked asbestos-filled spackle\nand sadness (http:\/\/phpsadness.com\/). It is the cockroach of languages: it is invasive\nand it is a survivor. It is a hydra; rewrite one PHP app and two more pop up. It is\nmuch maligned and a source of ridicule. It is the source of hundreds of bad practices,\nthousands of bad programmers, millions of bugs and an infinite abyss of security holes\nand vulnerabilities. It is a language that was born in the wild and raised in the darkness\nby two schizophrenic monkeys. But its got character; and in this world, that\u2019s enough.\n497 37. Basics\n<?php\n1\n2\nprintf(\"Hello World\\n\");\n3\n4\n?>\n5\nCode Sample 37.1.: Hello World Program in PHP\n<html>\n1\n<head>\n2\n<title>Hello World PHP Page<\/title>\n3\n<\/head>\n4\n<body>\n5\n<h1>A Simple PHP Script<\/h1>\n6\n7\n<?php printf(\"<p>Hello World<\/p>\"); ?>\n8\n9\n<\/body>\n10\n<\/html>\n11\nCode Sample 37.2.: Hello World Program in PHP with HTML\n37.1. Getting Started: Hello World\nThe hallmark of an introduction to a new programming language is the Hello World!\nprogram. It consists of a simple program whose only purpose is to print the message\n\u201cHello World!\u201d to the user. The simplicity of the program allows the focus to be on the\nbasic syntax of the language. It is also typically used to ensure that your development\nenvironment, interpretrer, runtime environment, etc. are functioning properly with a\nminimal example. A basic Hello World! program in PHP can be found in Code Sample\n37.1. A version in which the PHP code is interleaved in HTML is presented in Code\nSample 37.2.\nWe will not focus on any particular development environment, code editor, or any\nparticular operating system, interpreter, or ancillary standards in our presentation.\nHowever, as a first step, you should be able to write and run the above program on\nthe environment you intend to use for the rest of this book. This may require that\nyou download and install a basic PHP interpreter\/development environment (such as\na standard LAMP, WAMP or MAMP technology stack) or a full IDE (such as Eclipse,\nPhpStorm, etc.).\n498 37.2. Basic Elements\n37.2. Basic Elements\nUsing the Hello World! program as a starting point, we will examine the basic elements\nof the PHP language.\n37.2.1. Basic Syntax Rules\nPHP has adopted many aspects of the C programming language (the interpreter itself is\nwritten in C). However, there are some major aspects in which it differs from C. The\nmajor aspects and syntactic elements of PHP include the following.\n\u2022 PHP is an interpreted language: it is not compiled. Instead it is interpreted through\nan interpreter that parses commands in a script file line-by-line. Any syntax errors,\ntherefore, become runtime errors.\n\u2022 PHP is dynamically typed: you do not declare variables or specify a variable\u2019s\ntype. Instead, when you assign a variable a value, the variable\u2019s type dynamically\nchanges to accommodate the assigned value. Variable names always begin with a\ndollar sign, $.\n\u2022 Strings and characters are essentially the same thing (characters are strings of\nlength 1). Strings and characters can be delimited by either single quotes or double\nquotes. \"this is a string\", 'this is also a string'; 'A' and \"a\" are\nboth single character strings.\n\u2022 Executable statements are terminated by a semicolon, ;\n\u2022 Code blocks are defined by using opening and closing curly brackets, { ... }.\nMoreover, code blocks can be nested: code blocks can be defined within other code\nblocks.\n\u2022 A complete list of reserved and keywords can be found in the PHP Manual: http:\/\/\nphp.net\/manual\/en\/reserved.php and http:\/\/php.net\/manual\/en\/reserved.\nkeywords.php\nPHP also supports aspects of OOP including classes and inheritance. There is also no\nmemory management in PHP: it has automated garbage collection.\nThough not a syntactic requirement, the proper use of whitespace is important for good,\nreadable code. Code inside code blocks is indented at the same indentation. Nested\ncode blocks are indented further. Think of a typical table of contents or the outline of a\nformal paper or essay. Sections and subsections or points and subpoints all follow proper\nindentation with elements at the same level at the same indentation. This convention is\nused to organize code and make it more readable.\n499 37. Basics\n37.2.2. PHP Tags\nPHP code can be interleaved with static HTML or text. Because of this, we need a way\nto indicate what should be interpreted as PHP and what should be treated as static text.\nWe can do this using PHP tags: the opening tag is <?php and the closing tag is ?>.\nAnything placed between these tags will be interpreted as PHP code which must adhere\nto the syntax rules of the language.\nA file can contain multiple opening\/closing PHP tags to allow you to interleave multiple\nsections of HTML or text. When an interpreter runs a PHP script, it will start processing\nthe script file. Whenever it sees the opening PHP tag, it begins to execute the commands\nand stops executing commands when it sees the closing tag. The text outside the PHP\ntags is treated as raw data. The interpreter includes it as part of its output without\nmodifying or processing it.\n37.2.3. Libraries\nPHP has many built-in functions that you can use. These standard libraries are loaded\nand available to use without any special command to import or include them. Full docu-\nmentation on each of these functions is maintained in the PHP manual, available online\nat http:\/\/php.net\/. The manual\u2019s web pages also contain many curated comments\nfrom PHP developers which contain further explanations, tips & tricks, suggestions, and\nsample code to provide further assistance.\nThere are many useful functions that we\u2019ll mention as we progress through each topic.\nOne especially useful collection of functions is the math library. This library is directly\nadapted from C\u2019s standard math library so all the function names are the same. It\nprovides many common mathematical functions such as the square root and natural\nlogarithm. Table 37.1 highlights several of these functions; full documentation can be\nfound in the PHP manual (http:\/\/php.net\/manual\/en\/ref.math.php). To use these,\nyou simply \u201ccall\u201d them by providing input and assigning the output to a variable.\n$x = 1.5;\n1 \u221a \u221a\n$y = sqrt($x); \/\/y now has the value x = 1.5\n2\n$z = sin($x); \/\/z now has the value sin(x) = sin(1.5)\n3\nIn both of the function calls above, the value of the variable $x is \u201cpassed\u201d to the math\nfunction which computes and \u201creturns\u201d the result which then gets assigned to another\nvariable.\n37.2.4. Comments\nComments can be written in PHP code either as a single line using two forward slashes,\n\/\/comment or as a multiline comment using a combination of forward slash and asterisk:\n\/* comment *\/ . With a single line comment, everything on the line after the forward\n500 37.2. Basic Elements\nFunction Description\nabs($x) Absolute value, |x|\nceil($x) Ceiling function, (cid:100)46.3(cid:101) = 47.0\nfloor($x) Floor function, (cid:98)46.3(cid:99) = 46.0\ncos($x) Cosine functiona\nsin($x) Sine functiona\ntan($x) Tangent functiona\nexp($x) Exponential function, ex, e = 2.71828...\nlog($x) Natural logarithm, ln(x)b\nlog10($x) Logarithm base 10, log (x)b\n10\npow($x,$y) The power function, computes xyc\nsqrt($x) Square root functionb\nTable 37.1.: Several functions defined in the PHP math library. aAll trigonometric\nfunctions assume input is in radians, not degrees. bInput is assumed to\nbe positive, x > 0. cAlternatively, PHP supports exponentiation by using\nx ** y.\n501 37. Basics\nslashes is ignored. With a multiline comment, everything in between the forward\nslash\/asterisk is ignored. Comments are ultimately ignored by the interpreter. Consider\nthe following example.\n\/\/this is a single line comment\n1\n$x = 10; \/\/this is also a single line comment, but after some code\n2\n3\n\/*\n4\nThis is a comment that can\n5\nspan multiple lines to format the comment\n6\nmessage more clearly\n7\n*\/\n8\n$y = 3.14;\n9\nMost code editors and IDEs will present comments in a special color or font to distinguish\nthem from the rest of the code (just as our example above does). Failure to close a\nmultiline comment will likely result in a fatal interpreter error but with color-coded\ncomments its easy to see the mistake visually.\n37.2.5. Entry Point & Command Line Arguments\nEvery PHP script begins executing at the top of the script file and proceed in a linear,\nsequential manner top-to-bottom. In addition, you can provide a PHP script with inputs\nwhen you run it from the command line. These command line arguments are stored in\ntwo variables, $argc and $argv. The first variable, $argc is an integer that indicates\nthe number of arguments provided including the name of the script file being executed.\nThe second, $argv is an array (see Section 42) of strings consisting of the command\nline arguments. To access them, you can index them starting at zero, the first being\n$argv[0], the second $argv[1], the last one would be $argv[$argc-1]. The first\none is always the name of the script file being run. The remaining are the command line\narguments provided by the user when the script is executed. We\u2019ll see several examples\nlater.\n37.3. Variables\nPHP is a dynamically typed language. As a consequence, you do not declare variables\nbefore you start using them. If you need to store a value into a variable, you simply\nname the variable and use an assignment operator to assign the value. Since you do not\ndeclare variables, you also do not specify a variable\u2019s type. If you assign a string value\nto a variable, its type becomes a string. If you assign an integer to a variable, its type\nbecomes an integer. If you reassign the value of a variable to a value with a different\ntype, the variable\u2019s type also changes.\n502 37.3. Variables\nInternally PHP supports several different types: Booleans, integers, floating point\nnumbers, strings, arrays, and objects. The way that integers are represented may be\nplatform dependent, but are usually 32-bit signed two\u2019s complement integers, able to\nrepresent integers between \u22122,147,483,648 and 2,147,483,647. Floating point numbers\nare also platform dependent, but are usually 64-bit double precision numbers defined\nby the IEEE 754 standard, providing about 16 digits of precision. Strings and single\ncharacters are the same thing in PHP. Strings are represented as sequences of characters\nfrom the extended ASCII text table (see Table 2.4) which includes all characters in the\nrange 0\u2013255. PHP does not have native Unicode support for international characters.\n37.3.1. Using Variables\nTo use a variable in PHP, you simply need to assign a value to a named variable identifier\nand the variable is in scope. Variable names always begin with a single dollar sign, $.\nThe assignment operator is a single equal sign, = and is a right-to-left assignment. The\nvariable that we wish to assign the value to appears on the left-hand-side while the value\n(literal, variable or expression) is on the right-hand-size. For example:\n$numUnits = 42;\n1\n$costPerUnit = 32.79;\n2\n$firstInitial = \"C\";\n3\nEach assignment also implicitly changes the variable\u2019s type. Each of the variables above\nbecomesaninteger,floatingpointnumber,andstringrespectively. Assignmentstatements\nare terminated by a semicolon like most executable statements in PHP. The identifier\nrules are fairly standard: a variable\u2019s name can consist of lowercase and uppercase\nalphabetic characters, numbers, and underscores. You can also use the extended ASCII\ncharacter set in variable names but it is not recommended (umlauts and other diacritics\ncan easily be confused). Variable names are case sensitive. As previously mentioned,\nvariable names must always begin with a dollar sign, $. Stylistically, we adopt the\nmodern lower camel casing naming convention for variables in our code.\nIf you do not assign a value to a variable, that variable remains undefined or \u201cunset.\u201d\nUndefined variables are treated as null in PHP. The concept of \u201cnull\u201d refers to\nuninitialized, undefined, empty, missing, or meaningless values. In PHP the keyword\nnull is used which is case insensitive (null, Null and NULL are all the same), but\nfor consistency, we\u2019ll use null. When null values are used in arithmetic expressions,\nnull is treated as zero. So, (10 + null) is equal to 10. When null is used in the\ncontext of strings, it is treated as an empty string and ignored. When used in a Boolean\nexpression or conditional, null is treated as false.\nPHP also allows you to define constants: values that cannot be changed once set. To\ndefine a constant, you invoke a function named define and providing a name and value.\n503 37. Basics\ndefine(\"PI\", 3.14159);\n1\ndefine(\"INSTITUTION\", \"University of Nebraska-Lincoln\");\n2\ndefine(\"COST_PER_UNIT\", 2.50);\n3\nConstant names are case sensitive. By convention, we use uppercase underscore casing.\nAn attempt to redefine a constant value will raise a script warning, but will ultimately\nhave no effect. When referring to constants later in the script, you use the constant\u2019s\nname. You do not treat it as a string, nor do you use a dollar sign. For example:\n$area = $r * $r * PI;\n37.4. Operators\nPHP supports the standard arithmetic operators for addition, subtraction, multiplication,\nand division using +, -, *, and \/ respectively. Each of these operators is a binary op-\nerator that acts on two operands which can either be literals, variables or expressions and\nfollow the usual rules of arithmetic when it comes to order of precedence (multiplication\nand division before addition and subtraction).\n$a = 10, $b = 20, $c = 30;\n1\n$d = $a + 5;\n2\n$d = $a + $b;\n3\n$d = $a - $b;\n4\n$d = $a + $b * $c;\n5\n$d = $a * $b; \/\/d becomes a floating point number with a value .5\n6\n7\n$x = 1.5, $y = 3.4, $z = 10.5;\n8\n$w = $x + 5.0;\n9\n$w = $x + $y;\n10\n$w = $x - $y;\n11\n$w = $x + $y * $z;\n12\n$w = $x * $y;\n13\n$w = $x \/ $y;\n14\n15\n\/\/mixing integers and floating point numbers is no problem\n16\n$w = $a + $x;\n17\nPHP also supports the integer remainder operator using the % symbol. This operator\ngives the remainder of the result of dividing two integers. Examples:\n504 37.4. Operators\n$x = 10 % 5; \/\/x is 0\n1\n$x = 10 % 3; \/\/x is 1\n2\n$x = 29 % 5; \/\/x is 4\n3\n37.4.1. Type Juggling\nThe expectations of an arithmetic expression involving two variables that are either\nintegers or floating point numbers are straightforward. We expect the sum\/product\/etc.\nas a result. However, since PHP is dynamically typed, a variable involved in an arithmetic\nexpression could be anything, including a Boolean, object, array, or string. When a\nBoolean is involved in an arithmetic expression, true is treated as 1 and false is\ntreated as zero. If an array is involved in an expression, it is usually a fatal error.1\nNon-null objects are treated as 1 and null is treated as 0.\nHowever, whenstringvaluesareinvolvedinanarithmeticexpression, PHPdoessomething\ncalled type juggling. When juggled, an attempt is made to convert a string variable into\na numeric value by parsing it. The parsing goes over each numeric character, converting\nthe value to a numeric type (either an integer or floating point number). The first type a\nnon-numeric character is encountered, the parsing stops and the value parsed so far is\nthe value used in the expression.\nConsider the examples in Code Sample 37.3. In the first segment, $a is type juggled to\nthe value 10, then added to 5, resulting in 15. In the second example, $a represents a\nfloating point number, and is converted to 3.14, the result of adding to 5 is thus 8.14. In\nthe third example, the string does not contain any numerical values. In this case, the\nparsing stops at the first character and what has been parsed so far is zero! Finally, in\nthe last example, the first two characters in $a are numeric, so the parsing ends at the\nthird character, and what has been parsed so far is 10.\nRelying on type juggling to convert values can be ugly and error prone. You can write\nmuch more intentional code by using the several conversion functions provided by PHP.\nFor example:\n$a = intval(\"10\");\n1\n$b = floatval(\"3.14\");\n2\n$c = intval(\"ten\"); \/\/c has the value zero\n3\nIn all three of the examples above, the strings are converted just as they are when type\njuggled. However, the variables are guaranteed to have the type indicated (integer or\nfloating point number).\n1PHP does allow you to \u201cadd\u201d two arrays together which results in their union.\n505 37. Basics\n$a = \"10\";\n1\n$b = 5 + $a; \/\/b = 15\n2\n3\n$a = \"3.14\";\n4\n$b = 5 + $a; \/\/b = 8.14\n5\n6\n$a = \"ten\";\n7\n$b = 5 + $a; \/\/b = 5\n8\n9\n\/\/partial conversions also occur:\n10\n$a = \"10ten\";\n11\n$b = 5 + $a; \/\/b = 15\n12\nCode Sample 37.3.: Type Juggling in PHP\nThere are several utility functions that can be used to help determine the type of variable.\nThe function is_numeric($x) returns true if $x is a numeric (integer or floating\npoint number) or represents a pure numeric string. The functions is_int($x) and\nis_float($x) each return true or false depending on whether or not $x is of that\ntype.\n$a = 10;\n1\n$b = \"10\";\n2\n$c = 3.14;\n3\n$d = \"3.14\";\n4\n$e = \"hello\";\n5\n$f = \"10foo\";\n6\n7\nis_numeric($a); \/\/true\n8\nis_numeric($b); \/\/true\n9\nis_numeric($c); \/\/true\n10\nis_numeric($d); \/\/true\n11\nis_numeric($e); \/\/false\n12\nis_numeric($f); \/\/false\n13\n14\nis_int($a); \/\/true\n15\nis_int($b); \/\/false\n16\nis_int($c); \/\/false\n17\nis_int($d); \/\/false\n18\nis_int($e); \/\/false\n19\n506 37.4. Operators\nValue of $var isset($var) empty($var) is_null($var)\n42 bool(true) bool(false) bool(false)\n\"\" (an empty string) bool(true) bool(true) bool(false)\n\" \" (space) bool(true) bool(false) bool(false)\nfalse bool(true) bool(true) bool(false)\ntrue bool(true) bool(false) bool(false)\narray() (an empty array) bool(true) bool(true) bool(false)\nnull bool(false) bool(true) bool(true)\n\"0\" (0 as a string) bool(true) bool(true) bool(false)\n0 (0 as an integer) bool(true) bool(true) bool(false)\n0.0 (0 as a float) bool(true) bool(true) bool(false)\nvar $var; (declared with no value) bool(false) bool(true) bool(true)\nNULL byte (\"\\0\") bool(true) bool(false) bool(false)\nTable 37.2.: Results for various variable values\nis_int($f); \/\/false\n20\n21\nis_float($a); \/\/false\n22\nis_float($b); \/\/false\n23\nis_float($c); \/\/true\n24\nis_float($d); \/\/false\n25\nis_float($e); \/\/false\n26\nis_float($f); \/\/false\n27\nAmoregeneralwaytodeterminethetypeofavariableistousethefunction gettype($x)\nwhich returns a string representation of the type of the variable $x. The string returned\nby this function is one of the following depending on the type of $x: \"boolean\",\n\"integer\", \"double\", \"string\", \"array\", \"object\", \"resource\", \"NULL\", or\n\"unknown type\".\nOther checker functions allow you to determine if a variable has been set, if its null,\n\u201cempty\u201d etc. For example, is_null($x) returns true if $x is not set or is set, but\nhas been set to null. The function isset($x) returns true only if $x is set and it\nis not null. The function empty($x) returns true if $x represents an empty entity:\nan empty string, false, an empty array, null, \"0\", 0, or an unset variable. Several\nexamples are presented in Table 37.2.\n507 37. Basics\n37.4.2. String Concatenation\nStrings in PHP can be concatenated (combined) in several different ways. One way\nyou can combine strings is by using the concatenation operator. In PHP the string\nconcatenation operator is a single period.\n$s = \"Hello\";\n1\n$t = \"World!\";\n2\n$msg = $s . \" \" . $t; \/\/msg contains \"Hello World!\"\n3\nAnother way you can combine strings is by placing variables directly inside a string. The\nvariables inside the string are replaced with the variable\u2019s values. Example:\n$x = 13;\n1\n$name = \"Starlin\";\n2\n$msg = \"Hello, $name, your number is $x\";\n3\n\/\/msg contains the string \"Hello, Starlin, your number is 13\"\n4\n37.5. Basic I\/O\nRecall the main purpose of PHP is as a scripting language to serve dynamic webpages.\nHowever, it does support input and output from the standard input\/output. There are\nseveral ways to print output to the standard output. The keywords print and echo\n(which are aliases of each other) allow you to print any variable or string. PHP also has\na printf() function to allow formatted output. Some examples:\n$a = 10;\n1\n$b = 3.14;\n2\n3\nprint $a;\n4\nprint \"The value of a is $a\\n\";\n5\n6\necho $a;\n7\necho \"The value of a is $a\\n\";\n8\n9\nprintf(\"The value of a is %d, and b is %f\\n\", $a, $b);\n10\nThere are also several ways to perform standard input, but the easiest is to use fgets\n508 37.6. Examples\n(short for file get string) using the keyword STDIN (Standard Input). This function\nwill return, as a string, everything the user enters up to and including the enter key\n(interpreted as the endline character, \\n). To remove the endline character, you can use\nanother function, trim which removes leading and trailing whitespace from a string. A\nfull example:\n\/\/prompt the user to enter input\n1\nprintf(\"Please enter a number: \");\n2\n$a = fgets(STDIN);\n3\n$a = trim($a);\n4\nAlternatively, lines 3\u20134 could be combined into one: $a = trim(fgets(STDIN)); The\ncall to fgets waits (referred to as \u201cblocking\u201d) for the user to enter input. The user is\nfree to start typing. When the user is done, they hit the enter key at which point the\nprogram resumes and reads the input from the standard input buffer, and returns it as a\nstring value which we assign to the variable $a.\nThe standard input is unstructured. The user is free to type whatever they want. If\nwe prompt the user for a number but they just start mashing the keyboard giving\nnon-numerical input, we may get incorrect results. We can use the conversion functions\nmentioned above to attempt to properly convert the values. However, this only guarantees\nthat the resulting variable is of the type we want (integer or floating point value for\nexample). The standard input is not a good mechanism for reading input, but it provides\na good starting point to develop a few simple programs.\n37.6. Examples\n37.6.1. Converting Units\nLet\u2019s write a program that prompts the user to enter a temperature in degrees Fahrenheit\nand convert it to degrees Celsius using the formula\n5\nC = (F \u221232)\u00b7\n9\nWe begin with the basic script shell with the opening and closing PHP tags and some\ncomments documenting the purpose of our script.\n<?php\n1\n2\n\/**\n3\n* This program converts Fahrenheit temperatures to\n4\n* Celsius\n5\n509 37. Basics\n*\/\n6\n7\n\/\/TODO: implement this\n8\n9\n?>\n10\nIt is common for programmers to use a comment along with a TODO note to themselves\nas a reminder of things that they still need to do with the program. Let\u2019s first outline\nthe basic steps that our program will go through:\n1. We\u2019ll first prompt the user for input, asking them for a temperature in Fahrenheit\n2. Next we\u2019ll read the user\u2019s input and use a conversion function to ensure the input\nis a floating point number\n3. Once we have the input, we can calculate the degrees Celsius by using the formula\nabove\n4. Lastly, we will want to print the result to the user to inform them of the value\nSometimes it is helpful to write an outline of such a program directly in the code using\ncomments to provide a step-by-step process. For example:\n<?php\n1\n2\n\/**\n3\n* This program converts Fahrenheit temperatures to\n4\n* Celsius\n5\n*\/\n6\n7\n\/\/TODO: implement this\n8\n9\n\/\/1. Prompt the user for input in Fahrenheit\n10\n\/\/2. Read the Fahrenheit value from the standard input\n11\n\/\/3. Compute the degrees Celsius\n12\n\/\/4. Print the result to the user\n13\n14\n?>\n15\nAs we read each step it becomes apparent that we\u2019ll need a couple of variables: one to\nhold the Fahrenheit (input) value and one for the Celsius (output) value. We\u2019ll want to\nensure that these are floating point numbers which we can do by making some explicit\nconversion. We use a printf() statement in the first step to prompt the user for input.\n510 37.6. Examples\nprintf(\"Please enter degrees in Fahrenheit: \");\nIn the second step, we\u2019ll use the standard input to read the $fahrenheit variable value\nfrom the user. Recall that we can use fgets to read from the standard input, but may\nhave to trim the trailing whitespace.\n$fahrenheit = trim(fgets(STDIN));\nIf we want to ensure that the variable $fahrenheit is a floating point value, we can\nuse floatval():\n$fahrenheit = floatval($fahrenheit);\nWe can now compute $celsius using the formula provided:\n$celsius = ($fahrenheit - 32) * (5 \/ 9);\nFinally, we use printf() again to output the result to the user:\nprintf(\"%f Fahrenheit is %f Celsius\\n\", $fahrenheit, $celsius);\nThe full program can be found in Code Sample 37.4.\n<?php\n1\n2\n\/**\n3\n* This program converts Fahrenheit temperatures to\n4\n* Celsius\n5\n*\/\n6\n7\n\/\/1. Prompt the user for input in Fahrenheit\n8\nprintf(\"Please enter degrees in Fahrenheit: \");\n9\n10\n\/\/2. Read the Fahrenheit value from the standard input\n11\n$fahrenheit = trim(fgets(STDIN));\n12\n$fahrenheit = floatval($fahrenheit);\n13\n14\n\/\/3. Compute the degrees Celsius\n15\n$celsius = ($fahrenheit - 32) * (5\/9);\n16\n17\n\/\/4. Print the result to the user\n18\nprintf(\"%f Fahrenheit is %f Celsius\\n\", $fahrenheit, $celsius);\n19\n20\n?>\n21\nCode Sample 37.4.: Fahrenheit-to-Celsius Conversion Program in PHP\n511 37. Basics\n37.6.2. Computing Quadratic Roots\nSome programs require the user to enter multiple inputs. The prompt-input process can\nbe repeated. In this example, consider asking the user for the coefficients, a,b,c to a\nquadratic polynomial,\nax2 +bx+c\nand computing its roots using the quadratic formula,\n\u221a\n\u2212b\u00b1 b2 \u22124ac\nx =\n2a\nAs before, we can create a basic program with PHP tags and start filling in the details.\nIn particular, we\u2019ll need to prompt for the input a, then read it in; then prompt for b,\nread it in and repeat for c. Thus, we have\nprintf(\"Please enter a: \");\n1\n$a = floatval(trim(fgets(STDIN)));\n2\nprintf(\"Please enter b: \");\n3\n$b = floatval(trim(fgets(STDIN)));\n4\nprintf(\"Please enter c: \");\n5\n$c = floatval(trim(fgets(STDIN)));\n6\nWe need to take care that we correctly adapt the formula so it accurately reflects the\norder of operations. We also need to use the math library\u2019s square root function.\n$root1 = (-$b + sqrt($b*$b - 4*$a*$c) ) \/ (2*$a);\n1\n$root2 = (-$b - sqrt($b*$b - 4*$a*$c) ) \/ (2*$a);\n2\nFinally, we print the output using printf(). The full program can be found in Code\nSample 37.5.\nThis program was interactive. As an alternative, we could have read all three of the\ninputs as command line arguments, taking care to convert them to floating point numbers.\nLines 8\u201313 in the program could have been changed to\n$a = floatval($argv[1]);\n1\n$b = floatval($argv[2]);\n2\n$c = floatval($argv[3]);\n3\nFinally, think about the possible input a user could provide that may cause problems for\nthis program. For example:\n512 37.6. Examples\n<?php\n1\n2\n\/**\n3\n* This program computes the roots to a quadratic equation\n4\n* using the quadratic formula.\n5\n*\/\n6\n7\nprintf(\"Please enter a: \");\n8\n$a = floatval(trim(fgets(STDIN)));\n9\nprintf(\"Please enter b: \");\n10\n$b = floatval(trim(fgets(STDIN)));\n11\nprintf(\"Please enter c: \");\n12\n$c = floatval(trim(fgets(STDIN)));\n13\n14\n$root1 = (-$b + sqrt($b*$b - 4*$a*$c) ) \/ (2*$a);\n15\n$root2 = (-$b - sqrt($b*$b - 4*$a*$c) ) \/ (2*$a);\n16\n17\nprintf(\"The roots of %fx^2 + %fx + %f are: \\n\", $a, $b, $c);\n18\nprintf(\" root1 = %f\\n\", $root1);\n19\nprintf(\" root2 = %f\\n\", $root2);\n20\n21\n?>\n22\nCode Sample 37.5.: Quadratic Roots Program in PHP\n\u2022 What if the user entered zero for a?\n\u2022 What if the user entered some combination such that b2 < 4ac?\n\u2022 What if the user entered non-numeric values?\n\u2022 For the command line argument version, what if the user provided less than three\narguments? Or more?\nHow might we prevent the consequences of such bad input? How might we handle the\nevent that a user enters bad input and how do we communicate these errors to the user?\nTo begin to resolve these issues, we\u2019ll need conditionals.\n513  38. Conditionals\nPHP supports the basic if, if-else, and if-else-if conditional structures as well as switch\nstatements. Logical statements are built using the standard logical operators for numeric\ncomparisons as well as logical operators such as negations, And, and Or.\n38.1. Logical Operators\nPHP has a built-in Boolean type and supports the keywords true and false. However,\nany variable can be treated as a Boolean if used in a logical expression. Depending on\nthe variable, it could evaluate to true or false! For example, an empty string, \"\", null,\nor a numeric value of zero, 0 are all considered false. A non-empty string, a non-zero\nnumeric value, or a non-empty array all evaluate to true. It is best to avoid these issues\nby writing clean code that uses clear, explicit statements.\nBecause PHP is dynamically typed, comparison operators work differently depending on\nhow they are used. First, let\u2019s consider the four basic inequality operators, <, <=, >,\nand >=. When used to compare numeric types to numeric types, these operators work\nas expected and the value of the numbers are compared.\n$a = 10;\n1\n$b = 20;\n2\n$c = 20;\n3\n4\n$r = ($a < $b); \/\/true\n5\n$r = ($a <= $b); \/\/false\n6\n$r = ($b <= $c); \/\/true\n7\n$r = ($a > $b); \/\/false\n8\n$r = ($a >= $b); \/\/false\n9\n$r = ($b >= $c); \/\/true\n10\nWhen these operators are used to compare strings to strings, the strings are compared\nlexicographically according to the standard ASCII text table. Some examples follow,\nbut it is better to use a function (in particular strcmp see Chapter 43) to do string\ncomparisons.\n515 38. Conditionals\n$s = \"aardvark\";\n1\n$t = \"zebra\";\n2\n3\n$r = ($s < $t); \/\/true\n4\n$r = ($s <= $t); \/\/true\n5\n$r = ($s >= $t); \/\/false\n6\n$r = ($s > $t); \/\/false\n7\nHowever, when these operators are used to compare strings to numeric types, the strings\nare converted to numbers using the same type juggling that happens when strings are\nmixed with arithmetic operators. In the following example, $b gets converted to a\nnumeric type when compared to $a which give the results indicated in the comments.\n$a = 10;\n1\n$b = \"10\";\n2\n3\n$r = ($a <= $b); \/\/true\n4\n$r = ($a < $b); \/\/false\n5\n$r = ($a >= $b); \/\/true\n6\n$r = ($a > $b); \/\/false\n7\nWith the equality operators, == and !=, something similar happens. When the types of\nthe two operands match, the expected comparison is made: when numbers are compared\nto numbers their values are compared; when strings are compared to strings, their content\nis compared (case sensitively). However, when the types are different they are type\njuggled and strings are converted to numbers for the purpose of comparison. Thus, a\ncomparison like (10 == \"10\") ends up being true! The operators are == and != are\nreferred to as loose comparison operators because of this.\nWhat if we want to ensure that we\u2019re comparing apples to apples? To rectify this, PHP\noffers another set of comparison operators, strict comparison operators, === and !==\n(each has an extra equals sign, =). These operators will make a comparison without\ntype juggling either operand first. Now a similar comparison, (10 === \"10\") ends up\nevaluating to false. The operator === will only evaluate to true if the both the operands\u2019\ntype and value are the same.\n$a = 10;\n1\n$b = \"10\";\n2\n3\n$r = ($a == $b); \/\/true\n4\n$r = ($a != $b); \/\/false\n5\n516 38.2. If, If-Else, If-Else-If Statements\nOperator(s) Associativity Notes\nHighest ++, -- left-to-right increment operators\n-, ! right-to-left unary negation operator, logical\nnot\n*, \/, % left-to-right\n+, - left-to-right addition, subtraction\n<, <=, >, >= left-to-right comparison\n==, !=, ===, !== left-to-right equality, inequality\n&& left-to-right logical And\n|| left-to-right logical Or\nLowest =, +=, -=, *=, \/= right-to-left assignment and compound assign-\nment operators\nTable 38.1.: Operator Order of Precedence in PHP. Operators on the same level have\nequivalent order and are performed in the associative order specified.\n$r = ($a === $b); \/\/false\n6\n$r = ($a !== $b); \/\/true\n7\nThe three basic logical operators, not !, and &&, and or || are also supported in PHP.\n38.1.1. Order of Precedence\nAt this point it is worth summarizing the order of precedence of all the operators that\nwe\u2019ve seen so far including assignment, arithmetic, comparison, and logical. Since all of\nthese operators could be used in one statement, for example,\n($b*$b < 4*$a*$c || $a === 0 || $argc != 4)\nit is important to understand the order in which each one gets evaluated. Table 38.1\nsummarizestheorderofprecedencefortheoperatorsseensofar. Thisisnotanexhaustive\nlist of PHP operators.\n38.2. If, If-Else, If-Else-If Statements\nConditional statements in PHP utilize the keywords if, else, and else if. Condi-\ntions are placed inside parentheses immediately after the if and else if keywords.\nExamples of all three can be found in Code Sample 38.1.\nObserve that the statement, if($x < 10) does not have a semicolon at the end. This\nis because it is a conditional statement that determines the flow of control and not an\nexecutable statement. Therefore, no semicolon is used. Suppose we made a mistake and\ndid include a semicolon:\n517 38. Conditionals\n\/\/example of an if statement:\n1\nif($x < 10) {\n2\nprintf(\"x is less than 10\\n\");\n3\n}\n4\n5\n\/\/example of an if-else statement:\n6\nif($x < 10) {\n7\nprintf(\"x is less than 10\\n\");\n8\n} else {\n9\nprintf(\"x is 10 or more \\n\");\n10\n}\n11\n12\n\/\/example of an if-else-if statement:\n13\nif($x < 10) {\n14\nprintf(\"x is less than 10\\n\");\n15\n} else if($x === 10) {\n16\nprintf(\"x is equal to ten\\n\");\n17\n} else {\n18\nprintf(\"x is greater than 10\\n\");\n19\n}\n20\nCode Sample 38.1.: Examples of Conditional Statements in PHP\n518 38.3. Examples\n$x = 15;\n1\nif($x < 10); {\n2\nprintf(\"x is less than 10\\n\");\n3\n}\n4\nThis PHP code will run without error or warning. However, it will end up printing\nx is less than 10, even though x = 15! Recall that a conditional statement binds\nto the executable statement or code block immediately following it. In this case, we\u2019ve\nprovided an empty executable statement ended by the semicolon. The code is essentially\nequivalent to\n$x = 15;\n1\nif($x < 10) {\n2\n}\n3\nprintf(\"x is less than 10\\n\");\n4\nThis is obviously not what we wanted. The semicolon was bound to the empty executable\nstatement and the code block containing the print statement immediately followed, but\nwas not bound to the conditional statement which is why the print statement executed\nregardless of the value of x.\nAnother convention that we\u2019ve used in our code is where we have placed the curly brackets.\nIf a conditional statement is bound to only one statement, the curly brackets are not\nnecessary. However, it is best practice to include them even if they are not necessary\nand we\u2019ll follow this convention. Second, the opening curly bracket is on the same line as\nthe conditional statement while the closing curly bracket is indented to the same level\nas the start of the conditional statement. Moreover, the code inside the code block is\nindented. If there were more statements in the block, they would have all been at the\nsame indentation level.\n38.3. Examples\n38.3.1. Computing a Logarithm\nThe logarithm of x is the exponent that some base must be raised to get x. The most\ncommon logarithm is the natural logarithm, ln(x) which is base e = 2.71828.... But\nlogarithms can be in any base b > 1.1 What if we wanted to compute log (x)? Or\n2\nlog (x)? Let\u2019s write a program that will prompt the user for a number x and a base\n\u03c0\nb and computes log (x). Arbitrary bases can be computed using the change of base\nb\n1Bases can also be 0<b<1, but we\u2019ll restrict our attention to increasing functions only.\n519 38. Conditionals\nformula:\nlog (x)\nlog (x) = a\nb log (b)\na\nIf we can compute some base a, then we can compute any base b. Fortunately we have\nsuch a solution. Recall that the standard library provides a function to compute the\nnatural logarithm, log()). This is one of the fundamentals of problems solving: if a\nsolution already exists, use it. In this case, a solution exists for a different, but similar\nproblem (computing the natural logarithm), but we can adapt the solution using the\nchange of base formula. In particular, if we have variables b (base) and x, we can\ncompute log (x) using\nb\nlog(x) \/ log(b)\nWe have a problem similar to the examples in the previous section. The user could enter\ninvalid values such as b = \u221210 or x = \u22122.54 (logarithms are undefined for non-positive\nvalues in any base). We want to ensure that b > 1 and x > 0. With conditionals, we\ncan now do this. Once we have read in the input from the user we can make a check for\ngood input using an if statement.\nif($x <= 0 || $b <= 1) {\n1\nprintf(\"Error: bad input!\\n\");\n2\nexit(1);\n3\n}\n4\nThis code has something new: exit(1). The exit() function immediately terminates\nthe script regardless of the rest of the code that may remain. The argument passed to\nexit is an integer that represents an error code. The convention is that zero indicates\n\u201cno error\u201d while non-zero values indicate some error. This is a simple way of performing\nerror handling: if the user provides bad input, we inform them and quit the program,\nforcing them to run it again and provide good input. By prematurely terminating the\nprogram we avoid any illegal operation that would give a bad result.\nAlternatively, we could have split the conditions into two statements and given a more\ndescriptive error message. We use this design in the full program which can be found\nin Code Sample 38.2. The program also takes the input as command line arguments.\nNow that we have conditionals, we can check that the correct number of arguments was\nprovided by the user and quit in the event that they don\u2019t provide the correct number.\n38.3.2. Life & Taxes\nLet\u2019s adapt the conditional statements we developed in Section 3.6.4 into a full PHP\nscript. The first thing we need to do is establish the variables we\u2019ll need and read them\nin from the user. At the same time we can check for bad input (negative values) for both\nthe inputs.\n520 38.3. Examples\n\/\/prompt for income from the user\n1\nprintf(\"Please enter your Adjusted Gross Income: \");\n2\n3\n$income = floatval(trim(fgets(STDIN)));\n4\n5\n\/\/prompt for children\n6\nprintf(\"How many children do you have? \");\n7\n$numChildren = intval(trim(fgets(STDIN)));\n8\n9\nif($income < 0 || $numChildren < 0) {\n10\nprintf(\"Invalid inputs\");\n11\nexit(1);\n12\n}\n13\nNext, we can code a series of if-else-if statements for the income range. By placing the\nranges in increasing order, we only need to check the upper bounds just as in the original\nexample.\nif($income <= 18150) {\n1\n$baseTax = $income * .10;\n2\n} else if($income <= 73800) {\n3\n$baseTax = 1815 + ($income -18150) * .15;\n4\n} else if($income <= 148850) {\n5\n...\n6\n} else {\n7\n$baseTax = 127962.50 + ($income - 457600) * .396;\n8\n}\n9\nNext we compute the child tax credit, taking care that it does not exceed $3,000. A\nconditional based on the number of children suffices as at this point in the program we\nalready know it is zero or greater.\nif($numChildren <= 3) {\n1\n$credit = $numChildren * 1000;\n2\n} else {\n3\n$credit = 3000;\n4\n}\n5\nFinally, we need to ensure that the credit does not exceed the total tax liability (the\ncredit is non-refundable, so if the credit is greater, the tax should only be zero, not\n521 38. Conditionals\nnegative).\nif($baseTax - $credit >= 0) {\n1\n$totalTax = $baseTax - $credit;\n2\n} else {\n3\n$totalTax = 0;\n4\n}\n5\nThe full program is presented in Code Sample 38.3.\n38.3.3. Quadratic Roots Revisited\nLet\u2019sreturntothequadraticrootsprogramwepreviouslydesignedthatusesthequadratic\nequation to compute the roots of a quadratic polynomial by reading coefficients a,b,c\nin from the user. One of the problems we had previously identified is if the user enters\n\u201cbad\u201d input: if a = 0, we would end up dividing by zero; if b2 \u22124ac < 0 then we would\nhave complex roots. With conditionals, we can now check for these issues and exit with\nan error message.\nAnother potential case we might want to handle differently is when there is only one\ndistinct root (b2 \u22124ac = 0). In that case, the quadratic formula simplifies to \u2212b and we\n2a\ncan print a different, more specific message to the user. The full program can be found\nin Code Sample 38.4.\n522 38.3. Examples\n<?php\n1\n2\n\/**\n3\n* This program computes the logarithm base b (b > 1)\n4\n* of a given number x > 0\n5\n*\/\n6\n7\nif($argc != 3) {\n8\nprintf(\"Usage: %s b x \\n\", $argv[0]);\n9\nexit(1);\n10\n}\n11\n12\n$b = floatval($argv[1]);\n13\n$x = floatval($argv[2]);\n14\n15\nif($x <= 0) {\n16\nprintf(\"Error: x must be greater than zero\\n\");\n17\nexit(1);\n18\n}\n19\nif($b <= 1) {\n20\nprintf(\"Error: base must be greater than one\\n\");\n21\nexit(1);\n22\n}\n23\n24\n$result = log($x) \/ log($b);\n25\nprintf(\"log_(%f)(%f) = %f\\n\", $b, $x, $result);\n26\n27\n?>\n28\nCode Sample 38.2.: Logarithm Calculator Program in C\n523 38. Conditionals\n1 <?php\n2 \/\/prompt for income from the user\n3 printf(\"Please enter your Adjusted Gross Income: \");\n4\n5 $income = floatval(trim(fgets(STDIN)));\n6\n7 \/\/prompt for children\n8 printf(\"How many children do you have? \");\n9 $numChildren = intval(trim(fgets(STDIN)));\n10\n11 if($income < 0 || $numChildren < 0) {\n12 printf(\"Invalid inputs\");\n13 exit(1);\n14 }\n15\n16 if($income <= 18150) {\n17 $baseTax = $income * .10;\n18 } else if($income <= 73800) {\n19 $baseTax = 1815 + ($income -18150) * .15;\n20 } else if($income <= 148850) {\n21 $baseTax = 10162.50 + ($income - 73800) * .25;\n22 } else if($income <= 225850) {\n23 $baseTax = 28925.00 + ($income - 148850) * .28;\n24 } else if($income <= 405100) {\n25 $baseTax = 50765.00 + ($income - 225850) * .33;\n26 } else if($income <= 457600) {\n27 $baseTax = 109587.50 + ($income - 405100) * .35;\n28 } else {\n29 $baseTax = 127962.50 + ($income - 457600) * .396;\n30 }\n31\n32 if($numChildren <= 3) {\n33 $credit = $numChildren * 1000;\n34 } else {\n35 $credit = 3000;\n36 }\n37\n38 if($baseTax - $credit >= 0) {\n39 $totalTax = $baseTax - $credit;\n40 } else {\n41 $totalTax = 0;\n42 }\n43\n44 printf(\"AGI: $%10.2f\\n\", $income);\n45 printf(\"Tax: $%10.2f\\n\", $baseTax);\n46 printf(\"Credit: $%10.2f\\n\", $credit);\n47 printf(\"Tax Liability: $%10.2f\\n\", $totalTax);\n48\n49 ?>\nCode Sample 38.3.: Tax Program in PHP\n524 38.3. Examples\n<?php\n1\n2\n\/**\n3\n* This program computes the roots to a quadratic equation\n4\n* using the quadratic formula.\n5\n*\/\n6\n7\nif($argc != 4) {\n8\nprintf(\"Usage: %s a b c\\n\", $argv[0]);\n9\nexit(1);\n10\n}\n11\n12\n$a = floatval($argv[1]);\n13\n$b = floatval($argv[2]);\n14\n$c = floatval($argv[3]);\n15\n16\nif($a === 0) {\n17\nprintf(\"Error: a cannot be zero\\n\");\n18\nexit(1);\n19\n} else if($b*$b < 4*$a*$c) {\n20\nprintf(\"Error: cannot handle complex roots\\n\");\n21\nexit(1);\n22\n} else if($b*$b === 4*$a*$c) {\n23\n$root1 = -$b \/ (2*$a);\n24\nprintf(\"Only one distinct root: %f\\n\", $root1);\n25\n} else {\n26\n$root1 = (-$b + sqrt($b*$b - 4*$a*$c) ) \/ (2*$a);\n27\n$root2 = (-$b - sqrt($b*$b - 4*$a*$c) ) \/ (2*$a);\n28\n29\nprintf(\"The roots of %fx^2 + %fx + %f are: \\n\", $a, $b, $c);\n30\nprintf(\" root1 = %f\\n\", $root1);\n31\nprintf(\" root2 = %f\\n\", $root2);\n32\n}\n33\n34\n?>\n35\nCode Sample 38.4.: Quadratic Roots Program in PHP With Error Checking\n525  39. Loops\nPHP supports while loops, for loops, and do-while loops using the keywords while, for,\nand do (along with another while). Continuation conditions for loops are enclosed in\nparentheses, (...) and blocks of code associated with the loop are enclosed in curly\nbrackets.\n39.1. While Loops\nCode Sample 39.1 contains an example of a basic while loop in PHP. As with conditional\nstatements, our code style places the opening curly bracket on the same line as the\nwhile keyword and continuation condition. The inner block of code is also indented\nand all lines in the block are indented to the same level.\nIn addition, the continuation condition does not contain a semicolon since it is not an\nexecutable statement. Just as with an if-statement, if we had placed a semicolon it would\nhave led to unintended results. Consider the following:\nwhile($i <= 10); {\n1\n\/\/perform some action\n2\n$i++; \/\/iteration\n3\n}\n4\nA similar problem occurs. The while keyword and continuation condition bind to\nthe next executable statement or code block. As a consequence of the semicolon, the\nexecutable statement that gets bound to the while loop is empty. What happens is\n$i = 1; \/\/Initialization\n1\nwhile($i <= 10) { \/\/continuation condition\n2\n\/\/perform some action\n3\n$i++; \/\/iteration\n4\n}\n5\nCode Sample 39.1.: While Loop in PHP\n527 39. Loops\n$i = 1;\n1\n$flag = true;\n2\nwhile($flag) {\n3\n\/\/perform some action\n4\n$i++; \/\/iteration\n5\nif($i>10) {\n6\n$flag = false;\n7\n}\n8\n}\n9\nCode Sample 39.2.: Flag-controlled While Loop in PHP\neven worse: the program will enter an infinite loop. To see this, the code is essentially\nequivalent to the following:\nwhile($i <= 10) {\n1\n}\n2\n{\n3\n\/\/perform some action\n4\n$i++; \/\/iteration\n5\n}\n6\nIn the while loop, we never increment the counter variable $i, the loop does nothing,\nand so the computation will continue on forever! It is valid PHP and will run, but\nobviously won\u2019t work as intended. Avoid this problem by using proper syntax.\nAnother common use for a while loop is a flag-controlled loop in which we use a Boolean\nflag rather than an expression to determine if a loop should continue or not. Since PHP\nhas built-in Boolean types, we can use a variable along with the keywords true and\nfalse. An example can be found in Code Sample 39.2.\n39.2. For Loops\nFor loops in PHP use the familiar syntax of placing the initialization, continuation\ncondition, and iteration on the same line as the for keyword. An example can be found\nin Code Sample 39.3.\nSemicolons are placed at the end of the initialization and continuation condition, but not\nthe iteration statement. With while loops, the opening curly bracket is placed on the\nsame line as the for keyword. Code within the loop body is indented, all at the same\nindentation level.\n528 39.3. Do-While Loops\n$i;\n1\nfor($i=1; $i<=10; $i++) {\n2\n\/\/perform some action\n3\n}\n4\nCode Sample 39.3.: For Loop in PHP\n$i;\n1\ndo {\n2\n\/\/perform some action\n3\n$i++;\n4\n} while($i <= 10);\n5\nCode Sample 39.4.: Do-While Loop in PHP\n39.3. Do-While Loops\nPHP also supports do-while loops. Recall that the difference between a while loop and a\ndo-while loop is when the continuation condition is checked. For a while loop it is prior\nto the beginning of the loop body and in a do-while loop it is at the end of the loop.\nThis means that a do-while always executes at least once. An example can be found in\nCode Sample 39.4.\nThe opening curly bracket is again on the same line as the keyword do. The while\nkeyword and continuation condition are on the same line as the closing curly bracket.\nIn a slight departure from previous syntax, a semicolon does appear at the end of the\ncontinuation condition even though it is not an executable statement.\n39.4. Foreach Loops\nFinally, PHP supports foreach loops using the keyword foreach. Some of this will be a\npreview of Section 42 where we discuss arrays in PHP,1 In short you can iterate over the\nelements of an array as follows.\n$arr = array(1.41, 2.71, 3.14);\n1\nforeach($arr as $x) {\n2\n\/\/x now holds the \"current\" element in arr\n3\n1Actually, PHP supports associative arrays, which are not the same thing as traditional arrays.\n529 39. Loops\n}\n4\nIn the foreach syntax we specify the array we want to iterate over, $arr and use the\nkeyword as. The last element in the statement is the variable name that we want to use\nwithin the loop. This should be read as \u201cforeach element $x in the array $arr...\u201d.\nInside the loop, the variable $x will be automatically updated on each iteration to the\nnext element in $arr.\n39.5. Examples\n39.5.1. Normalizing a Number\nLet\u2019srevisittheexamplefromSection4.1.1inwhichwenormalize anumberbycontinually\ndividing it by 10 until it is less than 10. The code in Code Sample 39.5 specifically refers\nto the value 32145.234 but would work equally well with any value of $x.\n$x = 32145.234;\n1\n$k = 0;\n2\nwhile($x > 10) {\n3\n$x = $x \/ 10;\n4\n$k++;\n5\n}\n6\nCode Sample 39.5.: Normalizing a Number with a While Loop in PHP\n39.5.2. Summation\nLet\u2019s revisit the example from Section 4.2.1 in which we computed the sum of integers\n1+2+\u00b7\u00b7\u00b7+10. The code is presented in Code Sample 39.6\nWe could easily generalize this code. Instead of computing a sum up to a particular\nnumber, we could have written it to sum up to another variable $n, in which case the\nfor loop would instead look like the following.\nfor($i=1; $i<=$n; $i++) {\n1\n$sum += $i;\n2\n}\n3\n530 39.5. Examples\n$sum = 0;\n1\nfor($i=1; $i<=10; $i++) {\n2\n$sum += $i;\n3\n}\n4\nCode Sample 39.6.: Summation of Numbers using a For Loop in PHP\n39.5.3. Nested Loops\nRecall that you can write loops within loops. The inner loop will execute fully for each\niteration of the outer loop. An example of two nested of loops in PHP can be found in\nCode Sample 39.7.\n$n = 10;\n1\n$m = 20;\n2\nfor($i=0; $i<$n; $i++) {\n3\nfor($j=0; $j<$m; $j++) {\n4\nprintf(\"(i, j) = (%d, %d)\\n\", $i, $j);\n5\n}\n6\n}\n7\nCode Sample 39.7.: Nested For Loops in PHP\nThe inner loop executes for j = 0,1,2,...,19 < m = 20 for a total of 20 itera-\ntions. However, it executes 20 times for each iteration of the outer loop. Since\nthe outer loop executes for i = 0,1,2,...,9 < n = 10, the total number of times\nthe printf() statement executes is 10 \u00d7 20 = 200. In this example, the sequence\n(0,0),(0,1),(0,2),...,(0,19),(1,0),...,(9,19) will be printed.\n39.5.4. Paying the Piper\nLet\u2019s adapt the solution for the loan amortization schedule we developed in Section 4.7.3.\nFirst, we\u2019ll read the principle, terms, and interest as command line inputs. Adapting the\nformula for the monthly payment and using the standard math library\u2019s pow() function,\nwe get\n$monthlyPayment = ($monthlyInterestRate * $principle) \/\n1\n(1 - pow( (1 + $monthlyInterestRate), -$n));\n2\n531 39. Loops\nThe monthly payment may come out to be a fraction of a cent, say $43.871. For accuracy,\nwe need to ensure that all of the figures for currency are rounded to the nearest cent.\nThe standard math library does have a round() function, but it only rounds to the\nnearest whole number, not the nearest 100th.\nHowever, we can adapt the \u201coff-the-shelf\u201d solution to fit our needs. If we take the number,\nmultiply it by 100, we get 4387.1 which we can now round to the nearest whole number,\ngiving us 4387. We can then divide by 100 to get a number that has been rounded to\nthe nearest 100th!\n$monthlyPayment = round($monthlyPayment * 100) \/ 100;\nWe can use the same trick to round the monthly interest payment and any other number\nexpected to be whole cents. To output our numbers, we use printf() and take care to\nalign our columns to make make it look nice. To finish our adaptation, we handle the\nfinal month separately to account for an over\/under payment due to rounding. The full\nsolution can be found in Code Sample 39.8.\n532 39.5. Examples\n1 <?php\n2 if($argc != 4) {\n3 printf(\"Usage: %s principle apr terms\\n\", $argv[0]);\n4 exit(1);\n5 }\n6\n7 $principle = floatval($argv[1]);\n8 $apr = floatval($argv[2]);\n9 $n = intval($argv[3]);\n10\n11 $balance = $principle;\n12 $monthlyInterestRate = $apr \/ 12;\n13\n14 \/\/monthly payment\n15 $monthlyPayment = ($monthlyInterestRate * $principle) \/\n16 (1 - pow( (1 + $monthlyInterestRate), -$n));\n17 \/\/round to the nearest cent\n18 $monthlyPayment = round($monthlyPayment * 100) \/ 100;\n19\n20 printf(\"Principle: $%.2f\\n\", $principle);\n21 printf(\"APR: %.4f%%\\n\", $apr * 100.0);\n22 printf(\"Months: %d\\n\", $n);\n23 printf(\"Monthly Payment: $%.2f\\n\", $monthlyPayment);\n24\n25 \/\/for the first n-1 payments in a loop:\n26 for($i=1; $i<$n; $i++) {\n27 \/\/ compute the monthly interest, rounded:\n28 $monthlyInterest =\n29 round( ($balance * $monthlyInterestRate) * 100) \/ 100;\n30 \/\/ compute the monthly principle payment\n31 $monthlyPrinciplePayment = $monthlyPayment - $monthlyInterest;\n32 \/\/ update the balance\n33 $balance = $balance - $monthlyPrinciplePayment;\n34 \/\/ print i, monthly interest, monthly principle, new balance\n35 printf(\"%d\\t$%10.2f $%10.2f $%10.2f\\n\", $i, $monthlyInterest,\n36 $monthlyPrinciplePayment, $balance);\n37 }\n38\n39 \/\/handle the last month and last payment separately\n40 $lastInterest = round( ($balance * $monthlyInterestRate) * 100) \/ 100;\n41 $lastPayment = $balance + $lastInterest;\n42\n43 printf(\"Last payment = $%.2f\\n\", $lastPayment);\n44 ?>\nCode Sample 39.8.: Loan Amortization Program in PHP\n533  40. Functions\nFunctions are essential in PHP programming. PHP provides a large library of standard\nfunctions to perform basic input\/output, math, and many other functions. PHP also\nprovides the ability to define and use your own functions.\nPHP does not support function overloading, so when you define a function and give it a\nname, that name cannot be in conflict with any other function name in the standard\nlibrary or any other code that you might use. Careful thought should go into the design\nand naming of your functions.\nPHP supports both call by value and call by reference. As of PHP 5.6, vararg functions\nare also supported (though earlier versions supported some vararg-like functions such as\nprintf()). However, we will not go into detail here. Finally, another feature of PHP\nis that function parameters are all optional. You may invoke a function with a subset\nof the parameters. Depending on your PHP setup, the interpreter may issue a warning\nthat a parameter was omitted. However, PHP allows you to define default values for\noptional parameters.\n40.1. Defining & Using Functions\nIn general, you can define functions anywhere in your PHP script or codebase. They can\neven appear after code that invokes them because PHP hoists the function definitions\nby doing two passes of the script. However, it is good style to include function definitions\nat the top of your script or in a separate PHP file for organization.\n40.1.1. Declaring Functions\nIn PHP, to declare a function you use the keyword function. Because PHP is dynami-\ncally typed, a function can return any type. Therefore, you do not declare the return\ntype (just as you do not declare a variable\u2019s type). After the function keyword you\nprovide an identifier and parameters as the function signature. Immediately following,\nyou provide the function body enclosed with opening\/closing curly brackets.\nTypically, the documentation for functions is included with its declaration. Consider\nthe following examples. In these examples we use a commenting style known as \u201cdoc\ncomments.\u201d This style was originally developed for Java but has since been adopted by\nmany other languages.\n535 40. Functions\n\/**\n1\n* Computes the sum of the two arguments.\n2\n*\/\n3\nfunction sum($a, $b) {\n4\nreturn ($a + $b);\n5\n}\n6\n7\n\/**\n8\n* Computes the Euclidean distance between the 2-D points,\n9\n* (x1,y1) and (x2,y2).\n10\n*\/\n11\nfunction getDistance($x1, $y1, $x2, $y2) {\n12\n$xDiff = ($x1-$x2);\n13\n$yDiff = ($y1-$y2);\n14\nreturn sqrt( $xDiff * $xDiff + $yDiff * $yDiff);\n15\n}\n16\n17\n\/**\n18\n* Computes a monthly payment for a loan with the given\n19\n* principle at the given APR (annual percentage rate) which\n20\n* is to be repaid over the given number of terms (usually\n21\n* months).\n22\n*\/\n23\nfunction getMonthlyPayment($principle, $apr, $terms) {\n24\n$rate = ($apr \/ 12.0);\n25\n$payment = ($principle * $rate) \/ (1-pow(1+$rate, -$terms));\n26\nreturn $payment;\n27\n}\n28\nFunction identifiers (names) follow similar naming rules as variables, however they do\nnot begin with a dollar sign. Function names must begin with an alphabetic character\nand may contain alphanumeric characters as well as underscores. However, using modern\ncoding conventions we usually name functions using lower camel casing. Another quirk\nof PHP is that function names are case insensitive. Though we declared a function,\ngetDistance() above, it could be invoked with either getdistance(), GETDISTANCE\nor any other combination of uppercase\/lowercase letters. However, good code will use\nconsistent naming and your function calls should match their declaration.\nThe keyword return is used to specify the value that is returned to the calling function.\nWhatever value you end up returning is the return type of the function. Since you do not\nspecify variable or return types, functions are usually referred to as returning a \u201cmixed\u201d\ntype. You could design a function that, given one set of inputs, returns a number while\nanother set of inputs returns a string. You can use the syntax return; to return no\n536 40.1. Defining & Using Functions\nvalue (you do not use the keyword void). In practice, however, the function ends up\nreturning null when doing this.\n40.1.2. Organizing Functions\nThere are many coding standards that guide how PHP code should be organized. We\u2019ll\nonly discuss a simple mechanism here. One way to organize functions is to collect\nfunctions with similar functionality into separate PHP source files.\nSuppose the functions above are in a PHP source file named utils.php. We could\ninclude them in another source file (our \u201cmain\u201d source file) using an include_once\nfunction invocation. An example:\n<?php\n1\n2\ninclude_once(\"utils.php\");\n3\n4\n\/\/we can now use the functions in utils.php:\n5\n$p = getMonthlyPayment(1000, 0.05, 12);\n6\n7\n?>\n8\nThe include_once function loads and evaluates the given PHP source file at the point\nin the code in which it is invoked. The \u201conce\u201d in the function refers to the fact that if\nthe source file was already included in the script\/code before, it will not be included\na second time. This allows you to include the same source file in multiple source files\nwithout a conflict.\n40.1.3. Calling Functions\nThe syntax for calling a function is to simply provide the function name followed by\nparentheses containing values or variables to pass to the function. Some examples:\n$a = 10, $b = 20;\n1\n$c = sum($a, $b); \/\/c contains the value 30\n2\n3\n\/\/invoke a function with literal values:\n4\n$dist = getDistance(0.0, 0.0, 10.0, 20.0);\n5\n6\n\/\/invoke a function with a combination:\n7\n$p = 1500.0;\n8\n$r = 0.05;\n9\n$monthlyPayment = getMonthlyPayment($p, $r, 60);\n10\n537 40. Functions\n40.1.4. Passing By Reference\nBy default, all types (including numbers, strings, etc.) are passed by value. To be able\nto pass arguments by reference, we need to use slightly different syntax when defining\nour functions.\nTo specify that a parameter is to be passed by reference, we place an ampersand, & in\nfront of it in the function signature.1 No other syntax is necessary. When you call the\nfunction, PHP automatically takes care of the referencing\/dereferencing for you.\n<?php\n1\n2\nfunction swap($a, $b) {\n3\n$t = $a;\n4\n$a = $b;\n5\n$b = $t;\n6\n}\n7\n8\nfunction swapByRef(&$a, &$b) {\n9\n$t = $a;\n10\n$a = $b;\n11\n$b = $t;\n12\n}\n13\n14\n$x = 10;\n15\n$y = 20;\n16\n17\nprintf(\"x = %d, y = %d\\n\", $x, $y);\n18\nswap($x, $y);\n19\nprintf(\"x = %d, y = %d\\n\", $x, $y);\n20\nswapByRef($x, $y);\n21\nprintf(\"x = %d, y = %d\\n\", $x, $y);\n22\n23\n?>\n24\nThe first function, swap() passes both variables by value. Swapping the values only\naffects the copies of the parameters. The original variables $x and $y will be unaffected.\nIn the second function, swapByRef(), both variables are passed by reference as there\nare ampersands in front of them. Swapping them inside the function swaps the original\n1Those familiar with pointers in C will note that this is the exact opposite of the C operator.\n538 40.1. Defining & Using Functions\nvariables. The output to this code is as follows.\nx = 10, y = 20\nx = 10, y = 20\nx = 20, y = 10\nObserve that when we invoked the function, swapByRef($x, $y); we used the same\nsyntax as the pass by value version. The only syntax needed to pass by reference is in\nthe function signature itself.\n40.1.5. Optional & Default Parameters\nParameters in PHP functions are optional. You can invoke a function without providing\na subset of parameters. However, if a parameter is not provided, PHP will treat\nthe parameter as null. If we invoked the getDistance() function with only two\nparameters:\ngetDistance(10.0, 20.0);\nthen inside the function, $x1 and $y1 would take on the values 10 and 20, but $x2\nand $y2 would be null. When used in the distance formula calculations, both would\nbe treated as zero. If we had invoked the function with no arguments,\ngetDistance();\nthen all four parameters would be treated as null (and thus zero in the calculations).\nPHP also allows you to define alternative default values for function parameters. Consider\nthe following example.\nfunction getMonthlyPayment($principle, $apr = 0.05, $terms = 60) {\n1\n$rate = ($apr \/ 12);\n2\n$mp = (($principle * $rate) \/ (1-pow(1+$rate, -$terms)));\n3\nreturn round($mp * 100) \/ 100;\n4\n}\n5\nIn this example, the second and third parameter have been given default values of 0.05\nand 60 respectively. If a call to this function omits these parameters, they are not treated\nas null, but take on these defaults instead.\n$x = getMonthlyPayment(10000, 0.07, 72);\n1\nprint $x.\"\\n\"; \/\/170.49\n2\n3\n\/\/terms will be 60\n4\n$x = getMonthlyPayment(10000, 0.07);\n5\n539 40. Functions\nprint $x.\"\\n\"; \/\/198.01\n6\n7\n\/\/apr will be 0.05, terms will be 60\n8\n$x = getMonthlyPayment(10000);\n9\nprint $x.\"\\n\"; \/\/188.71\n10\n11\n\/\/balance will be null (0), apr will be 0.05, terms will be 60\n12\n$x = getMonthlyPayment();\n13\nprint $x.\"\\n\"; \/\/0 but also a warning\n14\nIt would not be possible to invoke getMonthlyPayment() by omitting only the second\nargument. Providing n arguments will match the first n parameters. Thus, in your\nfunction design you should place any optional\/default parameters last.\n40.1.6. Function Pointers\nFunctions are just pieces of code that reside somewhere in memory just as variables do.\nSince we can pass variables by reference, it also makes sense that we would do the same\nwith functions.\nIn PHP, functions are first-class citizens2 meaning that you can assign a function to a\nvariable just as you would a numeric value. For example, you can do the following.\n$func = swapByRef;\n1\n2\n$func($x, $y);\n3\nIn the example above, we assigned the function swapByRef() to the variable $func\nby using its identifier. The variable essentially holds a reference to the swapByRef()\nfunction. Since it refers to a function, we can also invoke the function using the variable\nas in the last line. This allows you to treat functions as callbacks to other functions. We\nwill revisit this concept in Chapter 47.\n40.2. Examples\n40.2.1. Generalized Rounding\nRecall that the standard math library provides a round() function that rounds a number\nto the nearest whole number. We\u2019ve had need to round to cents as well. We now have\n2Somewoulduseamuchmorerestrictivedefinitionoffirst-classandwouldnot considerthemfirst-class\ncitizens in this sense\n540 40.2. Examples\nthe ability to write a function to do this for us. Before we do, however, let\u2019s think more\ngenerally. What if we wanted to round to the nearest tenth? Or what if we wanted to\nround to the nearest 10s or 100s place? Let\u2019s write a general purpose rounding function\nthat allows us to specify which decimal place to round to.\nThe most natural input would be to specify the place using an integer exponent. That\nis, if we wanted to round to the nearest tenth, then we would pass it \u22121 as 0.1 = 10\u22121,\n\u22122 if we wanted to round to the nearest 100th, etc. In the other direction, passing in 0\nwould correspond to the usual round function, 1 to the nearest 10s spot, and so on.\nMoreover, we could demonstrate good code reuse (as well as procedural abstraction)\nby scaling the input value and reusing the functionality already provided in the math\nlibrary\u2019s round() function. We could further define a roundToCents() function that\nused our generalized round function. Consider the following.\n<?php\n1\n2\n\/**\n3\n* Rounds to the nearest digit specified by the place\n4\n* argument. In particular to the (10^place)-th digit\n5\n*\/\n6\nfunction roundToPlace($x, $place) {\n7\n$scale = pow(10, -$place);\n8\n$rounded = round(x * $scale) \/ $scale;\n9\nreturn $rounded;\n10\n}\n11\n12\n\/**\n13\n* Rounds to the nearest cent\n14\n*\/\n15\nfunction roundToCents($x) {\n16\nreturn roundToPlace($x, -2);\n17\n}\n18\n19\n?>\n20\nWe could place these functions into a file named round.php and include them in another\nPHP source file.\n40.2.2. Quadratic Roots\nAnother advantage of passing variables by reference is that we can \u201creturn\u201d multiple\nvalues with one function call. Functions are limited in that they can only return at most\none value. But if we pass multiple parameters by reference, the function can manipulate\n541 40. Functions\nthe contents of them, thereby communicating (though not strictly returning) multiple\nvalues.\nConsider again the problem of computing the roots of a quadratic equation,\nax2 +bx+c = 0\nusing the quadratic formula,\n\u221a\n\u2212b\u00b1 b2 \u22124ac\nx =\n2a\nSince there are two roots, we may have to write two functions, one for the \u201cplus\u201d root\nand one for the \u201cminus\u201d root both of which take the coefficients, a,b,c as arguments.\nHowever, if we wrote a single function that took the coefficients as parameters by value\nas well as two other parameters by reference, we could compute both root values, one in\neach of the by-reference variables.\nfunction quadraticRoots($a, $b, $c, &$root1, &$root2) {\n1\n$discriminant = sqrt($b*$b - 4*$a*$c);\n2\n$root1 = (-$b + $discriminant) \/ (2*$a);\n3\n$root2 = (-$b - $discriminant) \/ (2*$a);\n4\nreturn;\n5\n}\n6\nBy using pass by reference variables, we avoid multiple functions. Recall that there\ncould be several \u201cbad\u201d inputs to this function. The roots could be complex values, the\ncoefficient a could be zero, etc. In the next chapter, we examine how we can handle these\nerrors.\n542 41. Error Handling & Exceptions\nModern versions of PHP support error handling through the use of exceptions. PHP has\nseveral different predefined types of exceptions and also allows you to define your own\nexception types by creating new classes that inherit from the generic Exception class.\nPHP uses the standard try-catch-finally control structure to handle exceptions and\nallows you to throw your own exceptions.\n41.1. Throwing Exceptions\nThough PHP defines several different types of exceptions, we\u2019ll only cover the generic\nException class. We can throw an exception in PHP by using the keyword throw\nand creating a new Exception with an error message.\nthrow new Exception(\"Something went wrong\");\nBy using a generic Exception, we can only attach a message to the exception (which\ncan be printed by code that catches the exception). If we want more fine-grained control\nover the type of exceptions, we need to define our own exceptions.\n41.2. Catching Exceptions\nTo catch an exception in PHP you can use the standard try-catch control block.\nOptionally (and as of PHP version 5.5.0) you can use the finally block to clean up any\nresources or execute code regardless of whether or not an exception was raised. Consider\nthe simple task of reading input from a user and manually parsing its value into an\ninteger. If the user enters a non-numeric value, parsing will fail and we should instead\nthrow an exception. Consider the following function.\nfunction readNumber() {\n1\n$input = readline(\"Please enter a number: \");\n2\nif( is_numeric($input) ) {\n3\n$value = floatval($input);\n4\n} else {\n5\nthrow new Exception(\"Invalid input!\");\n6\n}\n7\n}\n8\n543 41. Error Handling & Exceptions\nElsewhere in the code, we can surround a call to readNumber() in a try-catch\nstatement.\ntry {\n1\nreadNumber();\n2\n} catch(Exception $e) {\n3\nprintf(\"Error: exception encountered: \" . $e->getMessage());\n4\nexit(1);\n5\n}\n6\nInthisexample,we\u2019vesimplydisplayedanerrormessagetothestandardoutputandexited\nthe program. We\u2019ve made the design decision that this error should be fatal. We could\nhave chosen to handle this error differently in the catch block. The $e->getMessage()\nprints the message that the exception was created with. In this case, \"Invalid input!\".\n41.3. Creating Custom Exceptions\nAs of PHP 5.3.0 it is possible to define custom exceptions by extending the Exception\nclass. To do this, you need to declare a new class. We cover classes and objects in\nChapter 45. For now, we present a simple example. Consider the example in the previous\nchapter of computing the roots of a quadratic polynomial. One possible error situation\nis when the roots are complex numbers. We could define a new PHP exception class as\nfollows.\n\/**\n1\n* Defines a ComplexRoot exception class\n2\n*\/\n3\nclass ComplexRootException extends Exception\n4\n{\n5\npublic function __construct($message = null,\n6\n$code = 0,\n7\nException $previous = null) {\n8\n\/\/ call the parent constructor\n9\nparent::__construct($message, $code, $previous);\n10\n}\n11\n12\n\/\/ custom string representation of object\n13\npublic function __toString() {\n14\nreturn __CLASS__ . \": [{$this->code}]: {$this->message}\\n\";\n15\n}\n16\n}\n17\n544 41.3. Creating Custom Exceptions\nNow in our code we can catch and even throw this new type of exception.\nif( $b*$b - 4*$a*$c < 0) {\n1\nthrow new ComplexRootException(\"Cannot Handle complex roots\");\n2\n}\n3\ntry {\n1\n$r1 = getRoot($a, $b, $c);\n2\n} catch(ComplexRootException $e) {\n3\n\/\/handle here\n4\n} catch(Exception $e) {\n5\n\/\/handle all other types of exceptions here\n6\n}\n7\nIn the code above we had two catch blocks. Since we can have multiple types of\nexceptions, we can catch each different type and handle them differently if we choose.\nEach catch block catches a different type of exception. The last catch block was\nwritten to catch a generic Exception. Much like an if-else-if statement, the first\ntype of exception that is caught is the block that will be executed and they are all\nmutually exclusive. Thus, a generic \u201ccatch all\u201d block like this should always be the last\ncatch block. The most specific types of exceptions should be caught first and the most\ngeneral types should be caught last.\n545  42. Arrays\nPHP allows you to use arrays, but PHP arrays are actually associative arrays. Though\nyou can treat them as regular arrays and use contiguous integer indices, they are more\nflexible than that. Integer indices need to be contiguous or start at zero and you can\nuse strings as indices. In addition, since PHP is dynamically typed, PHP arrays allow\nmixed types. An array has no fixed type and you can place different mixed types\ninto the same array. PHP arrays are dynamic, so there is no memory management or\nallocation\/deallocation of memory space. Arrays will grow and shrink automatically as\nyou add and remove elements.\n42.1. Creating Arrays\nSince PHP is dynamically typed, you do not need to declare an array or specify a\nparticular type of variable that it holds. However, there are several ways that you\ncan initialize an array. To create an empty array, you can call the array() function.\nOptionally, you can provide an initial list of elements to insert into the array by providing\nthe list of elements as arguments to the function.\n\/\/create an empty array:\n1\n$arr = array();\n2\n3\n\/\/create an array with elements 10, 20, 30:\n4\n$arr = array(10, 20, 30);\n5\n6\n\/\/create an array with mixed types:\n7\n$arr = array(10, 3.14, \"Hello\");\n8\n42.2. Indexing\nBy default, when inserting elements, 0-indexing is used. In the three examples above,\neach element would be located at indices 0, 1, and 2 respectively. The usual square\nbracket syntax can be used to access and assign elements.\n547 42. Arrays\n\/\/create an array with elements 10, 20, 30:\n1\n$arr = array(10, 20, 30);\n2\n3\n\/\/get the first element:\n4\n$x = $arr[0]; \/\/x has value 10\n5\n6\n\/\/change the 3rd element to 5:\n7\n$arr[2] = 5;\n8\n9\n\/\/print the 2nd element:\n10\nprintf(\"$arr[1] = %d\\n\", $arr[1]);\n11\nAttempting to access an element at an invalid index does not result in an error or an\nexception (though a warning may be issued depending on how PHP is setup). Instead, if\nyou attempt to access an invalid element, it will be treated as a null value.\n$arr = array(10, 20, 30);\n1\n$x = $arr[10]; \/\/x is null\n2\nHowever, an array could have null values in it as elements. How do we distinguish\nwhether or not an accessed value was actually null or if it is not part of the array?\nPHP provides a function, array_key_exists() to distinguish between these two cases.\nIt returns true or false depending on whether or not a particular index has been set\nor not.\n$arr = array(10, null, 30);\n1\nif(array_key_exists(1, $arr)) {\n2\nprint \"index 1 contains an element\\n\";\n3\n}\n4\nif(!array_key_exists(10, $arr)) {\n5\nprint \"index 10 does not contain an element\\n\";\n6\n}\n7\n8\nif($arr[1] === $arr[10]) {\n9\nprint \"but they are both null\\n\";\n10\n}\n11\n548 42.2. Indexing\n42.2.1. Strings as Indices\nSince arrays in PHP are associative arrays, keys are not limited to integers. You can also\nuse strings as keys to index elements.\n$arr = array();\n1\n$arr[0] = 5;\n2\n$arr[\"foo\"] = 10;\n3\n$arr[\"hello\"] = \"world\";\n4\n5\nprint \"value = \" . $arr[\"hello\"];\n6\nNote that strings that contain integer values will be type-juggled into their numeric\nvalues. Forexample, $arr[\"10\"] = 3; willbeequivalentto $arr[10] = 3;. However,\nstrings containing floating point values will not be coerced but will remain as strings,\n$arr[\"3.15\"] = 7; for example.\n42.2.2. Non-Contiguous Indices\nAnother aspect of PHP associative arrays is that integer indices need not be contiguous.\nFor example,\n$arr = array();\n1\n$arr[0] = 10;\n2\n$arr[5] = 20;\n3\nThe values at indices 1 through 4 are undefined and the array contains some \u201choles\u201d in\nits indices.\n42.2.3. Key-Value Initialization\nSince associative arrays in PHP can be indexed by either integers or strings and need not\nbe ordered or contiguous, we can use a special key-value initialization syntax to define\nnot only the values, but the keys that map to those values when we initialize an array.\nThe \u201cdouble arrow,\u201d => is used to denote the mapping.\n$arr = array(\n1\n\"foo\" => 5,\n2\n4 => \"bar\",\n3\n0 => 3.14,\n4\n549 42. Arrays\n\"baz\" => \"ten\"\n5\n);\n6\n42.3. Useful Functions\nThere are dozens of useful functions PHP defines that can be used with arrays. We\u2019ll\nonly highlight a few of the more useful ones. First, the count() function can be used\nto compute how many elements are stored in the array.\n$arr = array(10, 20, 30);\n1\n$n = count($arr); \/\/n is 3\n2\nFor convenience and debugging, a special function, print_r() allows you to print the\ncontentsofanarrayinahuman-readableformatthatresemblesthekey-valueinitialization\nsyntax above. For example,\n$arr = array(\n1\n\"foo\" => 5,\n2\n4 => \"bar\",\n3\n0 => 3.14,\n4\n\"baz\" => \"ten\"\n5\n);\n6\nprint_r($arr);\n7\nwould end up printing\nArray\n(\n[foo] => 5\n[4] => bar\n[0] => 3.14\n[baz] => ten\n)\nTwo other functions, array_keys() and array_values() return new zero-indexed\narrays containing the keys and the values of an array respectively. Reusing the example\nabove,\n550 42.4. Iteration\n$keys = array_keys($arr);\n1\n$vals = array_values($arr);\n2\nprint_r($keys);\n3\nprint_r($vals);\n4\nwould print\nArray\n(\n[0] => foo\n[1] => 4\n[2] => 0\n[3] => baz\n)\nArray\n(\n[0] => 5\n[1] => bar\n[2] => 3.14\n[3] => ten\n)\nFinally, you can use the equality operators, == and === to compare arrays. The first is\nthe loose equality operator and evaluates to true if the two compared arrays have the\nsame key-value pairs while the second is the strict equality operator and is true only if\nthe arrays have the same key\/value pairs in the same order and are of the same type.\n42.4. Iteration\nIf we have an array in PHP that we know is 0-indexed and all elements are contiguous, we\ncan use a normal for loop to iterate over its elements by incrementing an index variable.\nfor($i=0; $i<count($arr); $i++) {\n1\nprint $arr[$i] . \"\\n\";\n2\n}\n3\nThis fails, however, when we have an associative array that has a mix of integer and\nstring keys or \u201choles\u201d in the indexing of integer keys. For this reason, it is more reliable\nto use foreach loops. There are several ways that we can use a foreach loop. The\nmost general usage is to use the double arrow notation to iterate over each key-value\npair.\n551 42. Arrays\n\/\/for each key value pair:\n1\nforeach($arr as $key => $val) {\n2\nprint \"$key maps to $val \\n\";\n3\n}\n4\nThis syntax gives you access to both the key and the value for each element in the array\n$arr. The keyword as is used to denote the variable names $key and $val that\nwill be changed on each iteration of the loop. You need not use the identifiers $key and\n$val; you can use any legal variable names for the key\/value variables. If you do not\nneed the keys when iterating, you can use the following shorthand syntax.\n\/\/for each value:\n1\nforeach($arr as $val) {\n2\nprint \"$val \\n\";\n3\n}\n4\n42.5. Adding Elements\nYou can easily add elements to an array by providing an index and using the assignment\noperator as in the previous examples. There are also several functions PHP defines that\ncan insert elements to the beginning (array_unshift()), end (array_push()) or at\nan arbitrary position (array_splice()).\n$arr = array(10, 20, 30);\n1\n2\narray_unshift($arr, 15);\n3\n\/\/arr is now [15, 10, 20, 30]\n4\n5\narray_push($arr, 25);\n6\n\/\/arr is now [15, 10, 20, 30, 25]\n7\n8\n\/\/insert 35 at index 3:\n9\narray_splice($arr, 3, 0, 35);\n10\n\/\/arr is now [15, 10, 20, 35, 30, 25]\n11\nAnother, simpler way of adding elements is to use the following syntax:\n552 42.6. Removing Elements\n$arr = array(10, 20, 30);\n1\n$arr[] = 5;\n2\n$arr[] = 15;\n3\n$arr[] = 25;\n4\nprint_r($arr);\n5\nBy using the assignment operator but not specifying the index, the element will be added\nto the next available integer index. Since there were already 3 elements in the array, each\nsubsequent element is inserted at index 3, 4, and 5 respectively. In general, the element\nwill be inserted at the maximum index value already used plus one. The example above\nresults in the following.\nArray\n(\n[0] => 10\n[1] => 20\n[2] => 30\n[3] => 5\n[4] => 15\n[5] => 25\n)\n42.6. Removing Elements\nYou can remove elements from an array using the unset() function. This function only\nremoves the element from the array, it does not shift other elements down to fill in the\nunused index.\n$arr = array(10, 20, 30);\n1\nunset($arr[1]);\n2\nprint_r($arr);\n3\nThis example would result in the following.\nArray\n(\n[0] => 10\n[2] => 30\n)\nFurther, you can use unset() to destroy all elements in the array:\n553 42. Arrays\nunset($arr);\ndestroys the entire array. It does not merely empty the array, but it unsets the variable\n$arr itself.\n42.7. Using Arrays in Functions\nBy default, all arguments to a function in PHP are passed by value; this includes arrays.\nThus, if you make any changes to an array passed to a function, the changes are not\nrealized in the calling function. You can explicitly specify that the array parameter is\npassed by reference so that any changes to the array are realized in the calling function.\nTo illustrate, consider the following example.\nfunction setFirst($a) {\n1\n$a[0] = 5;\n2\n}\n3\n4\n$arr = array(10, 20, 30);\n5\nprint_r($arr);\n6\nsetFirst($arr);\n7\nprint_r($arr);\n8\nThis example results in the following.\nArray\n(\n[0] => 10\n[1] => 20\n[2] => 30\n)\nArray\n(\n[0] => 10\n[1] => 20\n[2] => 30\n)\nThat is, the change to the first element does not affect the original array. However, if we\nspecify that the array is passed by reference, then the change is realized. For example,\nfunction setFirst(&$a) {\n1\n$a[0] = 5;\n2\n}\n3\n4\n$arr = array(10, 20, 30);\n5\n554 42.8. Multidimensional Arrays\nprint_r($arr);\n6\nsetFirst($arr);\n7\nprint_r($arr);\n8\nThis now results in the original array being changed:\nArray\n(\n[0] => 10\n[1] => 20\n[2] => 30\n)\nArray\n(\n[0] => 5\n[1] => 20\n[2] => 30\n)\n42.8. Multidimensional Arrays\nPHP supports multidimensional arrays in the sense that elements in an array can be of\nany type, including other arrays. We can use the same syntax and operations for single\ndimensional arrays. For example, we can use the double arrow syntax and assign arrays\nas values to create a 2-dimensional array.\n$mat = array(\n1\n0 => array(10, 20, 30),\n2\n1 => array(40, 50, 60),\n3\n2 => array(70, 80, 90)\n4\n);\n5\nprint_r($mat);\n6\nWhich results in the following:\nArray\n(\n[0] => Array\n(\n[0] => 10\n[1] => 20\n[2] => 30\n)\n555 42. Arrays\n[1] => Array\n(\n[0] => 40\n[1] => 50\n[2] => 60\n)\n[2] => Array\n(\n[0] => 70\n[1] => 80\n[2] => 90\n)\n)\nAlternatively, you can use two indices to get and set values from a 2-dimensional array.\nfor($i=0; $i<3; $i++) {\n1\nfor($j=0; $j<4; $j++) {\n2\n$mat[$i][$j] = ($i+$j)*3;\n3\n}\n4\n}\n5\nwhich results in:\nArray\n(\n[0] => Array\n(\n[0] => 0\n[1] => 3\n[2] => 6\n[3] => 9\n)\n[1] => Array\n(\n[0] => 3\n[1] => 6\n[2] => 9\n[3] => 12\n)\n[2] => Array\n(\n[0] => 6\n[1] => 9\n[2] => 12\n[3] => 15\n)\n)\n556 43. Strings\nAs we\u2019ve previously seen, PHP has a built-in string type. Internally, PHP strings are\nsimply a sequence of bytes, but for our purposes we can treat it as a 0-indexed character\narray. PHP strings are mutable and can be changed, but it is considered best practice to\ntreat them as immutable and rely on the many functions PHP provides to manipulate\nstrings.\n43.1. Basics\nWe can create strings by assigning a string literal value to a variable. Strings can be\nspecified by either single quotes or double quotes (there are no individual characters in\nPHP, only single character strings), but we will use the double quote syntax.\n$firstName = \"Thomas\";\n1\n$lastName = \"Waits\";\n2\n3\n\/\/we can also reassign values\n4\n$firstName = \"Tom\";\n5\nThe reassignment in the last line in the example effectively destroys the old string. The\nassignment operator can also be used to make copies of strings.\n$firstName = \"Thomas\";\n1\n$alias = $firstName;\n2\nIt is important to understand that this assignment makes a deep copy of the string.\nChanges to the first do not affect the second one. You can make changes to individual\ncharacters in a string by treating it like a zero-indexed array.\n$a = \"hello\";\n1\n$a[0] = \"H\";\n2\n$a[5] = \"!\";\n3\n\/\/a is now \"Hello!\"\n4\n557 43. Strings\nThe last line extends the string by adding an additional character. You can even remove\ncharacters by setting them to the empty string.\n$a = \"Apples!\";\n1\n$a[5] = \"\";\n2\n\/\/a is now \"Apple!\"\n3\n43.2. String Functions\nPHP provides dozens of convenient functions that allow you to process and modify strings.\nWe highlight a few of the more common ones here. A full list of supported functions can\nbe found in standard documentation. Because of the history of PHP, many of the same\nfunctions defined in the C string library can also be used in PHP.\nLength\nWhen accessing individual characters in a string, it is necessary that we know the length\nof the string so that we do not access invalid characters (though doing so is not an error,\nit just results in null). The strlen() function returns an integer that represents the\nnumber of characters in the string.\n$s = \"Hello World!\";\n1\n$x = strlen($s); \/\/x is 12\n2\n$s = \"\";\n3\n$x = strlen($s); \/\/x is 0\n4\n5\n\/\/careful:\n6\n$s = NULL\n7\n$x = strlen($s); \/\/x is 0\n8\nAs demonstrated in the last example, strlen() will return 0 for null strings. Recall\nthat we can distinguish between these two situations by using is_null(). Using this\nfunction we can iterate over each individual character in a string.\n$fullName = \"Tom Waits\";\n1\nfor($i=0; $i<strlen($fullName); $i++) {\n2\nprintf(\"fullName[%d] = %s\\n\", $i, $fullName[$i]);\n3\n}\n4\n558 43.2. String Functions\nThis would print the following\nfullName[0] = T\nfullName[1] = o\nfullName[2] = m\nfullName[3] =\nfullName[4] = W\nfullName[5] = a\nfullName[6] = i\nfullName[7] = t\nfullName[8] = s\nConcatenation\nPHP has a concatenation operator built into the language. To concatenate one or more\nstrings together, you can use a simple period between them as the concatenation operator.\nConcatenation results in a new string.\n$firstName = \"Tom\";\n1\n$lastName = \"Waits\";\n2\n3\n$formattedName = $lastName . \", \" . $firstName;\n4\n\/\/formattedName now contains \"Waits, Tom\"\n5\nConcatenation also works with other variable types.\n$x = 10;\n1\n$y = 3.14;\n2\n3\n$s = \"Hello, x is \" . $x . \" and y = \" . $y;\n4\n\/\/s contains \"Hello, x is 10 and y = 3.14\"\n5\nComputing a Substring\nPHP provides a simple function, substr() to compute a substring of a string. It takes\nat at least 2 arguments: the string to operate on and the starting index. There is a third,\noptional parameter that allows you to specify the length of the resulting substring.\n559 43. Strings\n$name = \"Thomas Alan Waits\";\n1\n2\n$firstName = substr($name, 0, 6); \/\/\"Thomas\"\n3\n$middleName = substr($name, 7, 4); \/\/\"Alan\"\n4\n$lastName = substr($name, 12); \/\/\"Waits\"\n5\nInthefinalexample,omittingtheoptionallengthparameterresultsintheentireremainder\nof the string being returned as the substring.\n43.3. Arrays of Strings\nWe often need to deal with collections of strings. In PHP we can define arrays of strings.\nIndeed, we\u2019ve seen arrays of strings before. When processing command line arguments,\nPHP defines an array of strings, $argv. Each string can be accessed using an index,\n$argv[0] for example is always the name of the script.\nWe can create our own arrays of strings using the same syntax as with other arrays.\n$names = array(\n1\n\"Margaret Hamilton\",\n2\n\"Ada Lovelace\",\n3\n\"Grace Hopper\",\n4\n\"Marie Curie\",\n5\n\"Hedy Lamarr\");\n6\n43.4. Comparisons\nWhen comparing strings in PHP, we can use the usual comparison operators such\nas ===, <, or <= which will compare the strings lexicographically. However, this is\ngenerallydiscouragedbecauseoftypejugglingissuesandstrictvslooseequality\/inequality\ncomparisons. Instead, there are several comparator methods that PHP provides to\ncompare strings based on their content. strcmp($a, $b) takes two strings and returns\nan integer based on the lexicographic ordering of $a and $b. If $a precedes $b,\nstrcmp() returns something negative. It returns zero if $a and $b have the same\ncontent. Otherwise it returns something positive if $b precedes $a.\n$x = strcmp(\"apple\", \"banana\"); \/\/x is negative\n1\n$x = strcmp(\"zelda\", \"mario\"); \/\/x is positive\n2\n560 43.5. Tokenizing\n$x = strcmp(\"Hello\", \"Hello\"); \/\/x is zero\n3\n4\n\/\/shorter strings precede longer strings:\n5\n$x = strcmp(\"apple\", \"apples\"); \/\/x is negative\n6\n7\n$x = strcmp(\"Apple\", \"apple\"); \/\/x is negative\n8\nIn the last example, \"Apple\" precedes \"apple\" since uppercase letters are ordered\nbefore lowercase letters according to the ASCII table. We can also make case insen-\nsitive comparisons if we need to using the alternative, strcasecmp($a, $b). Here,\nstrcasecmp(\"Apple\", \"apple\") will return zero as the two strings are the same ig-\nnoring the cases.\nThe comparison functions also have length-limited versions, strncmp($a, $b, $n)\nand strncasecmp($a, $b, $n). Both will only make comparisons in the first $n\ncharacters of the strings. Thus, strncmp(\"apple\", \"apples\", 5) will result in zero\nas the two strings are equal in the first 5 characters.\n43.5. Tokenizing\nRecall that tokenizing is the process of splitting up a string along some delimiter. For\nexample, the comma delimited string, \"Smith,Joe,12345678,1985-09-08\" contains\nfour pieces of data delimited by a comma. Our aim is to split this string up into four\nseparate strings so that we can process each one. PHP provides several functions to to\nthis, explode() and preg_split().\nThe simpler one, explode() takes two arguments: the first one is a string delimiter and\nthe second is the string to be processed. It then returns an array of strings.\n$data = \"Smith,Joe,12345678,1985-09-08\";\n1\n2\n$tokens = explode(\",\", $data);\n3\n\/\/tokens is [ \"Smith\", \"Joe\", \"12345678\", \"1985-09-08\" ]\n4\n5\n$dateTokens = explode(\"-\", $tokens[3]);\n6\n\/\/dateTokens is now [ \"1985\", \"09\", \"08\" ]\n7\nThe more sophisticated preg_split() also takes two arguments,1 but instead of a\nsimple delimiter, it uses a regular expression; a sequence of characters that define a\nsearch pattern in which special characters can be used to define complex patterns. For\n1The \u201cpreg\u201d stands for Perl Compatible Regular Expression.\n561 43. Strings\nexample, the complex expression ^[+-]?(\\d+(\\.\\d+)?|\\.\\d+)([eE][+-]?\\d+)?$ will\nmatch any valid numerical value including scientific notation. We will not cover regular\nexpressions in depth, but to demonstrate their usefulness, here\u2019s an example by which\nyou can split a string along any and all whitespace:\n$s = \"Alpha Beta \\t Gamma \\n Delta \\t\\nEpsilon\";\n1\n$tokens = preg_split(\"\/[\\s]+\/\", $s);\n2\n\/\/tokens is now [ \"Alpha\", \"Beta\", \"Gamma\", \"Delta\", \"Epsilon\" ]\n3\n562 44. File I\/O\nBecause of the history of PHP, file functions, just like string functions, were mostly\ninfluenced by the C standard library functions and have very similar naming and usage.\nWriting binary or plaintext data is determined by which functions you use. In general\nwhether or not a file input\/output stream is buffered or unbuffered is determined by the\nsystem configuration. There are some ways in which this can be changed, but we will\nnot cover them in detail.\n44.1. Opening Files\nFiles are represented in PHP as a \u201cresource\u201d (also referred to as a handle) that can\nbe passed around to other functions to read and write to the file. For our purposes, a\nresource is simply a variable that can be stored and passed to other functions.\nTo open a file, you use the fopen() function (short for file open) which requires two\narguments and returns a file handle. The first argument is the file path\/name that you\nwant to open for processing. The second argument is a string representing the \u201cmode\u201d\nthat you want to open the file in. There are several supported modes, but the two we\nwill be interested in are reading, in which case you pass it \"r\" and writing in which case\nyou pass it \"w\". The path can be an absolute path, relative path, or may be omitted if\nthe file is in the current working directory.\n\/\/open a file for reading (input):\n1\n$input = fopen(\"\/user\/apps\/data.txt\", \"r\");\n2\n\/\/open a file for writing (output):\n3\n$output = fopen(\".\/results.txt\", \"w\");\n4\n5\nif(!$input) {\n6\nprintf(\"Unable to open input file\\n\");\n7\nexit(1);\n8\n}\n9\n10\nif(!$output) {\n11\nprintf(\"Unable to open output file\\n\");\n12\nexit(1);\n13\n}\n14\n563 44. File I\/O\n$h = fopen(\"input.data\", \"r\");\n1\nwhile(!feof($h)) {\n2\n\/\/read the next line:\n3\n$line = fgets($h);\n4\n\/\/trim it:\n5\n$line = trim($line);\n6\n\/\/process it, we'll just print it\n7\nprint $line;\n8\n}\n9\nCode Sample 44.1.: Processing a file line-by-line in PHP\nThe two conditionals above check that the file opened successfully. If opening the file\nfailed, fopen() returns false (and the interpreter issues warning).\n44.2. Reading & Writing\nWhen a file is opened, the file handle returned by fopen() initially points to the\nbeginning of the file. As you read or write from it, the resource advances through the file\ncontent.\nReading\nThere are a couple of ways to read input from a file. To read a file line by line, we\ncan use fgets() to get each line. It takes a single argument: the file handle that\nwas returned by fopen() and returns a string containing the entire line including the\nendline character. If necessary, leading and trailing whitespace can be removed using\ntrim(). To determine the end of a file you can use feof() which returns true when\nthe handle has reached the end of the file. Code Sample 44.1 contains a full example of\nprocessing a file line-by-line.\nAlternatively there is a convenient function, file_get_contents() that will retrieve\nthe entire file as a string.\n$fileContents = file_get_contents(\".\/inputFile.txt\");\nWriting\nThere are several ways that we can output to files, but the easiest is to simply use\nfwrite() (short for file write). This is a \u201cbinary-safe\u201d file output function that takes\ntwo arguments: the file handle to write to and a string of data to be written. It also\nreturns an integer representing the number of bytes written to the file (or false on\n564 44.2. Reading & Writing\nerror).\n$x = 10;\n1\n$y = 3.14;\n2\n3\n\/\/write to a plaintext file\n4\nfwrite($output, \"Hello World!\\n\");\n5\nfwrite($output, \"x = $x, y = $y\\n\");\n6\n44.2.1. Using URLs\nA nice feature of PHP is that you can use URLs as file names to read and write to a URL.\n\u201cReading\u201d from a URL mean connecting to a remote resource, such as a webservice and\ndownloading its contents (which may be HTML, XML or JSON data). Writing to a URL\nmay be used to post data to a web page in order to receive a response.\nAs an example, we can download a webpage in PHP as follows.\n$h = fopen(\"http:\/\/cse.unl.edu\", \"r\");\n1\n$contents = \"\";\n2\nwhile(!feof($h)) {\n3\n$contents .= fgets($h);\n4\n}\n5\n6\n\/\/or just:\n7\n$contents = file_get_contents(\"http:\/\/cse.unl.edu\");\n8\n44.2.2. Closing Files\nOnce you are done processing a file, you should close it using the fclose() function.\nfclose($h);\nwhich takes a single argument, the file handle that you wish to close.\n565  45. Objects\nObject-oriented features have been continually added to PHP with each new version.\nStarting with version 5, PHP has had a full, class-based object-oriented programming\nsupport, meaning that it facilitates the creation of objects through the use of classes and\nclass declarations. Classes are essentially \u201cblueprints\u201d for creating instances of objects.\nAn object is an entity that is characterized by identity, state and behavior. The identity\nof an object is an aspect that distinguishes it from other objects. The variables and\nvalues that a variable takes on within an object is its state. Typically the variables that\nbelong to an object are referred to as member variables. Finally, an object may also\nhave functions that operate on the data of an object. In the context of object-oriented\nprogramming, a function that belongs to an object is referred to as a member method.\nA class declaration specifies the member variables and member methods that belong\nto instances of the class. We discuss how to create and use instances of a class below.\nHowever, to begin, let\u2019s define a class that models a student by defining member variables\nto support a first name, last name, a unique identifier, and GPA.\nTo declare a class, we use the class keyword. Inside the class (denoted by curly\nbrackets), we place any code that belongs to the class. To declare member variables in a\nclass, we specify the variable names and their visibility inside the class, but outside any\nmethods in the class.\nclass Student {\n1\n2\n\/\/member variables:\n3\nprivate $firstName;\n4\nprivate $lastName;\n5\nprivate $id;\n6\nprivate $gpa;\n7\n8\n}\n9\nTo organize code, it is common practice to place class declarations in separate files with\nthe same name as the class. For example, this Student class declaration would be\nplaced in a file named Student.php and included in any other script files that utilized\nthe class.\n567 45. Objects\n45.1. Data Visibility\nRecall that encapsulation involves not only the grouping of data, but the protection of\ndata. The class declaration above achieves the grouping of data. To provide for the\nprotection of data, PHP defines several visibility keywords that specify what segments\nof code can \u201csee\u201d the variables. Visibility in this context determines whether or not a\nsegment of code can access and\/or modify the variable\u2019s value. PHP defines three levels\nof visibility using they keywords public, protected and private. Each of these\nkeywords can be applied to both member variables and member methods.\n\u2022 public \u2013 This is the least restrictive visibility level and makes the member variable\nvisible to any code segment.\n\u2022 protected \u2013 This is a bit more restrictive and makes it so that the member\nvariable is only visible to the code in the same class, or any subclass of the class.1\n\u2022 private \u2013 this is the most restrictive visibility level, private member variables\nare only visible to instances of the class itself.\nTable 45.1 summarizes these four keywords with respect to their access levels. It is\nimportant to understand that protection is in the context of encapsulation and does\nnot involve protection in the sense of \u201csecurity.\u201d Protection is this context is a design\nprinciple. Limiting the access of variables only affects how the rest of the code base\ninteracts with our class and its data.\nModifier Class Subclass World\npublic Y Y Y\nprotected Y Y N\nprivate Y N N\nTable 45.1.: PHP Visibility Keywords & Access Levels\nIn general, it is best practice to make member variables private and control access to\nthem via accessor and mutator methods (see below) unless there is a compelling design\nreason to increase their visibility.\n45.2. Methods\nThe third aspect of encapsulation involves the grouping of methods that act on an object\u2019s\ndata. Within a class, we can declare member methods using the syntax we\u2019re already\nfamiliar with. We declare a member method by using the keyword function and\nproviding a signature and body. We can use the same visibility keywords as with member\n1Subclasses are involved with inheritance, another object-oriented programming concept that we will\nnot discuss here.\n568 45.2. Methods\nvariables in order allow or restrict access to the methods. With methods, visibility and\naccess determine whether or not the method may be invoked.\nWe add to our example by providing two public methods that compute and return a\nresult on the member variables. We also use javadoc-style comments to document each\nmember method.\nclass Student {\n1\n2\n\/\/member variables:\n3\nprivate $firstName;\n4\nprivate $lastName;\n5\nprivate $id;\n6\nprivate $gpa;\n7\n8\n\/**\n9\n* Returns a formatted String of the Student's\n10\n* name as Last, First.\n11\n*\/\n12\npublic function getFormattedName() {\n13\nreturn $this->lastName . \", \" . $this->firstName;\n14\n}\n15\n16\n\/**\n17\n* Scales the GPA, which is assumed to be on a\n18\n* 4.0 scale to a percentage.\n19\n*\/\n20\npublic function getGpaAsPercentage() {\n21\nreturn $this->gpa \/ 4.0;\n22\n}\n23\n24\n}\n25\nThere is some new syntax in the example above. In the member methods, we need a way\nto refer to the instance\u2019s member variables. The keyword $this is used to refer to the\ninstance, this is known as open recursion.\nWhen an instance of a class is created, for example,\n$s = new Student();\nthe reference variable $s is how we can refer to it. This variable, however, exists outside\nthe class. Inside the class, we need a way to refer to the instance itself. Since we don\u2019t\nhave a variable inside the class to reference the instance itself, PHP provides the keyword\n$this in order to do so. Then, to access the member variables we use the arrow operator\n569 45. Objects\n(more below) and reference the member variable via its identifier but with no dollar sign.2\n45.2.1. Accessor & Mutator Methods\nSince we have made all the member variables private, no code outside the class may\naccess or modify their values. It is generally good practice to make member variables\nprivate to restrict access. However, if we still want code outside the object to access or\nmutate (that is, change) the variable values, we can define accessor and mutator methods\n(or simply getter and setter methods) to facilitate this.\nEach getter method returns the value of the instance\u2019s variable while each setter method\ntakes a value and sets the instance\u2019s variable to the new value. It is common to name\neach getter\/setter by prefixing a get and set to the variable\u2019s name using lower camel\ncasing. For example:\npublic function getFirstName() {\n1\nreturn $this->firstName;\n2\n}\n3\n4\npublic function setFirstName($firstName) {\n5\n$this->firstName = $firstName;\n6\n}\n7\nOne advantage to using getters and setters (as opposed to naively making everything\npublic) is that you can have greater control over the values that your variables can\ntake. For example, we may want to do some data validation by rejecting null values or\ninvalid values. For example:\npublic function setFirstName($firstName) {\n1\nif($firstName === null) {\n2\nthrow new Exception(\"names cannot be null\");\n3\n} else {\n4\n$this->firstName = $firstName;\n5\n}\n6\n}\n7\n8\npublic function setGpa($gpa) {\n9\nif($gpa < 0.0 || $gpa > 4.0) {\n10\n2You can use the syntax $this->$foo but it will assume that $foo is a string that contains the\nname of another variable, for example, if $foo = \"firstName\"; then $this->$foo would resolve\nto the instance\u2019s $firstName variable. This is useful if your object has been dynamically created\nby adding variables at runtime that were not part of the original class declaration.\n570 45.3. Constructors\nthrow new Exception(\"GPAs must be in [0, 4.0]\");\n11\n} else {\n12\n$this->gpa = $gpa;\n13\n}\n14\n}\n15\nControlling access of member variables through getters and setters is good encapsulation.\nDoing so makes your code more predictable and more testable. Making your member\nvariables public means that any piece of code can change their values. There is no way\nto do validation or prevent bad values.\nIn fact, it is good practice to not even have setter methods. If the value of member\nvariables cannot be changed, it makes the object immutable. Immutability is a nice\nproperty because it makes instances of the class thread-safe. That is, we can use instances\nof the class in a multithreaded program without having to worry about threads changing\nthe values of the instance on one another.\n45.3. Constructors\nIf we make the (good) design decision to make our class immutable, we still need a way\nto initialize the values. This is where a constructor comes in. A constructor is a special\nmethod that specifies how an object is constructed. With built-in variable types such as\nan numbers or strings, PHP \u201cknows\u201d how to interpret and assign a value. However, with\nuser-defined objects such as our Student class, we need to specify how the object is\ncreated.\nJust as with functions outside of classes, PHP does not support function overloading\ninside classes. That is, you can have one and only one function with a given identifier\n(name). Thus, there is only one possible constructor. Moreover, PHP reserves the\nname __construct for the constructor method. The two underscores are a naming\nconvention used by PHP to denote \u201cmagic methods\u201d that are reserved and have a special\npurpose in the language. Further, magic methods must be made public. Some magic\nmethods provide default behavior while others do not. For example, if you do not define\na constructor method, the default behavior will be to create an object whose member\nvariables all have null values.\nThe following constructor allows a user to construct an instance of our Student instance\nand specify all four member variables.\npublic function __construct($firstName, $lastName, $id, $gpa) {\n1\n$this->firstName = $firstName;\n2\n$this->lastName = $lastName;\n3\n$this->id = $id;\n4\n$this->gpa = $gpa;\n5\n571 45. Objects\n}\n6\nThough we cannot define multiple constructors, we can use the default value feature\nof PHP functions to allow a user to call our constructor with a different number of\nparameters. For example,\npublic function __construct($firstName, $lastName,\n1\n$id = 0, $gpa = 0.0) {\n2\n$this->firstName = $firstName;\n3\n$this->lastName = $lastName;\n4\n$this->id = $id;\n5\n$this->gpa = $gpa;\n6\n}\n7\n45.4. Usage\nOnce we have defined our class and its constructors, we can create and use instances of\nit. With regular variables, we simply need to assign them to an instance of an object\nand their type will dynamically change to match. To create new instances, we invoke a\nconstructor by using the new keyword and providing arguments to the constructor.\n$s = new Student(\"Alan\", \"Turing\", 1234, 3.4);\n1\n$t = new Student(\"Margaret\", \"Hamilton\", 4321, 3.9);\n2\n$u = new Student(\"John\", \"Smith\");\n3\nThe process of creating a new instance by invoking a constructor is referred to as\ninstantiation. Once instances have been instantiated, they can be used by invoking their\nmethods via the same arrow operator we used to access member variables. Outside the\nclass, however this will only work if the member method is public.\nprint $t->getFormattedName() . \"\\n\";\n1\n2\nif($s->getGpa() < $t->getGpa()) {\n3\nprint $t->getFirstName() . \" has a better GPA\\n\";\n4\n}\n5\n572 45.5. Common Methods\n45.5. Common Methods\nAnother useful magic method is the __toString() method which returns a string\nrepresentation of the object. Unlike the constructor method, there is no default behavior\nwith the __toString() method. If you do not define this function, it cannot be used\n(and any attempts to do so will result in a fatal error). We can define the method to\nreturn the values of all or some of the class\u2019s variables in whatever format we want.\npublic function __toString() {\n1\nreturn sprintf(\"%s, %s (ID = %d); %.2f\",\n2\n$this->lastName,\n3\n$this->firstName,\n4\n$this->id,\n5\n$this->gpa);\n6\n}\n7\nThis would return a string containing something similar to\n\"Hamilton, Margaret (ID = 4321); 3.90\"\n45.6. Composition\nAnother important concept when designing classes is composition. Composition is a\nmechanism by which an object is made up of other objects. One object is said to \u201cown\u201d\nan instance of another object.\nTo illustrate the importance of composition, we could extend the design of our Student\nclass to include a date of birth. However, a date of birth is also made up of multiple\npieces of data (a year, a month, a date, and maybe even a time and\/or locale). We could\ndesign our own date\/time class to model this, but its generally best to use what the\nlanguage already provides. PHP 5.2 introduced the DateTime object in which there is\na lot of functionality supporting the representation and comparison of dates and time.\nWe can take this concept further and have our own user-defined classes own instances of\neach other. For example, we could define a Course class and then update our Student\nclass to own a collection of Course objects representing a student\u2019s class schedule\n(this type of collection ownership is sometimes referred to as aggregation rather than\ncomposition).\nBoth of these design updates beg the question: who is responsible for instantiating the\ninstances of $dateOfBirth and the $schedule? Should we force the \u201coutside\u201d user of\nour Student class to build a DateTime instance and pass it to a constructor? Should\nwe allow the outside code to simply provide us a date of birth as a string and make the\nconstructor responsible for creating the proper DateTime instance? Do we require that\na user create a complete array of Course instances and provide it to the constructor at\ninstantiation?\n573 45. Objects\nA more flexible approach might be to allow the construction of a Student instance\nwithout having to provide a course schedule. Instead, we could add a method that\nallowed the outside code to add a course to the student. For example,\npublic function addCourse($c) {\n1\n$this->schedule[] = $c;\n2\n}\n3\nThis adds some flexibility to our object, but removes the immutability property. Design\nis always a balance and compromise between competing considerations.\n45.7. Example\nWe present the full and completed Student class in Code Sample 45.1.\n574 45.7. Example\n<?php\n1\nclass Student {\n2\n3\nprivate $firstName;\n4\nprivate $lastName;\n5\nprivate $id;\n6\nprivate $gpa;\n7\nprivate $dateOfBirth;\n8\nprivate $schedule;\n9\n10\npublic function __construct($firstName, $lastName, $id = 0, $gpa = 0.0,\n11\n$dateOfBirth = null, $schedule = array()) {\n12\n$this->firstName = $firstName;\n13\n$this->lastName = $lastName;\n14\n$this->id = $id;\n15\n$this->gpa = $gpa;\n16\n$this->dateOfBirth = new DateTime($dateOfBirth);\n17\n$this->schedule = $schedule;\n18\n}\n19\n20\npublic function __toString() {\n21\nreturn $this->getFormattedName() . \" born \" .\n22\n$this->dateOfBirth->format(\"Y-m-d\");\n23\n}\n24\n25\n\/**\n26\n* Returns a formatted String of the Student's\n27\n* name as Last, First.\n28\n*\/\n29\npublic function getFormattedName() {\n30\nreturn $this->lastName . \", \" . $this->firstName;\n31\n}\n32\n33\n\/**\n34\n* Scales the GPA, which is assumed to be on a\n35\n* 4.0 scale to a percentage.\n36\n*\/\n37\npublic function getGpaAsPercentage() {\n38\nreturn $this->gpa \/ 4.0;\n39\n}\n40\n41\npublic function getFirstName() {\n42\nreturn $this->firstName;\n43\n}\n44\n45\npublic function getLastName() {\n46\n575 45. Objects\nreturn $this->lastName;\n47\n}\n48\n49\npublic function getId() {\n50\nreturn $this->id;\n51\n}\n52\n53\npublic function getGpa() {\n54\nreturn $this->gpa;\n55\n}\n56\n57\npublic function addCourse($c) {\n58\n$this->schedule[] = $c;\n59\n}\n60\n61\n}\n62\n63\n?>\n64\nCode Sample 45.1.: The completed PHP Student class.\n576 46. Recursion\nPHP supports recursion with no special syntax necessary. However, recursion is generally\nexpensive and iterative or other non-recursive solutions are generally preferred. We\npresent a few examples to demonstrate how to write recursive functions in PHP.\nThe first example of a recursive function we gave was the toy count down example. In\nPHP it could be implemented as follows.\nfunction countDown($n) {\n1\nif($n===0) {\n2\nprintf(\"Happy New Year!\\n\");\n3\n} else {\n4\nprintf(\"%d\\n\", $n);\n5\ncountDown($n-1);\n6\n}\n7\n}\n8\nAs another example that actually does something useful, consider the following recursive\nsummation function that takes an array, its size and an index variable. The recursion\nworksasfollows: iftheindexvariablehasreachedthesizeofthearray, itstopsandreturns\nzero (the base case). Otherwise, it makes a recursive call to recSum(), incrementing\nthe index variable by 1. When the function returns, it adds the result to the i-th element\nin the array. To invoke this function we would call it with an initial value of 0 for the\nindex variable: recSum($arr, 0).\nfunction recSum($arr, $i) {\n1\nif($i === count($arr)) {\n2\nreturn 0;\n3\n} else {\n4\nreturn recSum($arr, $i+1) + $arr[$i];\n5\n}\n6\n}\n7\nThis example was not tail-recursive as the recursive call was not the final operation (the\nsum was the final operation). To make this function tail recursive, we can carry the\nsummation through to each function call ensuring that the summation is done prior to\n577 46. Recursion\nthe recursive function call.\nfunction recSumTail($arr, $i, $sum) {\n1\nif($i === count($arr)) {\n2\nreturn $sum;\n3\n} else {\n4\nreturn recSumTail($arr, $i+1, $sum + $arr[$i]);\n5\n}\n6\n}\n7\nAs a final example, consider the following PHP implementation of the naive recursive\nFibonacci sequence. An additional condition has been included to check for \u201cinvalid\u201d\nnegative values of n for which we throw an exception.\nfunction fibonacci($n) {\n1\nif($n < 0) {\n2\nthrow new Exception(\"Undefined for n<0.\");\n3\n} else if($n <= 1) {\n4\nreturn 1;\n5\n} else {\n6\nreturn fibonacci($n-1) + fibonacci($n-2);\n7\n}\n8\n}\n9\nPHP is not a language that provides implicit memoization. Instead, we need to explicitly\nkeep track of values using a table. In the following example, the table is passed through\nas an argument.\nfunction fibonacciMemoization($n, $table) {\n1\nif($n < 0) {\n2\nreturn 0;\n3\n} else if($n <= 1) {\n4\nreturn 1;\n5\n} else if(isset($table[$n])) {\n6\nreturn $table[$n];\n7\n} else {\n8\n$a = fibonacciMemoization($n-1, $table);\n9\n$b = fibonacciMemoization($n-2, $table);\n10\n$result = ($a + $b);\n11\n$table[$n] = $result;\n12\nreturn $result;\n13\n578 }\n14\n}\n15\n579  47. Searching & Sorting\nPHP provides over a dozen different sorting functions each with different properties and\nbehavior. Recall that PHP has associative arrays which store elements as key-value\npairs. Some functions sort by keys, others sort by the value (with some in ascending\norder, others in descending order). Some functions preserve the key-value mapping\nand others do not. For simplicity, we will focus on two of the most common sorting\nfunctions, sort(), which sorts the elements in ascending order and usort() which\nsorts according to a comparator function.\n47.1. Comparator Functions\nConsider a \u201cgeneric\u201d Quick Sort algorithm as was presented in Algorithm 12.6. The\nalgorithm itself specifies how to sort elements, but it doesn\u2019t specify how they are ordered.\nThe difference is subtle but important. Quick Sort needs to know when two elements, a,b\nare in order, out of order, or equivalent in order to decide which partition each element\ngoes in. However, it doesn\u2019t \u201cknow\u201d anything about the elements a and b themselves.\nThey could be numbers, they could be strings, they could be user-defined objects.\nA sorting algorithm still needs to be able to determine the proper ordering in order\nto sort. In PHP this is achieved through a comparator function, which is a function\nthat is responsible for comparing two elements and determining their proper order. A\ncomparator function has the following signature and behavior.\n\u2022 The function takes two elements $a and $b to be compared.\n\u2022 The function returns an integer indicating the relative ordering of the two elements:\n\u2013 It returns something negative if $a comes before $b (that is, a < b)\n\u2013 It returns zero if $a and $b are equal (a = b)\n\u2013 It returns something positive if $a comes after $b (that is, a > b)\nThere is no guarantee on the value\u2019s magnitude, it does not necessarily return \u22121 or +1;\nit just returns something negative or positive. We\u2019ve previously seen this pattern when\ncomparing strings. The standard PHP library provides a function, strcmp($a, $b)\nthat has the same contract: it takes two strings and returns something negative, zero or\nsomething positive depending on the lexicographic ordering of the two strings.\nThe PHP language \u201cknows\u201d how to compare built-in types like numbers and strings.\nHowever, to generalize the comparison operation, we can define comparator functions\n581 47. Searching & Sorting\nthat encapsulate more complex logic. As a simple first example, let\u2019s write a comparator\nfunction that orders numbers in ascending order.\nfunction cmpInt($a, $b) {\n1\nif($a < $b) {\n2\nreturn -1;\n3\n} else if($a === $b) {\n4\nreturn 0;\n5\n} else {\n6\nreturn -1;\n7\n}\n8\n}\n9\nWhat if we wanted to order integers in the opposite order? We could write another\ncomparator in which the comparisons or values are reversed. Even simpler, we could\nreuse the comparator above and \u201cflip\u201d the sign by multiplying by \u22121 (this is one of the\npurposes of writing functions: code reuse). Even simpler still, we could just flip the\narguments we pass to cmpInt() to reverse the order.\nfunction cmpIntDesc($a, $b) {\n1\nreturn cmpInt($b, $a);\n2\n}\n3\nTo illustrate some more examples, consider the Student class we defined in Code\nSample 45.1. The following code samples demonstrate various ways of ordering Student\ninstances based on one or more of their components.\n\/**\n1\n* A comparator function to order Student instances by\n2\n* last name\/first name in alphabetic order\n3\n*\/\n4\nfunction studentByNameCmp($a, $b) {\n5\nint result = strcmp($a->getLastName(), $b->getLastName());\n6\nif(result == 0) {\n7\nreturn strcmp($a->getFirstName(), $b->getFirstName());\n8\n} else {\n9\nreturn result;\n10\n}\n11\n}\n12\n582 47.1. Comparator Functions\n\/**\n1\n* A comparator function to order Student instances by\n2\n* last name\/first name in reverse alphabetic order\n3\n*\/\n4\nfunction studentByNameCmpDesc($a, $b) {\n5\nreturn studentByNameCmp($b, $a);\n6\n}\n7\n\/**\n1\n* A comparator function to order Student instances by\n2\n* id in ascending numerical order\n3\n*\/\n4\nfunction studentIdCmp($a, $b) {\n5\nif($a->getId() < $b->getId()) {\n6\nreturn -1;\n7\n} else if($a->getId() === $b->getId()) {\n8\nreturn 0;\n9\n} else {\n10\nreturn 1;\n11\n}\n12\n}\n13\n\/**\n1\n* A comparator function to order Student instances by\n2\n* GPA in descending order\n3\n*\/\n4\nfunction studentGpaCmp($a, $b) {\n5\nif($a->getGpa() > $b->getGpa()) {\n6\nreturn -1;\n7\n} else if($a->getGpa() == $b->getGpa()) {\n8\nreturn 0;\n9\n} else {\n10\nreturn 1;\n11\n}\n12\n}\n13\n583 47. Searching & Sorting\n47.1.1. Searching\nPHP provides a linear search function, array_search() that can be used to search for\nan element in an array. The array can be specified to use loose comparisons (default) or\nstrict comparisons. It returns the key (i.e. index) of the first matching element it finds\nand false if the search was unsuccessful. For example:\n$arr = array(10, 8, 3, 12, 4, 42, 7, 108);\n1\n$index = array_search(12, $arr); \/\/index is now 3\n2\n3\n$arr = array(\"hello\", 10, \"mixed\", 12, \"20\");\n4\n\/\/a loose search:\n5\n$index = array_search(20, $arr); \/\/index is now 4\n6\n\/\/a strict search:\n7\n$index = array_search(20, $arr, false); \/\/index is now false.\n8\nPHP does not provide a standard binary search function. Though you can write your\nown binary search implementation, likely the reason that that PHP does not provide\none is because one is not needed. The purpose of binary search is to search a sorted\narray efficiently. However, PHP arrays are not usual arrays: they are associative arrays,\nessentially key-value maps. Retrieving an element via its key is essentially a constant-time\noperation, even more efficient that binary search. A better solution may be to simply\nstore the elements using a proper key which can be used to retrieve the element later on.\n47.1.2. Sorting\nPHP\u2019s sort() function can be used to sort elements in ascending order. This is useful\nif you have arrays of numbers or strings, but doesn\u2019t work very well if you have an array\nof mixed types or objects.\n$arr = array(\"banana\", \"Apple\", \"zebra\", \"apple\", \"bananas\");\n1\nsort($arr);\n2\n\/\/arr is now (\"Apple\", \"apple\", \"banana\", \"bananas\", \"zebra\")\n3\n4\n$arr = array(10, 8, 3, 12, 4, 42, 7, 108);\n5\nsort($arr);\n6\n\/\/arr is now (3, 4, 7, 8, 10, 12, 42, 108)\n7\nPHP provides a more versatile sorting function, usort() (user defined sort) that\naccepts a comparator function that it uses to define the ordering of elements. To pass\na comparator function to the usort() function, we pass a string value containing the\n584 47.1. Comparator Functions\nname of the comparator function we wish to use. Recall that function names in PHP are\ncase insensitive, though it is still best practice to match the naming. Several examples of\nthe usage of this function are presented in Code Sample 47.1.\n$arr = array(10, 8, 3, 12, 4, 42, 7, 108);\n1\nusort($arr, \"cmpIntDesc\");\n2\n\/\/arr is now 108, 42, 12, 10, 8, 7, 4, 3\n3\n4\n\/\/roster is an array of Student instances\n5\n$roster = ...\n6\n7\n\/\/sort by name:\n8\nusort($roster, \"studentByNameCmp\");\n9\n10\n\/\/sort by ID:\n11\nusort($roster, \"studentIdCmp\");\n12\n13\n\/\/sort by GPA:\n14\nusort($roster, \"studentGpaCmp\");\n15\nCode Sample 47.1.: Using PHP\u2019s usort() Function\n585  Glossary\nabstraction a technique for managing complexity whereby levels of complexity are\nestablished so that higher levels do not see or have to worry about details at lower\nlevels.\nacceptance testing a phase of software testing that is tested, usually by humans, for\nacceptability and whether or not it fulfills the business requirements.\nad-hoc testing informal software testing method that is done without much planning\nusuallyasa\u201csanitycheck\u201dtoseeifapieceofcodeworksandintendedforimmediate\nfeedback.\nalgorithm a process or method that consists of a specified step-by-step set of operations.\n17\nanonymous class a class that is defined \u201cinline\u201d without declaring a named class; typi-\ncally created because the instance has a single use and there is no reason to create\nmultiple instances. 484\nanonymous function a function that has no identifier or name, typically created so that\nit can be passed as an argument to another function as a callback. 144\nanti-pattern a common software pattern that is used as a solution to recurring problems\nthat is usually ineffective in solving the problem or introduces risks and other\nproblems; a technical term for common \u201cbad-habits\u201d that can be found in software.\n152\narray an ordered collection of pieces of data, usually of the same type.\nassignment operator an operator that allows a user to assign a value to a variable. 33\nbackward compatible a program, code, library, or standard that is compatible with\nprevious versions so that current and older versions of it can coexist and successfully\noperate without breaking anything. 29\nbar a placeholder name. , see foo\nbaz a placeholder name. , see foo\n587 Glossary\nbike shedding a phenomenon in projects where a disproportionate amount of time is\nspent on trivial matters at the expense of spending adequate resources on more\nimportant matters. The term was applied to software development by Kamp [24]\nbut derives from Parkinson\u2019s law of triviality [31].\nbit the basic unit of information in a digital computer. A bit can be either 1 or 0\n(alternatively, true\/false, on\/off, high voltage\/low voltage, etc.). Originally a\nportmanteau (mash up) of binary digit. 4, 22, 23\nBoolean a data type that represents the truth value of a logical statement. Booleans\ntypically have only two values: true or false. 30\nbug A flaw or mistake in a computer program that results in incorrect behavior that may\nhave unintended such as errors or failure. The term predates modern computer\nsystems but was popularized by Grace Hopper who, when working with the Mark\nII computer in 1946 traced a system failure to a moth stuck in a relay. 46, 81, 151\nbyte a unit of information in a digital computer consisting of 8 bits. 4\ncache a component or data structure that stores data in an efficiently retrievable manner\nso that future requests for the data are fast. 208\ncall by reference when a variable\u2019s memory address is passed as a parameter to a\nfunction, enabling the function to manipulate the contents of the memory address\nand change the original variable\u2019s value. 142\ncall by value when a copy of a variable\u2019s value is passed as a parameter to a function;\nthe function has no reference to the original variable and thus changes to the copy\ninside the function have no effect on the original variable. 140\ncallback a function or executable unit of code that is passed as an argument to another\nfunction with the intention that the function that it is passed to will execute or\n\u201ccall back\u201d the passed function at some point. 144, 366\ncargo cult programming refers to the act of including code, patterns, or processes with\nno real purpose due to a lack of understanding of a bug or of the problem they\nwere attempting to solve or a lack of understanding of the copied code\/pattern\nitself or an inability to adapt it properly..\ncase sensitive a language is case sensitive if it recognizes differences between lower and\nupper case characters in identifier names. A language is case insensitive if it does\nnot.. 19\nchomp the operation of removing any endline characters from a string (especially when\nread from a file); may also refer more generally to removing leading and trailing\nwhitespace from a string or \u201ctrimming\u201d it. 337,\n588 Glossary\nclosure a function with its own environment in which variables exist. 485\ncode smell a symptom or common pattern in source code that is usually indicative of\na deeper problem or design flaw; smells are usually not bugs and may not cause\nproblems in and of themselves, but instead indicate a pattern of carelessness or low\nquality of software design or implementation. 152\ncomparator a function or object that allows you to pass in two elements a,b for com-\nparison and returns an integer indicating their relative order: something negative,\nzero, or something positive if a < b, a = b or a > b respectively. 178, 331, 560\ncompile the process of translating code in a high-level programming language to a low\nlevel language such as assembly or machine code.\ncomputer engineering a discipline integrating electrical engineering and computer sci-\nence that tends to focus on the development of hardware and its interaction with\nsoftware.\ncomputer science the mathematical modeling and scientific study of computation.\nconcatenation the process of combining two (or more) strings to create a new string by\nappending one of them to the end of the other. 178\nconstant a variable whose value cannot be changed once set.\ncontinuous integration a software development\/engineering process by which developer\ncode is merged and shared on a frequent basis.\ncontradiction a logical statement that is always false regardless of the truth values of\nthe statement\u2019s variables. 72\ncontrol flow the order in which individual statements in a program are executed or\nevaluated. 75\nConway\u2019s Law an observation that organizations that build software will inevitably\ndesign it as modeling the structure of the organization itself. Attributed to Melvin\nConway (1967) who originally stated it as \u201corganizations which design systems\n...are constrained to produce designs which are copies of the communication\nstructures of these organizations\u201d.\ncopy pasta bad coding practice of copy-pasting code and making slight changes when a\nfunction or other control structure should be written instead. Copy-pasta practices\noften lead to poorly designed code, bugs or spaghetti code..\ncruft anything that is left over, redundant or getting in the way; in the context of code\ncruft is code that is no longer needed, legacy or simply poorly written source code.\n589 Glossary\ndangling pointer when a reference to dynamically allocated memory is lost and the\nmemory can no longer be deallocated, resulting in a memory leak. Alternatively,\nwhen a reference points to memory that gets deallocated or reallocated but the\npointer remains unmodified, still referencing the deallocated memory. 165\ndead code a code segment that has no effect on a program either because it is unused\nor unreachable (the conditions involving the code will never be satisfied). 72\ndebug the process of analyzing a program to find a fault or error with the code that\nleads to bad or unexpected results. 152\ndebugger a software tool that facilitates debugging; usually a debugger simulates the\nexecution of a program allowing a developer to view the contents of a program as\nit executes and to \u201cwalk\u201d through the execution step by step. 152\ndeep copy in contrast to a shallow copy, a deep copy is a copy of an array or other piece\nof data that is distinct from the original. Changes to one copy do not affect the\nother. 166, 319, 443, 449, 557\ndefensive programming an approach to programming in which error conditions are\nchecked and handled, preventing undefined or erroneous operations from happening\nin a program. 38, 48, 84\ndynamic programming a technique for solving problems that involves iteratively com-\nputing values to subproblems, storing them in a table so that they can be used to\nsolve larger versions of the problem. 208\ndynamic typing a variable whose type can change during runtime based on the value it\nis assigned. 31,\nedge case a situation or input that represents an extreme value or parameter.\nencapsulation the grouping and protection of data together into one logical entity along\nwith the functionality (functions or methods) that act on that data. 30\nenumerated type a data type (usually user defined) that consists of a list of named\nvalues. 309, 436\nexception an event or occurrence of an erroneous or \u201cexceptional\u201d condition that inter-\nrupts the normal flow of control in a program, handing control over to exception\nhandler(s). 155\nexpression a combination of values, constants, literals, variables, operators and possibly\nfunction calls such that when evaluated, produce a resulting value. 34\nfile a resource on a computer stored in memory that holds data. 183\n590 Glossary\nflowchart a diagram that represents an algorithm or process, showing steps as boxes\nconnected by arrows which establish an order or flow. 17\nfoo along with \u201cbar,\u201d \u201cbaz,\u201d and the full \u201cfoobar\u201d, foo is a commonly used placeholder\nname in programming used to denote generic variables, functions, etc. Usually\nthese terms are used as examples when demonstrating a concept. The terms have\na long history [21].\nfoobar a placeholder name. , see foo\nfunction a sequence of program instructions that perform a specific task, packaged as a\nunit, also known as a subroutine. 133\nfunction overloading the ability to define multiple functions with the same name but\nwith with a different number of or different types of parameters. 145\nfuzzing An automated software testing technique that involves providing invalid or\nrandom data as input to a program or piece of code to test that it fails in an\nexpected manner..\ngarbage collection automated memory management in which a garbage collector at-\ntempts to reclaim memory (garbage) that is no longer being used by a program so\nthat it can be reallocated for other purposes. 165, 383\nglobal scope a variable, function, or other element in a program has global scope if it is\nvisible or has effect throughout the entire program. 32,\ngrok slang, meaning to understand something; originally from Stranger in a Strange\nLand by Robert A. Heinlein..\nhardware (computer hardware) the physical components that make up a computer\nsystem such as the processor, motherboard, storage devices, input and output\ndevices, etc..\nheisenbug a bug in a program that fails to manifest itself under testing or debugging\nconditions. Derived from the Heisenberg principle which states that you cannot\nobserve something without affecting it, thus tainting your observations..\nhexadecimal base-16 number system using the symbols 0, 1, ..., 9, A, B, C, D, E, F;\nusually denoted with a prefix 0x such as 0xff1321ab01. 470\nhoisting usually used in interpreted languages, hoisting involves processing code to find\nvariable or function declarations and processing them before actually executing the\ncode or script. 134\nidentifier a symbol, token, or label that is used to refer to a variable. Essentially, a\nvariable\u2019s name. 18\n591 Glossary\nidiom in the context of programming, an idiom is a commonly used pattern, expression\nor way of structuring code that is well-understood for users of the language. For\nexample, a for-loop structure that iterates over elements in an array. May also refer\nto a programming design pattern.. 315,\nimmutable an object whose internal state cannot be changed once created, alternatively,\none whose internal state cannot be observably changed once created. 390, 423, 449,\n466, 571\ninheritance an object oriented programming principle that allows you to derive an object\nfrom another object, usually to allow for more specificity.\ninput data or information that is provided to a computer program for processing. 41\nintegration testing a type of software testing used to determine if the integration of\ndifferent components or modules works or not.\ninteractive a program that is designed to interface with humans by prompting them for\ninput and displaying output directly to them. 41\ninteractive an informal, abstract, high-level description of a process or algorithm. 41\nkeyword a word in a programming language with a special meaning in a particular\ncontext. In contrast to a reserved word, a keyword may be used for an identifier\n(variable or function name) but it is strongly discouraged to do so as the keyword\nalready has an intended meaning.\nkilobyte a unit of information in a digital computer consisting of 1024 bytes (equivalently,\n210 bytes), KB for short.\nkludge a poorly designed or \u201cthrown-together\u201d solution; a design that is a collection of\nill-fitting parts that may be functional, but is fragile and not easily maintained.\nlambda expression another term for anonymous functions. 144, 493\nlexicographic a generalization of the usual dictionary order as codified with the ASCII\ncharacter table. 178\nlinking the process of generating an executable file from (multiple) object files.\nlint (or linter) a static code analysis tool that analyzes code for suspicious or error-prone\ncode that is likely to cause problems. 152\nliteral in a programming language, a literal is notation for specifying a value such as a\nnumber of string that can be directly assigned to a variable. 29, 34\nload testing a form of performance testing used to determine to what extent a piece of\nsoftware or a system can handle a high demand or \u201cload\u201d.\n592 Glossary\nmagic number a value used in a program with unexplained, undocumented, or am-\nbiguous meaning, usually making the code less understandable. 258, 309, 310,\n437\nmantissa the part of a floating-point number consisting of its significant digits (called a\nsignificand in scientific notation). 25\nmap a data structure that allows you to store elements as key-value pairs with the key\nmapping to a value.\nmemoization a technique which uses a table to store previously computed values of a\nfunction so that they do not need to be recomputed, essentially the table serves as\na cache. 208\nmemory leak the gradual loss of memory when a program fails to deallocate or free up\nunused memory, degrading performance and possibly resulting in the termination\nof the program when memory runs out. 165, 320, 326\nnaming convention a set of guidelines for choosing identifier names for variables, func-\ntions, etc. in a programming language. Conventions may be generally accepted\nby all developers of a particular language or they may be established for use in a\nparticular library, framework, or organization. 20\nnetwork a collection of two or more computer systems linked together through a physical\nconnection over which data can be transmitted using some protocol.\noctal base-8 number system using the symbols 0, 1, 2, ..., 6, 7; usually denoted with a\nsingle leading zero such as 0123742.\nopen recursion a mechanism by which an object is able to refer to itself usually using a\nkeyword such as this or self.. 200, 465, 569\noperand the arguments that an operator applies to. 33\noperator a symbol used to denote some transformation that combines or changes the\noperands it is applied to to produce a new value. 33\norder of precedence the order in which operators are evaluated, multiplication is per-\nformed before addition for example. 38\noutput data or information that is produced as the result of the execution of a program.\n41\noverflow when an arithmetic operation results in a number that is larger than the\nspecified type can represent overflow occurs resulting in an invalid result. 39\nparse to process data to identify its individual components or elements. 179,\n593 Glossary\npersistence the characteristic of data that outlives the process or program that created\nit; the saving of data across multiple runs of a program. 183\npointer a reference to a particular memory location in a computer. 30, 295\npolymorphism an object oriented programming concept that allows you to treat a\nvariable, method, or object as different types.\nprimitive a basic data type that is defined and provided by a programming language.\nTypically numeric and character types are primitive types in a language for example.\nGenerally, the user doesn\u2019t need to define the operations involving primitive types\nas they are defined by the language. Primitive data types are used as the basic\nbuilding blocks in a program and used to compose more complex user-defined types.\n30, 390\nprocedural abstraction the concept that a procedure or sequence of operations can be\nencapsulated into one logical unit (function, subroutine, etc.) so that a user need\nnot concern themselves with the low-level details of how it operates. 134\nprogram stack also referred to as a call stack, it is an area of memory where stack\nframes are stored for each function call containing memory for arguments, local\nvariables and return values\/addresses. 137\nprotocol a set of rules or procedures that define how communication takes place.\npseudocode the act of a program asking a user to enter input and subsequently waiting\nfor the user to enter data. 13\nquery an operation that retrieves data, typically from a database. 152\nqueue a data structure that store elements in a FIFO (First-In First-Out) manner;\nelements can be added to the end of a queue by an enqueue operation and removed\nfrom the start of a queue by a dequeue operation.\nradix the base of a number system. Binary, octal, decimal, hexadecimal would be base\n2, 8, 10, and 16 respectively.\nreentrant a function that can be interrupted during its execution while another thread\ncan successfully invoke the function without the two functions interfering with the\ndata used in either function call. 334\nrefactor the process of modifying, updating or restructuring code without changing\nits external behavior; refactoring may be done to make code more efficient, more\nreadable, more reliable, or simply to bring it into compliance with style or coding\nconventions.\nreference a reference in a computer program is a variable that refers to an object or\nfunction in memory. 30\n594 Glossary\nregression testing a type of software testing that tests software that previously passed\ntesting but that was changed or refactored in some way. Regression testing tests\nto see if the software still passes the tests or not in which case it is said to have\n\u201cregressed\u201d.\nregular expression a sequence of characters in which special characters and directives\ncan be used to define a complex pattern that can be searched and matched in\nanother string or data. 455, 561\nreserved word a word or identifier in a language that has a special meaning to the\nsyntax of the language and therefore cannot be used as an identifier in variables,\nfunctions, etc.. 19\nscope the scope of a variable, method, or other entity in a program is the part of the\nprogram in which the name or reference of the entity is bound. That is, the part of\nthe program that \u201cknows\u201d about the variable in which the variable can be accessed,\nchanged, or used. 32, 255, 386\nsegmentation fault a fault or error that arises when a program attempts to access a\nsegment of memory that it is not allowed access to, usually resulting in the program\nbeing terminated by the operating system. 296, 315\nshallow copy in contrast to a deep copy, a shallow copy is merely a reference that refers\nto the original array or piece of data. The two references point to the same data,\nso if the data is modified, both references will realize it.. 166, 319, 443\nshort circuiting the process by which the second operand in a logical statement is not\nevaluated if the value of the expression is determined by the first operand. 74\nsignature a function signature is how a function is uniquely identified. A signature\nincludes the name (identifier) of the function, its parameter list (and maybe types)\nand the return type. 134\nsoftware any set of machine-readable instructions that can be executed in a computer\nprocessor.\nsoftware engineering the study and application of engineering principles to the design,\ndevelopment, and maintenance of complex software systems.\nspaghetti code a negative term used for code that is overly complex, disorganized or\nunstructured code.\nstack a data structure that stores elements in a LIFO (last-in first-out) manner; elements\ncan be added to a stack via a push operation which places the element on the \u201ctop\u201d\nof the stack; elements can be removed from the top of the stack via a pop operation.\n137, 206\n595 Glossary\nstack overflow when a program runs out of stack space, it may result in a stack overflow\nand the termination of the program. 205\nstatic analysis the analysis of software that is performed on source (or object) code\nwithout actually running or compiling a program usually by using an automated\ntool that can detect actual or potential problems with the source code (other than\nsyntactic problems that could easily be found by a compiler). 152\nstatic dispatch when function overloading is supported in a language, this is the mecha-\nnism by which the compiler determines which function should be called based on\nthe number and type of arguments passed to the function when it is called. 145\nstatic typing a variable whose type is specified when it is created (declared) and does\nnot change while the variable remains in scope. 31,\nstring a data type that consists of a sequence of characters which are encoded under\nsome encoding standard such as ASCII or Unicode. 27, 177\nstring concatenation anoperationbywhichastringandanotherdatatypearecombined\nto form a new string. 37\nsyntactic sugar syntax in a language or program that is not absolutely necessary (that\nis, the same thing can be achieved using other syntax), but may be shorter, more\nconvenient, or easier to read\/write. In general, such syntax makes the language\n\u201csweeter\u201d for the humans reading and writing it. 40, 82, 102, 161, 451\ntautology a logical statement that is always true regardless of the truth values of the\nstatement\u2019s variables. 72\ntest case an input\/output pair that is known to be correct that is to be used to test a\nunit of software.\ntest case a collection of tests that are used to test a piece or collection of software.\ntoken whensomething(usuallyastring)isparsed, theindividualcomponentsorelements\nare referred to as tokens. 179\ntop-down design an approach to problem solving where a problem is broken down into\nsmaller parts. 3, 133\ntranspile to (automatically) translate code in one programming language into code\nin another programming language, usually between two high-level programming\nlanguages.\ntruncation removing the fractional part of a floating-point number to make it an integer.\nTruncation is not a rounding operation. 36, 263, 394,\n596 Glossary\ntwo\u2019s complement A way of representing signed (positive and negative) integers using\nthe first bit as a sign bit (0 for positive, 1 for negative) and where negative numbers\nare represented as the complement with respect to 2n (the result of subtracting the\nnumber from 2n) . 24\ntype a variable\u2019s type is the classification of the data it represents which could be\nnumeric, string, boolean, or a user defined type. 22\ntype casting converting or variable\u2019s type into another type, for example, converting an\ninteger into a more general floating-point number, or converting a floating-point\nnumber into an integer, truncating and losing the fractional part. 36, 263, 394\nunderflow when an arithmetic operation involving floating-point numbers results in a\nnumber that is smaller than the smallest representable number underflow occurs\nresulting in an invalid result. 39\nUnicode an international character encoding standard used in programming languages\nand data formats. 449\nunit test software testing method that tests an individual \u201cunit\u201d of code; depending on\nthe context, a unit may refer to an individual function, class, or module.\nunwinding the process of removing a stack frame when returning from a function. 164\nvalidation theprocessofverifyingthatdataiscorrectorconformstocertainexpectations\nincluding formatting, type, range of values, represents a valid value, etc.. 42\nvariable a memory location which stores a value that may be set using an assignment\noperator. Typically a variable is referred to using a name or identifier. 18\nwidget a generic term for a graphical user interface component such as a button or text\nbox.\nyak shaving an ostensibly pointless activity that despite its uselessness allows you to\novercome a a difficulty and solve a larger problem. Basically, screwing around\nuntil you become familiar enough with the problem that the solution presents itself.\nAttributed to Carlin Vieri who took it from an episode of Ren and Stimpy..\n597 "}