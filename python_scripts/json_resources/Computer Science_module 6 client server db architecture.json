{"text":"Module_6 - Client\/Server Architecture\n6.1 - Introduction and Background to Client\/Server Systems and Multi-tier Architecture\nThe client\/server model is the standard model of networked traffic in today's computing\nand database systems. The client\/server model was designed with world wide web services in\nmind and to allow for servers to provide service to end user devices all over the network. This\nmethodology has been adopted as the standard for content publishing and receiving by modern\nnetwork systems.\nFigure 1. A graphic demonstrating the architecture of client\/server systems. From \u201cAn\nIntroduction to Client\/Server Computing\u201d by Yadav SC, Singh SK, 2009.\nFor databases, the model of client\/server is ideal because the database can easily serve\nmultiple users at the same time through standardized calls for information. If multiple users are\nlooking to fetch the same files on a routine basis, tools can be deployed which monitor the trends\nof usage and allow for IT administrators to beef up the systems which serve those files, reducing\nwait times and increasing overall system performance. Similarly, for systems or databases which\nare accessed less frequently, those costs can be avoided.\nPrior to the client\/server architecture, peer-to-peer networking was used. This means that\nfor every request to send or receive, devices would communicate one-to-one, and for each\ntransaction of data, this process had to be repeated. By taking on the role of a \u201cserver\u201d, a system\ncan handle more than one call at once, drastically improving throughput and efficiency. Using the\nclient\/server model gives rise to a very specific set of requirements when designing a transport\nlayer protocol. Generally, a transport layer protocol needs to cover all of the following\nrequirements: a connection between a client and server, an interaction between the client and\nserver, authentication of the client and server, and a checksum or other method to maintain data\nintegrity after having sent and received packets.\nMulti-Tier Architecture (MTA) can be generalized as a separation and duplication of a\nserver\/database system by decentralizing data and compute resources. MTA is used to improve\nreliability and throughput, similarly to client\/server architecture. As such, an MTA environment\nwill almost certainly use client\/server communication.\nMTA systems are composed of 6 basic layers (Wall, D, Morgan Kaufmann):\n\u25cf Persistence: The database which serves files to the applications that service the clients or\nusers.\n\u25cf Accessor: Typically, the SQL server. Not the disks in the database, but the part of the\ndatabase which does the thinking. \u25cf Logic: The applications which the users interact with, in turn providing instructions to the\ndatabase from which files are requested.\n\u25cf Presentation: Systems applications which package data from the database into web\nbrowser languages such as HTML or XML.\n\u25cf Requester\/consumer: The web browser itself; this is on the client side.\n\u25cf Elsewhere: The sources of information hosted on other platforms, such as AWS, Azure,\nor GCP, or other sources of HTML content that are not native.\nFigure 2. A graphic demonstrating the architecture of multi tier architecture. From\n\u201cMulti-Tier Application Programming with PHP: Practical Guide for Architects and\nProgrammers\u201d by Wall, D, Morgan Kaufmann, 2004. 6.2 - Three components of client\/server systems\nThe client\/server model is designed to manage data and facilitate the methods by which\nusers can access it. In the client\/server model, data is shared between one central server that\nhouses and provides access to it and one or more clients that access the data through either a\ndirect or remote feed. By calling requests to the server, clients can access any information they\nhave access to, but clients cannot access information from other clients, as that would represent a\npeer-to-peer system, rather than a client\/server model.\nIn client\/server systems, there are three main components of logic. Presentation logic\ncontrols the inputs and outputs. It \"presents\" the data to the user in a readable format and also\ncollects information that a user inputs using their system. Processing logic oversees everything\naround turning the client request into a request the server can use in the next step to find\ninformation. The final component is storage logic, which handles physical data storage and\nprocesses for retrieving it upon user request.\nFigure 3. Client distribution models (made via Microsoft PowerPoint, Michael Nolan 2020)\nThe way that systems using this model delegate these logical applications defines\nindividual databases further. Two-tier database architecture is divided into three groups named to\nspecify what the client takes care of, as shown in Figure 1. In fat client distribution, presentation\nand processing are both handled by the client system, while the server exclusively handles the\nstorage logic application. In thin client distribution, the client only handles presentation, while\nthe server takes care of processing the request and dealing with storage. Finally, when a two-tier\nsystem is distributed in design, the client and server both handle parts of processing logic. In\nthese sorts of systems, presentation logic is still handled by the client and storage is still handled\nby the server exclusively.\nFurther levels of tiered architecture in databases works similarly to the aforementioned\ndesign ideas, but splits processing logic applications further between multiple intermediate\napplications and web servers before the client's request reaches the database server. a. Presentation\nPresentation logic is the high-level interactive portion of the database. It is where the end-\nuser can input requests and receive output on their host device.\nInput in the presentation level of the client-server model can be many different things.\nGUI elements can be added to make it easier, such as text fields that users can modify, copy, or\ndelete, buttons for submitting requests, menus, links, and more. Output is handled by the system\nto present the server response to user queries in a readable way that gives the user all the\ninformation they need without giving them information they did not request or information to\nwhich they are not allowed access.\nPresentation logic is handled exclusively by client software on the host device. This can\nbe managed by some language such as HTML to quickly take inputs and display outputs in a\ncontrolled location.\nb. Processing\nThe processing logic layer is an intermediary layer that translates information back and\nforth between user language coming from the client software and abstracted language used by the\ndatabase's storage unit to quickly access the correct information. The processing layer also\nhandles business rules, assuming they are not already built into the organizational DBMS.\nProcessing logic has many automated measures defined by business logic and business\nrules that are tailored to the specific company or organization the database is a part of. It is also\nwhere data integrity is insured whenever commands are sent to the storage database.\nApplications for this are generally coded in Java or C, as those languages can be applied\nto many kinds of hardware with ease and offer some scalability without slowing down the\nsystem. Attention needs to be paid to these processes to make sure that this stage of data transfer\ndoes not bottleneck, as the processing logic may have to handle many requests per day.\nProcessing logic is also where the majority of differences in database architecture lie.\nTwo-tier architecture can be split three ways: fat client, thin client, and distributed. Fat client\ndistribution has all processing logic handled on the client's side, so the user host machine sends a\nrequest to the database having already translated the language from the user's input into whatever\nlanguage that specific database uses for queries. Fat client distribution is the most commonly\nused organization of database access in the client-server system. Thin client distribution has all\nprocessing logic handled by the server system. The goal of this is to keep the user interface as\nlight as possible. Distributed systems have processing logic handled by both the client and server\nin a way that boosts efficiency. It is more complex than the other two methods to set up.\nMulti-tier organization splits processing logic in different ways. Three-tier systems may\nhave processing logic all performed on a separate web server that clients and servers both access.\nAbove that, processing can be handled by multiple web and application servers that each manage\nsmaller parts of the translation. The goal of these larger systems is to be more modular and\nscalable while still being easy to maintain, since problems can be pinpointed easily.\nc. Storage\nThe storage logic represents the physical database and storage devices. It is where data\nstorage and retrieval is handled in the system, and it is the part of the client-server system where\nthe DBMS interacts with everything else.\nData in the database can be stored in many different ways. Data can be accessed using the\ninformation provided by the processing applications very quickly. 6.3 Two-tier and three-tier architectural distinctions\nThough many people may not realize it, when a group of tech-savvy individuals develops\nsoftware, one of the most important decisions at the start is the architecture: \u201carchitecture is a key\nfeature which decides that the system will meet its performance and other quality objectives\u201d\n(Hayat and Akram, 2007). Several main components come into play when it comes to deciding\nthe type of architecture, including performance, availability, complexity, and cost.\nPerformance depends on the quantity of simultaneous users that can be processed by the\ndatabase system to ensure smooth processing. Typically, most applications limit the number of\nusers accessing different services of the application by only providing them with restricted data.\nWhile choosing an architecture, it is quite important to keep in mind the performance component.\nAnother significant factor is the cost. The selected architecture must be affordable for any\norganization just starting. Availability is the accessibility of the system to the community of\nusers. Complexity is the extent of difficulty of the system in terms of the user\u2019s and developer\u2019s\nviewpoint. If the developers feel they want a lower level of difficulty, they can make the user\u2019s\nlevel of difficulty rise due to lack of user interface organization\/improvements. However, to\nlower the user\u2019s level of difficulty, the developers may have to increase their effort and\ncontinuously improve, revise, and contemplate new ways to make the user interface easier and\nmore accessible.\nIn two-tier architectures, the interfaces run on a client, which means the client\ncommunicates with the server directly, and because it runs on a client, another data layer or\nstructure is then stored on a server, as seen in Figure 4 below. The client's responsibility covers\nuser interface logic from the presentation, which deals with how objects in the business get\nshown to other users of the software as well as data processing and rules (algorithms) that dictate\nthe information that gets exchanged between the database system and the user interface.\nMeanwhile, database servers access and process requests from the clients. This architecture\nallows for optimization of the processing time in the database servers and is highly recommended\nfor small workgroups. However, clients or servers that use two-tier architecture tend only to\nsupport a relatively small number of users, because the transaction of information is usually low,\nand security is not necessarily the top priority. Because of this, two-tier architectures are not used\nfor applications with large user bases due to their limited flexibility.\nFigure 4 Visual of two-tier architecture (two layers)\n(Made via Draw.io, Martin Nguyen, 2020) In general, three-tier (n-tier) architecture includes another server layer, as seen in Figure 2. This\nextra layer make it much easier to scale the system, which makes performance much better, resulting in a\nhighly flexible and reusable structure. The extra layer can have several purposes, such as an application\nserver, or it can be used as local storage and hold local databases. In contrast, the other servers hold more\nenclosed data. Utilizing a three-tier architecture can lead to better performance, and make it easier to\ntransport application code to other platforms, reducing dependency on commonly domain-specific\nlanguage. Three-tier systems can often be found in Web-based applications\u2014any program accessible\nusing HTTP.\nFigure 2 Visual of three-tier (three or nth layers)\n(Made via Draw.io, Martin Nguyen, 2020)\n6.4 Connecting to databases in three-tier applications\nThree-tier application structure is similar to the 7-layer OSI model of\ntelecommunications, in that it breaks up the presentation, data, and application functions into\neach of their own levels. This segmentation provides for a more streamlined approach to\nscalability and ease of development, since the developer does not have to produce a new web\ntechnology for every instance. Instead, standards such as HTML, CSS, or JavaScript may be\nused.\nWhen connecting to a three-tier based web application, the user will interact with the\npresentation tier. This layer is the visual wrapper between the functionality, database, and UI\nelements. This layer is displayed in a web browser, and served through the World Wide Web or a\nLocal Area Network. Connecting to an IP address using a compatible browser will provide the\nweb page to the user, being provided through a server which hosts the website and has access to\nthe databases which it uses. The presentation tier is largely the visual aspect of a website or\napplication and does not perform the computing or data storage\/retrieval. This layer is important,\nhowever, because data entry and user intent must be clearly interpreted for the right API calls to\nbe made by the presentation layer, to be sent to the application and data tiers.\nBy using a three-tier architecture, developers are able to concurrently work on each tier of\nthe application as they are designing it. This parallel development allows for fewer limitations\ndue to older design which cannot easily be changed. This is relevant to the connection to\ndatabases, due to the ability of the development teams to agree on which APIs and methods they\nwish to communicate with between each layer. For the database to be accessed, the user would make a request for a piece of information to be pulled from the database through the presentation\nlayer. The presentation layer would process the request through the application layer (or logic\nlayer) which would request the data from the database. All of this would happen through the use\nof API calls in a modern application. The database layer would be a version of SQL such as\nMySQL, Microsoft SQL Server, or another database type.\nOnce the request reaches the data layer, the database management system (DBMS) is\nwhat will actually do the work of finding what the request is looking for. This includes querying\nthe database indexes to see where the information is stored, as databases are usually composed of\none or more storage devices with many logical storage endpoints.\n6.5 - Section Concise Summary\nThe client-server model is regularly used today for designing system architecture. At its\nbase, it is a simple back-and-forth transfer of information from client requests to server\nresponses, but it is highly customizable for many functions.\nDifferent client-server implementations can take several forms, depending on how many\ntiers exist in the design. They range from simple thin and fat client two-tier systems to modular\ndistributed systems, up to any number of tiers of web and application servers separating clients\nfrom their servers. The addition of layers of abstraction serves to make the host client's UI as\nsimple to use as possible, making them desirable to many end users. "}