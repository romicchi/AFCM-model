{"text":"Data Structures and Algorithms!\nJennifer Rexford!\nThe material for this lecture is drawn, in part, from!\nThe Practice of Programming (Kernighan & Pike) Chapter 2!\n1 Motivating Quotations!\n\u201cEvery program depends on algorithms and data\nstructures, but few programs depend on the\ninvention of brand new ones.\u201d!\n-- Kernighan & Pike!\n\u201cI will, in fact, claim that the difference between a\nbad programmer and a good one is whether he\nconsiders his code or his data structures more\nimportant. Bad programmers worry about the\ncode. Good programmers worry about data\nstructures and their relationships.\u201d!\n-- Linus Torvalds!\n2 Goals of this Lecture!\n\u2022 Help you learn (or refresh your memory) about:!\n\u2022 Common data structures and algorithms\n!\n\u2022 Why? Shallow motivation:!\n\u2022 Provide examples of pointer-related C code!\n\u2022 Why? Deeper motivation:!\n\u2022 Common data structures and algorithms serve as \u201chigh\nlevel building blocks\u201d!\n\u2022 A power programmer:!\n\u2022 Rarely creates programs from scratch!\n\u2022 Often creates programs using building blocks!\n3 A Common Task!\n\u2022 Maintain a table of key\/value pairs!\n\u2022 Each key is a string; each value is an int\n\u2022 Unknown number of key-value pairs!\n\u2022 Examples!\n\u2022 (student name, grade)!\n\u2022 (\u201cjohn smith\u201d, 84), (\u201cjane doe\u201d, 93), (\u201cbill clinton\u201d, 81)!\n\u2022 (baseball player, number)!\n\u2022 (\u201cRuth\u201d, 3), (\u201cGehrig\u201d, 4), (\u201cMantle\u201d, 7)!\n\u2022 (variable name, value)!\n\u2022 (\u201cmaxLength\u201d, 2000), (\u201ci\u201d, 7), (\u201cj\u201d, -10)!\n\u2022 For simplicity, allow duplicate keys !\n(client responsibility)\n\u2022 In Assignment #3, must check for duplicate keys!!\n4 Data Structures and Algorithms!\n\u2022 Data structures!\n\u2022 Linked list of key\/value pairs!\n\u2022 Hash table of key\/value pairs!\n\u2022 Algorithms!\n\u2022 Create: Create the data structure!\n\u2022 Add: Add a key\/value pair!\n\u2022 Search: Search for a key\/value pair, by key!\n\u2022 Free: Free the data structure!\n5 Data Structure #1: Linked List!\n\u2022 Data structure: Nodes; each contains key\/value\npair and pointer to next node!\n\"Mantle\" \"Gehrig\" \"Ruth\"\n7 4 3\nNULL\n\u2022 Algorithms:!\n\u2022 Create: Allocate Table structure to point to first node!\n\u2022 Add: Insert new node at front of list!\n\u2022 Search: Linear search through the list!\n\u2022 Free: Free nodes while traversing; free Table structure!\n6 Linked List: Data Structure!\nstruct Node {\nconst char *key;\nint value;\nstruct Node *next;\n};\nstruct Table {\nstruct Node *first;\n};\nstruct! struct!\nstruct!\nNode! Node!\nTable!\n\"Gehrig\" \"Ruth\"\n4 3\nNULL\n7 Linked List: Create (1)!\nstruct Table *Table_create(void) {\nstruct Table *t;\nt = (struct Table*)\nmalloc(sizeof(struct Table));\nt->first = NULL;\nreturn t;\n}\nstruct Table *t;\n\u2026\nt = Table_create();\n\u2026\nt!\n8 Linked List: Create (2)!\nstruct Table *Table_create(void) {\nstruct Table *t;\nt = (struct Table*)\nmalloc(sizeof(struct Table));\nt->first = NULL;\nreturn t;\n}\nstruct Table *t;\n\u2026\nt = Table_create();\n\u2026\nt!\nNULL\n9 Linked List: Add (1)!\nvoid Table_add(struct Table *t,\nconst char *key, int value) {\nstruct Node *p = (struct Node*)malloc(sizeof(struct Node));\np->key = key;\np->value = value;\np->next = t->first;\nt->first = p;\n}\nstruct Table *t;\n\u2026\nThese are\nTable_add(t, \"Ruth\", 3);\npointers to!\nTable_add(t, \"Gehrig\", 4);\nstrings! Table_add(t, \"Mantle\", 7);\n\u2026\nt!\n\"Gehrig\" \"Ruth\"\n4 3\nNULL\n10 Linked List: Add (2)!\nvoid Table_add(struct Table *t,\nconst char *key, int value) {\nstruct Node *p = (struct Node*)malloc(sizeof(struct Node));\np->key = key;\np->value = value;\np->next = t->first;\nt->first = p;\n}\nstruct Table *t;\n\u2026\np!\nTable_add(t, \"Ruth\", 3);\nTable_add(t, \"Gehrig\", 4);\nTable_add(t, \"Mantle\", 7);\n\u2026\nt!\n\"Gehrig\" \"Ruth\"\n4 3\nNULL\n11 Linked List: Add (3)!\nvoid Table_add(struct Table *t,\nconst char *key, int value) {\nstruct Node *p = (struct Node*)malloc(sizeof(struct Node));\np->key = key;\np->value = value;\np->next = t->first;\nt->first = p;\n}\nstruct Table *t;\n\u2026\np!\nTable_add(t, \"Ruth\", 3);\nTable_add(t, \"Gehrig\", 4);\nTable_add(t, \"Mantle\", 7);\n\"Mantle\"\n\u2026\nt! 7\n\"Gehrig\" \"Ruth\"\n4 3\nNULL\n12 Linked List: Add (4)!\nvoid Table_add(struct Table *t,\nconst char *key, int value) {\nstruct Node *p = (struct Node*)malloc(sizeof(struct Node));\np->key = key;\np->value = value;\np->next = t->first;\nt->first = p;\n}\nstruct Table *t;\n\u2026\np!\nTable_add(t, \"Ruth\", 3);\nTable_add(t, \"Gehrig\", 4);\nTable_add(t, \"Mantle\", 7);\n\"Mantle\"\n\u2026\nt! 7\n\"Gehrig\" \"Ruth\"\n4 3\nNULL\n13 Linked List: Add (5)!\nvoid Table_add(struct Table *t,\nconst char *key, int value) {\nstruct Node *p = (struct Node*)malloc(sizeof(struct Node));\np->key = key;\np->value = value;\np->next = t->first;\nt->first = p;\n}\nstruct Table *t;\n\u2026\np!\nTable_add(t, \"Ruth\", 3);\nTable_add(t, \"Gehrig\", 4);\nTable_add(t, \"Mantle\", 7);\n\"Mantle\"\n\u2026\nt! 7\n\"Gehrig\" \"Ruth\"\n4 3\nNULL\n14 Linked List: Search (1)!\nint Table_search(struct Table *t,\nconst char *key, int *value) {\nstruct Node *p;\nfor (p = t->first; p != NULL; p = p->next)\nif (strcmp(p->key, key) == 0) {\n*value = p->value;\nreturn 1;\n} struct Table *t;\nreturn 0;\nint value;\n}\nint found;\n\u2026\nfound =\nTable_search(t, \"Gehrig\", &value);\n\u2026\nt!\n\"Mantle\" \"Gehrig\" \"Ruth\"\n7 4 3\nNULL\n15 Linked List: Search (2)!\nint Table_search(struct Table *t,\nconst char *key, int *value) {\nstruct Node *p;\nfor (p = t->first; p != NULL; p = p->next)\nif (strcmp(p->key, key) == 0) {\n*value = p->value;\nreturn 1;\n} struct Table *t;\nreturn 0;\nint value;\n}\nint found;\n\u2026\nfound =\nTable_search(t, \"Gehrig\", &value);\n\u2026\np!\nt!\n\"Mantle\" \"Gehrig\" \"Ruth\"\n7 4 3\nNULL\n16 Linked List: Search (3)!\nint Table_search(struct Table *t,\nconst char *key, int *value) {\nstruct Node *p;\nfor (p = t->first; p != NULL; p = p->next)\nif (strcmp(p->key, key) == 0) {\n*value = p->value;\nreturn 1;\n} struct Table *t;\nreturn 0;\nint value;\n}\nint found;\n\u2026\nfound =\nTable_search(t, \"Gehrig\", &value);\n\u2026\np!\nt!\n\"Mantle\" \"Gehrig\" \"Ruth\"\n7 4 3\nNULL\n17 Linked List: Search (4)!\nint Table_search(struct Table *t,\nconst char *key, int *value) {\nstruct Node *p;\nfor (p = t->first; p != NULL; p = p->next)\nif (strcmp(p->key, key) == 0) {\n*value = p->value;\nreturn 1;\n} struct Table *t;\nreturn 0;\nint value;\n}\nint found;\n\u2026\nfound =\nTable_search(t, \"Gehrig\", &value);\n\u2026\np!\nt!\n\"Mantle\" \"Gehrig\" \"Ruth\"\n7 4 3\nNULL\n18 Linked List: Search (5)!\nint Table_search(struct Table *t,\nconst char *key, int *value) {\nstruct Node *p;\nfor (p = t->first; p != NULL; p = p->next)\nif (strcmp(p->key, key) == 0) {\n*value = p->value;\nreturn 1;\n} struct Table *t;\nreturn 0;\nint value;\n}\nint found;\n\u2026\nfound =\nTable_search(t, \"Gehrig\", &value);\n\u2026\np!\nt!\n\"Mantle\" \"Gehrig\" \"Ruth\"\n7 4 3\nNULL\n19 Linked List: Search (6)!\nint Table_search(struct Table *t,\nconst char *key, int *value) {\nstruct Node *p;\nfor (p = t->first; p != NULL; p = p->next)\nif (strcmp(p->key, key) == 0) {\n*value = p->value;\nreturn 1;\n} struct Table *t;\nreturn 0;\nint value;\n}\nint found;\n\u2026\nfound =\nTable_search(t, \"Gehrig\", &value);\n\u2026\n1\np!\n4\nt!\n\"Mantle\" \"Gehrig\" \"Ruth\"\n7 4 3\nNULL\n20 Linked List: Free (1)!\nvoid Table_free(struct Table *t) {\nstruct Node *p;\nstruct Node *nextp;\nfor (p = t->first; p != NULL; p = nextp) {\nnextp = p->next;\nfree(p);\n}\nfree(t);\n}\nstruct Table *t;\n\u2026\nTable_free(t);\n\u2026\nt!\n\"Mantle\" \"Gehrig\" \"Ruth\"\n7 4 3\nNULL\n21 Linked List: Free (2)!\nvoid Table_free(struct Table *t) {\nstruct Node *p;\nstruct Node *nextp;\nfor (p = t->first; p != NULL; p = nextp) {\nnextp = p->next;\nfree(p);\n}\nfree(t);\n}\nstruct Table *t;\n\u2026\nTable_free(t);\n\u2026\np!\nt!\n\"Mantle\" \"Gehrig\" \"Ruth\"\n7 4 3\nNULL\n22 Linked List: Free (3)!\nvoid Table_free(struct Table *t) {\nstruct Node *p;\nstruct Node *nextp;\nfor (p = t->first; p != NULL; p = nextp) {\nnextp = p->next;\nfree(p);\n}\nfree(t);\n}\nstruct Table *t;\n\u2026\nTable_free(t);\n\u2026\np! nextp!\nt!\n\"Mantle\" \"Gehrig\" \"Ruth\"\n7 4 3\nNULL\n23 Linked List: Free (4)!\nvoid Table_free(struct Table *t) {\nstruct Node *p;\nstruct Node *nextp;\nfor (p = t->first; p != NULL; p = nextp) {\nnextp = p->next;\nfree(p);\n}\nfree(t);\n}\nstruct Table *t;\n\u2026\nTable_free(t);\n\u2026\np! nextp!\nt!\n\"Mantle\" \"Gehrig\" \"Ruth\"\n7 4 3\nNULL\n24 Linked List: Free (5)!\nvoid Table_free(struct Table *t) {\nstruct Node *p;\nstruct Node *nextp;\nfor (p = t->first; p != NULL; p = nextp) {\nnextp = p->next;\nfree(p);\n}\nfree(t);\n}\nstruct Table *t;\n\u2026\nTable_free(t);\n\u2026\np! nextp!\nt!\n\"Mantle\" \"Gehrig\" \"Ruth\"\n7 4 3\nNULL\n25 Linked List: Free (6)!\nvoid Table_free(struct Table *t) {\nstruct Node *p;\nstruct Node *nextp;\nfor (p = t->first; p != NULL; p = nextp) {\nnextp = p->next;\nfree(p);\n}\nfree(t);\n}\nstruct Table *t;\n\u2026\nTable_free(t);\n\u2026\np! nextp!\nt!\n\"Mantle\" \"Gehrig\" \"Ruth\"\n7 4 3\nNULL\n26 Linked List: Free (7)!\nvoid Table_free(struct Table *t) {\nstruct Node *p;\nstruct Node *nextp;\nfor (p = t->first; p != NULL; p = nextp) {\nnextp = p->next;\nfree(p);\n}\nfree(t);\n}\nstruct Table *t;\n\u2026\nTable_free(t);\n\u2026\np! nextp!\nt!\n\"Mantle\" \"Gehrig\" \"Ruth\"\n7 4 3\nNULL\n27 Linked List: Free (8)!\nvoid Table_free(struct Table *t) {\nstruct Node *p;\nstruct Node *nextp;\nfor (p = t->first; p != NULL; p = nextp) {\nnextp = p->next;\nfree(p);\n}\nfree(t);\n}\nstruct Table *t;\n\u2026\nTable_free(t);\n\u2026\np! nextp!\nt!\n\"Mantle\" \"Gehrig\" \"Ruth\"\n7 4 3\nNULL\n28 Linked List: Free (9)!\nvoid Table_free(struct Table *t) {\nstruct Node *p;\nstruct Node *nextp;\nfor (p = t->first; p != NULL; p = nextp) {\nnextp = p->next;\nfree(p);\n}\nfree(t)\n}\nstruct Table *t;\n\u2026\nTable_free(t);\n\u2026\np! nextp!\nt!\n\"Mantle\" \"Gehrig\" \"Ruth\"\n7 4 3\nNULL\n29 Linked List Performance!\n\u2022 Create: !fast!\nWhat are the\n\u2022 Add:! !fast!\nasymptotic run times\n(big-oh notation)?!\n\u2022 Search: !slow!\n\u2022 Free: !slow!\nWould it be better to\nkeep the nodes\nsorted by key?!\n30 Data Structure #2: Hash Table!\n\u2022 Fixed-size array where each element points to a linked list!\n0\nARRAYSIZE-1\nstruct Node *array[ARRAYSIZE];\n\u2022 Function maps each key to an array index !\n\u2022 For example, for an integer key h\n\u2022 Hash function: i = h % ARRAYSIZE (mod function)!\n\u2022 Go to array element i, i.e., the linked list hashtab[i]\n\u2022 Search for element, add element, remove element, etc.!\n31 Hash Table Example!\n\u2022 Integer keys, array of size 5 with hash function \u201ch\nmod 5\u201d !\n\u2022 \u201c1776 % 5\u201d is 1!\n\u2022 \u201c1861 % 5\u201d is 1!\n\u2022 \u201c1939 % 5\u201d is 4!\n1776 1861\n0\nRevolution Civil\n1\n2\n3\n4\n1939\nWW2\n32 How Large an Array?!\n\u2022 Large enough that average \u201cbucket\u201d size is 1!\n\u2022 Short buckets mean fast search!\n\u2022 Long buckets mean slow search!\n\u2022 Small enough to be memory efficient!\n\u2022 Not an excessive number of elements!\n\u2022 Fortunately, each array element is just storing a pointer!\n\u2022 This is OK:!\n0\nARRAYSIZE-1\n33 What Kind of Hash Function?!\n\u2022 Good at distributing elements across the array!\n\u2022 Distribute results over the range 0, 1, \u2026, ARRAYSIZE-1!\n\u2022 Distribute results evenly to avoid very long buckets!\n\u2022 This is not so good:!\n0\nARRAYSIZE-1\nWhat would be the\nworst possible hash\nfunction?!\n34 Hashing String Keys to Integers!\n\u2022 Simple schemes don\u02bct distribute the keys evenly enough!\n\u2022 Number of characters, mod ARRAYSIZE!\n\u2022 Sum the ASCII values of all characters, mod ARRAYSIZE!\n\u2022 \u2026!\n\u2022 Here\u02bcs a reasonably good hash function!\n\u2022 Weighted sum of characters x in the string!\ni\n\u2022 (\u03a3 aix ) mod ARRAYSIZE!\ni\n\u2022 Best if a and ARRAYSIZE are relatively prime!\n\u2022 E.g., a = 65599, ARRAYSIZE = 1024!\n35 Implementing Hash Function!\n\u2022 Potentially expensive to compute ai for each value of i!\n\u2022 Computing ai for each value of I!\n\u2022 Instead, do (((x[0] * 65599 + x[1]) * 65599 + x[2]) * 65599 + x[3]) * \u2026!\nunsigned int hash(const char *x) {\nint i;\nunsigned int h = 0U;\nfor (i=0; x[i]!='\\0'; i++)\nh = h * 65599 + (unsigned char)x[i];\nreturn h % 1024;\n}\nCan be more clever than this for powers of two!!\n(Described in Appendix)!\n36 Hash Table Example!\nExample: ARRAYSIZE = 7!\nLookup (and enter, if not present) these strings: the, cat, in, the, hat!\nHash table initially empty.!\nFirst word: the. hash(\u201cthe\u201d) = 965156977. 965156977 % 7 = 1.!\nSearch the linked list table[1] for the string \u201cthe\u201d; not found.!\n0\n1\n2\n3\n4\n5\n6\n37 Hash Table Example (cont.)!\nExample: ARRAYSIZE = 7!\nLookup (and enter, if not present) these strings: the, cat, in, the, hat!\nHash table initially empty.!\nFirst word: \u201cthe\u201d. hash(\u201cthe\u201d) = 965156977. 965156977 % 7 = 1.!\nSearch the linked list table[1] for the string \u201cthe\u201d; not found!\nNow: table[1] = makelink(key, value, table[1])!\n0\nthe\n1\n2\n3\n4\n5\n6\n38 Hash Table Example (cont.)!\nSecond word: \u201ccat\u201d. hash(\u201ccat\u201d) = 3895848756. 3895848756 % 7 = 2.!\nSearch the linked list table[2] for the string \u201ccat\u201d; not found!\nNow: table[2] = makelink(key, value, table[2])!\n0\nthe\n1\n2\n3\n4\n5\n6\n39 Hash Table Example (cont.)!\nThird word: \u201cin\u201d. hash(\u201cin\u201d) = 6888005. 6888005% 7 = 5.!\nSearch the linked list table[5] for the string \u201cin\u201d; not found!\nNow: table[5] = makelink(key, value, table[5])!\n0\nthe\n1\n2\n3 cat\n4\n5\n6\n40 Hash Table Example (cont.)!\nFourth word: \u201cthe\u201d. hash(\u201cthe\u201d) = 965156977. 965156977 % 7 = 1.!\nSearch the linked list table[1] for the string \u201cthe\u201d; found it!!\n0\nthe\n1\n2\n3 cat\n4\nin\n5\n6\n41 Hash Table Example (cont.)!\nFourth word: \u201chat\u201d. hash(\u201chat\u201d) = 865559739. 865559739 % 7 = 2.!\nSearch the linked list table[2] for the string \u201chat\u201d; not found.!\nNow, insert \u201chat\u201d into the linked list table[2]. !\nAt beginning or end? Doesn\u02bct matter.!\n0\nthe\n1\n2\n3 cat\n4\nin\n5\n6\n42 Hash Table Example (cont.)!\nInserting at the front is easier, so add \u201chat\u201d at the front !\n0\nthe\n1\n2\n3 hat cat\n4\nin\n5\n6\n43 Hash Table: Data Structure!\nenum {BUCKET_COUNT = 1024};\nstruct Node {\nconst char *key;\nstruct!\nint value; struct!\nstruct Node *next; Table!\nNode!\n};\n0 NULL struct!\n\"Ruth\"\nstruct Table { 1 NULL\n\u2026 3 Node!\nstruct Node *array[BUCKET_COUNT];\n}; 23 NULL\n\u2026 \"Gehrig\"\n723 4\n\u2026\nNULL\n806 NULL\n\u2026\n1023 NULL\n44 Hash Table: Create!\nstruct Table *Table_create(void) {\nstruct Table *t;\nt = (struct Table*)calloc(1, sizeof(struct Table));\nreturn t;\n}\nstruct Table *t;\n\u2026\nt = Table_create();\n\u2026\nt!\n0 NULL\n1 NULL\n\u2026\n1023 NULL\n45 Hash Table: Add (1)!\nvoid Table_add(struct Table *t,\nconst char *key, int value) {\nstruct Node *p = (struct Node*)malloc(sizeof(struct Node));\nint h = hash(key);\np->key = key;\nstruct Table *t;\np->value = value;\n\u2026\np->next = t->array[h];\nTable_add(t, \"Ruth\", 3);\nt->array[h] = p;\nTable_add(t, \"Gehrig\", 4);\n}\nTable_add(t, \"Mantle\", 7);\n\u2026\nt!\nThese are\npointers to\n0 NULL \"Ruth\" strings!\n1 NU \u2026L L 3\nNULL\n23 \u2026 \"Gehrig\"\n4\n723\n\u2026 NULL Pretend that \u201cRuth\u201d!\n806 NULL hashed to 23 and!\n\u2026\n1023 NULL \u201cGehrig\u201d to 723!\n46 Hash Table: Add (2)!\nvoid Table_add(struct Table *t,\nconst char *key, int value) {\nstruct Node *p = (struct Node*)malloc(sizeof(struct Node));\nint h = hash(key);\np->key = key;\nstruct Table *t;\np->value = value;\n\u2026\np->next = t->array[h];\nTable_add(t, \"Ruth\", 3);\nt->array[h] = p;\nTable_add(t, \"Gehrig\", 4);\n}\nTable_add(t, \"Mantle\", 7);\n\u2026\nt!\n0 NULL \"Ruth\"\n1 NU \u2026L L 3\nNULL p!\n23 \u2026 \"Gehrig\"\n4\n723\n\u2026 NULL\n806 NULL\n\u2026\n1023 NULL\n47 Hash Table: Add (3)!\nvoid Table_add(struct Table *t,\nconst char *key, int value) {\nstruct Node *p = (struct Node*)malloc(sizeof(struct Node));\nint h = hash(key);\np->key = key;\nstruct Table *t;\np->value = value;\n\u2026\np->next = t->array[h];\nTable_add(t, \"Ruth\", 3);\nt->array[h] = p;\nTable_add(t, \"Gehrig\", 4);\n}\nTable_add(t, \"Mantle\", 7);\n\u2026\nt!\nPretend that \u201cMantle\u201d!\nhashed to 806, and so!\n0 NULL \"Ruth\"\nh = 806!\n1 NU \u2026L L 3\nNULL p!\n23 \u2026 \"Gehrig\"\n4\n723\n\u2026 NULL\n806 NULL \"Mantle\"\n\u2026\n7\n1023 NULL\n48 Hash Table: Add (4)!\nvoid Table_add(struct Table *t,\nconst char *key, int value) {\nstruct Node *p = (struct Node*)malloc(sizeof(struct Node));\nint h = hash(key);\np->key = key;\nstruct Table *t;\np->value = value;\n\u2026\np->next = t->array[h];\nTable_add(t, \"Ruth\", 3);\nt->array[h] = p;\nTable_add(t, \"Gehrig\", 4);\n}\nTable_add(t, \"Mantle\", 7);\n\u2026\nt!\nh = 806!\n0 NULL \"Ruth\"\n1 NU \u2026L L 3\nNULL p!\n23 \u2026 \"Gehrig\"\n4\n723\n\u2026 NULL\n806 NULL \"Mantle\"\n\u2026\n7\n1023 NULL NULL\n49 Hash Table: Add (5)!\nvoid Table_add(struct Table *t,\nconst char *key, int value) {\nstruct Node *p = (struct Node*)malloc(sizeof(struct Node));\nint h = hash(key);\np->key = key;\nstruct Table *t;\np->value = value;\n\u2026\np->next = t->array[h];\nTable_add(t, \"Ruth\", 3);\nt->array[h] = p;\nTable_add(t, \"Gehrig\", 4);\n}\nTable_add(t, \"Mantle\", 7);\n\u2026\nt!\nh = 806!\n0 NULL \"Ruth\"\n1 NU \u2026L L 3\nNULL p!\n23 \u2026 \"Gehrig\"\n4\n723\n\u2026 NULL\n806 \"Mantle\"\n\u2026\n7\n1023 NULL NULL\n50 Hash Table: Search (1)!\nint Table_search(struct Table *t,\nconst char *key, int *value) {\nstruct Node *p;\nint h = hash(key);\nfor (p = t->array[h]; p != NULL; p = p->next)\nif (strcmp(p->key, key) == 0) {\nstruct Table *t;\n*value = p->value;\nint value;\nreturn 1;\nint found;\n}\n\u2026\nreturn 0;\nfound =\n}\nTable_search(t, \"Gehrig\", &value);\n\u2026\nt!\n0 NULL\n1 NU \u2026L L \"Ruth\"\n3\n23\n\u2026 NULL \"Gehrig\"\n723 4\n\u2026\u2026\nNULL\n\"Mantle\"\n806\n\u2026 7\n1023 NULL NULL 51 Hash Table: Search (2)!\nint Table_search(struct Table *t,\nconst char *key, int *value) {\nstruct Node *p;\nint h = hash(key);\nfor (p = t->array[h]; p != NULL; p = p->next)\nif (strcmp(p->key, key) == 0) {\nstruct Table *t;\n*value = p->value;\nint value;\nreturn 1;\nint found;\n}\n\u2026\nreturn 0;\nfound =\n}\nTable_search(t, \"Gehrig\", &value);\n\u2026\nt!\nPretend that \u201cGehrig\u201d!\n0 NULL hashed to 723, and so!\n1 NU \u2026L L \"Ruth\"\nh = 723!\n3\n23\n\u2026 NULL \"Gehrig\"\n723 4\n\u2026\u2026\nNULL\n\"Mantle\"\n806\n\u2026 7\n1023 NULL NULL 52 Hash Table: Search (3)!\nint Table_search(struct Table *t,\nconst char *key, int *value) {\nstruct Node *p;\nint h = hash(key);\nfor (p = t->array[h]; p != NULL; p = p->next)\nif (strcmp(p->key, key) == 0) {\nstruct Table *t;\n*value = p->value;\nint value;\nreturn 1;\nint found;\n}\n\u2026\nreturn 0;\nfound =\n}\nTable_search(t, \"Gehrig\", &value);\n\u2026\nt!\n0 NULL p! h = 723!\n1 NU \u2026L L \"Ruth\"\n3\n23\n\u2026 NULL \"Gehrig\"\n723 4\n\u2026\u2026\nNULL\n\"Mantle\"\n806\n\u2026 7\n1023 NULL NULL 53 Hash Table: Search (4)!\nint Table_search(struct Table *t,\nconst char *key, int *value) {\nstruct Node *p;\nint h = hash(key);\nfor (p = t->array[h]; p != NULL; p = p->next)\nif (strcmp(p->key, key) == 0) {\nstruct Table *t;\n*value = p->value;\nint value;\nreturn 1;\nint found;\n}\n\u2026\nreturn 0;\nfound =\n}\nTable_search(t, \"Gehrig\", &value);\n\u2026\nt!\n0 NULL p! h = 723!\n1 NU \u2026L L \"Ruth\"\n3\n23\n\u2026 NULL \"Gehrig\"\n723 4\n\u2026\u2026\nNULL\n\"Mantle\"\n806\n\u2026 7\n1023 NULL NULL 54 Hash Table: Search (5)!\nint Table_search(struct Table *t,\nconst char *key, int *value) {\nstruct Node *p;\nint h = hash(key);\nfor (p = t->array[h]; p != NULL; p = p->next)\nif (strcmp(p->key, key) == 0) {\nstruct Table *t;\n*value = p->value;\nint value;\nreturn 1;\nint found;\n}\n\u2026\nreturn 0;\nfound =\n}\nTable_search(t, \"Gehrig\", &value);\n\u2026\nt!\n1\n0 NULL p! h = 723!\n1 NU \u2026L L \"Ruth\" 4\n3\n23\n\u2026 NULL \"Gehrig\"\n723 4\n\u2026\u2026\nNULL\n\"Mantle\"\n806\n\u2026 7\n1023 NULL NULL 55 Hash Table: Free (1)!\nvoid Table_free(struct Table *t) {\nstruct Node *p;\nstruct Node *nextp;\nint b;\nfor (b = 0; b < BUCKET_COUNT; b++)\nfor (p = t->array[b]; p != NULL; p = nextp) {\nnextp = p->next;\nstruct Table *t;\nfree(p);\n} \u2026\nfree(t); Table_free(t);\n\u2026\n}\nt!\n0 NULL\n1 NU \u2026L L \"Ruth\"\n3\n23\n\u2026 NULL \"Gehrig\"\n723 4\n\u2026\u2026\nNULL\n\"Mantle\"\n806\n\u2026 7\n1023 NULL NULL 56 Hash Table: Free (2)!\nvoid Table_free(struct Table *t) {\nstruct Node *p;\nstruct Node *nextp;\nint b;\nfor (b = 0; b < BUCKET_COUNT; b++)\nfor (p = t->array[b]; p != NULL; p = nextp) {\nnextp = p->next;\nstruct Table *t;\nfree(p);\n} \u2026\nfree(t); Table_free(t);\n\u2026\n}\nt!\nb = 0!\n0 NULL\n1 NU \u2026L L \"Ruth\"\n3\n23\n\u2026 NULL \"Gehrig\"\n723 4\n\u2026\u2026\nNULL\n\"Mantle\"\n806\n\u2026 7\n1023 NULL NULL 57 Hash Table: Free (3)!\nvoid Table_free(struct Table *t) {\nstruct Node *p;\nstruct Node *nextp;\nint b;\nfor (b = 0; b < BUCKET_COUNT; b++)\nfor (p = t->array[b]; p != NULL; p = nextp) {\nnextp = p->next;\nstruct Table *t;\nfree(p);\n} \u2026\nfree(t); Table_free(t);\n\u2026\n}\nt!\np!\nb = 0!\n0 NULL\n1 NU \u2026L L \"Ruth\"\n3\n23\n\u2026 NULL \"Gehrig\"\n723 4\n\u2026\u2026\nNULL\n\"Mantle\"\n806\n\u2026 7\n1023 NULL NULL 58 Hash Table: Free (4)!\nvoid Table_free(struct Table *t) {\nstruct Node *p;\nstruct Node *nextp;\nint b;\nfor (b = 0; b < BUCKET_COUNT; b++)\nfor (p = t->array[b]; p != NULL; p = nextp) {\nnextp = p->next;\nstruct Table *t;\nfree(p);\n} \u2026\nfree(t); Table_free(t);\n\u2026\n}\nt!\np!\nb = 1, \u2026, 23!\n0 NULL\n1 NU \u2026L L \"Ruth\"\n3\n23\n\u2026 NULL \"Gehrig\"\n723 4\n\u2026\u2026\nNULL\n\"Mantle\"\n806\n\u2026 7\n1023 NULL NULL 59 Hash Table: Free (5)!\nvoid Table_free(struct Table *t) {\nstruct Node *p;\nstruct Node *nextp;\nint b;\nfor (b = 0; b < BUCKET_COUNT; b++)\nfor (p = t->array[b]; p != NULL; p = nextp) {\nnextp = p->next;\nstruct Table *t;\nfree(p);\n} \u2026\nfree(t); Table_free(t);\n\u2026\n}\nt!\np!\nb = 23!\n0 NULL\n1 NU \u2026L L \"Ruth\"\n3\n23\n\u2026 NULL \"Gehrig\"\n723 4\n\u2026\u2026\nNULL\n\"Mantle\"\n806\n\u2026 7\n1023 NULL NULL 60 Hash Table: Free (6)!\nvoid Table_free(struct Table *t) {\nstruct Node *p;\nstruct Node *nextp;\nint b;\nfor (b = 0; b < BUCKET_COUNT; b++)\nfor (p = t->array[b]; p != NULL; p = nextp) {\nnextp = p->next;\nstruct Table *t;\nfree(p);\n} \u2026\nfree(t); Table_free(t);\n\u2026\n}\nt!\np!\nnextp!\nb = 23!\n0 NULL\n1 NU \u2026L L \"Ruth\"\n3\n23\n\u2026 NULL \"Gehrig\"\n723 4\n\u2026\u2026\nNULL\n\"Mantle\"\n806\n\u2026 7\n1023 NULL NULL 61 Hash Table: Free (7)!\nvoid Table_free(struct Table *t) {\nstruct Node *p;\nstruct Node *nextp;\nint b;\nfor (b = 0; b < BUCKET_COUNT; b++)\nfor (p = t->array[b]; p != NULL; p = nextp) {\nnextp = p->next;\nstruct Table *t;\nfree(p);\n} \u2026\nfree(t); Table_free(t);\n\u2026\n}\nt!\np! nextp!\nb = 23!\n0 NULL\n1 NU \u2026L L \"Ruth\"\n3\n23\n\u2026 NULL \"Gehrig\"\n723 4\n\u2026\u2026\nNULL\n\"Mantle\"\n806\n\u2026 7\n1023 NULL NULL 62 Hash Table: Free (8)!\nvoid Table_free(struct Table *t) {\nstruct Node *p;\nstruct Node *nextp;\nint b;\nfor (b = 0; b < BUCKET_COUNT; b++)\nfor (p = t->array[b]; p != NULL; p = nextp) {\nnextp = p->next;\nstruct Table *t;\nfree(p);\n} \u2026\nfree(t); Table_free(t);\n\u2026\n}\nt!\nb = 24, \u2026, 723!\n0 NULL\nb = 724, \u2026, 806!\n1 NU \u2026L L \"Ruth\"\nb = 807, \u2026, 1024!\n3\n23\n\u2026 NULL \"Gehrig\"\n723 4\n\u2026\u2026\nNULL\n\"Mantle\"\n806\n\u2026 7\n1023 NULL NULL 63 Hash Table: Free (9)!\nvoid Table_free(struct Table *t) {\nstruct Node *p;\nstruct Node *nextp;\nint b;\nfor (b = 0; b < BUCKET_COUNT; b++)\nfor (p = t->array[b]; p != NULL; p = nextp) {\nnextp = p->next;\nstruct Table *t;\nfree(p);\n} \u2026\nfree(t); Table_free(t);\n\u2026\n}\nt!\nb = 1024!\n0 NULL\n1 NU \u2026L L \"Ruth\"\n3\n23\n\u2026 NULL \"Gehrig\"\n723 4\n\u2026\u2026\nNULL\n\"Mantle\"\n806\n\u2026 7\n1023 NULL NULL 64 Hash Table Performance!\n\u2022 Create: !fast!\nWhat are the\n\u2022 Add: !fast!\nasymptotic run times\n(big-oh notation)?!\n\u2022 Search: !fast!\n\u2022 Free: !slow!\nIs hash table\nsearch always\nfast?!\n65 Key Ownership!\n\u2022 Note: Table_add() functions contain this code:!\nvoid Table_add(struct Table *t, const char *key, int value) {\n\u2026\nstruct Node *p = (struct Node*)malloc(sizeof(struct Node));\np->key = key;\n\u2026\n}\n\u2022 Caller passes key, which is a pointer to memory where a string\nresides!\n\u2022 Table_add() function stores within the table the address where the\nstring resides!\n66 Key Ownership (cont.)!\n\u2022 Problem: Consider this calling code:!\nstruct Table t; \u2022 Via Table_add(), table contains\nchar k[100] = \"Ruth\";\nmemory address k!\n\u2026\n\u2022 Client changes string at\nTable_add(t, k, 3);\nmemory address k!\nstrcpy(k, \"Gehrig\");\n\u2026 \u2022 Thus client changes key within table!\nWhat happens if the What happens if the\nclient searches t for client searches t for\n\u201cRuth\u201d?! \u201cGehrig\u201d?!\n67 Key Ownership (cont.)!\n\u2022 Solution: Table_add() saves copy of given key!\nvoid Table_add(struct Table *t, const char *key, int value) {\n\u2026\nstruct Node *p = (struct Node*)malloc(sizeof(struct Node));\np->key = (const char*)malloc(strlen(key) + 1);\nstrcpy(p->key, key);\n\u2026\nWhy add 1?!\n}\n\u2022 If client changes string at memory address k, data structure is not\naffected!\n\u2022 Then the data structure \u201cowns\u201d the copy, that is:!\n\u2022 The data structure is responsible for freeing the memory in which\nthe copy resides!\n\u2022 The Table_free() function must free the copy!\n68 Summary!\n\u2022 Common data structures & associated algorithms!\n\u2022 Linked list!\n\u2022 Fast insert, slow search!\n\u2022 Hash table!\n\u2022 Fast insert, (potentially) fast search!\n\u2022 Invaluable for storing key\/value pairs!\n\u2022 Very common!\n\u2022 Related issues!\n\u2022 Hashing algorithms!\n\u2022 Memory ownership!\n69 Appendix!\n\u2022 \u201cStupid programmer tricks\u201d related to hash tables\u2026!\n70 Revisiting Hash Functions!\n\u2022 Potentially expensive to compute \u201cmod c\u201d!\n\u2022 Involves division by c and keeping the remainder!\n\u2022 Easier when c is a power of 2 (e.g., 16 = 24)!\n\u2022 An alternative (by example)!\n\u2022 53 = 32 + 16 + 4 + 1!\n32 16 8 4 2 1\n0 0 1 1 0 1 0 1\n\u2022 53 % 16 is 5, the last four bits of the number!\n32 16 8 4 2 1\n0 0 0 0 0 1 0 1\n\u2022 Would like an easy way to isolate the last four bits\u2026\n!\n71 Recall: Bitwise Operators in C!\n\u2022 Bitwise AND (&)! \u2022 Bitwise OR (|)!\n|\n& 0 1 0 1\n0 0 0 0 0 1\n1 0 1 1 1 1\n\u2022 Mod on the cheap!!\n\u2022 E.g., h = 53 & 15;!\n\u2022 One\u02bcs complement (~)!\n53 0 0 1 1 0 1 0 1 \u2022 Turns 0 to 1, and 1 to 0!\n\u2022 E.g., set last three bits to 0!\n& 15 0 0 0 0 1 1 1 1 \u2022 x = x & ~7;!\n5 0 0 0 0 0 1 0 1\n72 A Faster Hash Function!\nunsigned int hash(const char *x) {\nint i;\nunsigned int h = 0U;\nPrevious!\nfor (i=0; x[i]!='\\0'; i++)\nh = h * 65599 + (unsigned char)x[i]; version!\nreturn h % 1024;\n}\nunsigned int hash(const char *x) {\nint i;\nunsigned int h = 0U;\nfor (i=0; x[i]!='\\0'; i++)\nFaster!\nh = h * 65599 + (unsigned char)x[i];\nreturn h & 1023;\n}\nWhat happens if\nyou mistakenly\nwrite \u201ch & 1024\u201d?!\n73 Speeding Up Key Comparisons!\n\u2022 Speeding up key comparisons!\n\u2022 For any non-trivial value comparison function!\n\u2022 Trick: store full hash result in structure!\nint Table_search(struct Table *t,\nconst char *key, int *value) {\nstruct Node *p;\nint h = hash(key); \/* No % in hash function *\/\nfor (p = t->array[h%1024]; p != NULL; p = p->next)\nif ((p->hash == h) && strcmp(p->key, key) == 0) {\n*value = p->value;\nreturn 1;\n}\nreturn 0;\nWhy is this so\n}\nmuch faster?!\n74 "}