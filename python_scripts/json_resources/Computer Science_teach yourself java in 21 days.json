{"text":"Sams.net Learning\nCenter\nabcd\nTeach Yourself\nJAVA\nin 21 Days\nS\nS\nF\nR\nLaura Lemay\nW\nCharles L. Perkins\nT\nM\n201 West 103rd Street\nIndianapolis, Indiana 46290\nv\n030-4 FM 5 1\/29\/96, 8:10 PM\nP2\/V4SQC6 TY Java in 21 Days 030-4 louisa 12.31.95 FM LP#4 S\nF\nR\nW\nAbout This Book\nSams.net Learning\nCenter\nabcd\nThis book teaches you all about the Java language and how to use it to create\napplets and applications. By the time you get through with this book, you\u2019ll know\nenough about Java to do just about anything, inside an applet or out.\nWho Should Read This Book\nThis book is intended for people with at least some basic programming back-\nground, which includes people with years of programming experience or people\nwith only a small amount of experience. If you understand what variables, loops,\nand functions are, you\u2019ll be just fine for this book. The sorts of people who might\nwant to read this book include you, if\nnn You\u2019re a real whiz at HTML, understand CGI programming (in perl,\nAppleScript, Visual Basic, or some other popular CGI language) pretty\nwell, and want to move on to the next level in Web page design.\nnn You had some Basic or Pascal in school and you have a basic grasp of\nwhat programming is, but you\u2019ve heard Java is easy to learn, really\npowerful, and very cool.\nnn You\u2019ve programmed C and C++ for many years, you\u2019ve heard this Java\nthing is becoming really popular and you\u2019re wondering what all the fuss\nis all about.\nnn You\u2019ve heard that Java is really good for Web-based applets, and you\u2019re\ncurious about how good it is for creating more general applications.\nWhat if you know programming, but you don\u2019t know object-oriented program-\nming? Fear not. This book assumes no background in object-oriented design. If\nyou know object-oriented programming, in fact, the first couple of days will be\neasy for you.\nHow This Book Is Structured\nThis book is intended to be read and absorbed over the course of thrMee weeks.\nDuring each week, you\u2019ll read seven chapters that present concepts related to the T\nJava language and the creation of applets and applications. W\nR\ni\n030-4 FM 1 1\/29\/96, 8:10 PM\nP2\/V4SQC6 TY Java in 21 Days 030-4 louisa 12.31.95 FM LP#4 Sams.net Learning\nCenter\nabcd\nContents\nIntroduction xxi\nWeek 1 at a Glance 1\nDay 1 An Introduction to Java Programming 3 S\nWhat Is Java?..............................................................................................4\nJava\u2019s Past, Present, and Future...................................................................6 S\nWhy Learn Java?.........................................................................................7\nJava Is Platform-Independent.................................................................7\nF\nJava Is Object-Oriented.........................................................................9\nJava Is Easy to Learn..............................................................................9\nGetting Started with R\nProgramming in Java..............................................................................10\nGetting the Software.......................................................W.....................10\nApplets and Applications .....................................................................11\nCreating a Java Application..................................................................11\nCreating a Java Applet ...............................T..........................................13\nSummary..................................................................................................16\nQ&A...........................................M.............................................................16\nDay 2 Object-Oriented Programming and Java 19\nThinking in Objects: An Analogy.............................................................20\nObjects and Classes ..................................................................................21\nBehavior and Attributes............................................................................23\nAttributes.............................................................................................23\nBehavior ..............................................................................................24\nCreating a Class...................................................................................24\nInheritance, Interfaces, and Packages........................................................28\nInheritance...........................................................................................29\nCreating a Class Hierarchy...................................................................30\nHow Inheritance Works ......................................................................32\nSingle and Multiple Inheritance...........................................................34\nInterfaces and Packages........................................................................34\nCreating a Subclass...................................................................................35\nSummary..................................................................................................38\nQ&A........................................................................................................39\nDay 3 Java Basics 41\nStatements and Expressions......................................................................42\nVariables and Data Types.........................................................................43\nDeclaring Variables..............................................................................43\nNotes on Variable Names....................................................................44\nix\n030-4 FM 9 1\/29\/96, 8:11 PM\nP2\/V4SQC6 TY Java in 21 Days 030-4 louisa 12.31.95 FM LP#4 MTWTFSS\n21\nTeach Yourself JAVA in 21 Days\nVariable Types.....................................................................................45\nAssigning Values to Variables...............................................................46\nComments................................................................................................47\nLiterals......................................................................................................47\nNumber Literals...................................................................................47\nBoolean Literals...................................................................................48\nCharacter Literals.................................................................................48\nString Literals ......................................................................................49\nExpressions and Operators........................................................................50\nArithmetic ...........................................................................................50\nMore About Assignment......................................................................52\nIncrementing and Decrementing.........................................................52\nComparisons........................................................................................54\nLogical Operators ................................................................................55\nBitwise Operators ................................................................................55\nOperator Precedence............................................................................56\nString Arithmetic......................................................................................57\nSummary..................................................................................................58\nQ&A........................................................................................................60\nDay 4 Working with Objects 61\nCreating New Objects..............................................................................62\nUsing new............................................................................................63\nWhat new Does ...................................................................................64\nA Note on Memory Management........................................................64\nAccessing and Setting Class and Instance Variables...................................65\nGetting Values.....................................................................................65\nChanging Values..................................................................................65\nClass Variables.....................................................................................66\nCalling Methods.......................................................................................67\nClass Methods .....................................................................................69\nReferences to Objects ...............................................................................70\nCasting and Converting Objects and Primitive Types ..............................71\nCasting Primitive Types......................................................................71\nCasting Objects ..................................................................................72\nConverting Primitive Types\nto Objects and Vice Versa .................................................................73\nOdds and Ends.........................................................................................73\nComparing Objects .............................................................................74\nCopying Objects..................................................................................75\nDetermining the Class of an Object.....................................................76\nThe Java Class Libraries............................................................................76\nSummary..................................................................................................77\nQ&A........................................................................................................78\nx\n030-4 FM 10 1\/29\/96, 8:11 PM\nP2\/V4SQC6 TY Java in 21 Days 030-4 louisa 12.31.95 FM LP#4 Sams.net Learning\nCenter\nabcd\nDay 5 Arrays, Conditionals, and Loops 79\nArrays.......................................................................................................80\nDeclaring Array Variables....................................................................80\nCreating Array Objects........................................................................81\nAccessing Array Elements.....................................................................81\nChanging Array Elements....................................................................82\nMultidimensional Arrays......................................................................83\nBlock Statements......................................................................................83\nif Conditionals..........................................................................................83\nThe Conditional Operator...................................................................84\nswitch Conditionals...................................................................................85\nfor Loops ..................................................................................................86\nwhile and do Loops...................................................................................88\nwhile Loops..........................................................................................88\ndo...while Loops...................................................................................89\nBreaking Out of Loops.............................................................................89\nLabeled Loops......................................................................................90\nSummary..................................................................................................91\nQ&A........................................................................................................92\nDay 6 Creating Classes and Applications in Java 95\nDefining Classes.......................................................................................96\nCreating Instance and Class Variables.......................................................96\nDefining Instance Variables.................................................................97\nConstants.............................................................................................97\nClass Variables.....................................................................................98\nCreating Methods.....................................................................................99\nDefining Methods ...............................................................................99\nThe this Keyword...............................................................................101\nVariable Scope and Method Definitions............................................101\nPassing Arguments to Methods..........................................................102\nClass Methods ...................................................................................104\nCreating Java Applications......................................................................105\nJava Applications and Command-Line Arguments .................................106\nPassing Arguments to Java Programs..................................................106\nHandling Arguments in Your Java Program.......................................106\nSummary................................................................................................108\nQ&A......................................................................................................109\nDay 7 More About Methods 111\nCreating Methods with the Same Name, Different Arguments...............112\nConstructor Methods.............................................................................115\nBasic Constructors.............................................................................116\nCalling Another Constructor.............................................................117\nOverloading Constructors..................................................................117\nxi\n030-4 FM 11 1\/29\/96, 8:11 PM\nP2\/V4SQC6 TY Java in 21 Days 030-4 louisa 12.31.95 FM LP#4 MTWTFSS\n21\nTeach Yourself JAVA in 21 Days\nOverriding Methods...............................................................................119\nCreating Methods that Override Existing Methods............................119\nCalling the Original Method .............................................................121\nOverriding Constructors....................................................................122\nFinalizer Methods...................................................................................123\nSummary................................................................................................124\nQ&A......................................................................................................124\nWeek 2 at a Glance 127\nDay 8 Java Applet Basics 129\nHow Applets and Applications Are Different..........................................130\nCreating Applets.....................................................................................131\nMajor Applet Activities......................................................................132\nA Simple Applet.................................................................................134\nIncluding an Applet on a Web Page........................................................136\nThe <APPLET> Tag..........................................................................136\nTesting the Result..............................................................................137\nMaking Java Applets Available to the Web.........................................137\nMore About the <APPLET> Tag............................................................138\nALIGN ..............................................................................................138\nHSPACE and VSPACE......................................................................140\nCODE and CODEBASE....................................................................141\nPassing Parameters to Applets.................................................................141\nSummary................................................................................................146\nQ&A......................................................................................................147\nDay 9 Graphics, Fonts, and Color 149\nThe Graphics Class.................................................................................150\nThe Graphics Coordinate System ......................................................151\nDrawing and Filling ...............................................................................151\nLines..................................................................................................152\nRectangles..........................................................................................152\nPolygons............................................................................................155\nOvals.................................................................................................156\nArc.....................................................................................................157\nA Simple Graphics Example...............................................................161\nCopying and Clearing........................................................................163\nText and Fonts.......................................................................................163\nCreating Font Objects .......................................................................163\nDrawing Characters and Strings.........................................................164\nFinding Out Information About a Font.............................................166\nColor......................................................................................................168\nUsing Color Objects..........................................................................168\nTesting and Setting the Current Colors.............................................169\nA Single Color Example.....................................................................170\nSummary................................................................................................171\nQ&A......................................................................................................171\nxii\n030-4 FM 12 1\/29\/96, 8:11 PM\nP2\/V4SQC6 TY Java in 21 Days 030-4 louisa 12.31.95 FM LP#4 Sams.net Learning\nCenter\nabcd\nDay 10 Simple Animation and Threads 173\nCreating Animation in Java....................................................................174\nPainting and Repainting....................................................................174\nStarting and Stopping\nan Applet\u2019s Execution......................................................................175\nPutting It Together............................................................................175\nThreads: What They Are\nand Why You Need Them...................................................................177\nThe Problem with the Digital Clock Applet ......................................178\nWriting Applets with Threads............................................................179\nFixing The Digital Clock...................................................................180\nReducing Animation Flicker...................................................................182\nFlicker and How to Avoid It..............................................................182\nHow to Override Update...................................................................183\nSolution One: Don\u2019t Clear the Screen ...............................................183\nSolution Two: Redraw\nOnly What You Have To................................................................186\nSummary................................................................................................192\nQ&A......................................................................................................192\nDay 11 More Animation, Images, and Sound 195\nRetrieving and Using Images..................................................................196\nGetting Images ..................................................................................196\nDrawing Images.................................................................................198\nModifying Images..............................................................................201\nCreating Animation Using Images..........................................................201\nAn Example: Neko.............................................................................201\nRetrieving and Using Sounds..................................................................209\nSun\u2019s Animator Applet...........................................................................211\nMore About Flicker: Double-Buffering...................................................212\nCreating Applets with Double-Buffering............................................212\nAn Example: Checkers Revisited........................................................213\nSummary................................................................................................214\nQ&A......................................................................................................215\nDay 12 Managing Simple Events and Interactivity 217\nMouse Clicks..........................................................................................218\nmouseDown and mouseUp...................................................................219\nAn Example: Spots.............................................................................220\nMouse Movements.................................................................................223\nmouseDrag and mouseMove.................................................................223\nmouseEnter and mouseExit..................................................................223\nAn Example: Drawing Lines..............................................................224\nKeyboard Events.....................................................................................228\nThe keyDown Method .......................................................................228\nDefault Keys......................................................................................229\nxiii\n030-4 FM 13 1\/29\/96, 8:11 PM\nP2\/V4SQC6 TY Java in 21 Days 030-4 louisa 12.31.95 FM LP#4 MTWTFSS\n21\nTeach Yourself JAVA in 21 Days\nAn Example: Entering, Displaying, and Moving Characters ..............229\nTesting for Modifier Keys..................................................................232\nThe AWT Event Handler.......................................................................233\nSummary................................................................................................235\nQ&A......................................................................................................235\nDay 13 The Java Abstract Windowing Toolkit 237\nAn AWT Overview.................................................................................238\nThe Basic User Interface Components....................................................240\nLabels ................................................................................................241\nButtons..............................................................................................242\nCheckboxes........................................................................................243\nRadio Buttons....................................................................................244\nChoice Menus ...................................................................................245\nText Fields.........................................................................................247\nPanels and Layout...................................................................................249\nLayout Managers...............................................................................249\nInsets.................................................................................................254\nHandling UI Actions and Events............................................................255\nNesting Panels and Components............................................................258\nNested Panels ....................................................................................258\nEvents and Nested Panels ..................................................................258\nMore UI Components............................................................................259\nText Areas..........................................................................................259\nScrolling Lists....................................................................................261\nScrollbars and Sliders.........................................................................262\nCanvases............................................................................................265\nMore UI Events......................................................................................265\nA Complete Example:\nRGB to HSB Converter.......................................................................266\nCreate the Applet Layout...................................................................267\nCreate the Panel Layout.....................................................................267\nDefine the Subpanels.........................................................................269\nHandle the Actions............................................................................272\nUpdate the Result..............................................................................272\nThe Complete Source Code...............................................................274\nSummary................................................................................................277\nQ&A......................................................................................................277\nDay 14 Windows, Networking, and Other Tidbits 279\nWindows, Menus, and Dialog Boxes......................................................280\nFrames...............................................................................................280\nMenus ...............................................................................................282\nDialog Boxes......................................................................................285\nFile Dialogs........................................................................................287\nWindow Events.................................................................................288\nUsing AWT Windows in Stand-Alone Applications..........................288\nxiv\n030-4 FM 14 1\/29\/96, 8:11 PM\nP2\/V4SQC6 TY Java in 21 Days 030-4 louisa 12.31.95 FM LP#4 Sams.net Learning\nCenter\nabcd\nNetworking in Java.................................................................................289\nCreating Links Inside Applets............................................................290\nOpening Web Connections...............................................................292\nopenStream()......................................................................................293\nThe URLconnection Class...................................................................296\nSockets...............................................................................................296\nOther Applet Hints................................................................................297\nThe showStatus Method.....................................................................297\nApplet Information............................................................................298\nCommunicating Between Applets......................................................298\nSummary................................................................................................299\nQ&A......................................................................................................300\nWeek 3 at a Glance 303\nDay 15 Modifiers 305\nMethod and Variable Access Control......................................................307\nThe Four P\u2019s of Protection.................................................................307\nThe Conventions for Instance Variable Access...................................312\nClass Variables and Methods..................................................................314\nThe final Modifier..................................................................................316\nfinal Classes .......................................................................................316\nfinal Variables....................................................................................317\nfinal Methods ....................................................................................317\nabstract Methods and Classes..................................................................319\nSummary................................................................................................320\nQ&A......................................................................................................320\nDay 16 Packages and Interfaces 323\nPackages.................................................................................................324\nProgramming in the Large.................................................................324\nProgramming in the Small.................................................................327\nHiding Classes...................................................................................329\nInterfaces................................................................................................331\nProgramming in the Large.................................................................331\nProgramming in the Small.................................................................335\nSummary................................................................................................338\nQ&A......................................................................................................339\nDay 17 Exceptions 341\nProgramming in the Large......................................................................342\nProgramming in the Small......................................................................345\nThe Limitations Placed on the Programmer ...........................................348\nThe finally Clause...................................................................................349\nSummary................................................................................................350\nQ&A......................................................................................................351\nxv\n030-4 FM 15 1\/29\/96, 8:11 PM\nP2\/V4SQC6 TY Java in 21 Days 030-4 louisa 12.31.95 FM LP#4 MTWTFSS\n21\nTeach Yourself JAVA in 21 Days\nDay 18 Multithreading 353\nThe Problem with Parallelism.................................................................354\nThinking Multithreaded.........................................................................355\nPoints About Points...........................................................................357\nProtecting a Class Variable.................................................................360\nCreating and Using Threads...................................................................361\nThe Runnable Interface......................................................................362\nThreadTester ......................................................................................363\nNamedThreadTester ...........................................................................365\nKnowing When a Thread has Stopped ...................................................366\nThread Scheduling .................................................................................367\nPreemptive Versus Nonpreemptive....................................................367\nTesting Your Scheduler......................................................................368\nSummary................................................................................................371\nQ&A......................................................................................................372\nDay 19 Streams 375\nInput Streams.........................................................................................377\nThe abstract Class InputStream...........................................................377\nByteArrayInputStream.........................................................................381\nFileInputStream..................................................................................382\nFilterInputStream...............................................................................383\nPipedInputStream...............................................................................389\nSequenceInputStream..........................................................................389\nStringBufferInputStream.....................................................................390\nOutput Streams......................................................................................391\nThe abstract Class OutputStream........................................................391\nByteArrayOutputStream......................................................................392\nFileOutputStream...............................................................................393\nFilterOutputStream.............................................................................394\nPipedOutputStream............................................................................399\nRelated Classes .......................................................................................399\nSummary................................................................................................399\nQ&A......................................................................................................400\nDay 20 Native Methods and Libraries 403\nDisadvantages of native Methods............................................................404\nThe Illusion of Required Efficiency........................................................405\nBuilt-In Optimizations......................................................................407\nSimple Optimization Tricks...............................................................407\nWriting native Methods..........................................................................408\nThe Example Class ............................................................................409\nGenerating Header and Stub Files .....................................................410\nCreating SimpleFileNative.c..............................................................414\nxvi\n030-4 FM 16 1\/29\/96, 8:11 PM\nP2\/V4SQC6 TY Java in 21 Days 030-4 louisa 12.31.95 FM LP#4 Sams.net Learning\nCenter\nabcd\nA Native Library.....................................................................................417\nLinking It All.....................................................................................418\nUsing Your Library............................................................................418\nSummary................................................................................................418\nQ&A......................................................................................................419\nDay 21 Under the Hood 421\nThe Big Picture ......................................................................................422\nWhy It\u2019s a Powerful Vision................................................................423\nThe Java Virtual Machine.......................................................................423\nAn Overview......................................................................................424\nThe Fundamental Parts......................................................................426\nThe Constant Pool ............................................................................430\nLimitations........................................................................................430\nBytecodes in More Detail.......................................................................431\nThe Bytecode Interpreter...................................................................431\nThe \u201cJust-in-Time\u201d Compiler............................................................432\nThe java2c Translator........................................................................433\nThe Bytecodes Themselves ................................................................434\nThe _quick Bytecodes ........................................................................450\nThe .class File Format.............................................................................452\nMethod Signatures .................................................................................454\nThe Garbage Collector...........................................................................455\nThe Problem......................................................................................455\nThe Solution......................................................................................456\nJava\u2019s Parallel Garbage Collector........................................................459\nThe Security Story..................................................................................459\nWhy You Should Worry....................................................................459\nWhy You Might Not Have To ..........................................................460\nJava\u2019s Security Model.........................................................................460\nSummary................................................................................................470\nQ&A......................................................................................................470\nA Language Summary 473\nReserved Words......................................................................................474\nComments..............................................................................................475\nLiterals....................................................................................................475\nVariable Declaration...............................................................................476\nVariable Assignment...............................................................................476\nOperators ...............................................................................................477\nObjects...................................................................................................478\nArrays.....................................................................................................478\nLoops and Conditionals..........................................................................478\nClass Definitions ....................................................................................479\nMethod and Constructor Definitions.....................................................479\nPackages, Interfaces, and Importing........................................................480\nExceptions and Guarding .......................................................................481\nxvii\n030-4 FM 17 1\/29\/96, 8:12 PM\nP2\/V4SQC6 TY Java in 21 Days 030-4 louisa 12.31.95 FM LP#4 MTWTFSS\n21\nTeach Yourself JAVA in 21 Days\nB Class Hierarchy Diagrams 483\nAbout These Diagrams...........................................................................495\nC The Java Class Library 497\njava.lang.................................................................................................498\nInterfaces...........................................................................................498\nClasses...............................................................................................498\njava.util ..................................................................................................499\nInterfaces...........................................................................................499\nClasses...............................................................................................499\njava.io.....................................................................................................500\nInterfaces...........................................................................................500\nClasses...............................................................................................500\njava.net...................................................................................................501\nInterfaces...........................................................................................501\nClasses...............................................................................................502\njava.awt..................................................................................................502\nInterfaces...........................................................................................502\nClasses...............................................................................................502\njava.awt.image........................................................................................504\nInterfaces...........................................................................................504\nClasses...............................................................................................504\njava.awt.peer...........................................................................................505\njava.applet...............................................................................................505\nInterfaces...........................................................................................505\nClasses...............................................................................................505\nD How Java Differs from C and C++ 507\nPointers..................................................................................................508\nArrays.....................................................................................................508\nStrings....................................................................................................508\nMemory Management............................................................................509\nData Types.............................................................................................509\nOperators ...............................................................................................509\nControl Flow..........................................................................................510\nArguments..............................................................................................510\nOther Differences...................................................................................510\nIndex 511\nxviii\n030-4 FM 18 1\/29\/96, 8:12 PM\nP2\/V4SQC6 TY Java in 21 Days 030-4 louisa 12.31.95 FM LP#4 Sams.net Learning\nCenter\nabcd\n1\n1\n1\nS\nS\nWEEK\nF 1\nR\nW\nAn Introduction to\nT\nJava Programming\nM\nby Laura Lemay\n3\n030-4s CH01.i 3 1\/29\/96, 8:34 PM\nP2\/V4sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch01 LP#4 MTWRFSS\nDDAAYY\n1 An Introduction to Java Programming\nHello and welcome to Teach Yourself Java in 21 Days! Starting today and for the next three weeks\nyou\u2019ll learn all about the Java language and how to use it to create applets, as well as how to create\nstand-alone Java applications that you can use for just about anything.\nNEW* An applet is a dynamic and interactive program that can run inside a Web page displayed\nTERM by a Java-capable browser such as HotJava or Netscape 2.0.\nThe HotJava browser is a World Wide Web browser used to view Web pages, follow links, and\nsubmit forms. It can also download and play applets on the reader\u2019s system.\nThat\u2019s the overall goal for the next three weeks. Today, the goals are somewhat more modest,\nand you\u2019ll learn about the following:\nnn What exactly Java and HotJava are, and their current status\nnn Why you should learn Java\u2014its various features and advantages over other program-\nming languages\nnn Getting started programming in Java\u2014what you\u2019ll need in terms of software and\nbackground, as well as some basic terminology\nnn How to create your first Java programs\u2014to close this day, you\u2019ll create both a simple\nJava application and a simple Java applet!\nWhat Is Java?\nJava is an object-oriented programming language developed by Sun Microsystems, a company\nbest known for its high-end Unix workstations. Modeled after C++, the Java language was\ndesigned to be small, simple, and portable across platforms and operating systems, both at the\nsource and at the binary level (more about this later).\nJava is often mentioned in the same breath as HotJava, a World Wide Web browser from Sun\nlike Netscape or Mosaic (see Figure 1.1). What makes HotJava different from most other\nbrowsers is that, in addition to all its basic Web features, it can also download and play applets\non the reader\u2019s system. Applets appear in a Web page much in the same way as images do, but\nunlike images, applets are dynamic and interactive. Applets can be used to create animations,\nfigures, or areas that can respond to input from the reader, games, or other interactive effects on\nthe same Web pages among the text and graphics.\nAlthough HotJava was the first World Wide Web browser to be able to play Java applets, Java\nsupport is rapidly becoming available in other browsers. Netscape 2.0 provides support for Java\napplets, and other browser developers have also announced support for Java in forthcoming\nproducts.\n4\n030-4s CH01.i 4 1\/29\/96, 8:34 PM\nP2\/V4sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch01 LP#4 Sams.net Learning\nCenter\nabcd\nFigure 1.1.\nThe HotJava browser.\n1\nTo create an applet, you write it in the Java language, compile it using a Java compiler, and refer\nto that applet in your HTML Web pages. You put the resulting HTML and Java files on a Web\nsite much in the same way that you make ordinary HTML and image files available. Then, when\nsomeone using the HotJava browser (or other Java-aware browser) views your page with the\nembedded applet, that browser downloads the applet to the local system and executes it, and\nthen the reader can view and interact with your applet in all its glory (readers using other\nbrowsers won\u2019t see anything). You\u2019ll learn more about how applets, browsers, and the World\nWide Web work together further on in this book.\nThe important thing to understand about Java is that you can do so much more with it besides\ncreate applets. Java was written as a full-fledged programming language in which you can\naccomplish the same sorts of tasks and solve the same sorts of problems that you can in other\nprogramming languages, such as C or C++. HotJava itself, including all the networking, display,\nand user interface elements, is written in Java.\n5\n030-4s CH01.i 5 1\/29\/96, 8:35 PM\nP2\/V4sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch01 LP#4 MTWRFSS\nDDAAYY\n1 An Introduction to Java Programming\nJava\u2019s Past, Present, and Future\nThe Java language was developed at Sun Microsystems in 1991 as part of a research project to\ndevelop software for consumer electronics devices\u2014television sets, VCRs, toasters, and the\nother sorts of machines you can buy at any department store. Java\u2019s goals at that time were to\nbe small, fast, efficient, and easily portable to a wide range of hardware devices. It is those same\ngoals that made Java an ideal language for distributing executable programs via the World Wide\nWeb, and also a general-purpose programming language for developing programs that are easily\nusable and portable across different platforms.\nThe Java language was used in several projects within Sun, but did not get very much commercial\nattention until it was paired with HotJava. HotJava was written in 1994 in a matter of months,\nboth as a vehicle for downloading and running applets and also as an example of the sort of\ncomplex application that can be written in Java.\nAt the time this book is being written, Sun has released the beta version of the Java Developer\u2019s\nKit (JDK), which includes tools for developing Java applets and applications on Sun systems\nrunning Solaris 2.3 or higher for Windows NT and for Windows 95. By the time you read this,\nsupport for Java development may have appeared on other platforms, either from Sun or from\nthird-party companies.\nNote that because the JDK is currently in beta, it is still subject to change between now and when\nit is officially released. Applets and applications you write using the JDK and using the examples\nin this book may require some changes to work with future versions of the JDK. However,\nbecause the Java language has been around for several years and has been used for several projects,\nthe language itself is quite stable and robust and most likely will not change excessively. Keep\nthis beta status in mind as you read through this book and as you develop your own Java\nprograms.\nSupport for playing Java programs is a little more confusing at the moment. Sun\u2019s HotJava is\nnot currently included with the Beta JDK; the only available version of HotJava is an older alpha\nversion, and, tragically, applets written for the alpha version of Java do not work with the beta\nJDK, and vice versa. By the time you read this, Sun may have released a newer version of HotJava\nwhich will enable you to view applets.\nThe JDK does include an application called appletviewer that allows you to test your Java applets\nas you write them. If an applet works in the appletviewer, it should work with any Java-capable\nbrowser. You\u2019ll learn more about applet viewer later today.\nWhat\u2019s in store for the future? In addition to the final Java release from Sun, other companies\nhave announced support for Java in their own World Wide Web browsers. Netscape Commu-\nnications Corporation has already incorporated Java capabilities into the 2.0 version of their very\npopular Netscape Navigator Web browser\u2014pages with embedded Java applets can be viewed\nand played with Netscape. With support for Java available in as popular a browser as Netscape,\n6\n030-4s CH01.i 6 1\/29\/96, 8:35 PM\nP2\/V4sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch01 LP#4 Sams.net Learning\nCenter\nabcd\ntools to help develop Java applications (debuggers, development environments, and so on) most\nlikely will be rapidly available as well.\n1\nWhy Learn Java?\nAt the moment, probably the most compelling reason to learn Java\u2014and probably the reason\nyou bought this book\u2014is that HotJava applets are written in Java. Even if that were not the case,\nJava as a language has significant advantages over other languages and other programming\nenvironments that make it suitable for just about any programming task. This section describes\nsome of those advantages.\nJava Is Platform-Independent\nPlatform independence is one of the most significant advantages that Java has over other\nprogramming languages, particularly for systems that need to work on many different platforms.\nJava is platform-independent at both the source and the binary level.\nNEW* Platform-independence is a program\u2019s capability of moving easily from one computer\nTERM system to another.\nAt the source level, Java\u2019s primitive data types have consistent sizes across all development\nplatforms. Java\u2019s foundation class libraries make it easy to write code that can be moved from\nplatform to platform without the need to rewrite it to work with that platform.\nPlatform-independence doesn\u2019t stop at the source level, however. Java binary files are also\nplatform-independent and can run on multiple problems without the need to recompile the\nsource. How does this work? Java binary files are actually in a form called bytecodes.\nNEW* Bytecodes are a set of instructions that looks a lot like some machine codes, but that is not\nTERM specific to any one processor.\nNormally, when you compile a program written in C or in most other languages, the compiler\ntranslates your program into machine codes or processor instructions. Those instructions are\nspecific to the processor your computer is running\u2014so, for example, if you compile your code\non a Pentium system, the resulting program will run only on other Pentium systems. If you want\nto use the same program on another system, you have to go back to your original source, get a\ncompiler for that system, and recompile your code. Figure 1.2 shows the result of this system:\nmultiple executable programs for multiple systems.\nThings are different when you write code in Java. The Java development environment has two\nparts: a Java compiler and a Java interpreter. The Java compiler takes your Java program and\ninstead of generating machine codes from your source files, it generates bytecodes.\n7\n030-4s CH01.i 7 1\/29\/96, 8:35 PM\nP2\/V4sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch01 LP#4 MTWRFSS\nDDAAYY\n1 An Introduction to Java Programming\nFigure 1.2. Binary File(cid:13)\n(Pentium)\nTraditional compiled\nprograms.\nYour Code\nCompiler (Pentium) Binary File(cid:13)\n(PowerPC)\nCompiler (PowerPC) Binary File(cid:13)\n(SPARC)\nCompiler (SPARC)\nTo run a Java program, you run a program called a bytecode interpreter, which in turn executes\nyour Java program (see Figure 1.3). You can either run the interpreter by itself, or\u2014for applets\u2014\nthere is a bytecode interpreter built into HotJava and other Java-capable browsers that runs the\napplet for you.\nFigure 1.3. Window\nJava programs.\nJava Interpreter(cid:13)\nJava Bytecode(cid:13) (Pentium)\nJava Code Java Compiler(cid:13) (Platform-(cid:13)\n(Pentium) Independent) Window\nJava Compiler(cid:13)\n(PowerPC) Java Interpreter(cid:13)\n(PowerPC)\nWindow\nJava Compiler(cid:13)\n(SPARC)\nJava Interpreter(cid:13)\n(SPARC)\n8\n030-4s CH01.i 8 1\/29\/96, 8:35 PM\nP2\/V4sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch01 LP#4 Sams.net Learning\nCenter\nabcd\nWhy go through all the trouble of adding this extra layer of the bytecode interpreter? Having\nyour Java programs in bytecode form means that instead of being specific to any one system, your\n1\nprograms can be run on any platform and any operating or window system as long as the Java\ninterpreter is available. This capability of a single binary file to be executable across platforms\nis crucial to what enables applets to work, because the World Wide Web itself is also platform-\nindependent. Just as HTML files can be read on any platform, so applets can be executed on any\nplatform that is a Java-capable browser.\nThe disadvantage of using bytecodes is in execution speed. Because system-specific programs\nrun directly on the hardware for which they are compiled, they run significantly faster than Java\nbytecodes, which must be processed by the interpreter. For many Java programs, the speed may\nnot be an issue. If you write programs that require more execution speed than the Java interpreter\ncan provide, you have several solutions available to you, including being able to link native code\ninto your Java program or using tools to convert your Java bytecodes into native code. Note that\nby using any of these solutions, you lose the portability that Java bytecodes provide. You\u2019ll learn\nabout each of these mechanisms on Day 20.\nJava Is Object-Oriented\nTo some, object-oriented programming (OOP) technique is merely a way of organizing\nprograms, and it can be accomplished using any language. Working with a real object-oriented\nlanguage and programming environment, however, enables you to take full advantage of object-\noriented methodology and its capabilities of creating flexible, modular programs and reusing\ncode.\nMany of Java\u2019s object-oriented concepts are inherited from C++, the language on which it is\nbased, but it borrows many concepts from other object-oriented languages as well. Like most\nobject-oriented programming languages, Java includes a set of class libraries that provide basic\ndata types, system input and output capabilities, and other utility functions. These basic classes\nare part of the Java development kit, which also has classes to support networking, common\nInternet protocols, and user interface toolkit functions. Because these class libraries are written\nin Java, they are portable across platforms as all Java applications are.\nYou\u2019ll learn more about object-oriented programming and Java tomorrow.\nJava Is Easy to Learn\nIn addition to its portability and object-orientation, one of Java\u2019s initial design goals was to be\nsmall and simple, and therefore easier to write, easier to compile, easier to debug, and, best of\nall, easy to learn. Keeping the language small also makes it more robust because there are fewer\nchances for programmers to make difficult-to-find mistakes. Despite its size and simple design,\nhowever, Java still has a great deal of power and flexibility.\n9\n030-4s CH01.i 9 1\/29\/96, 8:35 PM\nP2\/V4sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch01 LP#4 MTWRFSS\nDDAAYY\n1 An Introduction to Java Programming\nJava is modeled after C and C++, and much of the syntax and object-oriented structure is\nborrowed from the latter. If you are familiar with C++, learning Java will be particularly easy for\nyou, because you have most of the foundation already.\nAlthough Java looks similar to C and C++, most of the more complex parts of those languages\nhave been excluded from Java, making the language simpler without sacrificing much of its\npower. There are no pointers in Java, nor is there pointer arithmetic. Strings and arrays are real\nobjects in Java. Memory management is automatic. To an experienced programmer, these\nomissions may be difficult to get used to, but to beginners or programmers who have worked\nin other languages, they make the Java language far easier to learn.\nGetting Started with\nProgramming in Java\nEnough background! Let\u2019s finish off this day by creating two real Java programs: a stand-alone\nJava application and an applet that you can view in either in the appletviewer (part of the JDK)\nor in a Java-capable browser. Although both these programs are extremely simple, they will give\nyou an idea of what a Java program looks like and how to compile and run it.\nGetting the Software\nIn order to write Java programs, you will, of course, need a Java development environment. At\nthe time this book is being written, Sun\u2019s Java Development Kit provides everything you need\nto start writing Java programs. The JDK is available for Sun SPARC systems running Solaris 2.2\nor higher and for Windows NT and Windows 95. You can get the JDK from several places:\nnn The CD-ROM that came with this book contains the full JDK distribution. See the\nCD information for installation instructions.\nnn The JDK can be downloaded from Sun\u2019s Java FTP site at ftp:\/\/java.sun.com\/pub\/ or\nfrom a mirror site (ftp:\/\/www.blackdown.org\/pub\/Java\/pub\/is one).\nNote: The Java Development Kit is currently in beta release. By the time you read\nthis, The JDK may be available for other platforms, or other organizations may be\nselling Java development tools as well.\nAlthough Netscape and other Java-aware browsers provide an environment for playing Java\napplets, they do not provide a mechanism for developing Java applications. For that, you need\nseparate tools\u2014merely having a browser is not enough.\n10\n030-4s CH01.i 10 1\/29\/96, 8:35 PM\nP2\/V4sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch01 LP#4 Sams.net Learning\nCenter\nabcd\nApplets and Applications\nJava applications fall into two main groups: applets and applications. 1\nApplets, as you have learned, are Java programs that are downloaded over the World Wide Web\nand executed by a Web browser on the reader\u2019s machine. Applets depend on a Java-capable\nbrowser in order to run (although they can also be viewed using a tool called the appletviewer,\nwhich you\u2019ll learn about later today).\nJava applications are more general programs written in the Java language. Java applications don\u2019t\nrequire a browser to run, and in fact, Java can be used to create most other kinds of applications\nthat you would normally use a more conventional programming language to create. HotJava\nitself is a Java application.\nA single Java program can be an applet or an application or both, depending on how you write\nthat program and the capabilities that program uses. Throughout this first week, you\u2019ll be\nwriting mostly HotJava applications; then you\u2019ll apply what you\u2019ve learned to write applets in\nWeek 2. If you\u2019re eager to get started with applets, be patient. Everything that you learn while\nyou\u2019re creating simple Java applications will apply to creating applets, and it\u2019s easier to start with\nthe basics before moving onto the hard stuff. You\u2019ll be creating plenty of applets in Week 2.\nCreating a Java Application\nLet\u2019s start by creating a simple Java application: the classic Hello World example that all language\nbooks use to begin.\nAs with all programming languages, your Java source files are created in a plain text editor, or\nin an editor that can save files in plain ASCII without any formatting characters. On Unix,\nemacs, ped, or vi will work; on Windows, Notepad or DOS Edit are both text editors.\nFire up your editor of choice, and enter the Java program shown in Listing 1.1. Type this\nprogram, as shown, in your text editor. Be careful that all the parentheses, braces, and quotes\nare there.\nType\nListing 1.1. Your first Java application.\n1: class HelloWorld {\n2: public static void main (String args[]) {\n3: System.out.println(\u201cHello World!\u201d);\n4: }\n5: }\n11\n030-4s CH01.i 11 1\/29\/96, 8:35 PM\nP2\/V4sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch01 LP#4 MTWRFSS\nDDAAYY\n1 An Introduction to Java Programming\n!\n! Warning: The numbers before each line are part of the listing and not part of the\nprogram; they\u2019re there so I can refer to specific line numbers when I explain what\u2019s\ngoing on in the program. Do not include them in your own file.\nAnalysis This program has two main parts:\nnn All the program is enclosed in a class definition\u2014here, a class called HelloWorld.\nnn The body of the program (here, just the one line) is contained in a routine called\nmain(). In Java applications, as in a C or C++ program, main() is the first\nroutine that is run when the program is executed.\nYou\u2019ll learn more about both these parts of a Java application as the book progresses.\nOnce you finish typing the program, save the file. Conventionally, Java source files are named\nthe same name as the class they define, with an extension of .java. This file should therefore be\ncalled HelloWorld.java.\nNow, let\u2019s compile the source file using the Java compiler. In Sun\u2019s JDK, the Java compiler is\ncalled javac.\nTo compile your Java program, Make sure the javac program is in your execution path and type\njavac followed by the name of your source file:\njavac HelloWorld.java\nNote: In these examples, and in all the examples throughout this book, we\u2019ll be\nusing Sun\u2019s Java compiler, part of the JDK. If you have a third-party development\nenvironment, check with the documentation for that program to see how to\ncompile your Java programs.\nThe compiler should compile the file without any errors. If you get errors, go back and make\nsure that you\u2019ve typed the program exactly as it appears in Listing 1.1.\nWhen the program compiles without errors, you end up with a file called HelloWorld.class, in\nthe same directory as your source file. This is your Java bytecode file. You can then run that\nbytecode file using the Java interpreter. In the JDK, the Java interpreter is called simply java.\nMake sure the java program is in your path and type java followed by the name of the file without\nthe .class extension:\njava HelloWorld\n12\n030-4s CH01.i 12 1\/29\/96, 8:35 PM\nP2\/V4sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch01 LP#4 Sams.net Learning\nCenter\nabcd\nIf your program was typed and compiled correctly, you should get the string \u201cHello World!\u201d\nprinted to your screen as a response.\n1\nNote: Remember, the Java compiler and the Java interpreter are different things.\nYou use the Java compiler (javac) for your Java source files to create .class files, and\nyou use the Java interpreter (java)to actually run your class files.\nCreating a Java Applet\nCreating applets is different from creating a simple application, because Java applets run and are\ndisplayed inside a Web page with other page elements and as such have special rules for how they\nbehave. Because of these special rules for applets in many cases (particularly the simple ones),\ncreating an applet may be more complex than creating an application.\nFor example, to do a simple Hello World applet, instead of merely being able to print a message,\nyou have to create an applet to make space for your message and then use graphics operations\nto paint the message to the screen.\nNote: Actually, if you run the Hello World application as an applet, the Hello\nWorld message prints to a special window or to a log file, depending on how the\nbrowser has screen messages set up. It will not appear on the screen unless you\nwrite your applet to put it there.\nIn the next example, you create that simple Hello World applet, place it inside a Web page, and\nview the result.\nFirst, you set up an environment so that your Java-capable browser can find your HTML files\nand your applets. Much of the time, you\u2019ll keep your HTML files and your applet code in the\nsame directory. Although this isn\u2019t required, it makes it easier to keep track of each element. In\nthis example, you use a directory called HTML that contains all the files you\u2019ll need.\nmkdir HTML\nNow, open up that text editor and enter Listing 1.2.\n13\n030-4s CH01.i 13 1\/29\/96, 8:36 PM\nP2\/V4sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch01 LP#4 MTWRFSS\nDDAAYY\n1 An Introduction to Java Programming\nType\nListing 1.2. The Hello World applet.\n1: import java.awt.Graphics;\n2:\n3: class HelloWorldApplet extends java.applet.Applet {\n4:\n5: public void paint(Graphics g) {\n6: g.drawString(\u201cHello world!\u201d, 5, 25);\n7: }\n8:}\nSave that file inside your HTML directory. Just like with Java applications, give your file a name\nthat has the same name as the class. In this case, the filename would be HelloWorldApplet.java.\nFeatures to note about applets? There are a couple I\u2019d like to point out:\nnn The import line at the top of the file is somewhat analogous to an #include statement\nin C; it enables this applet to interact with the JDK classes for creating applets and for\ndrawing graphics on the screen.\nnn The paint() method displays the content of the applet onto the screen. Here, the\nstring Hello World gets drawn. Applets use several standard methods to take the place\nof main(), which include init() to initialize the applet, start() to start it running,\nand paint() to display it to the screen. You\u2019ll learn about all of these in Week 2.\nNow, compile the applet just as you did the application, using javac, the Java compiler.\njavac HelloWorldApplet.java\nAgain, just as for applications, you should now have a file called HelloWorldApplet.class in your\nHTML directory.\nTo include an applet in a Web page, you refer to that applet in the HTML code for that Web\npage. Here, you create a very simple HTML file in the HTML directory (see Listing 1.3).\nType\nListing 1.3. The HTML with the applet in it.\n1: <HTML>\n2: <HEAD>\n3: <TITLE>Hello to Everyone!<\/TITLE>\n4: <\/HEAD><BODY>\n5: <P>My Java applet says:\n6: <APPLET CODE=\u201dHelloWorldApplet.class\u201d WIDTH=150 HEIGHT=25>\n7: <\/BODY>\n8: <\/HTML>\n14\n030-4s CH01.i 14 1\/29\/96, 8:36 PM\nP2\/V4sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch01 LP#4 Sams.net Learning\nCenter\nabcd\nAnalysis You refer to an applet in your HTML files with the <APPLET> tag. You\u2019ll learn more about\n<APPLET> later on, but here are two things to note:\n1\nnn Use the CODE attribute to indicate the name of the class that contains your applet.\nnn Use the WIDTH and HEIGHT attributes to indicate the size of the applet. The browser uses\nthese values to know how big a chunk of space to leave for the applet on the page.\nHere, a box 150 pixels wide and 25 pixels high is created.\nSave the HTML file in your HTML directory, with a descriptive name (for example, you might\nname your HTML file the same name as your applet\u2014HellowWorldApplet.html).\nAnd now, you\u2019re ready for the final test\u2014actually viewing the result of your applet. To view the\napplet, you need one of the following:\nnn A browser that supports Java applets, such as Netscape 2.0.\nnn The appletviewer application, which is part of the JDK. The appletviewer is not a\nWeb browser and won\u2019t enable you to see the entire Web page, but it\u2019s acceptable for\ntesting to see how an applet will look and behave if there is nothing else available.\nNote: Do not use the alpha version of HotJava to view your applets; applets\ndeveloped with the beta JDK and onward cannot be viewed by the alpha HotJava.\nIf, by the time you read this, there is a more recent version of HotJava, you can use\nthat one instead.\nIf you\u2019re using a Java-capable browser such as Netscape to view your applet files, you can use the\nOpen Local... item under the File menu to navigate to the HTML file containing the applet\n(make sure you open the HTML file and not the class file). You don\u2019t need to install anything\non a Web server yet; all this works on your local system.\nIf you don\u2019t have a Web browser with Java capabilities built into it, you can use the appletviewer\nprogram to view your Java applet. To run appletviewer, just indicate the path to the HTML file\non the command line:\nappletviewer HTML\/HelloWorldApplet.html\nTip: Although you can start appletviewer from the same directory as your HTML\nand class files, you may not be able to reload that applet without quitting\nappletviewer first. If you start appletviewer from some other directory (as in the\nprevious command line), you can modify and recompile your Java applets and then\njust use the Reload menu item to view the newer version.\n15\n030-4s CH01.i 15 1\/29\/96, 8:36 PM\nP2\/V4sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch01 LP#4 MTWRFSS\nDDAAYY\n1 An Introduction to Java Programming\nNow, if you use the browser to view the applet, you see something similar to the image shown\nin Figure 1.4. If you\u2019re using appletviewer, you won\u2019t see the text around the applet (My Java\napplet says...), but you will see the Hello World itself.\nFigure 1.4.\nThe Hello World applet.\nSummary\nToday, you got a basic introduction to the Java language and its goals and features. Java is a\nprogramming language, similar to C or C++, in which you can develop a wide range of programs.\nThe most common use of Java at the moment is in creating applets for HotJava, an advanced\nWorld Wide Web browser also written in Java. Applets are Java programs that are downloaded\nand run as part of a Web page. Applets can create animations, games, interactive programs, and\nother multimedia effects on Web pages.\nJava\u2019s strengths lie in its portability\u2014both at the source and at the binary level, in its object-\noriented design\u2014and in its simplicity. Each of these features help make applets possible, but\nthey also make Java an excellent language for writing more general-purpose programs that do\nnot require HotJava or other Java-capable browser to run. These general-purpose Java programs\nare called applications. HotJava itself is a Java application.\nTo end this day, you experimented with an example applet and an example application, getting\na feel for the differences between the two and how to create, compile, and run Java programs\u2014\nor, in the case of applets, how to include them in Web pages. From here, you now have the\nfoundation to create more complex applications and applets.\nQ&A\nQ I\u2019d like to use HotJava as my regular Web browser. You haven\u2019t mentioned much\nabout HotJava today.\nA The focus of this book is primarily on programming in Java and in the HotJava\nclasses, rather than on using HotJava itself. Documentation for using the HotJava\nbrowser comes with the HotJava package.\nQ I know a lot about HTML, but not much about computer programming. Can I\nstill write Java programs?\n16\n030-4s CH01.i 16 1\/29\/96, 8:36 PM\nP2\/V4sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch01 LP#4 Sams.net Learning\nCenter\nabcd\nA If you have no programming experience whatsoever, you most likely will find pro-\ngramming Java significantly more difficult. However, Java is an excellent language to\n1\nlearn programming with, and if you patiently work through the examples and the\nexercises in this book, you should be able to learn enough to get started with Java.\nQ According to today\u2019s lesson, Java applets are downloaded via HotJava and run on\nthe reader\u2019s system. Isn\u2019t that an enormous security hole? What stops someone\nfrom writing an applet that compromises the security of my system\u2014or worse,\nthat damages my system?\nA Sun\u2019s Java team has thought a great deal about the security of applets within Java-\ncapable browsers and has implemented several checks to make sure applets cannot do\nnasty things:\nnn Java applets cannot read or write to the disk on the local system.\nnn Java applets cannot execute any programs on the local system.\nnn Java applets cannot connect to any machines on the Web except for the server\nfrom which they are originally downloaded.\nIn addition, the Java compiler and interpreter check both the Java source code and the\nJava bytecodes to make sure that the Java programmer has not tried any sneaky tricks\n(for example, overrunning buffers or stack frames).\nThese checks obviously cannot stop every potential security hole, but they can\nsignificantly reduce the potential for hostile applets. You\u2019ll learn more about security\nissues later on in this book.\nQ I followed all the directions you gave for creating a Java applet. I loaded it into\nHotJava, but Hello World didn\u2019t show up. What did I do wrong?\nA I\u2019ll bet you\u2019re using the alpha version of HotJava to view the applet. Unfortunately,\nbetween alpha and beta, significant changes were made as to how applets are written.\nThe result is that you can\u2019t view beta applets (as this one was) in the alpha version of\nHotJava, nor can you view alpha applets in browsers that expect beta applets. To view\nthe applet, either use a different browser, or use the appletviewer application that\ncomes with the JDK.\n17\n030-4s CH01.i 17 1\/29\/96, 8:36 PM\nP2\/V4sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch01 LP#4 Sams.net Learning\nCenter\nabcd\n2\n2\n2\nS\nS\nWEEK\nF 1\nR\nW\nObject-Oriented\nT\nProgramming\nM\nand Java\nby Laura Lemay\n19\n030-4S CH02.i 19 1\/29\/96, 8:37 PM\nP2\/V4sqc6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch02 LP#3 MTWRFSS\nDDAAYY\n2 Object-Oriented Programming and Java\nObject-oriented programming (OOP) is one of the bigger programming buzzwords of recent\nyears, and you can spend years learning all about object-oriented programming methodologies\nand how they can make your life easier than The Old Way of programming. It all comes down\nto organizing your programs in ways that echo how things are put together in the real world.\nToday, you\u2019ll get an overview of object-oriented programming concepts in Java and how they\nrelate to how you structure your own programs:\nnn What classes and objects are, and how they relate to each other\nnn The two main parts of a class or object: its behaviors and its attributes\nnn Class inheritance and how inheritance affects the way you design your programs\nnn Some information about packages and interfaces\nIf you\u2019re already familiar with object-oriented programming, much of today\u2019s lesson will be old\nhat to you. You may want to skim it and go to a movie today instead. Tomorrow, you\u2019ll get into\nmore specific details.\nThinking in Objects: An Analogy\nConsider, if you will, Legos. Legos, for those who do not spend much time with children, are\nsmall plastic building blocks in various colors and sizes. They have small round bits on one side\nthat fit into small round holes on other Legos so that they fit together snugly to create larger\nshapes. With different Lego bits (Lego wheels, Lego engines, Lego hinges, Lego pulleys), you can\nput together castles, automobiles, giant robots that swallow cities, or just about anything else you\ncan create. Each Lego bit is a small object that fits together with other small objects in predefined\nways to create other larger objects.\nHere\u2019s another example. You can walk into a computer store and, with a little background and\noften some help, assemble an entire PC computer system from various components: a\nmotherboard, a CPU chip, a video card, a hard disk, a keyboard, and so on. Ideally, when you\nfinish assembling all the various self-contained units, you have a system in which all the units\nwork together to create a larger system with which you can solve the problems you bought the\ncomputer for in the first place.\nInternally, each of those components may be vastly complicated and engineered by different\ncompanies with different methods of design. But you don\u2019t need to know how the component\nworks, what every chip on the board does, or how, when you press the A key, an \u201cA\u201d gets sent\nto your computer. As the assembler of the overall system, each component you use is a self-\ncontained unit, and all you are interested in is how the units interact with each other. Will this\nvideo card fit into the slots on the motherboard and will this monitor work with this video card?\nWill each particular component speak the right commands to the other components it interacts\nwith so that each part of the computer is understood by every other part? Once you know what\n20\n030-4S CH02.i 20 1\/29\/96, 8:37 PM\nP2\/V4sqc6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch02 LP#3 Sams.net Learning\nCenter\nabcd\nthe interactions are between the components and can match the interactions, putting together\nthe overall system is easy.\nWhat does this have to do with programming? Everything. Object-oriented programming\nworks in exactly this same way. Using object-oriented programming, your overall program is\nmade up of lots of different self-contained components (objects), each of which has a specific\nrole in the program and all of which can talk to each other in predefined ways.\n2\nObjects and Classes\nObject-oriented programming is modeled on how, in the real world, objects are often made up\nof many kinds of smaller objects. This capability of combining objects, however, is only one very\ngeneral aspect of object-oriented programming. Object-oriented programming provides several\nother concepts and features to make creating and using objects easier and more flexible, and the\nmost important of these features is that of classes.\nNEW* A class is a template for multiple objects with similar features. Classes embody all the\nTERM features of a particular set of objects.\nWhen you write a program in an object-oriented language, you don\u2019t define actual objects. You\ndefine classes of objects.\nFor example, you might have a Tree class that describes the features of all trees (has leaves and\nroots, grows, creates chlorophyll). The Tree class serves as an abstract model for the concept of\na tree\u2014to reach out and grab, or interact with, or cut down a tree you have to have a concrete\ninstance of that tree. Of course, once you have a tree class, you can create lots of different\ninstances of that tree, and each different tree instance can have different features (short, tall,\nbushy, drops leaves in Autumn), while still behaving like and being immediately recognizable\nas a tree (see Figure 2.1).\nNEW* An instance of a class is another word for an actual object. If classes are an abstract\nTERM representation of an object, an instance is its concrete representation.\nSo what, precisely, is the difference between an instance and an object? Nothing, really. Object\nis the more general term, but both instances and objects are the concrete representation of a class.\nIn fact, the terms instance and object are often used interchangeably in OOP language. An\ninstance of a tree and a tree object are both the same thing.\nIn an example closer to the sort of things you might want to do in Java programming, you might\ncreate a class for the user interface element called a button. The Button class defines the features\nof a button (its label, its size, its appearance) and how it behaves (does it need a single click or\na double click to activate it, does it change color when it\u2019s clicked, what does it do when it\u2019s\nactivated?). Once you define the Button class, you can then easily create instances of that\nbutton\u2014that is, button objects\u2014that all take on the basic features of the button as defined by\n21\n030-4S CH02.i 21 1\/29\/96, 8:37 PM\nP2\/V4sqc6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch02 LP#3 MTWRFSS\nDDAAYY\n2 Object-Oriented Programming and Java\nthe class, but may have different appearances and behavior based on what you want that\nparticular button to do. By creating a Button class, you don\u2019t have to keep rewriting the code\nfor each individual button you want to use in your program, and you can reuse the Button class\nto create different kinds of buttons as you need them in this program and in other programs.\nFigure 2.1.\nThe tree class and\ntree instances.\nTree\nTree\nTree Class(cid:13)\n(Abstract)\nTree\nTree\nTip: If you\u2019re used to programming in C, you can think of a class as sort of\ncreating a new composite data type by using struct and typedef. Classes, how-\never, can provide much more than just a collection of data, as you\u2019ll discover in the\nrest of today\u2019s lesson.\nWhen you write a Java program, you design and construct a set of classes. Then, when your\nprogram runs, instances of those classes are created and discarded as needed. Your task, as a Java\nprogrammer, is to create the right set of classes to accomplish what your program needs to\naccomplish.\n22\n030-4S CH02.i 22 1\/29\/96, 8:37 PM\nP2\/V4sqc6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch02 LP#3 Sams.net Learning\nCenter\nabcd\nFortunately, you don\u2019t have to start from the very beginning: the Java environment comes with\na library of classes that implement a lot of the basic behavior you need\u2014not only for basic\nprogramming tasks (classes to provide basic math functions, arrays, strings, and so on), but also\nfor graphics and networking behavior. In many cases, the Java class libraries may be enough so\nthat all you have to do in your Java program is create a single class that uses the standard class\nlibraries. For complicated Java programs, you may have to create a whole set of classes with\ndefined interactions between them.\n2\nNEW* A class library is a set of classes.\nTERM\nBehavior and Attributes\nEvery class you write in Java is generally made up of two components: attributes and behavior.\nIn this section, you\u2019ll learn about each one as it applies to a thoeretical class called Motorcycle.\nTo finish up this section, you\u2019ll create the Java code to implement a representation of a\nmotorcycle.\nAttributes\nAttributes are the individual things that differentiate one object from another and determine the\nappearance, state, or other qualities of that object. Let\u2019s create a theoretical class called\nMotorcycle. The attributes of a motorcycle might include the following:\nnn Color: red, green, silver, brown\nnn Style: cruiser, sport bike, standard\nnn Make: Honda, BMW, Bultaco\nAttributes of an object can also include information about its state; for example, you could have\nfeatures for engine condition (off or on) or current gear selected.\nAttributes are defined by variables; in fact, you can consider them analogous to global variables\nfor the entire object. Because each instance of a class can have different values for its variables,\neach variable is called an instance variable.\nNEW* Instance variables define the attributes of an object. The class defines the kind of attribute,\nTERM and each instance stores its own value for that attribute.\nEach attribute, as the term is used here, has a single corresponding instance variable; changing\nthe value of a variable changes the attribute of that object. Instance variables may be set when\nan object is created and stay constant throughout the life of the object, or they may be able to\nchange at will as the program runs.\n23\n030-4S CH02.i 23 1\/29\/96, 8:38 PM\nP2\/V4sqc6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch02 LP#3 MTWRFSS\nDDAAYY\n2 Object-Oriented Programming and Java\nIn addition to instance variables, there are also class variables, which apply to the class itself and\nto all its instances. Unlike instance variables, whose values are stored in the instance, class\nvariables\u2019 values are stored in the class itself. You\u2019ll learn about class variables later on this week;\nyou\u2019ll learn more specifics about instance variables tomorrow.\nBehavior\nA class\u2019s behavior determines what instances of that class do when their internal state changes\nor when that instance is asked to do something by another class or object. Behavior is the way\nobjects can do anything to themselves or have anything done to them. For example, to go back\nto the theoretical Motorcycle class, here are some behaviors that the Motorcycle class might have:\nnn Start the engine\nnn Stop the engine\nnn Speed up\nnn Change gear\nnn Stall\nTo define an object\u2019s behavior, you create methods, which look and behave just like functions\nin other languages, but are defined inside a class. Java does not have functions defined outside\nclasses (as C++ does).\nNEW* Methods are functions defined inside classes that operate on instances of those classes.\nTERM\nMethods don\u2019t always affect only a single object; objects communicate with each other using\nmethods as well. A class or object can call methods in another class or object to communicate\nchanges in the environment or to ask that object to change its state.\nJust as there are instance and class variables, there are also instance and class methods. Instance\nmethods (which are so common they\u2019re usually just called methods) apply and operate on an\ninstance; class methods apply and operate on a class (or on other objects). You\u2019ll learn more about\nclass methods later on this week.\nCreating a Class\nUp to this point, today\u2019s lesson has been pretty theoretical. In this section, you\u2019ll create a working\nexample of the Motorcycle class so that you can see how instance variables and methods are\ndefined in a class. You\u2019ll also create a Java application that creates a new instance of the\nMotorcycle class and shows its instance variables.\n24\n030-4S CH02.i 24 1\/29\/96, 8:38 PM\nP2\/V4sqc6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch02 LP#3 Sams.net Learning\nCenter\nabcd\nNote: I\u2019m not going to go into a lot of detail about the actual syntax of this\nexample here. Don\u2019t worry too much about it if you\u2019re not really sure what\u2019s going\non; it will become clear to you later on this week. All you really need to worry\nabout in this example is understanding the basic parts of this class definition.\nReady? Let\u2019s start with a basic class definition. Open up that editor and enter the following: 2\nclass Motorcycle {\n}\nCongratulations! You\u2019ve now created a class. Of course, it doesn\u2019t do very much at the moment,\nbut that\u2019s a Java class at its very simplest.\nFirst, let\u2019s create some instance variables for this class\u2014three of them, to be specific. Just below\nthe first line, add the following three lines:\nString make;\nString color;\nboolean engineState;\nHere, you\u2019ve created three instance variables: two, make and color, can contain String objects\n(String is part of that standard class library mentioned earlier). The third, engineState, is a\nboolean that refers to whether the engine is off or on.\nTechnical Note: boolean in Java is a real data type that can have the value true or\nfalse. Unlike C, booleans are not numbers. You\u2019ll hear about this again tomorrow\nso you won\u2019t forget.\nNow let\u2019s add some behavior (methods) to the class. There are all kinds of things a motorcycle\ncan do, but to keep things short, let\u2019s add just one method\u2014a method that starts the engine.\nAdd the following lines below the instance variables in your class definition:\nvoid startEngine() {\nif (engineState == true)\nSystem.out.println(\u201cThe engine is already on.\u201d);\nelse {\nengineState = true;\nSystem.out.println(\u201cThe engine is now on.\u201d);\n}\n}\n25\n030-4S CH02.i 25 1\/29\/96, 8:38 PM\nP2\/V4sqc6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch02 LP#3 MTWRFSS\nDDAAYY\n2 Object-Oriented Programming and Java\nThe startEngine method tests to see whether the engine is already running (in the line\nengineState == true) and, if it is, merely prints a message to that effect. If the engine isn\u2019t already\nrunning, it changes the state of the engine to true and then prints a message.\nWith your methods and variables in place, save the program to a file called Motorcycle.java\n(remember, you should always name your Java files the same names as the class they define).\nHere\u2019s what your program should look like so far:\nclass Motorcycle {\nString make;\nString color;\nboolean engineState;\nvoid startEngine() {\nif (engineState == true)\nSystem.out.println(\u201cThe engine is already on.\u201d);\nelse {\nengineState = true;\nSystem.out.println(\u201cThe engine is now on.\u201d);\n}\n}\n}\nTip: The indentation of each part of the class isn\u2019t important to the Java compiler.\nUsing some form of indentation, however, makes your class definition easier for\nyou and for other people to read. The indentation used here, with instance vari-\nables and methods indented from the class definition, is the style used throughout\nthis book. The Java class libraries use a similar indentation. You can choose any\nindentation style that you like.\nBefore you compile this class, let\u2019s add one more method. The showAtts method prints the\ncurrent values of the instance variables in an instance of your Motorcycle class. Here\u2019s what it\nlooks like:\nvoid showAtts() {\nSystem.out.println(\u201cThis motorcycle is a \u201c\n+ color + \u201c \u201c + make);\nif (engineState == true)\nSystem.out.println(\u201cThe engine is on.\u201d);\nelse System.out.println(\u201cThe engine is off.\u201d);\n}\nThe showAtts method prints two lines to the screen: the make and color of the motorcycle object,\nand whether or not the engine is on or off.\n26\n030-4S CH02.i 26 1\/29\/96, 8:38 PM\nP2\/V4sqc6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch02 LP#3 Sams.net Learning\nCenter\nabcd\nSave that file again and compile it using javac:\njavac Motorcycle.java\nNote: After this point, I\u2019m going to assume you know how to compile and run Java\nprograms. I won\u2019t repeat this information after this.\n2\nWhat happens if you now use the Java interpreter to run this compiled class? Try it. Java assumes\nthat this class is an application and looks for a main method. This is just a class, however, so it\ndoesn\u2019t have a main method. The Java interpreter (java) gives you an error like this one:\nIn class Motorcycle: void main(String argv[]) is not defined\nTo do something with the Motorcycle class\u2014for example, to create instances of that class and\nplay with them\u2014you\u2019re going to need to create a Java application that uses this class or add a\nmain method to this one. For simplicity\u2019s sake, let\u2019s do the latter. Listing 2.1 shows the main()\nmethod you\u2019ll add to the Motorcycle class (you\u2019ll go over what this does in a bit).\nType\nListing 2.1. The main() method for Motorcycle.java.\n1: public static void main (String args[]) {\n2: Motorcycle m = new Motorcycle();\n3: m.make = \u201cYamaha RZ350\u201d;\n4: m.color = \u201cyellow\u201d;\n5: System.out.println(\u201cCalling showAtts...\u201d);\n6: m.showAtts();\n7: System.out.println(\u201c--------\u201d);\n8: System.out.println(\u201cStarting engine...\u201d);\n9: m.startEngine();\n10: System.out.println(\u201c--------\u201d);\n11: System.out.println(\u201cCalling showAtts...\u201d);\n12: m.showAtts();\n13: System.out.println(\u201c--------\u201d);\n14: System.out.println(\u201cStarting engine...\u201d);\n15: m.startEngine();\n16:}\nWith the main() method, the Motorcycle class is now an application, and you can compile it\nagain and this time it\u2019ll run. Here\u2019s how the output should look:\nOutput Calling showAtts...\nThis motorcycle is a yellow Yamaha RZ350\nThe engine is off.\n--------\n27\n030-4S CH02.i 27 1\/29\/96, 8:38 PM\nP2\/V4sqc6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch02 LP#3 MTWRFSS\nDDAAYY\n2 Object-Oriented Programming and Java\nStarting engine...\nThe engine is now on.\n--------\nCalling showAtts...\nThis motorcycle is a yellow Yamaha RZ350\nThe engine is on.\n--------\nStarting engine...\nThe engine is already on.\nAnalysis The contents of the main() method are all going to look very new to you, so let\u2019s go through\nit line by line so that you at least have a basic idea of what it does (you\u2019ll get details about\nthe specifics of all of this tomorrow and the day after).\nThe first line declares the main() method. The main() method always looks like this; you\u2019ll learn\nthe specifics of each part later this week.\nLine 2, Motorcycle m = new Motorcycle(), creates a new instance of the Motorcycle class and\nstores a reference to it in the variable m. Remember, you don\u2019t usually operate directly on classes\nin your Java programs; instead, you create objects from those classes and then modify and call\nmethods in those objects.\nLines 3 and 4 set the instance variables for this motorcycle object: the make is now a Yamaha RZ350\n(a very pretty motorcycle from the mid-1980s), and the color is yellow.\nLines 5 and 6 call the showAtts() method, defined in your motorcycle object. (Actually, only\n6 does; 5 just prints a message that you\u2019re about to call this method.) The new motorcycle object\nthen prints out the values of its instance variables\u2014the make and color as you set in the previous\nlines\u2014and shows that the engine is off.\nLine 7 prints a divider line to the screen; this is just for prettier output.\nLine 9 calls the startEngine() method in the motorcycle object to start the engine. The engine\nshould now be on.\nLine 12 prints the values of the instance variables again. This time, the report should say the\nengine is now on.\nLine 15 tries to start the engine again, just for fun. Because the engine is already on, this should\nprint the error message.\nInheritance, Interfaces, and Packages\nNow that you have a basic grasp of classes, objects, methods, variables, and how to put it all\ntogether in a Java program, it\u2019s time to confuse you again. Inheritance, interfaces, and packages\nare all mechanisms for organizing classes and class behaviors. The Java class libraries use all these\nconcepts, and the best class libraries you write for your own programs will also use these concepts.\n28\n030-4S CH02.i 28 1\/29\/96, 8:39 PM\nP2\/V4sqc6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch02 LP#3 Sams.net Learning\nCenter\nabcd\nInheritance\nInheritance is one of the most crucial concepts in object-oriented programming, and it has a very\ndirect effect on how you design and write your Java classes. Inheritance is a powerful mechanism\nthat means when you write a class you only have to specify how that class is different from some\nother class, while also giving you dynamic access to the information contained in those other\nclasses.\nNEW*\nWith inheritance, all classes\u2014those you write, those from other class libraries that you use,\n2\nTERM\nand those from the standard utility classes as well\u2014are arranged in a strict hierarchy (see\nFigure 2.2).\nEach class has a superclass (the class above it in the hierarchy), and each class can have one or\nmore subclasses (classes below that class in the hierarchy). Classes further down in the hierarchy\nare said to inherit from classes further up in the hierarchy.\nFigure 2.2.\nA class hierarchy.\nClass A \u2022 Class A is the superclass of B(cid:13)\n\u2022 Class B is a subclass of A(cid:13)\n\u2022 Class B is the superclass(cid:13)\nof C, D, and E(cid:13)\n\u2022 Classes C, D, and E(cid:13)\nare subclasses of B\nClass B\nClass C Class D Class E\nSubclasses inherit all the methods and variables from their superclasses\u2014that is, in any particular\nclass, if the superclass defines behavior that your class needs, you don\u2019t have to redefine it or copy\nthat code from some other class. Your class automatically gets that behavior from its superclass,\nthat superclass gets behavior from its superclass, and so on all the way up the hierarchy. Your\nclass becomes a combination of all the features of the classes above it in the hierarchy.\nAt the top of the Java class hierarchy is the class Object; all classes inherit from this one superclass.\nObject is the most general class in the hierarchy; it defines behavior specific to all objects in the\nJava class hierarchy. Each class farther down in the hierarchy adds more information and\nbecomes more tailored to a specific purpose. In this way, you can think of a class hierarchy as\n29\n030-4S CH02.i 29 1\/29\/96, 8:39 PM\nP2\/V4sqc6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch02 LP#3 MTWRFSS\nDDAAYY\n2 Object-Oriented Programming and Java\ndefining very abstract concepts at the top of the hierarchy and those ideas becoming more\nconcrete the farther down the chain of superclasses you go.\nMost of the time when you write new Java classes, you\u2019ll want to create a class that has all the\ninformation some other class has, plus some extra information. For example, you may want a\nversion of a Button with its own built-in label. To get all the Button information, all you have\nto do is define your class to inherit from Button. Your class will automatically get all the behavior\ndefined in Button (and in Button\u2019s superclasses), so all you have to worry about are the things\nthat make your class different from Button itself. This mechanism for defining new classes as the\ndifferences between them and their superclasses is called subclassing.\nNEW* Subclassing involves creating a new class that inherits from some other class in the class\nTERM hierarchy. Using subclassing, you only need to define the differences between your class\nand its parent; the additional behavior is all available to your class through inheritance.\nWhat if your class defines entirely new behavior, and isn\u2019t really a subclass of another class? Your\nclass can also inherit directly from Object, which still allows it to fit neatly into the Java class\nhierarchy. In fact, if you create a class definition that doesn\u2019t indicate its superclass in the first\nline, Java automatically assumes you\u2019re inheriting from Object. The Motorcycle class you created\nin the previous section inherited from Object.\nCreating a Class Hierarchy\nIf you\u2019re creating a larger set of classes, it makes sense for your classes not only to inherit from\nthe existing class hierarchy, but also to make up a hierarchy themselves. This may take some\nplanning beforehand when you\u2019re trying to figure out how to organize your Java code, but the\nadvantages are significant once it\u2019s done:\nnn When you develop your classes in a hierarchy, you can factor out information com-\nmon to multiple classes in superclasses, and then reuse that superclass\u2019s information\nover and over again. Each subclass gets that common information from its superclass.\nnn Changing (or inserting) a class further up in the hierarchy automatically changes the\nbehavior of the lower classes\u2014no need to change or recompile any of the lower\nclasses, because they get the new information through inheritance and not by copying\nany of the code.\nFor example, let\u2019s go back to that Motorcycle class, and pretend you created a Java program to\nimplement all the features of a motorcycle. It\u2019s done, it works, and everything is fine. Now, your\nnext task is to create a Java class called Car.\nCar and Motorcycle have many similar features\u2014both are vehicles driven by engines. Both\nhave transmissions and headlamps and speedometers. So, your first impulse may be to open up\nyour Motorcycle class file and copy over a lot of the information you already defined into the\nnew class Car.\n30\n030-4S CH02.i 30 1\/29\/96, 8:39 PM\nP2\/V4sqc6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch02 LP#3 Sams.net Learning\nCenter\nabcd\nA far better plan is to factor out the common information for Car and Motorcycle into a more\ngeneral class hierarchy. This may be a lot of work just for the classes Motorcycle and Car, but once\nyou add Bicycle, Scooter, Truck, and so on, having common behavior in a reuseable superclass\nsignificantly reduces the amount of work you have to do overall.\nLet\u2019s design a class hierarchy that might serve this purpose. Starting at the top is the class Object,\nwhich is the root of all Java classes. The most general class to which motorcycle and car both\nbelong might be called Vehicle. A vehicle, generally, is defined as a thing that propels someone 2\nfrom one place to another. In the Vehicle class, you define only the behavior that enables\nsomeone to be propelled from point a to point b, and nothing more.\nBelow Vehicle? How about two classes: PersonPoweredVehicle and EnginePoweredVehicle?\nEnginePoweredVehicle is different from Vehicle because is has an engine, and the behaviors\nmight include stopping and starting the engine, having certain amounts of gasoline and oil, and\nperhaps the speed or gear in which the engine is running. Person-powered vehicles have some\nkind of mechanism for translating people motion into vehicle motion\u2014pedals, for example.\nFigure 2.3 shows what you have so far.\nFigure 2.3.\nThe basic vehicle hierarchy.\nObject\nVehicle\nPersonPoweredVehicle EnginePoweredVehicle\nNow, let\u2019s become even more specific. With EnginePoweredVehicle, you might have several\nclasses: Motorcycle, Car, Truck, and so on. Or you can factor out still more behavior and have\nintermediate classes for TwoWheeled and FourWheeled vehicles, with different behaviors for each\n(see Figure 2.4).\nFinally, with a subclass for the two-wheeled engine-powered vehicles you can finally have a class\nfor motorcycles. Alternatively, you could additionally define scooters and mopeds, both of\nwhich are two-wheeled engine-powered vehicles but have different qualities from motorcycles.\nWhere do qualities such as make or color come in? Wherever you want them to go\u2014or, more\nusually, where they fit most naturally in the class hierarchy. You can define the make and color\n31\n030-4S CH02.i 31 1\/29\/96, 8:39 PM\nP2\/V4sqc6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch02 LP#3 MTWRFSS\nDDAAYY\n2 Object-Oriented Programming and Java\non Vehicle, and all the subclasses will have those variables as well. The point to remember is that\nyou have to define a feature or a behavior only once in the hierarchy; it\u2019s automatically reused\nby each subclass.\nFigure 2.4.\nEnginePoweredVehicle\nTwo-wheeled and four-\nwheeled vehicles.\nTwoWheeled(cid:13) FourWheeled(cid:13)\nEnginePoweredVehicle EnginePoweredVehicle\nMotorcycle Scooter Moped\nHow Inheritance Works\nHow does inheritance work? How is it that instances of one class can automatically get variables\nand methods from the classes further up in the hierarchy?\nFor instance variables, when you create a new instance of a class, you get a \u201cslot\u201d for each variable\ndefined in the current class and for each variable defined in all its superclasses. In this way, all\nthe classes combine to form a template for the current object and then each object fills in the\ninformation appropriate to its situation.\nMethods operate similarly: new objects have access to all the method names of its class and its\nsuperclasses, but method definitions are chosen dynamically when a method is called. That is,\nif you call a method on a particular object, Java first checks the object\u2019s class for the definition\nof that method. If it\u2019s not defined in the object\u2019s class, it looks in that class\u2019s superclass, and so\non up the chain until the method definition is found (see Figure 2.5).\nThings get complicated when a subclass defines a method that has the same signature (name and\nnumber and type of arguments) as a method defined in a superclass. In this case, the method\ndefinition that is found first (starting at the bottom and working upward toward the top of the\nhierarchy) is the one that is actually executed. Because of this, you can purposefully define a\nmethod in a subclass that has the same signature as a method in a superclass, which then \u201chides\u201d\nthe superclass\u2019s method. This is called overriding a method. You\u2019ll learn all about methods on\nDay 7.\n32\n030-4S CH02.i 32 1\/29\/96, 8:39 PM\nP2\/V4sqc6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch02 LP#3 Sams.net Learning\nCenter\nabcd\nFigure 2.5. Method(cid:13)\ndefinition\nHow methods are located.\nClass\n2\nClass Class\nMessage sent to object and(cid:13)\nClass Class passed up class hierarchy(cid:13)\nuntil a definition is found\nObject Object\nNEW* Overriding a method is creating a method in a subclass that has the same signature (name,\nTERM number and type of arguments) as a method in a superclass. That new method then hides\nthe superclass\u2019s method (see Figure 2.6).\nFigure 2.6.\nClass\nOverriding methods.\nMethod is overridden(cid:13)\nby this definition\nInitial method(cid:13)\ndefinition Class\nMessage sent to object and(cid:13)\nClass Class passed up class hierarchy(cid:13)\nuntil a definition is found\nObject Object\n33\n030-4S CH02.i 33 1\/29\/96, 8:40 PM\nP2\/V4sqc6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch02 LP#3 MTWRFSS\nDDAAYY\n2 Object-Oriented Programming and Java\nSingle and Multiple Inheritance\nJava\u2019s form of inheritance, as you learned in the previous sections, is called single inheritance.\nSingle inheritance means that each Java class can have only one superclass (although any given\nsuperclass can have multiple subclasses).\nIn other object-oriented programming languages, such as C++ and Smalltalk, classes can have\nmore than one superclass, and they inherit combined variables and methods from all those\nclasses. This is called multiple inheritance. Multiple inheritance can provide enormous power\nin terms of being able to create classes that factor just about all imaginable behavior, but it can\nalso significantly complicate class definitions and the code to produce them. Java makes\ninheritance simpler by being only singly inherited.\nInterfaces and Packages\nJava has two remaining concepts to discuss here: packages and interfaces. Both are advanced\ntopics for implementing and designing groups of classes and class behavior. You\u2019ll learn about\nboth interfaces and packages on Day 16, but they are worth at least introducing here.\nRecall that Java classes have only a single superclass, and they inherit variables and methods from\nthat superclass and all its superclasses. Although single inheritance makes the relationship\nbetween classes and the functionality those classes implement easy to understand and to design,\nit can also be somewhat restricting\u2014in particular, when you have similar behavior that needs\nto be duplicated across different \u201cbranches\u201d of the class hierarchy. Java solves this problem of\nshared behavior by using the concept of interfaces.\nNEW* An interface is a collection of method names, without actual definitions, that indicate that\nTERM a class has a set of behaviors in addition to the behaviors the class gets from its superclasses.\nAlthough a single Java class can have only one superclass (due to single inheritance), that class\ncan also implement any number of interfaces. By implementing an interface, a class provides\nmethod implementations (definitions) for the method names defined by the interface. If two\nvery disparate classes implement the same interface, they can both respond to the same method\ncalls (as defined by that interface), although what each class actually does in response to those\nmethod calls may be very different.\nYou don\u2019t need to know very much about interfaces right now. You\u2019ll learn more as the book\nprogresses, so if all this is very confusing, don\u2019t panic!\nThe final new Java concept for today is that of packages.\nNEW* Packages in Java are a way of grouping together related classes and interfaces. Packages\nTERM enable modular groups of classes to be available only if they are needed and eliminate\npotential conflicts between class names in different groups of classes.\n34\n030-4S CH02.i 34 1\/29\/96, 8:40 PM\nP2\/V4sqc6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch02 LP#3 Sams.net Learning\nCenter\nabcd\nYou\u2019ll learn all about packages, including how to create and use them, in Week 3. For now, there\nare only a few things you need to know:\nnn The class libraries in the Java Developer\u2019s Kit are contained in a package called java.\nThe classes in the java package are guaranteed to be available in any Java implementa-\ntion, and are the only classes guaranteed to be available across different implementa-\ntions. The java package itself contains other packages for classes that define the\nlanguage itself, the input and output classes, some basic networking, and the window 2\ntoolkit functions. Classes in other packages (for example, classes in the sun or netscape\npackages) may be available only in specific implementations.\nnn By default, your Java classes have access to only the classes in java.lang (the base\nlanguage package inside the java package). To use classes from any other package, you\nhave to either refer to them explicitly by package name or import them in your source\nfile.\nnn To refer to a class within a package, list all the packages that class is contained in and\nthe class name, all separated by periods (.). For example, take the Color class, which is\ncontained in the awt package (awt stands for Abstract Windowing Toolkit). The awt\npackage, in turn, is inside the java package. To refer to the Color class in your pro-\ngram, you use the notation java.awt.Color.\nCreating a Subclass\nTo finish up today, let\u2019s create a class that is a subclass of another class and override some\nmethods. You\u2019ll also get a basic feel for how packages work in this example.\nProbably the most typical instance of creating a subclass, at least when you first start\nprogramming in Java, is in creating an applet. All applets are subclasses of the class Applet (which\nis part of the java.applet package). By creating a subclass of Applet, you automatically get all\nthe behavior from the window toolkit and the layout classes that enables your applet to be drawn\nin the right place on the page and to interact with system operations, such as keypresses and\nmouse clicks.\nIn this example, you\u2019ll create an applet similar to the Hello World applet from yesterday, but\none that draws the Hello string in a larger font and a different color. To start this example, let\u2019s\nfirst construct the class definition itself. Remember the HTML and classes directories you\ncreated yesterday? Let\u2019s go back to those, go back to your text editor, and enter the following class\ndefinition:\npublic class HelloAgainApplet extends java.applet.Applet {\n}\nHere, you\u2019re creating a class called HelloAgainApplet. Note the part that says extends\njava.applet.Applet\u2014that\u2019s the part that says your applet class is a subclass of the Applet class.\n35\n030-4S CH02.i 35 1\/29\/96, 8:40 PM\nP2\/V4sqc6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch02 LP#3 MTWRFSS\nDDAAYY\n2 Object-Oriented Programming and Java\nNote that because the Applet class is contained in the java.applet package, you don\u2019t have\nautomatic access to that class, and you have to refer to it explicitly by package and class name.\nThe other part of this class definition is the public keyword. Public means that your class is\navailable to the Java system at large once it is loaded. Most of the time you need to make a class\npublic only if you want it to be visible to all the other classes in your Java program; but applets,\nin particular, must be declared to be public. (You\u2019ll learn more about public classes in Week 3.)\nA class definition with nothing in it doesn\u2019t really have much of a point; without adding or\noverriding any of its superclasses\u2019 variables or methods, there\u2019s no point to creating a subclass\nat all. Let\u2019s add some information to this class to make it different from its superclass.\nFirst, add an instance variable to contain a Font object:\nFont f = new Font(\u201cTimesRoman\u201d,Font.BOLD,36);\nThe f instance variable now contains a new instance of the class Font, part of the java.awt\npackage. This particular font object is a Times Roman font, boldface, 36 points high. In the\nprevious Hello World applet, the font used for the text was the default font: 12 point Times\nRoman. Using a font object, you can change the font of the text you draw in your applet.\nBy creating an instance variable to hold this font object, you make it available to all the methods\nin your class. Now let\u2019s create a method that uses it.\nWhen you write applets, there are several \u201cstandard\u201d methods defined in the applet superclasses\nthat you will commonly override in your applet class. These include methods to initialize the\napplet, to start it running, to handle operations such as mouse movements or mouse clicks, or\nto clean up when the applet stops running. One of those standard methods is the paint()\nmethod, which actually displays your applet on screen. The default definition of paint() doesn\u2019t\ndo anything\u2014it\u2019s an empty method. By overriding paint(), you tell the applet just what to draw\non the screen. Here\u2019s a definition of paint():\npublic void paint(Graphics g) {\ng.setFont(f);\ng.setColor(Color.red);\ng.drawString(\u201cHello again!\u201d, 5, 25);\n}\nThere are two things to know about the paint() method. First, note that this method is declared\npublic, just as the applet itself was. The paint() method is actually public for a different\nreason\u2014because the method it\u2019s overriding is also public. If you try to override a method in your\nown class that\u2019s public in a superclass, you get a compiler error, so the public is required.\nSecondly, note that the paint() method takes a single argument: an instance of the Graphics\nclass. The Graphics class provides platform-independent behavior for rendering fonts, colors,\nand basic drawing operations. You\u2019ll learn a lot more about the Graphics class in Week 2, when\nyou create more extensive applets.\n36\n030-4S CH02.i 36 1\/29\/96, 8:40 PM\nP2\/V4sqc6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch02 LP#3 Sams.net Learning\nCenter\nabcd\nInside your paint() method, you\u2019ve done three things:\nnn You\u2019ve told the graphics object that the default drawing font will be the one contained\nin the instance variable f.\nnn You\u2019ve told the graphics object that the default color is an instance of the Color class\nfor the color red.\nnn Finally, you\u2019ve drawn your \u201cHello Again!\u201d string onto the screen itself, at the x and y\n2\npositions of 5 and 25. The string will be rendered in the default font and color.\nFor an applet this simple, this is all you need to do. Here\u2019s what the applet looks like so far:\npublic class HelloAgainApplet extends java.applet.Applet {\nFont f = new Font(\u201cTimesRoman\u201d,Font.BOLD,36);\npublic void paint(Graphics g) {\ng.setFont(f);\ng.setColor(Color.red);\ng.drawString(\u201cHello again!\u201d, 5, 50);\n}\n}\nIf you\u2019ve been paying attention, you\u2019ll notice something is wrong with this example up to this\npoint. If you don\u2019t know what it is, try saving this file (remember, save it to the same name as\nthe class: HelloAgainApplet.java) and compiling it using the Java compiler. You should get a\nbunch of errors similar to this one:\nHelloAgainApplet.java:7: Class Graphics not found in type declaration.\nWhy are you getting these errors? Because the classes you\u2019re referring to are part of a package.\nRemember that the only package you have access to automatically is java.lang. You referred to\nthe Applet class in the first line of the class definition by referring to its full package name\n(java.applet.Applet). Further on in the program, however, you referred to all kinds of other\nclasses as if they were already available.\nThere are two ways to solve this problem: refer to all external classes by full package name or\nimport the appropriate class or package at the beginning of your class file. Which one you choose\nto do is mostly a matter of choice, although if you find yourself referring to a class in another\npackage lots of times, you may want to import it to cut down on the amount of typing.\nIn this example, you\u2019ll import the classes you need. There are three of them: Graphics, Font, and\nColor. All three are part of the java.awt package. Here are the lines to import these classes. These\nlines go at the top of your program, before the actual class definition:\nimport java.awt.Graphics;\nimport java.awt.Font;\nimport java.awt.Color;\n37\n030-4S CH02.i 37 1\/29\/96, 8:40 PM\nP2\/V4sqc6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch02 LP#3 MTWRFSS\nDDAAYY\n2 Object-Oriented Programming and Java\nTip: You also can import an entire package of (public) classes by using an asterisk\n(*) in place of a specific class name. For example, to import all the classes in the awt\npackage, you can use this line:\nimport java.awt.*;\nNow, with the proper classes imported into your program, HelloAgainApplet should compile\ncleanly to a class file. To test it, create an HTML file with the <APPLET> tag as you did yesterday.\nHere\u2019s an HTML file to use:\n<HTML>\n<HEAD>\n<TITLE>Another Applet<\/TITLE>\n<\/HEAD>\n<BODY>\n<P>My second Java applet says:\n<APPLET CODE=\u201dHelloAgainApplet.class\u201d WIDTH=200 HEIGHT=50>\n<\/APPLET>\n<\/BODY>\n<\/HTML>\nFor this HTML example, your Java class file is in the same directory as this HTML file. Save\nthe file to HelloAgainApplet.html and fire up your Java-aware browser or the Java applet viewer.\nFigure 2.7 shows the result you should be getting (the Hello Again string is red).\nFigure 2.7.\nThe Hello Again applet.\nSummary\nIf this is your first encounter with object-oriented programming, a lot of the information in this\nchapter is going to seem really theoretical and overwhelming. Fear not\u2014the further along in this\nbook you get, and the more Java applications you create, the easier it is to understand.\nOne of the biggest hurdles of object-oriented programming is not necessarily the concepts, it\u2019s\ntheir names. OOP has lots of jargon surrounding it. To summarize today\u2019s material, here\u2019s a\nglossary of terms and concepts you learned today:\n38\n030-4S CH02.i 38 1\/29\/96, 8:40 PM\nP2\/V4sqc6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch02 LP#3 Sams.net Learning\nCenter\nabcd\nClass: A template for an object, which contains variables and methods representing\nbehavior and attributes. Classes can inherit variables and methods from other classes.\nObject: A concrete instance of some class. Multiple objects that are instances of the\nsame class have access to the same methods, but often have different values for their\ninstance variables.\nInstance: The same thing as an object; each object is an instance of some class.\nSuperclass: A class further up in the inheritance hierarchy than its child, the subclass. 2\nSubclass: A class lower in the inheritance hierarchy than its parent, the superclass.\nWhen you create a new class, that\u2019s often called subclassing.\nInstance method: A method defined in a class, which operates on an instance of that\nclass. Instance methods are usually called just methods.\nClass method: A method defined in a class, which can operate on the class itself or on\nany object.\nInstance variable: A variable that is owned by an individual instance and whose value is\nstored in the instance.\nClass variable: A variable that is owned by the class and all its instances as a whole, and\nis stored in the class.\nInterface: A collection of abstract behavior specifications that individual classes can\nthen implement.\nPackage: A collection of classes and interfaces. Classes from packages other than\njava.lang must be explicitly imported or referred to by full package name.\nQ&A\nQ Methods are effectively functions that are defined inside classes. If they look like\nfunctions and act like functions, why aren\u2019t they called functions?\nA Some object-oriented programming languages do call them functions (C++ calls them\nmember functions). Other object-oriented languages differentiate between functions\ninside and outside a body of a class or object, where having separate terms is impor-\ntant to understanding how each works. Because the difference is relevant in other\nlanguages, and because the term method is now in such common use in object-\noriented technology, Java uses the word as well.\nQ I understand instance variables and methods, but not class variables and\nmethods.\nA Most everything you do in a Java program will be with objects. Some behaviors and\nattributes, however, make more sense if they are stored in the class itself rather than in\nthe object. For example, to create a new instance of a class, you need a method that is\n39\n030-4S CH02.i 39 1\/29\/96, 8:40 PM\nP2\/V4sqc6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch02 LP#3 MTWRFSS\nDDAAYY\n2 Object-Oriented Programming and Java\ndefined for the class itself, not for an object. (Otherwise, how can you create an\ninstance of class? You need an object to call the new method in, but you don\u2019t have an\nobject yet.) Class variables, on the other hand, are often used when you have an\nattribute whose value you want to share with the instances of a class.\nMost of the time, you\u2019ll use instance variables and methods. You\u2019ll learn more about\nclass variables and methods later on this week.\n40\n030-4S CH02.i 40 1\/29\/96, 8:40 PM\nP2\/V4sqc6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch02 LP#3 Sams.net Learning\nCenter\nabcd\n3\n3\n3\nS\nS\nWEEK\nF 1\nR\nW\nJava Basics\nT\nM\nby Laura Lemay\n41\n030-4S CH03.i 41 1\/29\/96, 8:45 PM\nP2\/V4 sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 03 LP#4 MTWRFSS\nDDAAYY\n3 Java Basics\nOn Days 1 and 2, you learned about Java programming in very broad terms\u2014what a Java\nprogram and an executable look like, and how to create simple classes. For the remainder of this\nweek, you\u2019re going to get down to details and deal with the specifics of what the Java language\nlooks like.\nToday, you won\u2019t define any classes or objects or worry about how any of them communicate\ninside a Java program. Rather, you\u2019ll draw closer and examine simple Java statements\u2014the basic\nthings you can do in Java within a method definition such as main().\nToday you\u2019ll learn about the following:\nnn Java statements and expressions\nnn Variables and data types\nnn Comments\nnn Literals\nnn Arithmetic\nnn Comparisons\nnn Logical operators\nTechnical Note: Java looks a lot like C++, and\u2014by extension\u2014like C. Much of\nthe syntax will be very familiar to you if you are used to working in these languages.\nIf you are an experienced C or C++ programmer, you may want to pay special\nattention to the Technical Notes (such as this one), because they will provide\ninformation about the specific differences between these and other traditional\nlanguages and Java.\nStatements and Expressions\nA statement is the simplest thing you can do in Java; a statement forms a single Java operation.\nAll the following are simple Java statements:\nint i = 1;\nimport java.awt.Font;\nSystem.out.println(\u201cThis motorcycle is a \u201c\n+ color + \u201c \u201c + make);\nm.engineState = true;\nStatements sometimes return values\u2014for example, when you add two numbers together or test\nto see whether one value is equal to another. These kind of statements are called expressions.\nWe\u2019ll discuss these later on today.\n42\n030-4S CH03.i 42 1\/29\/96, 8:45 PM\nP2\/V4 sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 03 LP#4 Sams.net Learning\nCenter\nabcd\nThe most important thing to remember about Java statements is that each one ends with a\nsemicolon. Forget the semicolon and your Java program won\u2019t compile.\nJava also has compound statements, or blocks, which can be placed wherever a single statement\ncan. Block statements are surrounded by braces ({}). You\u2019ll learn more about blocks in Chapter\n5, \u201cArrays, Conditionals, and Loops.\u201d\nVariables and Data Types\nVariables are locations in memory in which values can be stored. They have a name, a type, and\na value. Before you can use a variable, you have to declare it. After it is declared, you can then\nassign values to it.\n3\nJava actually has three kinds of variables: instance variables, class variables, and local variables.\nInstance variables, as you learned yesterday, are used to define attributes or the state for a\nparticular object. Class variables are similar to instance variables, except their values apply to all\nthat class\u2019s instances (and to the class itself) rather than having different values for each object.\nLocal variables are declared and used inside method definitions, for example, for index counters\nin loops, as temporary variables, or to hold values that you need only inside the method\ndefinition itself. They can also be used inside blocks ({}), which you\u2019ll learn about later this week.\nOnce the method (or block) finishes executing, the variable definition and its value cease to exist.\nUse local variables to store information needed by a single method and instance variables to store\ninformation needed by multiple methods in the object.\nAlthough all three kinds of variables are declared in much the same ways, class and instance\nvariables are accessed and assigned in slightly different ways from local variables. Today, you\u2019ll\nfocus on variables as used within method definitions; tomorrow, you\u2019ll learn how to deal with\ninstance and class variables.\nNote: Unlike other languages, Java does not have global variables\u2014that is, vari-\nables that are global to all parts of a program. Instance and class variables can be\nused to communicate global information between and among objects. Remember,\nJava is an object-oriented language, so you should think in terms of objects and\nhow they interact, rather than in terms of programs.\nDeclaring Variables\nTo use any variable in a Java program, you must first declare it. Variable declarations consist of\na type and a variable name:\n43\n030-4S CH03.i 43 1\/29\/96, 8:44 PM\nP2\/V4 sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 03 LP#4 MTWRFSS\nDDAAYY\n3 Java Basics\nint myAge;\nString myName;\nboolean isTired;\nVariable definitions can go anywhere in a method definition (that is, anywhere a regular Java\nstatement can go), although they are most commonly declared at the beginning of the definition\nbefore they are used:\npublic static void main (String args\u201a ]) {\nint count;\nString title;\nboolean isAsleep;\n...\n}\nYou can string together variable names with the same type:\nint x, y, z;\nString firstName, LastName;\nYou can also give each variable an initial value when you declare it:\nint myAge, mySize, numShoes = 28;\nString myName = \u201cLaura\u201d;\nboolean isTired = true;\nint a = 4, b = 5, c = 6;\nIf there are multiple variables on the same line with only one initializer (as in the first of the\nprevious examples), the initial value applies to only the last variable in a declaration. You can also\ngroup individual variables and initializers on the same line using commas, as with the last\nexample, above.\nLocal variables must be given values before they can be used (your Java program will not compile\nif you try to use an unassigned local variable). For this reason, it\u2019s a good idea always to give local\nvariables initial values. Instance and class variable definitions do not have this restriction (their\ninitial value depends on the type of the variable: null for instances of classes, 0 for numeric\nvariables, \u2018\\0\u2019 for characters, and false for booleans).\nNotes on Variable Names\nVariable names in Java can start with a letter, an underscore (_), or a dollar sign ($). They cannot\nstart with a number. After the first character, your variable names can include any letter or\nnumber. Symbols, such as %, *, @, and so on, are often reserved for operators in Java, so be careful\nwhen using symbols in variable names.\nIn addition, the Java language uses the Unicode character set. Unicode is a character set\ndefinition that not only offers characters in the standard ASCII character set, but also several\nmillion other characters for representing most international alphabets. This means that you can\n44\n030-4S CH03.i 44 1\/29\/96, 8:44 PM\nP2\/V4 sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 03 LP#4 Sams.net Learning\nCenter\nabcd\nuse accented characters and other glyphs as legal characters in variable names, as long as they have\na Unicode character number above 00C0.\n!\n! Caution: The Unicode specification is a two-volume set of lists of thousands of\ncharacters. If you don\u2019t understand Unicode, or don\u2019t think you have a use for it,\nit\u2019s safest just to use plain numbers and letters in your variable names. You\u2019ll learn a\nlittle more about Unicode later on.\nFinally, note that the Java language is case-sensitive, which means that uppercase letters are\ndifferent from lowercase letters. This means that the variable X is different from the variable x,\n3\nand a rose is not a Rose is not a ROSE. Keep this in mind as you write your own Java programs\nand as you read Java code other people have written.\nBy convention, Java variables have meaningful names, often made up of several words\ncombined. The first word is lowercase, but all following words have an initial uppercase letter:\nButton theButton;\nlong reallyBigNumber;\nboolean currentWeatherStateOfPlanetXShortVersion;\nVariable Types\nIn addition to the variable name, each variable declaration must have a type, which defines what\nvalues that variable can hold. The variable type can be one of three things:\nnn One of the eight basic primitive data types\nnn The name of a class\nnn An array\nYou\u2019ll learn about how to declare and use array variables in Chapter 5.\nThe eight primitive data types handle common types for integers, floating-point numbers,\ncharacters, and boolean values (true or false). They\u2019re called primitive because they\u2019re built into\nthe system and are not actual objects, which makes them more efficient to use. Note that these\ndata types are machine-independent, which means that you can rely on their sizes and\ncharacteristics to be consistent across your Java programs.\nThere are four Java integer types, each with different ranges of values (as listed in Table 3.1). All\nare signed, which means they can hold either positive or negative numbers. Which type you\nchoose for your variables depends on the range of values you expect that variable to hold; if a\nvalue becomes too big for the variable type, it is truncated.\n45\n030-4S CH03.i 45 1\/29\/96, 8:44 PM\nP2\/V4 sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 03 LP#4 MTWRFSS\nDDAAYY\n3 Java Basics\nTable 3.1. Integer types.\nType Size Range\nbyte 8 bits \u2013128 to 127\nshort 16 bits \u2013-32,768 to 32,767\nint 32 bits \u20132,147,483,648 to 2,147,483,647\nlong 64 bits \u20139223372036854775808 to 9223372036854775807\nFloating-point numbers are used for numbers with a decimal part. Java floating-point numbers\nare compliant with IEEE 754 (an international standard for defining floating-point numbers\nand arithmetic). There are two floating-point types: float (32 bits, single-precision) and double\n(64 bits, double-precision).\nThe char type is used for individual characters. Because Java uses the Unicode character set, the\nchar type has 16 bits of precision, unsigned.\nFinally, the boolean type can have one of two values, true or false. Note that unlike in other\nC-like languages, boolean is not a number, nor can it be treated as one. All tests of boolean\nvariables should test for true or false.\nIn addition to the eight basic data types, variables in Java can also be declared to hold an instance\nof a particular class:\nString LastName;\nFont basicFont;\nOvalShape myOval;\nEach of these variables can then hold only instances of the given class. As you create new classes,\nyou can declare variables to hold instances of those classes (and their subclasses) as well.\nTechnical Note: Java does not have a typedef statement (as in C and C++). To\ndeclare new types in Java, you declare a new class; then variables can be declared to\nbe of that class\u2019s type.\nAssigning Values to Variables\nOnce a variable has been declared, you can assign a value to that variable by using the assignment\noperator =:\nsize = 14;\ntooMuchCaffiene = true;\n46\n030-4S CH03.i 46 1\/29\/96, 8:44 PM\nP2\/V4 sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 03 LP#4 Sams.net Learning\nCenter\nabcd\nComments\nJava has three kinds of comments. \/* and *\/ surround multiline comments, as in C or C++. All\ntext between the two delimiters is ignored:\n\/* I don\u2019t know how I wrote this next part; I was working\nreally late one night and it just sort of appeared. I\nsuspect the code elves did it for me. It might be wise\nnot to try and change it.\n*\/\nComments cannot be nested; that is, you cannot have a comment inside a comment.\nDouble-slashes (\/\/) can be used for a single line of comment. All the text up to the end of the\nline is ignored:\n3\nint vices = 7; \/\/ are there really only 7 vices?\nThe final type of comment begins with \/** and ends with *\/. These are special comments that\nare used for the javadoc system. Javadoc is used to generate API documentation from the code.\nYou won\u2019t learn about javadoc in this book; you can find out more information from the\ndocumentation that came with Sun\u2019s Java Developer\u2019s Kit or from Sun\u2019s Java home page (http:\/\n\/java.sun.com).\nLiterals\nLiterals are used to indicate simple values in your Java programs.\nNEW* Literal is a programming language term, which essentially means that what you type is\nTERM what you get. For example, if you type 4 in a Java program, you automatically get an integer\nwith the value 4. If you type \u2018a\u2019, you get a character with the value a.\nLiterals may seem intuitive most of the time, but there are some special cases of literals in Java\nfor different kinds of numbers, characters, strings, and boolean values.\nNumber Literals\nThere are several integer literals. 4, for example, is a decimal integer literal of type int (although\nyou can assign it to a variable of type byte or short because it\u2019s small enough to fit into those\ntypes). A decimal integer literal larger than an int is automatically of type long. You also can force\na smaller number to a long by appending an L or l to that number (for example, 4L is a long\ninteger of value 4). Negative integers are preceded by a minus sign\u2014for example, -45.\nIntegers can also be expressed as octal or hexadecimal: a leading 0 indicates that a number is\noctal\u2014for example, 0777 or 0004. A leading 0x (or 0X) means that it is in hex (0xFF, 0XAF45).\n47\n030-4S CH03.i 47 1\/29\/96, 8:44 PM\nP2\/V4 sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 03 LP#4 MTWRFSS\nDDAAYY\n3 Java Basics\nHexadecimal numbers can contain regular digits (0\u20139) or upper- or lowercase hex digits (a\u2013f or\nA\u2013F).\nFloating-point literals usually have two parts: the integer part and the decimal part\u2014for\nexample, 5.677777. Floating-point literals result in a floating-point number of type double,\nregardless of the precision of that number. You can force the number to the type float by\nappending the letter f (or F) to that number\u2014for example, 2.56F.\nYou can use exponents in floating-point literals using the letter e or E followed by the exponent\n(which can be a negative number): 10e45 or .36E-2.\nBoolean Literals\nBoolean literals consist of the keywords true and false. These keywords can be used anywhere\nyou need a test or as the only possible values for boolean variables.\nCharacter Literals\nCharacter literals are expressed by a single character surrounded by single quotes: \u2019a\u2019, \u2019#\u2019, \u20193\u2019,\nand so on. Characters are stored as 16-bit Unicode characters. Table 3.2 lists the special codes\nthat can represent nonprintable characters, as well as characters from the Unicode character set.\nThe letter d in the octal, hex, and Unicode escapes represents a number or a hexadecimal digit\n(a\u2013f or A\u2013F).\nTable 3.2. Character escape codes.\nEscape Meaning\n\\n Newline\n\\t Tab\n\\b Backspace\n\\r Carriage return\n\\f Formfeed\n\\\\ Backslash\n\\\u2019 Single quote\n\\\u201d Double quote\n\\ddd Octal\n\\xdd Hexadecimal\n\\udddd Unicode character\n48\n030-4S CH03.i 48 1\/29\/96, 8:43 PM\nP2\/V4 sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 03 LP#4 Sams.net Learning\nCenter\nabcd\nTechnical Note: C and C++ programmers should note that Java does not include\ncharacter codes for \\a (bell) or \\v (vertical tab).\nString Literals\nA combination of characters is a string. Strings in Java are instances of the class String. Strings\nare not simple arrays of characters as they are in C or C++, although they do have many array-\nlike characteristics (for example, you can test their length and add and delete individual\ncharacters as if they were arrays). Because string objects are real objects in Java, they have\nmethods that enable you to combine, test, and modify strings very easily.\n3\nString literals consist of a series of characters inside double quotes:\n\u201cHi, I\u2019m a string literal.\u201d\n\u201c\u201d \/\/an empty string\nStrings can contain character constants such as newline, tab, and Unicode characters:\n\u201cA string with a \\t tab in it\u201d\n\u201cNested strings are \\\u201dstrings inside of\\\u201d other strings\u201d\n\u201cThis string brought to you by Java\\u2122\u201d\nIn the last example, the Unicode code sequence for \\u2122 produces a trademark symbol (\u2122).\nNote: Just because you can represent a character using a Unicode escape does not\nmean your computer can display that character\u2014the computer or operating system\nyou are running may not support Unicode, or the font you\u2019re using may not have a\nglyph (picture) for that character. All that Unicode escapes in Java provide is a way\nto encode special characters for systems that support Unicode.\nWhen you use a string literal in your Java program, Java automatically creates an instance of the\nclass String for you with the value you give it. Strings are unusual in this respect; the other literals\ndo not behave in this way (none of the primitive base types are actual objects), and usually\ncreating a new object involves explicitly creating a new instance of a class. You\u2019ll learn more about\nstrings, the String class, and the things you can do with strings later today and tomorrow.\n49\n030-4S CH03.i 49 1\/29\/96, 8:43 PM\nP2\/V4 sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 03 LP#4 MTWRFSS\nDDAAYY\n3 Java Basics\nExpressions and Operators\nExpressions are the simplest form of statement in Java that actually accomplishes something.\nNEW* Expressions are statements that return a value.\nTERM\nOperators are special symbols that are commonly used in expressions.\nArithmetic and tests for equality and magnitude are common examples of expressions. Because\nthey return a value, you can assign that result to a variable or test that value in other Java\nstatements.\nOperators in Java include arithmetic, various forms of assignment, increment and decrement,\nand logical operations. This section describes all these things.\nArithmetic\nJava has five operators for basic arithmetic (see Table 3.3).\nTable 3.3. Arithmetic operators.\nOperator Meaning Example\n+ Addition 3 + 4\n\u2013 Subtraction 5 \u2013 7\n* Multiplication 5 * 5\n\u201a Division 14 \u201a 7\n% Modulus 20 % 7\nEach operator takes two operands, one on either side of the operator. The subtraction operator\n(\u2013) can also be used to negate a single operand.\nInteger division results in an integer. Because integers don\u2019t have decimal fractions, any\nremainder is ignored. The expression 31 \u201a 9, for example, results in 3 (9 goes into 31 only 3\ntimes).\nModulus (%) gives the remainder once the operands have been evenly divided. For example, 31\n% 9 results in 4 because 9 goes into 31 three times, with 4 left over.\nNote that, for integers, the result type of most operations is an int or a long, regardless of the\noriginal type of the operands. Large results are of type long; all others are int. Arithmetic wherein\none operand is an integer and another is a floating point results in a floating-point result. (If\nyou\u2019re interested in the details of how Java promotes and converts numeric types from one type\n50\n030-4S CH03.i 50 1\/29\/96, 8:43 PM\nP2\/V4 sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 03 LP#4 Sams.net Learning\nCenter\nabcd\nto another, you may want to check out the Java Language Specification; that\u2019s more detail than\nI want to cover here.)\nListing 3.1 is an example of simple arithmetic.\nType\nListing 3.1. Simple arithmetic.\n1: class ArithmeticTest {\n2: public static void main (String[] args) {\n3: short x = 6;\n4: int y = 4;\n5: float a = 12.5f;\n6: float b = 7f;\n7:\n8: System.out.println(\u201cx is \u201c + x + \u201c, y is \u201c + y);\n9: System.out.println(\u201cx + y = \u201c + (x + y)); 3\n10: System.out.println(\u201cx - y = \u201c + (x - y));\n11: System.out.println(\u201cx \/ y = \u201c + (x \/ y));\n12: System.out.println(\u201cx % y = \u201c + (x % y));\n13:\n14: System.out.println(\u201ca is \u201c + a + \u201c, b is \u201c + b;\n15: System.out.println(\u201ca \/ b = \u201c + (a \/ b));\n16: }\n17:\n18: }\nOutput x is 6, y is 4\nx + y = 10\nx - y = 2\nx \/ y = 1\nx % y = 2\na is 12.5, b is 7\na \/ b = 1.78571\nAnalysis In this simple Java application (note the main() method), you initially define four variables\nin lines 3 through 6: x and y, which are integers (type int), and a and b, which are floating-\npoint numbers (type float). Keep in mind that the default type for floating-point literals\n(such as 12.5) is double, so to make sure these are numbers of type float, you have to use an f\nafter each one (lines 5 and 6).\nThe remainder of the program merely does some math with integers and floating point numbers\nand prints out the results.\nThere is one other thing to mention about this program: the method System.out.println().\nYou\u2019ve seen this method on previous days, but you haven\u2019t really learned exactly what it does.\nThe System.out.println() method merely prints a message to the standard output of your\nsystem\u2014to the screen, to a special window, or maybe just to a special log file, depending on your\nsystem and the development environment you\u2019re running (Sun\u2019s JDK prints it to the screen).\nThe System.out.println() method takes a single argument\u2014a string\u2014but you can use + to\nconcatenate values into a string, as you\u2019ll learn later today.\n51\n030-4S CH03.i 51 1\/29\/96, 8:43 PM\nP2\/V4 sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 03 LP#4 MTWRFSS\nDDAAYY\n3 Java Basics\nMore About Assignment\nVariable assignment is a form of expression; in fact, because one assignment expression results\nin a value, you can string them together like this:\nx = y = z = 0;\nIn this example, all three variables now have the value 0.\nThe right side of an assignment expression is always evaluated before the assignment takes place.\nThis means that expressions such as x = x + 2 do the right thing; 2 is added to the value of x,\nand then that new value is reassigned to x. In fact, this sort of operation is so common that Java\nhas several operators to do a shorthand version of this, borrowed from C and C++. Table 3.4\nshows these shorthand assignment operators.\nTable 3.4. Assignment operators.\nExpression Meaning\nx += y x = x + y\nx \u2013= y x + x \u2013 y\nx *= y x = x * y\nx \u201a = y x = x \u201a y\nTechnical Note: If you rely on complicated side effects of subexpressions on either\nside of these assignments, the shorthand expressions may not be entirely equivalent\nto their longhand equivalents. For more information about very complicated\nexpressions, evaluation order, and side effects, you may want to consult the Java\nLanguage Specification.\nIncrementing and Decrementing\nAs in C and C++, the ++ and \u2013\u2013 operators are used to increment or decrement a value by 1. For\nexample, x++ increments the value of x by 1 just as if you had used the expression x = x + 1.\nSimilarly x\u2013\u2013 decrements the value of x by 1.\nThese increment and decrement operators can be prefixed or postfixed; that is, the ++ or \u2013\u2013 can\nappear before or after the value it increments or decrements. For simple increment or decrement\nexpressions, which one you use isn\u2019t overly important. In complex assignments, where you are\nassigning the result of an increment or decrement expression, which one you use makes a\ndifference.\n52\n030-4S CH03.i 52 1\/29\/96, 8:43 PM\nP2\/V4 sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 03 LP#4 Sams.net Learning\nCenter\nabcd\nTake, for example, the following two expressions:\ny = x++;\ny = ++x;\nThese two expressions give very different results because of the difference between prefix and\npostfix. When you use postfix operators (x++ or x\u2013\u2013), y gets the value of x before before x is\nincremented; using prefix, the value of x is assigned to y after the increment has occurred. Listing\n3.2 is a Java example of how all this works.\nType\nListing 3.2. Test of prefix and postfix increment operators.\n1: class PrePostFixTest {\n2:\n3: public static void main (String args[]) {\n4: int x = 0; 3\n5: int y = 0;\n6:\n7: System.out.println(\u201cx and y are \u201c + x + \u201c and \u201c + y );\n8: x++;\n9: System.out.println(\u201cx++ results in \u201c + x);\n10: ++x;\n11: System.out.println(\u201c++x results in \u201c + x);\n12: System.out.println(\u201cResetting x back to 0.\u201d);\n13: x = 0;\n14: System.out.println(\u201c\u2014\u2014\u2014\u2014\u2014\u2014\u201d);\n15: y = x++;\n16: System.out.println(\u201cy = x++ (postfix) results in:\u201d);\n17: System.out.println(\u201cx is \u201c + x);\n18: System.out.println(\u201cy is \u201c + y);\n19: System.out.println(\u201c\u2014\u2014\u2014\u2014\u2014\u2014\u201d);\n20:\n21: y = ++x;\n22: System.out.println(\u201cy = ++x (prefix) results in:\u201d);\n23: System.out.println(\u201cx is \u201c + x);\n24: System.out.println(\u201cy is \u201c + y);\n25: System.out.println(\u201c\u2014\u2014\u2014\u2014\u2014\u2014\u201d);\n26:\n27: }\n28:\n29: }\nOutput x and y are 0 and 0\nx++ results in 1\n++x results in 2\nResetting x back to 0.\n\u2014\u2014\u2014\u2014\u2014\u2014\ny = x++ (postfix) results in:\nx is 1\ny is 0\n\u2014\u2014\u2014\u2014\u2014\u2014\ny = ++x (prefix) results in:\nx is 2\ny is 2\n\u2014\u2014\u2014\u2014\u2014\u2014\n53\n030-4S CH03.i 53 1\/29\/96, 8:42 PM\nP2\/V4 sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 03 LP#4 MTWRFSS\nDDAAYY\n3 Java Basics\nAnalysis In the first part of this example, you increment x alone using both prefix and postfix\nincrement operators. In each, x is incremented by 1 each time. In this simple form, using\neither prefix or postfix works the same way.\nIn the second part of this example, you use the expression y = x++, in which the postfix\nincrement operator is used. In this result, the value of x is incremented after that value is assigned\nto y. Hence the result: y is assigned the original value of x (0), and then x is incremented by 1.\nIn the third part, you use the prefix expression y = ++x. Here, the reverse occurs: x is incremented\nbefore its value is assigned to y. Because x is 1 from the previous step, its value is incremented\n(to 2), and then that value is assigned to y. Both x and y end up being 2.\nTechnical Note: Technically, this description is not entirely correct. In reality, Java\nalways completely evaluates all expressions on the right of an expression before\nassigning that value to a variable, so the concept of \u201cassigning x to y before x is\nincremented\u201d isn\u2019t precisely right. Instead, Java takes the value of x and \u201cremem-\nbers\u201d it, evaluates (increments) x, and then assigns the original value of x to y.\nAlthough in most simple cases this distinction may not be important, for more\ncomplex expressions with side effects it may change the behavior of the expression\noverall. See the Language Specification for many more details about the details of\nexpression evaluation in Java.\nComparisons\nJava has several expressions for testing equality and magnitude. All of these expressions return\na boolean value (that is, true or false). Table 3.5 shows the comparison operators:\nTable 3.5. Comparison operators.\nOperator Meaning Example\n== Equal x == 3\n!= Not equal x != 3\n< Less than x < 3\n> Greater than x > 3\n\u00a3 Less than or equal to x \u00a3 3\n\u2021 Greater than or equal to x \u2021 3\n54\n030-4S CH03.i 54 1\/29\/96, 8:42 PM\nP2\/V4 sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 03 LP#4 Sams.net Learning\nCenter\nabcd\nLogical Operators\nExpressions that result in boolean values (for example, the comparison operators) can be\ncombined by using logical operators that represent the logical combinations AND, OR, XOR, and\nlogical NOT.\nFor AND combinations, use either the & or &&. The expression will be true only if both operands\ntests are also true; if either expression is false, the entire expression is false. The difference between\nthe two operators is in expression evaluation. Using &, both sides of the expression are evaluated\nregardless of the outcome. Using &&, if the left side of the expression is false, the entire expression\nreturns false, and the right side of the expression is never evaluated.\nFor OR expressions, use either | or ||. OR expressions result in true if either or both of the operands\nis also true; if both operands are false, the expression is false. As with & and &&, the single | 3\nevaluates both sides of the expression regardless of the outcome; with ||, if the left expression\nis true, the expression returns true and the right side is never evaluated.\nIn addition, there is the XOR operator ^, which returns true only if its operands are different (one\ntrue and one false, or vice versa) and false otherwise (even if both are true).\nIn general, only the && and || are commonly used as actual logical combinations. &, |, and ^ are\nmore commonly used for bitwise logical operations.\nFor NOT, use the ! operator with a single expression argument. The value of the NOT expression\nis the negation of the expression; if x is true, !x is false.\nBitwise Operators\nFinally, here\u2019s a short summary of the bitwise operators in Java. These are all inherited from C\nand C++ and are used to perform operations on individual bits in integers. This book does not\ngo into bitwise operations; it\u2019s an advanced topic covered better in books on C or C++. Table\n3.6 summarizes the bitwise operators.\nTable 3.6. Bitwise operators.\nOperator Meaning\n& Bitwise AND\n| Bitwise OR\n^ Bitwise XOR\n<< Left shift\n>> Right shift\n>>> Zero fill right shift\ncontinues\n55\n030-4S CH03.i 55 1\/29\/96, 8:42 PM\nP2\/V4 sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 03 LP#4 MTWRFSS\nDDAAYY\n3 Java Basics\nTable 3.6. continued\nOperator Meaning\n~ Bitwise complement\n<<= Left shift assignment (x = x << y)\n>>= Right shift assignment (x = x >> y)\n>>>= Zero fill right shift assignment (x = x >>> y)\nx&=y AND assignment (x = x & y)\nx|=y OR assignment (x + x | y)\nx^=y NOT assignment (x = x ^ y)\nOperator Precedence\nOperator precedence determines the order in which expressions are evaluated. This, in some\ncases, can determine the overall value of the expression. For example, take the following\nexpression:\ny = 6 + 4 \/ 2\nDepending on whether the 6 + 4 expression or the 4 \u201a 2 expression is evaluated first, the value\nof y can end up being 5 or 8. Operator precedence determines the order in which expressions\nare evaluated, so you can predict the outcome of an expression. In general, increment and\ndecrement are evaluated before arithmetic, arithmetic expressions are evaluated before compari-\nsons, and comparisons are evaluated before logical expressions. Assignment expressions are\nevaluated last.\nTable 3.8 shows the specific precedence of the various operators in Java. Operators further up\nin the table are evaluated first; operators on the same line have the same precedence and are\nevaluated left to right based on how they appear in the expression itself. For example, give that\nsame expression y = 6 + 4 \u201a 2, you now know, according to this table, that division is evaluated\nbefore addition, so the value of y will be 8.\nTable 3.7. Operator precedence.\nOperator Notes\n. [] () Parentheses () group expressions; dot (.) is used for access to\nmethods and variables within objects and classes (discussed\ntomorrow); [] is used for arrays (discussed later on in the week)\n++ \u2013\u2013 ! ~ instanceof Returns true or false based on whether the object is an instance\nof the named class or any of that class\u2019s superclasses (discussed\ntomorrow)\n56\n030-4S CH03.i 56 1\/29\/96, 8:42 PM\nP2\/V4 sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 03 LP#4 Sams.net Learning\nCenter\nabcd\nOperator Notes\nnew (type)expression The new operator is used for creating new instances of classes; ()\nin this case is for casting a value to another type (you\u2019ll learn\nabout both of these tomorrow)\n* \u201a % Multiplication, division, modulus\n+ \u2013 Addition, subtraction\n<< >> >>> Bitwise left and right shift\n< > \u00a3 \u2021 Relational comparison tests\n== != Equality\n& AND\n3\n^ XOR\n| OR\n&& Logical AND\n|| Logical OR\n? : Shorthand for if...then...else (discussed on Day 5)\n= += \u2013= *= \u201a = %= ^= Various assignments\n&= |= <<= >>= >>>=\nYou can always change the order in which expressions are evaluated by using parentheses around\nthe expressions you want to evaluate first. You can nest parentheses to make sure expressions\nevaluate in the order you want them to (the innermost parenthetical expression is evaluated\nfirst). The following expression results in a value of 5, because the 6 + 4 expression is evaluated\nfirst, and then the result of that expression (10) is divided by 2:\ny = (6 + 4) \/ 2\nParentheses also can be useful in cases where the precedence of an expression isn\u2019t immediately\nclear\u2014in other words, they can make your code easier to read. Adding parentheses doesn\u2019t hurt,\nso if they help you figure out how expressions are evaluated, go ahead and use them.\nString Arithmetic\nOne special expression in Java is the use of the addition operator (+) to create and concatenate\nstrings. In most of the previous examples shown today and in earlier lessons, you\u2019ve seen lots of\nlines that looked something like this:\nSystem.out.println(name + \u201c is a \u201c + color \u201c beetle\u201d);\nThe output of that line (to the standard output) is a single string, with the values of the variables\n(here, name and color), inserted in the appropriate spots in the string. So what\u2019s going on here?\n57\n030-4S CH03.i 57 1\/29\/96, 8:42 PM\nP2\/V4 sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 03 LP#4 MTWRFSS\nDDAAYY\n3 Java Basics\nThe + operator, when used with strings and other objects, creates a single string that contains\nthe concatenation of all its operands. If any of the operands in string concatenation is not a string,\nit is automatically converted to a string, making it easy to create these sorts of output lines.\nTechnical Note: An object or type can be converted to a string if you implement\nthe method toString(). All objects have a default string representation (the name\nof the class followed by brackets), but most classes override toString() to provide a\nmore meaningful printable representation.\nString concatenation makes lines such as the previous one especially easy to construct. To create\na string, just add all the parts together\u2014the descriptions plus the variables\u2014and output it to the\nstandard output, to the screen, to an applet, or anywhere.\nThe += operator, which you learned about earlier, also works for strings. For example, take the\nfollowing expression:\nmyName += \u201c Jr.\u201d;\nThis expression is equivalent to this:\nmyName = myName + \u201c Jr.\u201d;\njust as it would be for numbers. In this case, it changes the value of myName (which might be\nsomething like John Smith to have a Jr. at the end (John Smith Jr.).\nSummary\nAs you learned in the last two lessons, a Java program is made up primarily of classes and objects.\nClasses and objects, in turn, are made up of methods and variables, and methods are made up\nof statements and expressions. It is those last two things that you\u2019ve learned about today; the\nbasic building blocks that enable you to create classes and methods and build them up to a full-\nfledged Java program.\nToday, you learned about variables, how to declare them and assign values to them; literals for\neasily creating numbers, characters, and strings; and operators for arithmetic, tests, and other\nsimple operations. With this basic syntax, you can move on tomorrow to learning about working\nwith objects and building simple useful Java programs.\nTo finish up this summary, Table 3.8 is a list of all the operators you learned about today so that\nyou can refer back to them.\n58\n030-4S CH03.i 58 1\/29\/96, 8:42 PM\nP2\/V4 sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 03 LP#4 Sams.net Learning\nCenter\nabcd\nTable 3.8. Operator summary.\nOperator Meaning\n+ Addition\n\u2013 Subtraction\n* Multiplication\n\u201a Division\n% Modulus\n< Less than\n> Greater than\n\u00a3 Less than or equal to\n3\n\u2021 Greater than or equal to\n== Equal\n!= Not equal\n&& Logical AND\n|| Logical OR\n! Logical NOT\n& AND\n| OR\n^ XOR\n<< Left shift\n>> Right shift\n>>> Zero fill right shift\n~ Complement\n= Assignment\n++ Increment\n\u2013\u2013 Decrement\n+= Add and assign\n\u2013= Subtract and assign\n*= Multiply and assign\n\u201a = Divide and assign\n%= Modulus and assign\n&= AND and assign\ncontinues\n59\n030-4S CH03.i 59 1\/29\/96, 8:41 PM\nP2\/V4 sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 03 LP#4 MTWRFSS\nDDAAYY\n3 Java Basics\nTable 3.8. continued\nOperator Meaning\n|= OR and assign\n<<= Left shift and assign\n>>= Right shift and assign\n>>>= Zero fill right shift and assign\nQ&A\nQ I didn\u2019t see any way to define constants.\nA You can\u2019t create local constants in Java; you can create only constant instance and class\nvariables. You\u2019ll learn how to do this tomorrow.\nQ What happens if you declare a variable to be some integer type and then give it a\nnumber outside the range of values that variable can hold?\nA Logically, you would think that the variable is just converted to the next larger type,\nbut this isn\u2019t what happens. What does happen is called overflow. This means that if a\nnumber becomes too big for its variable, that number wraps around to the smallest\npossible negative number for that type and starts counting upward toward zero again.\nBecause this can result in some very confusing (and wrong) results, make sure that you\ndeclare the right integer type for all your numbers. If there\u2019s a chance a number will\noverflow its type, use the next larger type instead.\nQ How can you find out the type of a given variable?\nA If you\u2019re using the base types (int, float, boolean), and so on, you can\u2019t. If you care\nabout the type, you can convert the value to some other type by using casting (you\u2019ll\nlearn about this tomorrow).\nIf you\u2019re using class types, you can use the instanceof operator, which you\u2019ll learn\nmore about tomorrow.\nQ Why does Java have all these shorthand operators for arithmetic and assignment?\nIt\u2019s really hard to read that way.\nA The syntax of Java is based on C++, and therefore on C. One of C\u2019s implicit goals is\nthe capability of doing very powerful things with a minimum of typing. Because of\nthis, shorthand operators, such as the wide array of assignments, are common.\nThere\u2019s no rule that says you have to use these operators in your own programs,\nhowever. If you find your code to be more readable using the long form, no one will\ncome to your house and make you change it.\n60\n030-4S CH03.i 60 1\/29\/96, 8:41 PM\nP2\/V4 sqc7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 03 LP#4 Sams.net Learning\nCenter\nabcd\n4\n4\nS\nS\nWEEK\n4\nF 1\nR\nW\nWorking with\nT\nObjects\nM\nby Laura Lemay\n61\n030-4s CH04.i 61 1\/29\/96, 8:45 PM\nP2\/V4\/sqc4 TY Java in 21 Days 030-4 Josette 12.21.95 Ch04 LP#4 MTWRFSS\nDDAAYY\n4 Working with Objects\nLet\u2019s start today\u2019s lesson with an obvious statement: because Java is an object-oriented language,\nyou\u2019re going to be dealing with a lot of objects. You\u2019ll create them, modify them, move them\naround, change their variables, call their methods, combine them with other objects\u2014and, of\ncourse, develop classes and use your own objects in the mix.\nToday, therefore, you\u2019ll learn all about the Java object in its natural habitat. Today\u2019s topics\ninclude:\nnn Creating instances of classes\nnn Testing and modifying class and instance variables in your new instance\nnn Calling methods in that object\nnn Casting (converting) objects and other data types from one class to another\nnn Other odds and ends about working with objects\nnn An overview of the Java class libraries\nCreating New Objects\nWhen you write a Java program, you define a set of classes. As you learned on Day 2, classes are\ntemplates for objects; for the most part, you merely use the class to create instances and then work\nwith those instances. In this section, therefore, you\u2019ll learn how to create a new object from any\ngiven class.\nRemember strings from yesterday? You learned that using a string literal\u2014a series of characters\nenclosed in double-quotes\u2014creates a new instance of the class String with the value of that\nstring.\nThe String class is unusual in that respect\u2014although it\u2019s a class, there\u2019s an easy way to create\ninstances of that class using a literal. The other classes don\u2019t have that shortcut; to create instances\nof those classes you have to do so explicitly by using the new operator.\nNote: What about the literals for numbers and characters? Don\u2019t they create\nobjects, too? Actually, they don\u2019t. The primitive data types for numbers and\ncharacters create numbers and characters, but for efficiency, they aren\u2019t actually\nobjects. You can put object-wrappers around them if you need to treat them like\nobjects (you\u2019ll learn how to do this later).\n62\n030-4s CH04.i 62 1\/29\/96, 8:46 PM\nP2\/V4\/sqc4 TY Java in 21 Days 030-4 Josette 12.21.95 Ch04 LP#4 Sams.net Learning\nCenter\nabcd\nUsing new\nTo create a new object, you use new with the name of the class you want to create an instance\nof, then parentheses after that:\nString str = new String();\nRandom r = new Random();\nMotorcycle m2 = new Motorcycle()\nThe parentheses are important; don\u2019t leave them off. The parentheses can be empty, in which\ncase the most simple, basic object is created, or the parentheses can contain arguments that\ndetermine the initial values of instance variables or other initial qualities of that object. The\nnumber and type of arguments you can use with new are defined by the class itself by using a\nspecial method called a constructor; you\u2019ll learn about how to create constructors in your own\nclasses later on this week.\n!\n! Caution: Some classes may not enable you to create instances without any argu- 4\nments. Check the class to make sure.\nFor example, take the Date class, which creates date objects. Listing 4.1 is a Java program that\nshows three different ways of creating a Date object using new:\nType\nListing 4.1. Laura\u2019s Date program.\n1: import java.util.Date;\n2:\n3: class CreateDates {\n4:\n5: public static void main (String args[]) {\n6: Date d1, d2, d3;\n7:\n8: d1 = new Date();\n9: System.out.println(\u201cDate 1: \u201c + d1);\n10:\n11: d2 = new Date(71, 7, 1, 7, 30);\n12: System.out.println(\u201cDate 2: \u201c + d2);\n13:\n14: d3 = new Date(\u201cApril 3 1993 3:24 PM\u201d);\n15: System.out.println(\u201cDate 3: \u201c + d3);\n16: }\n17: }\nOutput Date 1: Sun Nov 26 19:10:56 PST 1995\nDate 2: Sun Aug 01 07:30:00 PDT 1971\nDate 3: Sat Apr 03 15:24:00 PST 1993\n63\n030-4s CH04.i 63 1\/29\/96, 8:46 PM\nP2\/V4\/sqc4 TY Java in 21 Days 030-4 Josette 12.21.95 Ch04 LP#4 MTWRFSS\nDDAAYY\n4 Working with Objects\nAnalysis In this example, three different dates are created by using different arguments to new. The\nfirst instance (line 8) uses new with no arguments, which creates a Date object for today\u2019s\ndate (as the first line of the output shows).\nThe second Date object you create in this example has five integer arguments. The arguments\nrepresent a date: year, month, day, hours, and seconds. And, as the output shows, this creates\na Date object for that particular date: Sunday, August first, 1971, at 7:30 AM.\nThe third version of Date takes one argument, a string, representing the date as a text string.\nWhen the Date object is created, that string is parsed, and a Date object with that date and time\nis created (see the third line of output). The date string can take many different formats; see the\nAPI documentation for the Date class (part of the java.util package) for information about\nwhat strings you can use.\nWhat new Does\nWhat does new do? When you use the new operator, several things happen: first, the new instance\nof the given class is created, and memory is allocated for it. In addition (and most importantly),\nwhen the new object is created, a special method defined in the given class is called. This special\nmethod is called a constructor.\nNEW* Constructors are special methods for creating and initializing new instances of classes.\nTERM Constructors initialize the new object and its variables, create any other objects that object\nneeds, and generally perform any other operations the object needs to run.\nMultiple constructor definitions in a class can each have a different number or type of\narguments\u2014then, when you use new, you can specify different arguments in the argument list,\nand the right constructor for those arguments will be called. That\u2019s how each of those different\nversions of new that were listed previously can create different things.\nWhen you create your own classes, you can define as many constructors as you need to\nimplement that class\u2019s behavior. You\u2019ll learn how to create constructors on Day 7.\nA Note on Memory Management\nMemory management in Java is dynamic and automatic. When you create a new object in Java,\nJava automatically allocates the right amount of memory for that object in the heap. You don\u2019t\nhave to allocate any memory for any objects explicitly; Java does it for you.\nWhat happens when you\u2019re finished with that object? How do you de-allocate the memory that\nobject uses? The answer is again: memory management is automatic. Once you finish with an\nobject, that object no longer has any live references to it (it won\u2019t be assigned to any variables\nyou\u2019re still using or stored in any arrays). Java has a garbage collector that looks for unused objects\n64\n030-4s CH04.i 64 1\/29\/96, 8:46 PM\nP2\/V4\/sqc4 TY Java in 21 Days 030-4 Josette 12.21.95 Ch04 LP#4 Sams.net Learning\nCenter\nabcd\nand reclaims the memory that those objects are using. You don\u2019t have to do any explicit freeing\nof memory; you just have to make sure you\u2019re not still holding onto an object you want to get\nrid of. You\u2019ll learn more specific details about the Java garbage collector and how it works on\nDay 21.\nAccessing and Setting Class and\nInstance Variables\nNow you have your very own object, and that object may have class or instance variables defined\nin it. How do you work with those variables? Easy! Class and instance variables behave in exactly\nthe same ways as the local variables you learned about yesterday; you just refer to them slightly\ndifferently than you do regular variables in your code.\nGetting Values\nTo get at the value to an instance variable, you use dot notation.\n4\nNEW* With dot notation, an instance or class variable name has two parts: the object on the left\nTERM side of the dot, and the variable on the right side of the dot.\nFor example, if you have an object assigned to the variable myObject, and that object has a variable\ncalled var, you refer to that variable\u2019s value like this:\nmyObject.var;\nThis form for accessing variables is an expression (it returns a value), and both sides of the dot\nare also expressions. This means that you can nest instance variable access. If that var instance\nvariable itself holds an object, and that object has its own instance variable called state, you can\nrefer to it like this:\nmyObject.var.state;\nDot expressions are evaluated left to right, so you start with myObject\u2019s variable var, which points\nto another object with the variable state. You end up with the value of that state variable.\nChanging Values\nAssigning a value to that variable is equally easy\u2014just tack an assignment operator on the right\nside of the expression:\nmyObject.var.state = true;\n65\n030-4s CH04.i 65 1\/29\/96, 8:46 PM\nP2\/V4\/sqc4 TY Java in 21 Days 030-4 Josette 12.21.95 Ch04 LP#4 MTWRFSS\nDDAAYY\n4 Working with Objects\nListing 4.2 is an example of a program that tests and modifies the instance variables in a Point\nobject. Point is part of the java.awt package and refers to a coordinate point with an x and a y\nvalue.\nType\nListing 4.2. The TestPoint Class.\n1: import java.awt.Point;\n2:\n3: class TestPoint {\n4:\n5: public static void main (String args[]) {\n6: Point thePoint = new Point(10,10);\n7:\n8: System.out.println(\u201cX is \u201c + thePoint.x);\n9: System.out.println(\u201cY is \u201c + thePoint.y);\n10:\n11: System.out.println(\u201cSetting X to 5.\u201d);\n12: thePoint.x = 5;\n13: System.out.println(\u201cSetting y to 15.\u201d);\n14: thePoint.y = 15;\n15:\n16: System.out.println(\u201cX is \u201c + thePoint.x);\n17: System.out.println(\u201cY is \u201c + thePoint.y);\n18:\n19: }\n20: }\nOutput X is 10\nY is 10\nSetting X to 5.\nSetting y to 15.\nX is 5\nY is 15\nAnalysis In this example, you first create an instance of Point where X and Y are both 10 (line 6). Lines\n8 and 9 print out those individual values, and you can see dot notation at work there. Lines\n11 through 14 change the values of those variables to 5 and 15, respectively. Finally, lines\n16 and 17 print out the values of X and Y again to show how they\u2019ve changed.\nClass Variables\nClass variables, as you learned before, are variables that are defined and stored in the class itself.\nTheir values, therefore, apply to the class and to all its instances.\nWith instance variables, each new instance of the class gets a new copy of the instance variables\nthat class defines. Each instance can then change the values of those instance variables without\naffecting any other instances. With class variables, there is only one copy of that variable. Every\ninstance of the class has access to that variable, but there is only one value. Changing the value\nof that variable changes it for all the instances of that class.\n66\n030-4s CH04.i 66 1\/29\/96, 8:46 PM\nP2\/V4\/sqc4 TY Java in 21 Days 030-4 Josette 12.21.95 Ch04 LP#4 Sams.net Learning\nCenter\nabcd\nYou define class variables by including the static keyword before the variable itself. You\u2019ll learn\nmore about this on Day 6. For example, take the following partial class definition:\nclass FamilyMember {\nstatic String surname = \u201cJohnson\u201d;\nString name;\nint age;\n...\n}\nInstances of the class FamilyMember each have their own values for name and age. But the class\nvariable surname has only one value for all family members. Change surname, and all the instances\nof FamilyMember are affected.\nTo access class variables, you use the same dot notation as you do with instance variables. To\nget or change the value of the class variable, you can use either the instance or the name of the\nclass on the left side of the dot. Both the lines of output in this example print the same value):\nFamilyMember dad = new FamilyMember()\nSystem.out.println(\u201cFamily\u2019s surname is: \u201c + dad.surname);\nSystem.out.println(\u201cFamily\u2019s surname is: \u201c + FamilyMember.surname);\nBecause you can use an instance to change the value of a class variable, it\u2019s easy to become 4\nconfused about class variables and where their values are coming from (remember, the value of\na class variable affects all the instances). For this reason, it\u2019s a good idea to use the name of the\nclass when you refer to a class variable\u2014it makes your code easier to read and strange results\neasier to debug.\nCalling Methods\nCalling a method in objects is similar to referring to its instance variables: method calls also use\ndot notation. The object whose method you\u2019re calling is on the left side of the dot; the name\nof the method and its arguments is on the right side of the dot:\nmyObject.methodOne(arg1, arg2, arg3);\nNote that all methods must have parentheses after them, even if that method takes no arguments:\nmyObject.methodNoArgs();\nIf the method you\u2019ve called results in an object that itself has methods, you can nest methods\nas you would variables:\nmyObject.getClass().getName();\nYou can combine nested method calls and instance variable references as well:\nmyObject.var.methodTwo(arg1, arg2);\n67\n030-4s CH04.i 67 1\/29\/96, 8:47 PM\nP2\/V4\/sqc4 TY Java in 21 Days 030-4 Josette 12.21.95 Ch04 LP#4 MTWRFSS\nDDAAYY\n4 Working with Objects\nSystem.out.println(), the method you\u2019ve been using all through the book this far, is a great\nexample of nesting variables and methods. The System class (part of the java.lang package)\ndescribes system-specific behavior. System.out is a class variable that contains an instance of the\nclass PrintStream that points to the standard output of the system. PrintStream instances have\na println() method that prints a string to that output stream.\nListing 4.3 shows an example of calling some methods defined in the String class. Strings\ninclude methods for string tests and modification, similar to what you would expect in a string\nlibrary in other languages.\nType\nListing 4.3. Several Uses of String methods.\n1: class TestString {\n2:\n3: public static void main (String args[]) {\n4: String str = \u201cNow is the winter of our discontent\u201d;\n5:\n6: System.out.println(\u201cThe string is: \u201c + str);\n7: System.out.println(\u201cLength of this string: \u201c\n8: + str.length());\n9: System.out.println(\u201cThe character at position 5: \u201c\n10: + str.charAt(5));\n11: System.out.println(\u201cThe substring from 11 to 18: \u201c\n12: + str.substring(11, 18));\n13: System.out.println(\u201cThe index of the character d: \u201c\n14: + str.indexOf(\u2018d\u2019));\n15: System.out.print(\u201cThe index of the beginning of the \u201c);\n16: System.out.println(\u201csubstring \\\u201dwinter\\\u201d:\u201d\n17: + str.indexOf(\u201cwinter\u201d));\n18: System.out.println(\u201cThe string in upper case: \u201c\n19: + str.toUpperCase());\n20: }\n21: }\nOutput The string is: Now is the winter of our discontent\nLength of this string: 35\nThe character at position 5: s\nThe substring from positions 11 to 18: winter\nThe index of the character d: 25\nThe index of the beginning of the substring \u201cwinter\u201d: 11\nThe string in upper case: NOW IS THE WINTER OF OUR DISCONTENT\nAnalysis In line 4, you create a new instance of String by using a string literal (it\u2019s easier that way\nthan using new and then putting the characters in individually). The remainder of the\nprogram simply calls different string methods to do different operations on that string:\nnn Line 6 prints the value of the string we created in line 4: \u201cNow is the winter of our\ndiscontent\u201d.\n68\n030-4s CH04.i 68 1\/29\/96, 8:47 PM\nP2\/V4\/sqc4 TY Java in 21 Days 030-4 Josette 12.21.95 Ch04 LP#4 Sams.net Learning\nCenter\nabcd\nnn Line 7 calls the length() method in the new String object. This string has 35 charac-\nters.\nnn Line 9 calls the charAt() method, which returns the character at the given position in\nthe string. Note that string positions start at 0, so the character at position 5 is s.\nnn Line 11 calls the substring() method, which takes two integers indicating a range and\nreturns the substring at those starting and ending points. The substring() method\ncan also be called with only one argument, which returns the substring from that\nposition to the end of the string.\nnn Line 13 calls the indexOf() method, which returns the position of the first instance of\nthe given character (here, \u2018d\u2019).\nnn Line 15 shows a different use of the indexOf() method, which takes a string argument\nand returns the index of the beginning of that string.\nnn Finally, line 18 uses the toUpperCase() method to return a copy of the string in all\nuppercase.\nClass Methods\n4\nClass methods, like class variables, apply to the class as a whole and not to its instances. Class\nmethods are commonly used for general utility methods that may not operate directly on an\ninstance of that class, but fit with that class conceptually. For example, the String class contains\na class method called valueOf(), which can take one of many different types of arguments\n(integers, booleans, other objects, and so on). The valueOf() method then returns a new\ninstance of String containing the string value of the argument it was given. This method doesn\u2019t\noperate directly on an existing instance of String, but getting a string from another object or data\ntype is definitely a String-like operation, and it makes sense to define it in the String class.\nClass methods can also be useful for gathering general methods together in one place (the class).\nFor example, the Math class, defined in the java.lang package, contains a large set of\nmathematical operations as class methods\u2014there are no instances of the class Math, but you can\nstill use its methods with numeric or boolean arguments.\nTo call a class method, use dot notation as you do with instance methods. As with class variables,\nyou can use either an instance of the class or the class itself on the left site of the dot. However,\nfor the same reasons noted in the discussion on class variables, using the name of the class for\nclass variables makes your code easier to read. The last two lines in this example produce the same\nresult:\nString s, s2;\ns = \u201cfoo\u201d;\ns2 = s.valueOf(5);\ns2 = String.valueOf(5);\n69\n030-4s CH04.i 69 1\/29\/96, 8:47 PM\nP2\/V4\/sqc4 TY Java in 21 Days 030-4 Josette 12.21.95 Ch04 LP#4 MTWRFSS\nDDAAYY\n4 Working with Objects\nReferences to Objects\nAs you work with objects, one important thing going on behind the scenes is the use of references\nto those objects. When you assign objects to variables, or pass objects as arguments to methods,\nyou are passing references to those objects, not the objects themselves or copies of those objects.\nAn example should make this clearer. Examine the following snippet of code:\nimport java.awt.Point;\nclass ReferencesTest {\npublic static void main (String args[]) {\nPoint pt1, pt2;\npt1 = new Point(100, 100);\npt2 = pt1;\npt1.x = 200;\npt1.y = 200;\nSystem.out.println(\u201cPoint1: \u201c + pt1.x + \u201c, \u201c + pt1.y);\nSystem.out.println(\u201cPoint2: \u201c + pt2.x + \u201c, \u201c + pt2.y);\n}\n}\nIn this program, you declare two variables of type Point, and assign a new Point object to pt1.\nThen you assign the value of pt1 to pt2.\nNow, here\u2019s the challenge. After changing pt1\u2019s x and y instance variables, what will pt2 look\nlike?\nHere\u2019s the output of that program:\nOutput Point1: 200, 200\nPoint2: 200, 200\nAnalysis As you can see, pt2 was also changed. When you assign the value of pt1 to pt2, you actually\ncreate a reference from p2 to the same object to which pt1 refers. Change the object that\npt2 refers to, and you also change the object that pt1 points to, because both are references\nto the same object.\nFigure 4.1. pt1 Point object\nReferences.\nx: 200(cid:13)\npt2\ny: 200\nThe fact that Java uses references becomes particularly important when you pass arguments to\nmethods. You\u2019ll learn more about this later on today, but keep these references in mind.\n70\n030-4s CH04.i 70 1\/29\/96, 8:47 PM\nP2\/V4\/sqc4 TY Java in 21 Days 030-4 Josette 12.21.95 Ch04 LP#4 Sams.net Learning\nCenter\nabcd\nTechnical Note: There are no explicit pointers or pointer arithmetic in Java\u2014just\nreferences. However, because of Java references, you have most of the capabilities\nthat you have with pointers without the confusion and lurking bugs that explicit\npointers can create.\nCasting and Converting Objects and\nPrimitive Types\nSometimes in your Java programs you may have a value stored somewhere that is the wrong type.\nMaybe it\u2019s an instance of the wrong class, or perhaps it\u2019s a float and you want it to be an int,\nor it\u2019s an integer and you want it to be a string. To convert the value of one type to another, you\nuse a mechanism called casting.\nNEW* Casting is a mechanism of converting the value of an object or primitive type into another\nTERM type. The result of a cast is a new object or value; casting does not affect the original object 4\nor value.\nAlthough the concept of casting is a simple one, the rules for what types in Java can be converted\nto what other types are complicated by the fact that Java has both primitive types (int, float,\nboolean), and object types (String, Point, Window, and so on). Because of these three types, there\nare three forms of casts and conversions to talk about in this section:\nnn Casting between primitive types: int to float to boolean\nnn Casting between object types: an instance of a class to an instance of another class\nnn Converting primitive types to objects and then extracting primitive values back out of\nthose objects\nCasting Primitive Types\nCasting between primitive types enables you to \u201cconvert\u201d the value of one type to another\nprimitive type\u2014for example, to assign a number of one type to a variable of another type.\nCasting between primitive types most commonly occurs with the numeric types; boolean values\ncannot be cast to any other primitive type. You can, however, cast 1 or 0 to boolean values.\nOften, if the type you are casting to is \u201clarger\u201d than the type of the value you\u2019re converting, you\nmay not have to use an explicit cast. You can often automatically treat a byte or a character as\nan int, for example, or an int as a long, an int as a float, or anything as a double automatically.\nIn this case, because the larger type provides more precision than the smaller, no loss of\ninformation occurs when the value is cast.\n71\n030-4s CH04.i 71 1\/29\/96, 8:47 PM\nP2\/V4\/sqc4 TY Java in 21 Days 030-4 Josette 12.21.95 Ch04 LP#4 MTWRFSS\nDDAAYY\n4 Working with Objects\nTo convert a large value to smaller type, you must use an explicit cast, because converting that\nvalue may result in a loss of precision. Explicit casts look like this:\n(typename) value\nIn this form, typename is the name of the type you\u2019re converting to (for example: short, int,\nfloat, boolean), and value is an expression that results in the value you want to convert. This\nexpression divides the values of x by the value of y and casts the result to an int:\n(int) (x \/ y);\nNote that because the precedence of casting is higher than that of arithmetic, you have to use\nparentheses so that the result of the division is what gets cast to an int.\nCasting Objects\nInstances of classes can also be cast to instances of other classes, with one restriction: the class\nof the object you\u2019re casting and the class you\u2019re casting it to must be related by inheritance; that\nis, you can cast an object only to an instance of its class\u2019s sub- or superclass\u2014not to any random\nclass.\nAnalogous to converting a primitive value to a larger type, some objects may not need to be cast\nexplicitly. In particular, because instances\u2019 subclasses usually contain all the information that\ninstances\u2019 superclasses do, you can use an instance of a subclass anywhere a superclass is expected.\nSuppose you have a method that takes two arguments: one of type Object, and one of type\nNumber. You don\u2019t have to pass instances of those particular classes to that method. For the Object\nargument, you can pass any subclass of Object (any object, in other words), and for the Number\nargument you can pass in any instance of any subclass of Number (Integer, Boolean, Float, and\nso on).\nCasting an object to an instance of one of that object\u2019s superclasses loses the information the\noriginal subclass provided and requires a specific cast. To cast an object to another class, you use\nthe same casting operation that you used for base types:\n(classname) object\nIn this case, classname is the name of the class you want to cast the object to, and object is a\nreference to the object you\u2019re casting. Note that casting creates a new instance of the new class\nwith all the information that the old object contained; the old object still continues to exist as\nit did before.\nHere\u2019s a (fictitious) example of a cast of an instance of the class GreenApple to an instance of the\nclass Apple (where GreenApple is theoretically a subclass of Apple):\nGreenApple a;\nApple a2;\n72\n030-4s CH04.i 72 1\/29\/96, 8:48 PM\nP2\/V4\/sqc4 TY Java in 21 Days 030-4 Josette 12.21.95 Ch04 LP#4 Sams.net Learning\nCenter\nabcd\na = new GreenApple();\na2 = (Apple) a;\nIn addition to casting objects to classes, you can also cast objects to interfaces\u2014but only if that\nobject\u2019s class or one of its superclasses actually implements that interface. Casting an object to\nan interface then enables you to call one of that interface\u2019s methods even if that object\u2019s class does\nnot directly implement that interface. You\u2019ll learn more about interfaces in Week 3.\nConverting Primitive Types\nto Objects and Vice Versa\nNow you know how to cast a primitive type to another primitive type and how to cast between\nclasses. How can you cast one to the other?\nYou can\u2019t! Primitive types and objects are very different things in Java and you can\u2019t\nautomatically cast or convert between the two. However, the java.lang package includes several\nspecial classes that correspond to each primitive data type: Integer for ints, Float for floats,\nBoolean for booleans, and so on.\n4\nUsing class methods defined in these classes, you can create an object-equivalent for all the\nprimitive types using new. The following line of code creates an instance of the Integer class with\nthe value 35:\nInteger intObject = new Integer(35);\nOnce you have actual objects, you can treat those values as objects. Then, when you want the\nprimitive values back again, there are methods for that as well\u2014for example, the intValue()\nmethod extracts an int primitive value from an Integer object:\nint theInt = intObject.intValue(); \/\/ returns 35\nSee the Java API documentation for these special classes for specifics on the methods for\nconverting primitives to and from objects.\nOdds and Ends\nThis section is a catchall for other information about working with objects, in particular:\nnn Comparing objects\nnn Copying objects\nnn Finding out the class of any given object\nnn Testing to see whether an object is an instance of a given class\n73\n030-4s CH04.i 73 1\/29\/96, 8:48 PM\nP2\/V4\/sqc4 TY Java in 21 Days 030-4 Josette 12.21.95 Ch04 LP#4 MTWRFSS\nDDAAYY\n4 Working with Objects\nComparing Objects\nYesterday, you learned about operators for comparing values: equals, not equals, less than, and\nso on. Most of these operators work only on primitive types, not on objects. If you try to use other\nvalues as operands, the Java compiler produces errors.\nThe exception to this rule is with the operators for equality: == (equal) and != (not equal). These\noperators, when used with objects, tests whether the two operands refer to exactly the same\nobject.\nWhat should you do if you want to be able to compare instances of your class and have\nmeaningful results? You have to implement special methods in your class, and you have to call\nthose methods using those method names.\nTechnical Note: Java does not have the concept of operator overloading\u2014that is,\nthe capability of defining the behavior of the built-in operators by defining meth-\nods in your own classes. The built-in operators remain defined only for numbers.\nA good example of this is the String class. It is possible to have two strings, two independent\nobjects in memory with the same values\u2014that is, the same characters in the same order.\nAccording to the == operator, however, those two String objects will not be equal, because,\nalthough their contents are the same, they are not the same object.\nThe String class, therefore, defines a method called equals() that tests each character in the\nstring and returns true if the two strings have the same values. Listing 4.4 illustrates this.\nType\nListing 4.4. A Test of String Equality.\n1: class EqualsTest {\n2:\n3: public static void main (String args[]) {\n4: String str1, str2;\n5: str1 = \u201cshe sells sea shells by the sea shore.\u201d;\n6: str2 = str1;\n7:\n8: System.out.println(\u201cString1: \u201c + str1);\n9: System.out.println(\u201cString2: \u201c + str2);\n10: System.out.println(\u201cSame object? \u201c + (str1 == str2));\n11:\n12: str2 = new String(str1);\n13:\n14: System.out.println(\u201cString1: \u201c + str1);\n15: System.out.println(\u201cString2: \u201c + str2);\n16: System.out.println(\u201cSame object? \u201c + (str1 == str2));\n17: System.out.println(\u201cSame value? \u201c + str1.equals(str2));\n18: }\n19: }\n74\n030-4s CH04.i 74 1\/29\/96, 8:48 PM\nP2\/V4\/sqc4 TY Java in 21 Days 030-4 Josette 12.21.95 Ch04 LP#4 Sams.net Learning\nCenter\nabcd\nOutput String1: she sells sea shells by the sea shore.\nString2: she sells sea shells by the sea shore.\nSame object? true\nString1: she sells sea shells by the sea shore.\nString2: she sells sea shells by the sea shore.\nSame object? false\nSame value? true\nAnalysis The first part of this program (lines 4 through 6) declares two variables, str1 and str2,\nassigns the literal she sells sea shells by the sea shore. to str1, and then assigns that\nvalue to str2. As you know from object references, now str1 and str2 point to the same\nobject, and the test at line 10 proves that.\nIn the second part, you create a new string object with the value of str1. Now you have two\ndifferent string objects with the same value. Testing them to see whether they\u2019re the same object\nby using the == operator (line 16) returns the expected answer, as does testing them using the\nequals method (line 17) to compare their values.\nTechnical Note: Why can\u2019t you just use another literal when you change str2,\nrather than using new? String literals are optimized in Java\u2014if you create a string 4\nusing a literal, and then use another literal with the same characters, Java knows\nenough merely to give you the first String object back. Both strings are the same\nobjects\u2014to create two separate objects you have to go out of your way.\nCopying Objects\nRecall from the section on object references that assigning variables and passing objects as\narguments to methods affect only the object\u2019s reference and doesn\u2019t create copies of those\nobjects. How do you create copies of objects? There are two ways: the copy() method and the\nclone() method.\nThe copy() method (defined in Object, and so available to all objects), takes a single argument\u2014\nanother instance of the same class\u2014and copies the values of all the argument\u2019s instance variables\ninto the instance variables of the current object (the one in which you\u2019re calling the method).\nNote that if those instance variables in turn hold references to objects, only the references are\ncopied, not the objects.\nPoint pt1, pt2, pt3;\npt1 = new Point(0,0);\npt2 = new Point(100,100);\npt2.copy(pt1); \/\/ pt1\u2019s values are copied into pt2; both now are (0,0).\n75\n030-4s CH04.i 75 1\/29\/96, 8:48 PM\nP2\/V4\/sqc4 TY Java in 21 Days 030-4 Josette 12.21.95 Ch04 LP#4 MTWRFSS\nDDAAYY\n4 Working with Objects\nThe clone() method is similar to copy(), except that clone() takes no arguments. The clone()\nmethod creates a new instance of the same class as the source object and then copies the values\nof the instance variables (either primitive types or references to other objects). clone() returns\nan instance of the class Object; to use it as an instance of the original class you have to cast it.\nHere\u2019s an example that clones the Point object in pt2 and stores the result in pt3:\npt3 = (Point) pt2.clone();\nDetermining the Class of an Object\nWant to find out the class of an object? Here\u2019s the way to do it for an object assigned to the\nvariable obj:\nString name = obj.getClass().getName();\nWhat does this do? The getClass() method is defined in the Object class, and as such is available\nfor all objects. The result of that method is a Class object (where Class is itself a class), which\nhas a method called getName(). getName() returns a string representing the name of the class.\nAnother test that might be useful to you is the instanceof operator. instanceof has two\noperands: an object on the left, and the name of a class on the right. The expression returns true\nor false based on whether the object is an instance of the named class or any of that class\u2019s\nsuperclasses:\n\u201cfoo\u201d instanceof String \/\/ true\nPoint pt = new Point(10,10);\npt instanceof String \/\/ false\nThe instanceof operator can also be used for interfaces; if an object implements an interface,\nthe instanceof operator with an interface name on the right side returns true. You\u2019ll learn all\nabout interfaces in Week 3.\nThe Java Class Libraries\nTo finish up today, let\u2019s look at the some of the Java class libraries. Actually, you\u2019ve had some\nexperience with them already, so they shouldn\u2019t seem that strange.\nThe Java class libraries provide the set of classes that are guaranteed to be available in any\ncommercial Java environment (for example, in HotJava or in Netscape 2.0). Those classes are\nin the java package and include all the classes you\u2019ve seen so far in this book, plus a whole lot\nmore classes you\u2019ll learn about later on in this book (and more you may not learn about at all).\nThe Java Developer\u2019s Kit comes with documentation for all the Java class libraries, which\nincludes descriptions of each class\u2019s instance variables, methods, constructors, interfaces, and so\non. A shorter summary of the Java API is in Appendix B as well. Exploring the Java class libraries\n76\n030-4s CH04.i 76 1\/29\/96, 8:48 PM\nP2\/V4\/sqc4 TY Java in 21 Days 030-4 Josette 12.21.95 Ch04 LP#4 Sams.net Learning\nCenter\nabcd\nand their methods and instance variables is a great way to figure out what Java can and cannot\ndo, as well as a starting point for your own development.\nHere are the class packages that are part of the Java class libraries:\nnn java.lang: Classes that apply to the language itself, which includes the Object class,\nthe String class, and the System class. It also contains the special classes for the\nprimitive types (Integer, Character, Float, and so on).\nnn java.util: Utility classes, such as Date, as well as simple collection classes, such as\nVector and Hashtable.\nnn java.io: Input and output classes for writing to and reading from streams (such as\nstandard input and output) and for handling files.\nnn java.net: Classes for networking support, including Socket and URL (a class to\nrepresent references to documents on the World Wide Web).\nnn java.awt: (the Abstract Window Toolkit): Classes to implement a graphical user\ninterface, including classes for Window, Menu, Button, Font, CheckBox, and so on. This\npackage also includes classes for processing images (the java.awt.Image package).\nnn java.applet: Classes to implement Java applets, including the Applet class itself, as 4\nwell as the AudioClip class.\nIn addition to the Java classes, your development environment may also include additional\nclasses that provide other utilities or functionality. Although these classes may be useful, because\nthey are not part of the standard Java library, they won\u2019t be available to other people trying to\nrun your Java program. This is particularly important for applets, because applets are expected\nto be able to run on any platform, using any Java-aware browser. Only classes inside the java\npackage are guaranteed to be available on all browsers and Java environments.\nSummary\nObjects, objects everywhere. Today, you learned all about how to deal with objects: how to\ncreate them, how to find out and change the values of their variables, and how to call their\nmethods. You also learned how to copy and compare them, and how to convert them into other\nobjects. Finally, you learned a bit about the Java class libraries\u2014which give you a whole slew of\nclasses to play with in your own programs.\nYou now have the fundamentals of how to deal with most simple things in the Java language.\nAll you have left are arrays, conditionals, and loops, which you\u2019ll learn about tomorrow. Then\nyou\u2019ll learn how to define and use classes in Java applications on Day 6, and launch directly into\napplets next week. With just about everything you do in your Java programs, you\u2019ll always come\nback to objects.\n77\n030-4s CH04.i 77 1\/29\/96, 8:49 PM\nP2\/V4\/sqc4 TY Java in 21 Days 030-4 Josette 12.21.95 Ch04 LP#4 MTWRFSS\nDDAAYY\n4 Working with Objects\nQ&A\nQ I\u2019m confused about the differences between objects and the primitive data types,\nsuch as int and boolean.\nA The primitive types in the language (byte, short, int, long, float, double, and char)\nrepresent the smallest things in the language. They are not objects, although in many\nways they can be handled like objects\u2014they can be assigned to variables and passed in\nand out of methods. Most of the operations that work exclusively on objects, however,\nwill not.\nObjects usually represent instances of classes and as such, are much more complex\ndata types than simple numbers and characters, often containing numbers and\ncharacters as instance or class variables.\nQ In the section on calling methods, you had examples of calling a method with a\ndifferent number of arguments each time\u2014and it gave a different kind of result.\nHow is that possible?\nA That\u2019s called method overloading. Overloading enables the same function name to have\ndifferent behavior based on the arguments it\u2019s called with\u2014and the number and type\nof arguments can vary. When you define methods in your own classes, you define\nseparate method signatures with different sets or arguments and different definitions.\nWhen that method is called, Java figures out which definition to execute based on the\nnumber and type of arguments with which you called it.\nYou\u2019ll learn all about this on Day 6.\nQ No operator overloading in Java? Why not? I thought Java was based on C++,\nand C++ has operator overloading.\nA Java was indeed based on C++, but it was also designed to be simple, so many of\nC++\u2019s features have been removed. The argument against operator overloading is that\nbecause the operator can be defined to mean anything, it makes it very difficult to\nfigure out what any given operator is doing at any one time. This can result in entirely\nunreadable code. Given the potential for abuse, the designers of Java felt it was one of\nthe C++ features that was best left out.\n78\n030-4s CH04.i 78 1\/29\/96, 8:49 PM\nP2\/V4\/sqc4 TY Java in 21 Days 030-4 Josette 12.21.95 Ch04 LP#4 Sams.net Learning\nCenter\nabcd\n5\n5\nS\nS\nWEEK\nF 1\nR\nW 5\nArrays,\nT\nConditionals,\nM\nand Loops\nby Laura Lemay\n79\n030-4s CH05.i 79 1\/29\/96, 9:02 PM\nSQC 6 P2\/V4 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch5 LP#3 MTWRFSS\nDDAAYY\n5 Arrays, Conditionals, and Loops\nAlthough you could write Java programs using what you\u2019ve learned so far, those programs would\nbe pretty dull. Much of the good stuff in Java or in any programming language results when you\nhave arrays to store values in and control-flow constructs (loops and conditionals) to execute\ndifferent bits of a program based on tests. Today, you\u2019ll find out about the following:\nnn Arrays, one of the most useful objects in Java, which enable you to collect objects into\nan easy-to-manage list\nnn Block statements, for grouping together related statements\nnn if and switch, for conditional tests\nnn for and while loops, for iteration or repeating a statement or statements multiple\ntimes\nArrays\nArrays in Java are different than they are in other languages. Arrays in Java are actual objects that\ncan be passed around and treated just like other objects.\nNEW* Arrays are a way to store a list of items. Each element of the array holds an individual item,\nTERM and you can place items into and remove items from those slots as you need to.\nArrays can contain any type of value (base types or objects), but you can\u2019t store different types\nin a single array. You can have an array of integers, or an array of strings, or an array of arrays,\nbut you can\u2019t have an array that contains, for example, both strings and integers.\nTo create an array in Java, you use three steps:\n1. Declare a variable to hold the array.\n2. Create a new array object and assign it to the array variable.\n3. Store things in that array.\nDeclaring Array Variables\nThe first step to creating an array is creating a variable that will hold the array, just as you would\nany other variable. Array variables indicate the type of object the array will hold (just as they do\nfor any variable) and the name of the array, followed by empty brackets ([]). The following are\nall typical array variable declarations:\nString difficultWords[];\nPoint hits[];\nint temps[];\n80\n030-4s CH05.i 80 1\/29\/96, 9:02 PM\nSQC 6 P2\/V4 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch5 LP#3 Sams.net Learning\nCenter\nabcd\nAn alternate method of defining an array variable is to put the brackets after the type instead of\nafter the variable. They are equivalent, but this latter form is often much more readable. So, for\nexample, these three declarations could be written like this:\nString[] difficultWords;\nPoint[] hits;\nint[] temps;\nCreating Array Objects\nThe second step is to create an array object and assign it to that variable. There are two ways to\ndo this:\nnn Using new\nnn Directly initializing the contents of that array\nThe first way is to use the new operator to create a new instance of an array:\nString[] names = new String[10];\nThat line creates a new array of Strings with ten slots, or elements. When you create the new array\nobject using new, you must indicate how many elements that array will hold.\nArray objects can contain primitive types such as integers or booleans, just as they can contain\nobjects: 5\nint[] temps = new int[99];\nWhen you create an array object using new, all its elements are initialized for you (0 for numeric\narrays, false for boolean, \u2018\\0\u2019 for character arrays, and null for everything else). You can also\ncreate and initialize an array at the same time. Instead of using new to create the new array object,\nenclose the elements of the array inside braces, separated by commas:\nString[] chiles = { \u201cjalapeno\u201d, \u201canaheim\u201d, \u201cserrano,\u201d\n\u201chabanero,\u201d \u201cthai\u201d };\nEach of the elements inside the braces must be of the same type and must be the same type as\nthe variable that holds that array. An array the size of the number of elements you\u2019ve included\nwill be automatically created for you. This example creates an array of String objects named\nchiles that contains five elements.\nAccessing Array Elements\nOnce you have an array with initial values, you can test and change the values in each slot of that\narray. To get at a value stored within an array, use the array subscript expression:\nmyArray[subscript];\n81\n030-4s CH05.i 81 1\/29\/96, 9:02 PM\nSQC 6 P2\/V4 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch5 LP#3 MTWRFSS\nDDAAYY\n5 Arrays, Conditionals, and Loops\nThe myArray part of this expression is a variable holding an array object, although it can also be\nan expression that results in an array). The subscript is the slot within the array to access, which\ncan also be an expression. Array subscripts start with 0, as they do in C and C++. So, an array\nwith ten elements has array values from subscript 0 to 9.\nNote that all array subscripts are checked to make sure that they are inside the boundaries of the\narray (greater than 0 but less than the array\u2019s length) either when your Java program is compiled\nor when it is run. It is impossible in Java to access or assign a value to an array element outside\nof the boundaries of the array. Note the following two statements, for example:\nString arr[] = new String[10];\narr[10] = \u201ceggplant\u201d;\nA program with that last statement in it produces a compiler error at that line when you try to\ncompile it. The array stored in arr has only ten elements numbered from 0, the element at\nsubscript 10 doesn\u2019t exist, and the Java compiler will check for that.\nIf the array subscript is calculated at run-time (for example, as part of a loop) and ends up outside\nthe boundaries of the array, the Java interpreter also produces an error (actually, to be technically\ncorrect, it throws an exception). You\u2019ll learn more about exceptions later on next week and on\nDay 18.\nHow can you keep from overrunning the end of an array accidentally in your own programs?\nYou can test for the length of the array in your programs using the length instance variable\u2014\nit\u2019s available for all array objects, regardless of type:\nint len = arr.length \/\/ returns 10\nChanging Array Elements\nTo assign a value to a particular array slot, merely put an assignment statement after the array\naccess expression:\nmyarray[1] = 15;\nsentence[0] = \u201cThe\u201d;\nsentence[10] = sentence[0];\nAn important thing to note is that an array of objects in Java is an array of references to those\nobjects (similar in some ways to an array of pointers in C or C++). When you assign a value to\na slot in an array, you\u2019re creating a reference to that object, just as you do for a plain variable.\nWhen you move values around inside arrays (as in that last line), you just reassign the reference;\nyou don\u2019t copy the value from one slot to another. Arrays of primitive types such as ints or floats\ndo copy the values from one slot to another.\nArrays of references to objects, as opposed to the objects themselves, are particularly useful\nbecause it means you can have multiple references to the same objects both inside and outside\narrays\u2014for example, you can assign an object contained in an array to a variable and refer to that\nsame object by using either the variable or the array position.\n82\n030-4s CH05.i 82 1\/29\/96, 9:03 PM\nSQC 6 P2\/V4 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch5 LP#3 Sams.net Learning\nCenter\nabcd\nMultidimensional Arrays\nJava does not support multidimensional arrays. However, you can declare and create an array\nof arrays (and those arrays can contain arrays, and so on, for however many dimensions you\nneed), and access them as you would C-style multidimensional arrays:\nint coords[][] = new int[12][12];\ncoords[0][0] = 1;\ncoords[0][1] = 2;\nBlock Statements\nA block statement is a group of other statements surrounded by braces ({}). You can use a block\nanywhere a single statement would go, and the new block creates a new local scope for the\nstatements inside it. This means that you can declare and use local variables inside a block, and\nthose variables will cease to exist after the block is finished executing. For example, here\u2019s a block\ninside a method definition that declares a new variable y. You cannot use y outside the block in\nwhich it\u2019s declared:\nvoid testblock() {\nint x = 10;\n{ \/\/ start of block\nint y = 50;\nSystem.out.println(\u201cinside the block:\u201d);\nSystem.out.println(\u201cx:\u201d + x);\nSystem.out.println(\u201cy:\u201d + y);\n} \/\/ end of block 5\n}\nBlocks are not usually used in this way\u2014alone in a method definition. You\u2019ve mostly seen blocks\nup to this point surrounding class and method definitions, but another very common use of\nblock statements is in the control flow constructs you\u2019ll learn about in the remainder of today\u2019s\nlesson.\nif Conditionals\nThe if conditional, which enables you to execute different bits of code based on a simple test\nin Java, is nearly identical to if statements in C. if conditionals contain the keyword if,\nfollowed by a boolean test, followed by a statement (often a block statement) to execute if the\ntest is true:\nif (x < y)\nSystem.out.println(\u201cx is smaller than y\u201d);\nAn optional else keyword provides the statement to execute if the test is false:\nif (x < y)\nSystem.out.println(\u201cx is smaller than y\u201d);\nelse System.out.println(\u201cy is bigger.\u201d);\n83\n030-4s CH05.i 83 1\/29\/96, 9:03 PM\nSQC 6 P2\/V4 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch5 LP#3 MTWRFSS\nDDAAYY\n5 Arrays, Conditionals, and Loops\nTechnical Note: The difference between if conditionals in Java and C or C++ is\nthat the test must return a boolean value (true or false). Unlike in C, the test\ncannot return an integer.\nif (engineState == true )\nSystem.out.println(\u201cEngine is already on.\u201d);\nelse {\nSystem.out.println(\u201cNow starting Engine\u201d);\nif (gasLevel >= 1)\nengineState = true;\nelse System.out.println(\u201cLow on gas! Can\u2019t start engine.\u201d);\n}\nThis example uses the test (engineState == false). For boolean tests of this type, a common\nshortcut is merely to include the first part of the expression, rather than explicitly testing its value\nagainst true or false:\nif (engineState)\nSystem.out.println(\u201cEngine is on.\u201d);\nelse System.out.println(\u201cEngine is off\u201d);\nThe Conditional Operator\nAn alternative to using the if and else keywords in a conditional statement is to use the\nconditional operator, sometimes called the ternary operator.\nNEW* A conditional operator is a ternary operator because it has three terms.\nTERM\nThe conditional operator is an expression, meaning that it returns a value (unlike the more\ngeneral if, which can result in any statement or block being executed). The conditional operator\nis most useful for very short or simple conditionals, and looks like this:\ntest ? trueresult : falseresult\nThe test is an expression that returns true or false, just like the test in the if statement. If the\ntest is true, the conditional operator returns the value of trueresult; if it\u2019s false, it returns the\nvalue of falseresult. For example, the following conditional tests the values of x and y, returns\nthe smaller of the two, and assigns that value to the variable smaller:\nint smaller = x < y ? x : y;\nThe conditional operator has a very low precedence; that is, it\u2019s usually evaluated only after all\nits subexpressions are evaluated. The only operators lower in precedence are the assignment\noperators. See the precedence chart in Day 3\u2019s lesson for a refresher on precedence of all the\noperators.\n84\n030-4s CH05.i 84 1\/29\/96, 9:03 PM\nSQC 6 P2\/V4 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch5 LP#3 Sams.net Learning\nCenter\nabcd\nswitch Conditionals\nA common practice in programming in any language is to test a variable against some value, and\nif it doesn\u2019t match that value, to test it again against a different value, and if it doesn\u2019t match that\none to make yet another test, and so on. Using only if statements, this can become unwieldy,\ndepending on how it\u2019s formatted and how many different options you have to test. For example,\nyou might end up with a set of if statements something like this or longer:\nif (oper == \u2018+\u2019)\naddargs(arg1,arg2);\nelse if (oper == \u2018=\u2019)\nsubargs(arg1,arg2);\nelse if (oper == \u2018*\u2019)\nmultargs(arg1,arg2);\nelse if (oper == \u2018\/\u2019)\ndivargs(arg1,arg2);\nThis form of if statement is called a nested if, because each else statement in turn contains yet\nanother if, and so on, until all possible tests have been made.\nA common shorthand mechanism for nested ifs that you can use in some cases allows you tests\nand actions together in a single statement. This is the switch or case statement; in Java it\u2019s switch\nand behaves as it does in C:\nswitch (test) {\ncase valueOne:\nresultOne;\nbreak; 5\ncase valueTwo:\nresultTwo;\nbreak;\ncase valueThree:\nresultThree;\nbreak;\n...\ndefault: defaultresult;\n}\nIn the switch statement, the test (a primitive type of byte, char, short, or int) is compared with\neach of the case values in turn. If a match is found, the statement, or statements after the test\nis executed. If no match is found, the default statement is executed. The default is optional,\nso if there isn\u2019t a match in any of the cases and default doesn\u2019t exist, the switch statement\ncompletes without doing anything.\nNote that the significant limitation of the switch in Java is that the tests and values can be only\nsimple primitive types (and then only primitive types that are castable to int). You cannot use\nlarger primitive types (long, float) or objects within a switch, nor can you test for any\nrelationship other than equality. This limits the usefulness of switch to all but the simplest cases;\nnested ifs can work for any kind of test on any type.\n85\n030-4s CH05.i 85 1\/29\/96, 9:03 PM\nSQC 6 P2\/V4 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch5 LP#3 MTWRFSS\nDDAAYY\n5 Arrays, Conditionals, and Loops\nHere\u2019s a simple example of a switch statement similar to the nested if shown earlier:\nswitch (oper) {\ncase \u2018+\u2019:\naddargs(arg1,arg2);\nbreak;\ncase \u2018*\u2019:\nsubargs(arg1,arg2);\nbreak;\ncase \u2018-\u2019:\nmultargs(arg1,arg2);\nbreak;\ncase \u2018\/\u2019:\ndivargs(arg1,arg2);\nbreak;\n}\nNote the break statement included in every line. Without the explicit break, once a match is\nmade, the statements for that match and also all the statements further down in the switch are\nexecuted until a break or the end of the switch is found (and then execution continues after the\nend of the switch). In some cases, this may be exactly what you want to do, but in most cases,\nyou\u2019ll want to make sure to include the break so that only the statements you want to be executed\nare executed.\nOne handy use of falling through occurs when you want multiple values to execute the same\nstatements. In this instance, you can use multiple case lines with no result, and the switch will\nexecute the first statements it finds. For example, in the following switch statement, the string\n\u201cx is an even number.\u201d is printed if x has values of 2, 4, 6, or 8. All other values of x print the\nstring \u201cx is an odd number.\u201d\nswitch (x) {\ncase 2:\ncase 4:\ncase 6:\ncase 8:\nSystem.out.println(\u201cx is an even number.\u201d);\nbreak;\ndefault: System.out.println(\u201cx is an odd number.\u201d);\n}\nfor Loops\nThe for loop, as in C, repeats a statement or block of statements some number of times until\na condition is matched. for loops are frequently used for simple iteration in which you repeat\na block of statements a certain number of times and then stop, but you can use for loops for just\nabout any kind of loop.\nThe for loop in Java looks roughly like this:\nfor (initialization; test; increment) {\n86\n030-4s CH05.i 86 1\/29\/96, 9:03 PM\nSQC 6 P2\/V4 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch5 LP#3 Sams.net Learning\nCenter\nabcd\nstatements;\n}\nThe start of the for loop has three parts:\nnn initialization is an expression that initializes the start of the loop. If you have a loop\nindex, this expression might declare and initialize it, for example, int i = 0. Variables\nthat you declare in this part of the for loop are local to the loop itself; they cease\nexisting after the loop is finished executing. (This is different from C or C++.)\nnn test is the test that occurs after each pass of the loop. The test must be a boolean\nexpression or function that returns a boolean value, for example, i < 10. If the test is\ntrue, the loop executes. Once the test is false, the loop stops executing.\nnn increment is any expression or function call. Commonly, the increment is used to\nchange the value of the loop index to bring the state of the loop closer to returning\nfalse and completing.\nThe statement part of the for loop is the statement that is executed each time the loop iterates.\nJust as with if, you can include either a single statement here or a block; the previous example\nused a block because that is more common. Here\u2019s an example of a for loop that initializes all\nthe values of a String array to null strings:\nString strArray[] = new String[10];\nint i; \/\/ loop index\nfor (i = 0; i < strArray.length; i++)\nstrArray[i] = \u201c\u201d;\n5\nAny of the parts of the for loop can be empty statements, that is, you can simply include a\nsemicolon with no expression or statement, and that part of the for loop will be ignored. Note\nthat if you do use a null statement in your for loop, you may have to initialize or increment any\nloop variables or loop indices yourself elsewhere in the program.\nYou can also have an empty statement for the body of your for loop, if everything you want to\ndo is in the first line of that loop. For example, here\u2019s one that finds the first prime number higher\nthan 4000:\nfor (i = 4001; notPrime(i); i += 2)\n;\nNote that a common mistake in C that also occurs in Java is accidentally to put a semicolon after\nthe first line of the for loop:\nfor (i = 0; i < 10; i++);\nSystem.out.println(\u201cLoop!\u201d);\nBecause the first semicolon ends the loop with an empty statement, the loop doesn\u2019t actually do\nanything. The println function will be printed only once, because it\u2019s actually outside the for\nloop entirely. Be careful not to make this mistake in your own Java programs.\n87\n030-4s CH05.i 87 1\/29\/96, 9:03 PM\nSQC 6 P2\/V4 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch5 LP#3 MTWRFSS\nDDAAYY\n5 Arrays, Conditionals, and Loops\nwhile and do Loops\nFinally, there are while and do loops. while and do loops, like for loops, enable a block of Java\ncode to be executed repeatedly until a specific condition is met. Whether you use a for loop, a\nwhile, or a do is mostly a matter of your programming style.\nwhile and do loops, like for, are exactly the same as those same constructions in C and C++.\nwhile Loops\nThe while loop is used to repeat a statement or block of statements as long as a particular\ncondition is true. while loops look like this:\nwhile (condition) {\nbodyOfLoop;\n}\nThe condition is a boolean expression. If it returns true, the while loop executes the statements\nin bodyOfLoop and then tests the condition again, repeating until the condition is false. I\u2019ve\nshown the while loop here with a block statement, because it\u2019s most commonly used, although\nyou can use a single statement in place of the block.\nHere\u2019s an example of a while loop that copies the elements of an array of integers (in array1)\nto an array of floats (in array2), casting each element to a float as it goes. The one catch is that\nif any of the elements in the first array is 0, the loop will immediately exit at that point. To cover\nboth the cases wherein all the elements have been copied and an element is 0, you can use a\ncompound test with the && operator:\nwhile ((ch != \u2018 \u2018) && (ch != \u2018\\t\u2019) && (ch != \u2018\\n\u2019) && (ch != \u2018\\r\u2019)) {\naddChar(ch, theName);\nch = instream.read();\n}\nNote that if the condition is initially false the first time it is tested (for example, if the first element\nin that first array is 0), the body of the while loop will never be executed. If you need to execute\nthe loop at least once, you can do one of two things:\nnn Duplicate the body of the loop outside the while loop.\nnn Use a do loop (described below).\nThe do loop is considered the better solution of the two.\n88\n030-4s CH05.i 88 1\/29\/96, 9:04 PM\nSQC 6 P2\/V4 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch5 LP#3 Sams.net Learning\nCenter\nabcd\ndo...while Loops\nThe do loop is just like a while loop, except that do executes a given statement or block until a\ncondition is false. The main difference is that while loops test the condition before looping,\nmaking it possible that the body of the loop will never execute if the condition is false the first\ntime it\u2019s tested. do loops run the body of the loop at least once before testing the condition. do\nloops look like this:\ndo {\nbodyOfLoop;\n} while (condition);\nHere, the bodyOfLoop part is the statements that are executed with each iteration. It\u2019s shown here\nwith a block statement because it\u2019s most commonly used that way, but you can substitute the\nbraces for a single statement as you can with the other control-flow constructs. The condition\nis a boolean test. If it returns true, the loop is run again. If it returns false, the loop exits. Keep\nin mind that with do loops, the body of the loop executes at least once.\nHere\u2019s a simple example of a do loop that prints a message each time the loop iterates:\nint x = 1;\ndo {\nSystem.out.println(\u201cLooping, round \u201c + x);\nx++;\n} while (x <= 10);\nHere\u2019s the output of these statements:\nOutput Looping, round 1 5\nLooping, round 2\nLooping, round 3\nLooping, round 4\nLooping, round 5\nLooping, round 6\nLooping, round 7\nLooping, round 8\nLooping, round 9\nLooping, round 10\nBreaking Out of Loops\nIn all the loops (for, while, and do), the loop ends when the condition you\u2019re testing for is met.\nWhat happens if something odd occurs within the body of the loop and you want to exit the loop\nearly? For that, you can use the break and continue keywords.\n89\n030-4s CH05.i 89 1\/29\/96, 9:04 PM\nSQC 6 P2\/V4 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch5 LP#3 MTWRFSS\nDDAAYY\n5 Arrays, Conditionals, and Loops\nYou\u2019ve already seen break as part of the switch statement; it stops execution of the switch, and\nthe program continues. The break keyword, when used with a loop, does the same thing\u2014it\nimmediately halts execution of the current loop. If you\u2019ve nested loops within loops, execution\npicks up in the next outer loop; otherwise, the program merely continues executing the next\nstatement after the loop.\nFor example, suppose you have a while loop that copies elements from one array into another.\nEach element in the array should be copied until the end of the array is reached or if an element\ncontains 0. You can test for that latter case inside the body of the while and then use a break to\nexit the loop:\nwhile (count < array1.length) {\nif (array1[count] == 0) {\nbreak;\n}\narray2[count] = array1[count];\ncount++;\n}\n}\ncontinue is similar to break except that instead of halting execution of the loop entirely, the loop\nstarts over at the next iteration. For do and while loops, this means the execution of the clock\nstarts over again; for for loops, the increment expression is evaluated and then block is executed.\ncontinue is useful when you want to special-case elements within a loop. With the previous\nexample of copying one array to another, you can test for whether the current element is 0 and\nrestart the loop if you find it so that the resulting array will never contain zero. Note that because\nyou\u2019re skipping elements in the first array, you now have to keep track of two different array\ncounters:\nwhile (count < array1.length) {\nif (array1[count] == 0)\ncontinue;\narray2[count2++] = (float)array1[count++];\n}\nLabeled Loops\nBoth break and continue can have an optional label that tells Java where to break to. Without\na label, break jumps outside the nearest loop (to an enclosing loop or to the next statement\noutside the loop), and continue restarts the enclosing loop. Using labeled breaks and continues\nenables you to break outside nested loops or to continue a loop outside the current loop.\n90\n030-4s CH05.i 90 1\/29\/96, 9:04 PM\nSQC 6 P2\/V4 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch5 LP#3 Sams.net Learning\nCenter\nabcd\nTo use a labeled loop, add the label before the initial part of the loop, with a colon between them.\nThen, when you use break or continue, add the name of the label after the keyword itself:\nout:\nfor (int i = 0; i <10; i++) {\nwhile (x < 50) {\nif (i * x == 400)\nbreak out;\n...\n}\n...\n}\nIn this snippet of code, the label out labels the outer for loop. Then, inside both the for and the\nwhile loop, if a particular condition is met inside both loops, a break causes the execution to\ncreak out of both loops and restart back at the label (out).\nHere\u2019s another example. the following program contains a nested for loop. Inside the innermost\nloop, if the sum values of the two counters is greater than four, both loops exit at once:\nfoo:\nfor (int i = 1; i <= 5; i++)\nfor (int j = 1; j <= 3; j++) {\nSystem.out.println(\u201ci is \u201c + i + \u201c, j is \u201c + j);\nif ((i + j) > 4)\nbreak foo;\n}\nSystem.out.println(\u201cend of loops\u201d);\nHere\u2019s the output from this program:\n5\nOutput i is 1, j is 1\ni is 1, j is 2\ni is 1, j is 3\ni is 2, j is 1\ni is 2, j is 2\ni is 2, j is 3\nend of loops\nAnalysis As you can see, the loop iterated until the sum of i and j was greater than 4, and then both\nloops exited back to the outer block and the final message was printed.\nSummary\nToday, you learned about three main topics that you\u2019ll most likely use quite often in your own\nJava programs: arrays, conditionals, and loops.\nYou learned how to declare an array variable, create and assign an array object to that variable,\nand access and change elements within that array.\n91\n030-4s CH05.i 91 1\/29\/96, 9:04 PM\nSQC 6 P2\/V4 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch5 LP#3 MTWRFSS\nDDAAYY\n5 Arrays, Conditionals, and Loops\nConditionals include the if and switch statements, with which you can branch to different parts\nof your program based on a boolean test.\nFinally, you learned about the for, while, and do loops, each of which enable you to execute a\nportion of your program repeatedly until a given condition is met.\nNow that you\u2019ve learned the small stuff, all that\u2019s left is to go over the bigger issues of declaring\nclasses and creating methods within which instances of those classes can communicate with each\nother by calling methods. Get to bed early tonight, because tomorrow is going to be a wild ride.\nQ&A\nQ If arrays are objects, and you use new to create them, and they have an instance\nvariable length, where is the Array class? I didn\u2019t see it in the Java class libraries.\nA Arrays are implemented kind of weirdly in Java. The Array class is constructed\nautomatically when your Java program runs; Array provides the basic framework for\narrays, including the length variable. Additionally, each primitive type and object has\nan implicit subclass of Array that represents an array of that class or object. When you\ncreate a new array object, it may not have an actual class, but it behaves as if it does.\nQ Does Java have gotos?\nA The Java language defines the keyword goto, but it is not currently used for anything.\nIn other words, no, Java does not have gotos.\nQ I declared a variable inside a block statement for an if. When the if was done,\nthe definition of that variable vanished. Where did it go?\nA In technical terms, block statements inside braces form a new lexical scope. What this\nmeans is that if you declare a variable inside a block, it\u2019s only visible and usable inside\nthat block. Once the block finishes executing, all the variables you declared go away.\nIt\u2019s a good idea to declare most of your variables in the outermost block in which\nthey\u2019ll be needed\u2014usually at the top of a block statement. The exception might be\nvery simple variables, such as index counters in for loops, where declaring them in the\nfirst line of the for loop is an easy shortcut.\nYou\u2019ll learn more about variables and scope tomorrow.\nQ What can\u2019t you use switch with strings?\nA Strings are objects, and switch in Java works only for the primitive types that can be\ncast to integers (byte, char, short, and int). To compare strings, you have to use\nnested ifs, which enable more general expression tests, including string comparison.\n92\n030-4s CH05.i 92 1\/29\/96, 9:04 PM\nSQC 6 P2\/V4 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch5 LP#3 Sams.net Learning\nCenter\nabcd\nQ It seems to me that a lot of for loops could be written as while loops, and vice\nversa.\nA True. The for loop is actually a special case of while that enables you to iterate a loop\na specific number of times. You could just as easily do this with a while and then\nincrement a counter inside the loop. Either works equally well. This is mostly just a\nquestion of programming style and personal choice.\n5\n93\n030-4s CH05.i 93 1\/29\/96, 9:04 PM\nSQC 6 P2\/V4 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch5 LP#3 Sams.net Learning\nCenter\nabcd\n6\n6\nS\nS\nWEEK\nF 1\nR\nW\nCreating Classes\nT\nand Applications\nM 6\nin Java\nBy Laura Lemay\n95\n030-4s CH06.i 95 1\/29\/96, 9:05 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 6 LP#3 MTWRFSS\nDDAAYY\n6 Creating Classes and Applications in Java\nIn just about every lesson up to this point you\u2019ve been creating Java applications\u2014writing\nclasses, creating instance variables and methods, and running those applications to perform\nsimple tasks. Also up to this point, you\u2019ve focused either on the very broad (general object-\noriented theory) or the very minute (arithmetic and other expressions). Today, you pull it all\ntogether and learn how and why to create classes by using the following basics:\nnn The parts of a class definition\nnn Declaring and using instance variables\nnn Defining and using methods\nnn Creating Java applications, including the main() method and how to pass arguments\nto a Java program from a command line\nDefining Classes\nDefining classes is pretty easy; you\u2019ve seen how to do it a bunch of times in previous lessons. To\ndefine a class, use the class keyword and the name of the class:\nclass MyClassName {\n...\n}\nIf this class is a subclass of another class, use extends to indicate the superclass of this class:\nclass myClassName extends mySuperClassName {\n...\n}\nIf this class implements a specific interface, use implements to refer to that interface:\nclass MyRunnableClassName implements Runnable {\n...\n}\nBoth extends and implements are optional. You\u2019ll learn about using and defining interfaces in\nWeek 3.\nCreating Instance and Class Variables\nA class definition with nothing in it is pretty dull; usually, when you create a class, you have\nsomething you want to add to make that class different from its superclasses. Inside each class\ndefinition are declarations and definitions for variables or methods or both\u2014for the class and\nfor each instance. In this section, you\u2019ll learn all about instance and class variables; the next\nsection talks about methods.\n96\n030-4s CH06.i 96 1\/29\/96, 9:05 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 6 LP#3 Sams.net Learning\nCenter\nabcd\nDefining Instance Variables\nOn Day 3, you learned how to declare and initialize local variables\u2014that is, variables inside\nmethod definitions. Instance variables, fortunately, are declared and defined in exactly the same\nway as local variables; the only difference is their location in the class definition. Instance\nvariables are considered instance variables if they are declared outside a method definition.\nCustomarily, however, most instance variables are defined just after the first line of the class\ndefinition. For example, Listing 6.1 shows a simple class definition for the class Bicycle, which\ninherits from the class PersonPoweredVehicle. This class definition contains four instance\nvariables:\nnn bikeType: the kind of bicycle this bicycle is\u2014for example, Mountain or Street\nnn chainGear, the number of gears in the front\nnn rearCogs, the number of minor gears on the rear axle\nnn currentGearFront and currentGearRear: the gears the bike is currently in, both front\nand rear\nType\nListing 6.1. The bicycle class.\n1: class Bicycle extends PersonPoweredVehicle {\n2: String bikeType;\n3: int chainGear;\n4: int rearCogs;\n5: int currentGearFront;\n6: int currentGearRear;\n7: }\nConstants\n6\nConstants are useful for setting global states in a method or object, or for giving meaningful\nnames to object-wide values that will never change. In Java, you can create constants only for\ninstance or class variables, not for local variables.\nNEW* A constant variable or constant is a variable whose value never changes (which may seem\nTERM strange given the meaning of the word \u201cvariable\u201d).\nTo declare a constant, use the final keyword before the variable declaration and include an\ninitial value for that variable:\nfinal float pi = 3.141592;\nfinal boolean debug = false;\nfinal int maxsize = 40000;\n97\n030-4s CH06.i 97 1\/29\/96, 9:06 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 6 LP#3 MTWRFSS\nDDAAYY\n6 Creating Classes and Applications in Java\nTechnical Note: The only way to define constants in Java is by using the final\nkeyword. Neither the C and C++ constructs for #define nor const are available in\nJava.\nConstants can be useful for naming various states of an object and then testing for those states.\nFor example, suppose you have a test label that can be aligned left, right, or center. You can define\nthose values as constant integers:\nfinal int LEFT = 0;\nfinal int RIGHT = 1;\nfinal int CENTER = 2;\nThe variable alignment is then also declared as an int:\nint alignment;\nThen, later on in the body of a method definition, you can either set the alignment:\nthis.alignment = CENTER;\nor test for a given alignment:\nswitch (this.alignment) {\ncase LEFT: \/\/ deal with left alignment\n...\nbreak;\ncase RIGHT: \/\/ deal with right alignment\n...\nbreak;\ncase CENTER: \/\/ deal with center alignment\n...\nbreak;\n}\nClass Variables\nAs you learned in previous lessons, class variables are global to a class and to all that class\u2019s\ninstances. You can think of class variables as being even more global than instance variables. Class\nvariables are good for communicating between different objects with the same class, or for\nkeeping track of global states among a set of objects.\nTo declare a class variable, use the static keyword in the class declaration:\nstatic int sum;\nstatic final int maxObjects = 10;\n98\n030-4s CH06.i 98 1\/29\/96, 9:06 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 6 LP#3 Sams.net Learning\nCenter\nabcd\nCreating Methods\nMethods, as you learned on Day 2, define an object\u2019s behavior\u2014what happens when that object\nis created and the various operations that object can perform during its lifetime. In this section,\nyou\u2019ll get a basic introduction to method definition and how methods work; tomorrow, you\u2019ll\ngo into more detail about advanced things you can do with methods.\nDefining Methods\nMethod definitions have four basic parts:\nnn The name of the method\nnn The type of object or base type this method returns\nnn A list of parameters\nnn The body of the method\nNEW* The method\u2019s signature is a combination of the name of the method, the type of object or\nTERM base type this method returns, and a list of parameters.\nNote: To keep things simple today, I\u2019ve left off two optional parts of the method\ndefinition: an access qualifier such as public or private, and the throws keyword,\nwhich indicates the exceptions a method can throw. You\u2019ll learn about these parts\nof a method definition in Week 3.\nIn other languages, the name of the method (or function, subroutine, or procedure) is enough\nto distinguish it from other methods in the program. In Java, you can have different methods\n6\nthat have the same name but a different return type or argument list. This is called method\noverloading, and you\u2019ll learn more about it tomorrow.\nHere\u2019s what a basic method definition looks like:\nreturntype methodname (type1 arg1, type2 arg2, type3 arg3..) {\n...\n}\nThe returntype is the primitive type or class of the of the value this method returns. It can be\none of the primitive types, a class name, or void if the method does not return a value at all.\nNote that if this method returns an array object, the array brackets can go either after the return\ntype or after the parameter list; because the former way is considerably easier to read, it is used\nin the examples today (and throughout this book):\nint[] makeRange (int lower, int upper) {...}\n99\n030-4s CH06.i 99 1\/29\/96, 9:06 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 6 LP#3 MTWRFSS\nDDAAYY\n6 Creating Classes and Applications in Java\nThe method\u2019s parameter list is a set of variable declarations, separated by commas, inside\nparentheses. These parameters become local variables in the body of the method, whose values\nare the objects or values of primitives passed in when the method is called.\nInside the body of the method you can have statements, expressions, method calls to other\nobjects, conditionals, loops, and so on\u2014everything you\u2019ve learned about in the previous lessons.\nIf your method has a real return type (that is, it has not been declared to return void), somewhere\ninside the body of the method you need to return a value. Use the return keyword to do this.\nListing 6.2 shows an example of a class that defines a makeRange() method. makeRange() takes\ntwo integers\u2014a lower bound and an upper bound\u2014and creates an array that contains all the\nintegers between those two boundaries (inclusive).\nType\nListing 6.2. The RangeClass class.\n1: class RangeClass {\n2: int[] makeRange (int lower, int upper) {\n3: int arr[] = new int[ (upper - lower) + 1 ];\n4:\n5: for (int i = 0; i < arr.length; i++) {\n6: arr[i] = lower++;\n7: }\n8: return arr;\n9: }\n10:\n11: public static void main (String arg[]) {\n12: int theArray[];\n13: RangeClass theRange = new RangeClass();\n14:\n15: theArray = theRange.makeRange(1,10);\n16: System.out.print(\u201cThe array: [ \u201c);\n17: for (int i = 0; i < theArray.length; i++) {\n18: System.out.print(theArray[i] + \u201c \u201c);\n19: }\n20: System.out.println(\u201c]\u201d);\n21: }\n22:\n23: }\nHere\u2019s the output of this program:\nOutput The array: [ 1 2 3 4 5 6 7 8 9 10 ]\nAnalysis The main() method in this class tests the makeRange() method by creating a range where\nthe lower and upper boundaries of the range are 1 and 10, respectively (see line 6), and then\nuses a for loop to print the values of the new array.\n100\n030-4s CH06.i 100 1\/29\/96, 9:07 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 6 LP#3 Sams.net Learning\nCenter\nabcd\nThe this Keyword\nSometimes, in the body of a method definition, you may want to refer to the current object\u2014\nfor example, to refer to that object\u2019s instance variables or to pass the current object as an\nargument to another method. To refer to the current object in these cases, you can use the this\nkeyword. this refers to the current object, and you can use it anywhere that object might\nappear\u2014in dot notation to refer to the object\u2019s instance variables, as an argument to a method,\nas the return value for the current method, and so on. Here\u2019s an example:\nt = this.x \/\/ the x instance variable for this object\nthis.myMethod(this) \/\/ call the mymethod method, defined in\n\/\/ this class, and pass it the current\n\/\/ object\nreturn this; \/\/ return the current object\nIn many cases, however, you may be able to omit the this keyword. You can refer to both\ninstance variables and method calls defined in the current class simply by name; the this is\nimplicit in those references. So, the first two examples could be written like this:\nt = x \/\/ the x instance variable for this object\nmyMethod(this) \/\/ call the myMethod method, defined in this\n\/\/ class\nNote: Omitting the this keyword for instance variables depends on whether there\nare no variables of the same name declared in the local scope. See the next section\nfor details.\nKeep in mind that because this is a reference to the current instance of a class, it makes sense\nto use it only inside the body of an instance method definition. Class methods, that is, methods\ndeclared with the static keyword, cannot use this.\n6\nVariable Scope and Method Definitions\nWhen you refer to a variable within your method definitions, Java checks for a definition of that\nvariable first in the current scope (which may be a block), then in the outer scopes up to the\ncurrent method definition. If that variable is not a local variable, Java then checks for a definition\nof that variable as an instance variable in the current class, and then, finally, in each superclass\nin turn.\nBecause of the way Java checks for the scope of a given variable, it is possible for you to create\na variable in a lower scope such that a definition of that same variable \u201chides\u201d the original value\nof that variable. This can introduce subtle and confusing bugs into your code.\n101\n030-4s CH06.i 101 1\/29\/96, 9:07 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 6 LP#3 MTWRFSS\nDDAAYY\n6 Creating Classes and Applications in Java\nFor example, note this small Java program:\nclass ScopeTest {\nint test = 10;\nvoid printTest () {\nint test = 20;\nSystem.out.println(\u201ctest = \u201c + test);\n}\n}\nIn this class, you have two variables with the same name and definition: the first, an instance\nvariable, has the name test and is initialized to the value 10. The second is a local variable with\nthe same name, but with the value 20. Because the local variable hides the instance variable, the\nprintln() method will print that test is 20.\nYou can get around this particular instance by using this.test to refer to the instance variable,\nand just test to refer to the local variable.\nA more insidious example of this occurs when you redefine a variable in a subclass that already\noccurs in a superclass. This can create very insidious bugs in your code\u2014for example, you may\ncall methods that are intended to change the value of an instance variable, but that change the\nwrong one. Another bug might occur when you cast an object from one class to another\u2014the\nvalue of your instance variable may mysteriously change (because it was getting that value from\nthe superclass instead of from your class). The best way to avoid this behavior is to make sure\nthat, when you define variables in a subclass, you\u2019re aware of the variables in each of that class\u2019s\nsuperclasses and you don\u2019t duplicate what is already there.\nPassing Arguments to Methods\nWhen you call a method with object parameters, the variables you pass into the body of the\nmethod are passed by reference, which means that whatever you do to those objects inside the\nmethod affects the original objects as well. This includes arrays and all the objects that arrays\ncontain; when you pass an array into a method and modify its contents, the original array is\naffected. (Note that primitive types are passed by value.)\nHere\u2019s an example to demonstrate how this works. First, you have a simple class definition,\nwhich includes a single method called OneToZero() (see Listing 6.3).\nType\nListing 6.3. The PassByReference class.\n1: class PassByReference {\n2: int OnetoZero (int arg[]) {\n3: int count = 0;\n4:\n5: for (int i = 0; i < arg.length; i++) {\n6: if (arg[i] == 1) {\n102\n030-4s CH06.i 102 1\/29\/96, 9:07 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 6 LP#3 Sams.net Learning\nCenter\nabcd\n7: count++;\n8: arg[i] = 0;\n9: }\n10: }\n11: return count;\n12: }\n13: }\nThe OnetoZero() method does two things:\nnn It counts the number of ones in the array and returns that value.\nnn If it finds a one, it substitutes a zero in its place in the array.\nListing 6.4 shows the main() method for the PassByReference class, which tests the OnetoZero()\nmethod:\nType\nListing 6.4. The main() method in PassByReference.\n1: public static void main (String arg[]) {\n2: int arr[] = { 1, 3, 4, 5, 1, 1, 7 };\n3: PassByReference test = new PassByReference();\n4: int numOnes;\n5:\n6: System.out.print(\u201cValues of the array: [ \u201c);\n7: for (int i = 0; i < arr.length; i++) {\n8: System.out.print(arr[i] + \u201c \u201c);\n9: }\n10: System.out.println(\u201c]\u201d);\n11:\n12: numOnes = test.OnetoZero(arr);\n13: System.out.println(\u201cNumber of Ones = \u201c + numOnes);\n14: System.out.print(\u201cNew values of the array: [ \u201c);\n15: for (int i = 0; i < arr.length; i++) {\n16: System.out.print(arr[i] + \u201c \u201c);\n17: }\n18: System.out.println(\u201c]\u201d); 6\n19: }\nHere is the output of this program:\nOutput Values of the array: [ 1 3 4 5 1 1 7 ]\nNumber of Ones = 3\nNew values of the array: [ 0 3 4 5 0 0 7 ]\nAnalysis Let\u2019s go over the main() method line by line so that you can see what is going on.\nLines 2 through 4 set up the initial variables for this example. The first one is an array of integers;\nthe second one is an instance of the class PassByReference, which is stored in the variable test.\nThe third is a simple integer to hold the number of ones in the array.\n103\n030-4s CH06.i 103 1\/29\/96, 9:07 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 6 LP#3 MTWRFSS\nDDAAYY\n6 Creating Classes and Applications in Java\nLines 6 through 11 print out the initial values of the array; you can see the output of these lines\nin the first line of the output.\nLine 12 is where the real work takes place; this is where you call the OnetoZero() method, defined\nin the object test, and pass it the array stored in arr. This method returns the number of ones\nin the array, which you\u2019ll then assign to the variable numOnes.\nGot it so far? Line 13 prints out the number of ones, that is, the value you got back from the\nOnetoZero() method. It returns three, as you would expect.\nThe last bunch of lines print out the array values. Because a reference to the array object is passed\nto the method, changing the array inside that method changes that original copy of the array.\nPrinting out the values in lines 14 through 18 proves this\u2014that last line of output shows that\nall the 1s in the array have been changed to 0s.\nClass Methods\nJust as you have class and instance variables, you also have class and instance methods, and the\ndifference between the two types of methods are analogous. Class methods are global to the class\nitself and available to any other classes or objects. Therefore, class methods can be used anywhere\nregardless of whether an instance of the class exists or not.\nFor example, the Java class libraries include a class called Math. The Math class defines a whole\nset of math operations that can be used in any program with the various number types:\nfloat root = Math.sqrt(453.0);\nSystem.out.print(\u201cThe larger of x and y is\u201d + Math.max(x,y));\nTo define class methods, use the static keyword in front of the method definition, just as you\nwould create a class variable. For example, that max class method might have a signature like this:\nstatic int max (int arg1, int arg2) { ... }\nIn a similar example, Java supplies \u201cwrapper\u201d classes for each of the base types\u2014for example,\nclasses for Integer, Float, and Boolean. Using class methods defined in those classes, you can\nconvert to and from objects and base types. For example, the parseInt() class method in the\nInteger class takes a string and a radix (base) and returns the value of that string as an integer:\nint count = Integer.parseInt(\u201c42\u201d, 10) \/\/ returns 42\nMost methods that operate on a particular object, or that affect that object, should be defined\nas instance methods. Methods that provide some general utility but do not directly affect an\ninstance of that class are better declared as class methods.\n104\n030-4s CH06.i 104 1\/29\/96, 9:08 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 6 LP#3 Sams.net Learning\nCenter\nabcd\nCreating Java Applications\nNow that you know how to create classes, objects, and class and instance variables and methods,\nall that\u2019s left is to put it together into something that can actually run\u2014in other words, to create\na Java application.\nApplications, to refresh your memory, are Java programs that run on their own. Applications\nare different from applets, which require HotJava or a Java-capable browser to view them. Much\nof what you\u2019ve been using up to this point have been Java applications; next week you\u2019ll dive into\nhow to create applets. (Applets require a bit more background in order to get them to interact\nwith the browser and draw and update with the graphics system. You\u2019ll learn all of this next\nweek.)\nA Java application consists of one of more classes and can be as large or as small as you want it\nto be. HotJava is an example of a Java application. The only thing you need to make a Java\napplication run is one class that serves as the \u201cjumping-off\u201d point for the rest of your Java\nprogram. If your program is small enough, it may need only the one class.\nThe jumping-off class for your program needs one thing: a main() method. When you run your\ncompiled Java class (using the Java interpreter), the main() method is the first thing that gets\ncalled. None of this should be much of a surprise to you at this point; you\u2019ve been creating Java\napplications with main() methods all along.\nThe signature for the main() method always looks like this:\npublic static void main (String arg[]) {...}\nHere\u2019s a run-down of the parts of the main() method:\nnn public means that this method is available to other classes and objects. The main()\nmethod must be declared public. You\u2019ll learn more about public and private\nmethods in Week 3. 6\nnn static means that this is a class method.\nnn void means the main() method doesn\u2019t return anything.\nnn main() takes one parameter: an array of strings. This argument is used for command-\nline arguments, which you\u2019ll learn about in the next section.\nThe body of the main() method contains any code you need to get your application started:\ninitial variables or creating instances of any classes you may have declared.\nWhen Java executes the main() method, keep in mind that main() is a class method\u2014the class\nthat holds it is not automatically instantiated when your program runs. If you want to treat that\nclass as an object, you have to instantiate it in the main() method yourself (all the examples up\nto this point have done this).\n105\n030-4s CH06.i 105 1\/29\/96, 9:08 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 6 LP#3 MTWRFSS\nDDAAYY\n6 Creating Classes and Applications in Java\nJava Applications and Command-Line\nArguments\nBecause Java applications are stand-alone programs, it\u2019s useful to be able to pass arguments or\noptions to that program to determine how the program is going to run, or to enable a generic\nprogram to operate on many different kinds of input. Command-line arguments can be used\nfor many different purposes\u2014for example, to turn on debugging input, to indicate a filename\nto read or write from, or for any other information that you might want your Java program to\nknow.\nPassing Arguments to Java Programs\nTo pass arguments to a Java program, you merely append them to the command line when you\nrun your Java program:\njava Myprogram argumentOne 2 three\nOn this command line, you have three arguments: argumentOne, the number 2, and three. Note\nthat a space separates arguments, so this command line produces three arguments:\njava myprogram Java is cool\nTo group arguments, surround them with double-quotes. This command line produces one\nargument:\njava myprogram \u201cJava is cool\u201d\nThe double-quotes are stripped off before the argument gets to your Java program.\nHandling Arguments in Your Java Program\nHow does Java handle arguments? It stores them in an array of strings, which is passed to the\nmain() method in your Java program. Remember the signature for main():\npublic static void main (String arg[]) {...}\nHere, arg is the name of the array of strings that contains the list of arguments. You can actually\ncall it anything you want; argv is common (after the array of the same name from C and Unix\nshell scripting).\nInside your main() method, you can then handle the arguments your program was given by\niterating over the array of arguments and handling those arguments any way you want. For\nexample, Listing 6.5 is a really simple class that prints out the arguments it gets, one per line.\n106\n030-4s CH06.i 106 1\/29\/96, 9:08 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 6 LP#3 Sams.net Learning\nCenter\nabcd\nType\nListing 6.5. The EchoArgs class.\n1: class EchoArgs {\n2: public static void main(String args[]) {\n3: for (int i = 0; i < args.length; i++) {\n4: System.out.println(\u201cArgument \u201c + i + \u201c: \u201c + args[i]);\n5: }\n6: }\n7: }\nThe following is some sample input and output from this program:\njava EchoArgs 1 2 3 jump\nOutput Argument 0: 1\nArgument 1: 2\nArgument 2: 3\nArgument 3: jump\njava EchoArgs \u201cfoo bar\u201d zap twaddle 5\nOutput Argument 0: foo bar\nArgument 1: zap\nArgument 2: twaddle\nArgument 3: 5\nNote how the arguments are grouped in the listing; putting quotes around foo bar causes that\nargument to be treated as one unit inside the argument array.\nTechnical Note: The array of arguments in Java is not analogous to argv in C and\nUnix. In particular, arg[0], the first element in the array of arguments, is the first\ncommand-line argument after the name of the class\u2014not the name of the program\nas it would be in C. Be careful of this as you write your Java programs. 6\nAn important thing to note about the arguments you pass into a Java program is that those\narguments will be stored in an array of strings. This means that any arguments you pass to your\nJava program will be converted to strings so they can be stored in the argument array. To treat\nthem as non-strings, you\u2019ll have to convert them to whatever type you want them to be.\nFor example, suppose you have a very simple Java program called SumAverage that takes any\nnumber of numeric arguments and returns the sum and the average of those arguments. Listing\n6.6 shows a first pass at this program.\n107\n030-4s CH06.i 107 1\/29\/96, 9:08 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 6 LP#3 MTWRFSS\nDDAAYY\n6 Creating Classes and Applications in Java\nType\nListing 6.6. First try at the SumAverage class.\n1: class SumAverage {\n2: public static void main (String args[]) {\n3: int sum = 0;\n4:\n5: for (int i = 0; i < args.length; i++) {\n6: sum += args[i];\n7: }\n8:\n9: System.out.println(\u201cSum is: \u201c + sum);\n10: System.out.println(\u201cAverage is: \u201c +\n11: (float)sum \/ (float)args.length);\n12: }\n13: }\nAnalysis At first glance, this program seems rather straightforward\u2014a for loop iterates over the array\nof arguments, summing them, and then the sum and the average are printed out as the last\nstep.\nWhat happens when you try and compile this? You get the following error:\nSumAverage.java:9: Incompatible type for +=. Can\u2019t convert java.lang.String to int.\nsum += args[i];\nYou get this error because the argument array is an array of strings. Even though you passed\nintegers into the program from the command line, those integers were converted to strings\nbefore they were stored in the array. To be able to sum those integers, you have to convert them\nback from strings to integers. There\u2019s a class method for the Integer class, called parseInt, that\ndoes just this. If you change line 7 to use that method, everything works just fine:\nsum += Integer.parseInt(args[i]);\nNow, compiling the program produces no errors and running it with various arguments returns\nthe expected results. For example, java SumAverage 1 2 3 returns the following output:\nOutput Sum is: 6\nAverage is: 2\nSummary\nToday, you put together everything you\u2019ve come across in the preceding days of this week about\nhow to create Java classes and use them in Java applications. This included the following:\nnn Instance and class variables, which hold the attributes of the class and its instances.\nYou learned how to declare them, how they are different from regular local variables,\nand how to declare constants.\n108\n030-4s CH06.i 108 1\/29\/96, 9:09 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 6 LP#3 Sams.net Learning\nCenter\nabcd\nnn Instance and class methods, which define a class\u2019s behavior. You learned how to define\nmethods, including the parts of a method\u2019s signature, how to return values from a\nmethod, how arguments are passed in and out of methods, and the this keyword to\nrefer to the current object\nnn Java applications\u2014all about the main() method and how it works as well as how to\npass arguments into a Java application from a command line.\nQ&A\nQ I tried creating a constant variable inside a method, and I got a compiler error\nwhen I tried it. What was I doing wrong?\nA You can create only constant (final) class or instance variables; local variables cannot\nbe constant.\nQ static and final are not exactly the most descriptive words for creating class\nvariables, class methods, and constants. Why not use class and const?\nA static comes from Java\u2019s C++ heritage; C++ uses the static keyword to retain\nmemory for class variables and methods (and, in fact, they aren\u2019t called class methods\nand variables in C++: static member functions and variables are more common\nterms).\nfinal, however, is new. final is used in a more general way for classes and methods to\nindicate that those things cannot be subclassed or overridden. Using the final\nkeyword for variables is consistent with that behavior. final variables are not quite the\nsame as constant variables in C++, which is why the const keyword is not used.\nQ In my class, I have an instance variable called name. I also have a local variable\ncalled name in a method, which, because of variable scope, gets hidden by the\nlocal variable. Is there any way to get hold of the instance variable\u2019s value?\n6\nA The easiest way is not to name your local variables the same names as your instance\nvariables. If you feel you must, you can use this.name to refer to the instance variable\nand name to refer to the local variable.\nQ I want to pass command-line arguments to an applet. How do I do this?\nA You\u2019re writing applets already? Been skipping ahead, have you? The answer is that you\nuse HTML attributes to pass arguments to an applet, not the command line (you\ndon\u2019t have a command line for applets). You\u2019ll learn how to do this next week.\nQ I wrote a program to take four arguments, but if I give it too few arguments, it\ncrashes with a run-time error.\nA Testing for the number and type of arguments your program expects is up to you in\nyour Java program; Java won\u2019t do it for you. If your program requires four arguments,\ntest that you have indeed been given four arguments, and return an error message if\nyou haven\u2019t.\n109\n030-4s CH06.i 109 1\/29\/96, 9:09 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 6 LP#3 Sams.net Learning\nCenter\nabcd\n7\n7\nS\nS\nWEEK\nF 1\nR\nW\nMore About\nT\nMethods\nM\nby Laura Lemay 7\n111\n030-4s CH07.i 111 1\/29\/96, 9:11 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 7 LP#3 MTWRFSS\nDDAAYY\n7 More About Methods\nMethods are arguably the most important part of any object-oriented language. Whereas classes\nand objects provide the framework, and class and instance variables provide a way of holding\nthat class or object\u2019s attributes and state, it is the methods that actually provide an object\u2019s\nbehavior and define how that object interacts with other objects in the system.\nYesterday, you learned a little about defining methods. With what you learned yesterday, you\ncould create lots of Java programs, but you\u2019d be missing some of the features of methods that\nmake them really powerful, that make your objects and classes more efficient and easier to\nunderstand. Today, you\u2019ll learn about these additional features, including the following:\nnn Overloading methods, sometimes called creating polymorphic methods\u2014that is,\ncreating methods with multiple signatures and definitions but with the same name\nnn Creating constructor methods\u2014methods that enable you to initialize objects to set up\nan initial state in the system when an object is created\nnn Overriding methods\u2014creating a different definition for a method that has been\ndefined in a superclass\nnn Finalizer methods\u2014a way for an object to clean up after itself before it is removed\nfrom the system\nCreating Methods with the Same\nName, Different Arguments\nYesterday, you learned how to create methods with a single name and a single signature.\nMethods in Java can also be overloaded\u2014that is, you can create methods that have the same\nname, but different signatures and different definitions. Method overloading enables instances\nof your class to have a simpler interface to other objects (no need for entirely different methods\nthat do essentially the same thing) and to behave differently based on the input to that method.\nWhen you call a method in an object, Java matches up the method name and the number and\ntype of arguments to choose which method definition to execute.\nTo create an overloaded method, all you need to do is create several different method definitions\nin your class, all with the same name, but with different parameter lists (either in number or type\nof arguments) and with different bodies. Java can understand method overloading as long as\neach parameter list is unique for each method name.\nNote that Java differentiates overloaded methods with the same name, based on the number and\ntype of parameters to that method, not on its return type. That is, if you try to create two methods\nwith the same name, same parameter list, but different return types, you\u2019ll get a compiler error.\nThe variable names you choose for each parameter to the method are irrelevant\u2014all that matters\nis the number and the type.\n112\n030-4s CH07.i 112 1\/29\/96, 9:11 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 7 LP#3 Sams.net Learning\nCenter\nabcd\nHere\u2019s an example of creating an overloaded method. Listing 7.1 shows a simple class definition\nfor a class called MyRect, which defines a rectangular shape. The MyRect class has four instance\nvariables to define the upper left and lower right corners of the rectangle: x1, y1, x2, and y2.\nNote: Why did I call it MyRect? Java\u2019s awt package has a class called Rectangle that\nimplements much of this same behavior. I called this class MyRect to prevent\nconfusion between the two classes.\nType\nListing 7.1. The MyRect class.\nclass MyRect {\nint x1 = 0;\nint y1 = 0;\nint x2 = 0;\nint y2 = 0;\n}\nWhen a new instance of the myRect class is initially created, all its instance variables are initialized\nto 0. Let\u2019s define a buildRect() method that takes four integer arguments and \u201cresizes\u201d the\nrectangle to have the appropriate values for its corners, returning the resulting rectangle object\n(note that because the arguments have the same names as the instance variables, you have to\nmake sure to use this to refer to them):\nMyRect buildRect(int x1, int y1, int x2, int y2) {\nthis.x1 = x1;\nthis.y1 = y1;\nthis.x2 = x2;\nthis.y2 = y2;\nreturn this;\n}\nWhat if you want to define a rectangle\u2019s dimensions in a different way\u2014for example, by using\nPoint objects rather than individual coordinates? You can overload buildRect() so that its\nparameter list takes two Point objects (note that you\u2019ll need to import the Point class at the top\nof your source file so Java can find it):\n7\nMyRect buildRect(Point topLeft, Point bottomRight) {\nx1 = topLeft.x;\ny1 = topLeft.y;\nx2 = bottomRight.x;\ny2 = bottomRight.y;\nreturn this;\n}\n113\n030-4s CH07.i 113 1\/29\/96, 9:12 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 7 LP#3 MTWRFSS\nDDAAYY\n7 More About Methods\nPerhaps you want to define the rectangle using a top corner and a width and height. Just create\na different definition for buildRect():\nMyRect buildRect(Point topLeft, int w, int h) {\nx1 = topLeft.x;\ny1 = topLeft.y;\nx2 = (x1 + w);\ny2 = (y1 + h);\nreturn this;\n}\nTo finish up this example, let\u2019s create a method to print out the rectangle\u2019s coordinates, and a\nmain() method to test it all (just to prove that this does indeed work). Listing 7.2 shows the\ncompleted class definition with all its methods.\nType\nListing 7.2. The complete MyRect class.\nimport java.awt.Point;\nclass MyRect {\nint x1 = 0;\nint y1 = 0;\nint x2 = 0;\nint y2 = 0;\nMyRect buildRect(int x1, int y1, int x2, int y2) {\nthis.x1 = x1;\nthis.y1 = y1;\nthis.x2 = x2;\nthis.y2 = y2;\nreturn this;\n}\nMyRect buildRect(Point topLeft, Point bottomRight) {\nx1 = topLeft.x;\ny1 = topLeft.y;\nx2 = bottomRight.x;\ny2 = bottomRight.y;\nreturn this;\n}\nMyRect buildRect(Point topLeft, int w, int h) {\nx1 = topLeft.x;\ny1 = topLeft.y;\nx2 = (x1 + w);\ny2 = (y1 + h);\nreturn this;\n}\nvoid printRect(){\nSystem.out.print(\u201cMyRect: <\u201c + x1 + \u201c, \u201c + y1);\nSystem.out.println(\u201c, \u201c + x2 + \u201c, \u201c + y2 + \u201c>\u201d);\n}\n114\n030-4s CH07.i 114 1\/29\/96, 9:12 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 7 LP#3 Sams.net Learning\nCenter\nabcd\npublic static void main (String args[]) {\nMyRect rect = new MyRect();\nSystem.out.println(\u201cCalling buildRect with coordinates 25,25 50,50:\u201d);\nrect.buildRect(25, 25, 50, 50);\nrect.printRect();\nSystem.out.println(\u201c----------\u201d);\nSystem.out.println(\u201cCalling buildRect w\/points (10,10), (20,20):\u201d);\nrect.buildRect(new Point(10,10), new Point(20,20));\nrect.printRect();\nSystem.out.println(\u201c----------\u201d);\nSystem.out.print(\u201cCalling buildRect w\/1 point (10,10),\u201d);\nSystem.out.println(\u201c width (50) and height (50)\u201d);\nrect.buildRect(new Point(10,10), 50, 50);\nrect.printRect();\nSystem.out.println(\u201c----------\u201d);\n}\n}\nHere\u2019s the output of this Java program:\nOutput Calling buildRect with coordinates 25,25 50,50:\nMyRect: <25, 25, 50, 50>\n----------\nCalling buildRect w\/points (10,10), (20,20):\nMyRect: <10, 10, 20, 20>\n----------\nCalling buildRect w\/1 point (10,10), width (50) and height (50)\nMyRect: <10, 10, 60, 60>\n----------\nAs you can see from this example, all the buildRect() methods work based on the arguments\nwith which they are called. You can define as many versions of a method as you need to in your\nown classes to implement the behavior you need for that class.\nConstructor Methods\nIn addition to regular methods, you can also define constructor methods in your class definition.\n7\nNEW* A constructor method is a special kind of method that determines how an object is initialized\nTERM when it\u2019s created.\nUnlike regular methods, you can\u2019t call a constructor method by calling it directly; instead,\nconstructor methods are called by Java automatically. Here\u2019s how it works: when you use new\nto create a new instance of a class, Java does three things:\nnn Allocates memory for the object\n115\n030-4s CH07.i 115 1\/29\/96, 9:12 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 7 LP#3 MTWRFSS\nDDAAYY\n7 More About Methods\nnn Initializes that object\u2019s instance variables, either to their initial values or to a default (0\nfor numbers, null for objects, false for booleans)\nnn Calls the class\u2019s constructor method (which may be one of several methods)\nIf a class doesn\u2019t have any special constructor methods defined, you\u2019ll still end up with an object,\nbut you\u2019ll have to set its instance variables or call other methods that object needs to initialize\nitself to that object afterward. All the examples you\u2019ve created up to this point have behaved like\nthis.\nBy defining constructor methods in your own classes, you can set initial values of instance\nvariables, call methods based on those variables or call methods on other objects, or calculate\ninitial properties of your object. You can also overload constructors, as you would regular\nmethods, to create an object that has specific properties based on the arguments you give to new.\nBasic Constructors\nConstructors look a lot like regular methods, with two basic differences:\nnn Constructors always have the same name as the class.\nnn Constructors don\u2019t have a return type.\nFor example, Listing 7.3 shows a simple class called Person, with a constructor that initializes\nits instance variables based on the arguments to new. The class also includes a method for the\nobject to introduce itself, and a main() method to test each of these things.\nType\nListing 7.3. The Person class.\nclass Person {\nString name;\nint age;\nPerson(String n, int a) {\nname = n;\nage = a;\n}\nvoid printPerson() {\nSystem.out.print(\u201cHi, my name is \u201c + name);\nSystem.out.println(\u201c. I am \u201c + age + \u201c years old.\u201d);\n}\npublic static void main (String args[]) {\nPerson p;\np = new Person(\u201cLaura\u201d, 20);\np.printPerson();\nSystem.out.println(\u201c--------\u201d);\n116\n030-4s CH07.i 116 1\/29\/96, 9:13 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 7 LP#3 Sams.net Learning\nCenter\nabcd\np = new Person(\u201cTommy\u201d, 3);\np.printPerson();\nSystem.out.println(\u201c--------\u201d);\n}\n}\nHere\u2019s the output for this example program:\nOutput Hi, my name is Laura. I am 20 years old.\n--------\nHi, my name is Tommy. I am 3 years old.\n--------\nCalling Another Constructor\nSome constructors you write may be a superset of another constructor defined in your class; that\nis, they might have the same behavior plus a little bit more. Rather than duplicating identical\nbehavior in multiple constructor methods in your class, it makes sense to be able to just call that\nfirst constructor from inside the body of the second constructor. Java provides a special syntax\nfor doing this. To call a constructor defined on the current class, use this form:\nthis(arg1, arg2, arg3...);\nThe arguments to this are, of course, the arguments to the constructor.\nOverloading Constructors\nLike regular methods, constructors can also take varying numbers and types of parameters,\nenabling you to create your objects with exactly the properties you want it to have, or for it to\nbe able to calculate properties from different kinds of input.\nFor example, the buildRect() methods you defined in the MyRect class earlier today would make\nexcellent constructors, because what they\u2019re doing is initializing an object\u2019s instance variables to\nthe appropriate objects. So, instead of the original buildRect() method you had defined (which\ntook four parameters for the coordinates of the corners), you can create a constructor instead.\nListing 7.4 shows a new class, called MyRect2, that has all the same functionality of the original\nMyRect, except with overloaded constructor methods instead of the buildRect() method.\n7\nType\nListing 7.4. The MyRect2 class (with constructors).\nimport java.awt.Point;\nclass MyRect2 {\nint x1 = 0;\nint y1 = 0;\ncontinues\n117\n030-4s CH07.i 117 1\/29\/96, 9:13 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 7 LP#3 MTWRFSS\nDDAAYY\n7 More About Methods\nListing 7.4. continued\nint x2 = 0;\nint y2 = 0;\nMyRect2(int x1, int y1, int x2, int y2) {\nthis.x1 = x1;\nthis.y1 = y1;\nthis.x2 = x2;\nthis.y2 = y2;\n}\nMyRect2(Point topLeft, Point bottomRight) {\nx1 = topLeft.x;\ny1 = topLeft.y;\nx2 = bottomRight.x;\ny2 = bottomRight.y;\n}\nMyRect2(Point topLeft, int w, int h) {\nx1 = topLeft.x;\ny1 = topLeft.y;\nx2 = (x1 + w);\ny2 = (y1 + h);\n}\nvoid printRect(){\nSystem.out.print(\u201cMyRect: <\u201c + x1 + \u201c, \u201c + y1);\nSystem.out.println(\u201c, \u201c + x2 + \u201c, \u201c + y2 + \u201c>\u201d);\n}\npublic static void main (String args[]) {\nMyRect2 rect;\nSystem.out.println(\u201cCalling MyRect2 with coordinates 25,25 50,50:\u201d);\nrect = new MyRect2(25, 25, 50,50);\nrect.printRect();\nSystem.out.println(\u201c----------\u201d);\nSystem.out.println(\u201cCalling buildRect w\/points (10,10), (20,20):\u201d);\nrect= new MyRect2(new Point(10,10), new Point(20,20));\nrect.printRect();\nSystem.out.println(\u201c----------\u201d);\nSystem.out.print(\u201cCalling buildRect w\/1 point (10,10),\u201d);\nSystem.out.println(\u201c width (50) and height (50)\u201d);\nrect = new MyRect2(new Point(10,10), 50, 50);\nrect.printRect();\nSystem.out.println(\u201c----------\u201d);\n}\n}\nHere\u2019s the output for this example program (it\u2019s the same output from the previous example;\nonly the code to produce it has changed):\n118\n030-4s CH07.i 118 1\/29\/96, 9:13 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 7 LP#3 Sams.net Learning\nCenter\nabcd\nOutput Calling MyRect2 with coordinates 25,25 50,50:\nMyRect: <25, 25, 50, 50>\n----------\nCalling buildRect w\/points (10,10), (20,20):\nMyRect: <10, 10, 20, 20>\n----------\nCalling buildRect w\/1 point (10,10), width (50) and height (50)\nMyRect: <10, 10, 60, 60>\n----------\nOverriding Methods\nWhen you class a method in an object, Java looks for that method definition in the correct object,\nand if it doesn\u2019t find one, it passes the method call up the class hierarchy until a method\ndefinition is found. Method inheritance enables you to define and use methods repeatedly in\nsubclasses without having to duplicate the code itself.\nHowever, there may be times when you want an object to respond to the same methods but have\ndifferent behavior when that method is called. In this case, you can override that method.\nOverriding a method involves defining a method in a subclass that has the same signature as a\nmethod in a superclass. Then, when that method is called, the method in the subclass is found\nand executed instead of the one in the superclass.\nCreating Methods\nthat Override Existing Methods\nTo override a method, all you have to do is create a method in your superclass that has the same\nsignature (name, return type, and parameter list) as a method defined by one of your class\u2019s\nsuperclasses. Because Java executes the first method definition it finds that matches the\nsignature, this effectively \u201chides\u201d the original method definition. Here\u2019s a simple example;\nListing 7.5 shows a simple class with a method called printMe(), which prints out the name of\nthe class and the values of its instance variables.\nType\nListing 7.5. The PrintClass class.\nclass PrintClass {\nint x = 0; 7\nint y = 1;\nvoid printMe() {\nSystem.out.println(\u201cX is \u201c + x + \u201c, Y is \u201c + y);\nSystem.out.println(\u201cI am an instance of the class \u201c +\nthis.getClass().getName());\n}\n}\n119\n030-4s CH07.i 119 1\/29\/96, 9:14 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 7 LP#3 MTWRFSS\nDDAAYY\n7 More About Methods\nListing 7.6 shows a class called PrintSubClass that is a subclass of (extends) PrintClass. The\nonly difference between PrintClass and PrintSubClass is that the latter has a z instance variable.\nType\nListing 7.6. The PrintSubClass class.\nclass PrintSubClass extends PrintClass {\nint z = 3;\npublic static void main (String args[]) {\nPrintSubClass obj = new PrintSubClass();\nobj.printMe();\n}\n}\nHere\u2019s the output from PrintSubClass:\nOutput X is 0, Y is 1\nI am an instance of the class PrintSubClass\nAnalysis In the main() method of PrintSubClass, you create a PrintSubClass object and call the\nprintMe() method. Note that PrintSubClass doesn\u2019t define this method, so Java looks for\nit in each of PrintSubClass\u2019s superclasses\u2014and finds it, in this case, in PrintClass.\nUnfortunately, because printMe() is still defined in PrintClass, it doesn\u2019t print the z instance\nvariable.\nNow, let\u2019s create a third class. PrintSubClass2 is nearly identical to PrintSubClass, but you\noverride the printMe() method to include the z variable. Listing 7.7 shows this class.\nType\nListing 7.7. The PrintSubClass2 class.\nclass PrintSubClass2 extends PrintClass {\nint z = 3;\nvoid printMe() {\nSystem.out.println(\u201cx is \u201c + x + \u201c, y is \u201c + y +\n\u201c, z is \u201c + z);\nSystem.out.println(\u201cI am an instance of the class \u201c +\nthis.getClass().getName());\n}\npublic static void main (String args[]) {\nPrintSubClass2 obj = new PrintSubClass2();\nobj.printMe();\n}\n}\nNow, when you instantiate this class and call the printMe() method, the version of printMe()\nyou defined for this class is called instead of the one in the superclass PrintClass (as you can see\nin this output):\n120\n030-4s CH07.i 120 1\/29\/96, 9:14 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 7 LP#3 Sams.net Learning\nCenter\nabcd\nOutput x is 0, y is 1, z is 3\nI am an instance of the class PrintSubClass2\nCalling the Original Method\nUsually, there are two reasons why you want to override a method that a superclass has already\nimplemented:\nnn To replace the definition of that original method completely\nnn To augment the original method with additional behavior\nYou\u2019ve already learned about the first one; by overriding a method and giving that method a new\ndefinition, you\u2019ve hidden the original method definition. But sometimes you may just want to\nadd behavior to the original definition rather than erase it altogether. This is particularly useful\nwhere you end up duplicating behavior in both the original method and the method that\noverrides it; by being able to call the original method in the body of the overridden method, you\ncan add only what you need.\nTo call the original method from inside a method definition, use the super keyword to pass the\nmethod call up the hierarchy:\nvoid myMethod (String a, String b) {\n\/\/ do stuff here\nsuper.myMethod(a, b);\n\/\/ maybe do more stuff here\n}\nThe super keyword, like the this keyword, is a placeholder for this class\u2019s superclass. You can\nuse it anywhere you want to refer to your superclass rather than to the current class.\nFor example, Listing 7.8 shows those printMe() methods used in the previous example.\nType\nListing 7.8. The printMe methods.\n\/\/ from PrintClass\nvoid printMe() {\nSystem.out.println(\u201cX is \u201c + x + \u201c, Y is \u201c + y);\nSystem.out.println(\u201cI am an instance of the class\u201d +\nthis.getClass().getName());\n7\n}\n}\n\/\/from PrintSubClass2\nvoid printMe() {\nSystem.out.println(\u201cX is \u201c + x + \u201c, Y is \u201c + y + \u201c, Z is \u201c + z);\nSystem.out.println(\u201cI am an instance of the class \u201c +\nthis.getClass().getName());\n}\n121\n030-4s CH07.i 121 1\/29\/96, 9:14 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 7 LP#3 MTWRFSS\nDDAAYY\n7 More About Methods\nRather than duplicating most of the behavior of the superclass\u2019s method in the subclass, you can\nrearrange the superclass\u2019s method so that additional behavior can easily be added:\n\/\/ from PrintClass\nvoid printMe() {\nSystem.out.println(\u201cI am an instance of the class\u201d +\nthis.getClass().getName());\nSystem.out.println(\u201cX is \u201c + x);\nSystem.out.println(\u201cY is \u201c + y);\n}\n}\nThen, in the superclass, when you override printMe, you can merely call the original method and\nthen add the extra stuff:\n\/\/ From PrintSubClass2\nvoid printMe() {\nsuper.printMe();\nSystem.out.println(\u201cZ is \u201c + z);\n}\n}\nHere\u2019s the output of calling printMe() on an instance of the superclass:\nOutput I am an instance of the class PrintSubClass2\nX is 0\nY is 1\nZ is 3\nOverriding Constructors\nConstructors cannot technically be overridden. Because they always have the same name as the\ncurrent class, you\u2019re always creating new constructors instead of inheriting the ones you\u2019ve got.\nMuch of the time, this is fine, because when your class\u2019s constructor is called, the constructor\nwith the same signature for all your superclass is also called, so initialization of all the parts of\na class you inherit can happen.\nHowever, when you\u2019re defining constructors for your own class, you may want to change how\nyour object is initialized, not only by initializing the information your class adds, but also to\nchange the information that is already there. You can do this by explicitly calling your\nsuperclass\u2019s constructors.\nTo call a regular method in a superclass, you use super.methodname(arguments). Because with\nconstructors you don\u2019t have a method name to call, however, you have to use a different form:\nsuper(arg1, arg2, ...);\nSimilar to using this(...) in a constructor, super(...) calls the constructor method for the\nimmediate superclass (which may, in turn, call the constructor of its superclass, and so on).\n122\n030-4s CH07.i 122 1\/29\/96, 9:15 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 7 LP#3 Sams.net Learning\nCenter\nabcd\nFor example, Listing 7.9 shows a class called NamedPoint, which extends the class Point from\nJava\u2019s awt package. The Point class has only one constructor, which takes an x and a y argument\nand returns a Point object. NamedPoint has an additional instance variable (a string for the name)\nand defines a constructor to initialize x, y, and the name.\nType\nListing 7.9. The NamedPoint class.\n1: import java.awt.Point;\n2: class NamedPoint extends Point {\n3: String name;\n4:\n5: NamedPoint(int x, int y, String name) {\n6: super(x,y);\n7: this.name = name;\n8: }\n9: }\nAnalysis The constructor defined here for NamedPoint (lines 6 through 8) calls Point\u2019s constructor\nmethod to initialize Point\u2019s instance variables (x and y). Although you can just as easily\ninitialize x and y yourself, you may not know what other things Point is doing to initialize\nitself, so it\u2019s always a good idea to pass constructors up the hierarchy to make sure everything\nis set up correctly.\nFinalizer Methods\nFinalizer methods are like the opposite of constructor methods; whereas a constructor method\nis used to initialize an object, finalizer methods are called just before the object is garbage-\ncollected and its memory reclaimed.\nTo create a finalizer method, include a method with the following signature in your class\ndefinition:\nvoid finalize() {\n...\n}\nInside the body of that finalize() method, include any cleaning up you want to do for that\n7\nobject.\nBefore you start using finalizer methods extensively in your Java programs, however, be aware\nthat finalizer methods have several very important restrictions. First of all, the finalizer method\nis not guaranteed to be called until the object\u2019s memory is actually reclaimed, which may be some\ntime after you\u2019ve removed all references to that object.\n123\n030-4s CH07.i 123 1\/29\/96, 9:15 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 7 LP#3 MTWRFSS\nDDAAYY\n7 More About Methods\nYou can always call the finalize() method yourself at any time; it\u2019s just a plain method like any\nother. However, calling finalize() does not trigger an object to be garbage-collected. Only\nremoving all references to an object will cause it to be marked for deleting, and even then, Java\nmay or may not call the finalize() method itself\u2014regardless of whether or not you\u2019ve already\ncalled it.\nFinalizer methods are best used for optimizing the removal of an object\u2014for example, by\nremoving references to other objects, by cleaning up things that object may have touched, or for\nother optional behaviors that may make it easier for that object to be removed. In most cases,\nyou may not need to use finalize() at all.\nSummary\nToday, you learned all kinds of techniques for using, reusing, defining, and redefining methods.\nYou learned how to overload a method name so that the same method can have different\nbehaviors based on the arguments with which it\u2019s called. You learned about constructor\nmethods, which are used to initialize a new object when it\u2019s created. You learned about method\ninheritance and how to override methods that have been defined in a class\u2019s superclasses. Finally,\nyou learned about finalizer methods, that can be used to clean up after an object just before that\nobject is garbage-collected and its memory reclaimed.\nCongratulations on completing your first week of Teach Yourself Java in 21 Days! Starting next\nweek, you\u2019ll apply everything you\u2019ve learned this week to writing Java applets and to working\nwith more advanced concepts in putting together Java programs and working with the standard\nJava class libraries.\nQ&A\nQ I created two methods with the following signatures:\nint total(int arg1, int arg2, int arg3) {...}\nfloat total(int arg1, int arg2, int arg3) {...}\nThe Java compiler complains when I try to compile the class with these method\ndefinitions. But their signatures are different\u2014what have I done wrong?\nA Method overloading in Java works only if the parameter lists are different\u2014either in\nnumber or type of arguments. Return type is not relevant for method overloading.\nThink about it\u2014if you had two methods with exactly the same parameter list, how\nwould Java know which one to call?\n124\n030-4s CH07.i 124 1\/29\/96, 9:16 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 7 LP#3 Sams.net Learning\nCenter\nabcd\nQ You described using the this() method (this(arg, arg, ...)) to call a construc-\ntor from inside another constructor. Are you limited to using the this() method\ncall inside constructors?\nA No, you can use that method anywhere to refer to the current object\u2019s constructor.\nOn an existing object, calling a constructor is an easy way to reinitialize that object\nback to its default state (or to change it to have the state that you want it to have).\nQ Can I overload overridden methods (that is, can I create methods that have the\nsame name as an inherited method, but a different parameter list)?\nA Sure! As long as a parameter lists vary, it doesn\u2019t matter whether you\u2019ve defined a new\nmethod name or one that you\u2019ve inherited from a superclass.\nQ I created a finalizer method to decrement a class variable and print a message\nwhen my object gets garbage-collected. This way I can keep track of how many\nobjects of this class are running at any given time. But sometimes finalize() gets\ncalled and sometimes it doesn\u2019t. How can I guarantee that finalize() will be\ncalled and my program will operate correctly?\nA finalize() is provided as a convenience, to give an object a chance to clean up after\nitself. finalize() may or may not be called on any given object before it is garbage-\ncollected, so you should not depend on its existence; you should be using finalize()\nonly to provide program optimizations.\nIf you absolutely require that an object perform some operation before that object gets\ngarbage-collected, you should create a specific method other than finalize() and\nexplicitly call that method before discarding references to that object.\n7\n125\n030-4s CH07.i 125 1\/29\/96, 9:16 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 7 LP#3 S\nWEESams\nK.net Learning\nCenter\nabcd\nS\nF\n2\n8\nE\nR\nW C\n9\nN\nT\nM A\nL 10\nG\n11\nA\nnn Java Applet Basics\nIncluding an applet on a Web page\nT\nPassing parameters\n12\nnn Graphics, Fonts, and Color\nA\nGraphics primitives\nThe Color class\nnn Simple Animation and Threads\n13\npaint() and repaint()\nReducing animation flicker\nstop and start\nnn More Animation, Images, and Sound\n14\nScaling options, executing sound effectively\nDouble-buffering\nnn Managing Simple Events and Interactivity\nMouseDown and MouseUp\nThe Java event handler\n127\n030-4s AAG 02 127 1\/29\/96, 8:16 PM\nP2\/V4 \/sqc8 TY Java in 21 Days 030-4 Everly 12.11.95 AAG 2 LP#2 MTWRFSS WWEEEEKK\n2 Week 2 at a Glance\nnn User Interfaces with the Java Abstract Windowing Toolkit\nCanvases, text components, widgets, and window construction components\nnn Windows, Networking, and Other Tidbits\nProgramming menus and creating links inside applets\n128\n030-4s AAG 02 128 1\/29\/96, 8:16 PM\nP2\/V4 \/sqc8 TY Java in 21 Days 030-4 Everly 12.11.95 AAG 2 LP#2 Sams.net Learning\nCenter\nabcd\n8\n8\n8\nS\nS\nWEEK\nF 2\nR\nW\nJava Applet Basics\nT\nM\nby Laura Lemay\n129\n030-4s CH08.i 129 1\/29\/96, 9:17 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 mww 12.12.95 Ch 8 LP#2 MTWRFSS\nDDAAYY\n8 Java Applet Basics\nMuch of Java\u2019s current popularity has come about because of Java-capable World Wide Web\nbrowsers and their support for applets: small programs that run inside a Web page and can be\nused to create dynamic, interactive Web designs. Applets, as I noted at the beginning of this\nbook, are written in the Java language, and can be viewed in any browser that supports Java,\nincluding Sun\u2019s HotJava and Netscape\u2019s Navigator 2.0. Learning how to create applets is most\nlikely the reason you bought this book, so let\u2019s waste no more time.\nLast week, you focused on learning about the Java language itself, and most of the little programs\nyou created were Java applications. This week, now that you have the basics down, you move\non to creating and using applets, which includes a discussion of many of the classes in the\nstandard Java class library.\nToday, you\u2019ll start with the basics:\nnn A small review of differences between Java applets and applications\nnn Getting started with applets: the basics of how an applet works and how to create your\nown simple applets\nnn Including an applet on a Web page by using the <APPLET> tag, including the various\nfeatures of that tag\nnn Passing parameters to applets\nHow Applets and Applications Are\nDifferent\nAlthough you explored the differences between Java applications and Java applets in the early\npart of this book, let\u2019s review them.\nIn short, Java applications are stand-alone Java programs that can be run by using just the Java\ninterpreter, for example, from a command line. Most everything you\u2019ve used up to this point\nin the book has been a Java application, albeit a simple one.\nJava applets, however, are run from inside a World Wide Web browser. A reference to an applet\nis embedded in a Web page using a special HTML tag. When a reader, using a Java-aware\nbrowser, loads a Web page with an applet in it, the browser downloads that applet from a Web\nserver and executes it on the local system (the one the browser is running on).\nBecause Java applets run inside the Java browser, they have access to the same capabilities that\nthe browser has: sophisticated graphics, drawing, and image processing packages; user interface\nelements; networking; and event handling. Java applications can also take advantage of these\nfeatures, but they don\u2019t require them (you\u2019ll learn how to create Java applications that use applet-\nlike graphics and UI features on Day 14).\n130\n030-4s CH08.i 130 1\/29\/96, 9:18 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 Ch 8 LP#3 Sams.net Learning\nCenter\nabcd\nThe advantages applets have over applications in terms of graphics and UI capabilities, however,\nare hampered by restrictions on what applets can do. Given the fact that Java applets can be\n8\ndownloaded from anywhere and run on a client\u2019s system, restrictions are necessary to prevent\nan applet from causing system damage or security breaches. Without these restrictions in place,\nJava applets could be written to contain viruses or trojan horses (programs that seem friendly\nbut do some sort of damage to the system), or be used to compromise the security of the system\nthat runs them. The restrictions on what an applet can do include the following:\nnn Applets can\u2019t read or write to the reader\u2019s file system, except in specific directories\n(which are defined by the user through an access control list that, by default, is\nempty). Some browsers may not even allow an applet to read or write to the file\nsystem at all.\nnn Applets can\u2019t usually communicate with a server other than the one that had originally\nstored the applet. (This may be configurable by the browser; however, you should not\ndepend on having this behavior available.)\nnn Applets can\u2019t run any programs on the reader\u2019s system. For Unix systems, this includes\nforking a process.\nnn Applets can\u2019t load programs native to the local platform, including shared libraries\nsuch as DLLs.\nIn addition, Java itself includes various forms of security and consistency checking in the Java\ncompiler and interpreter to prevent unorthodox use of the language (you\u2019ll learn more about this\non Day 21). This combination of restrictions and security features make it more difficult for a\nrogue Java applet to do damage to the client\u2019s system.\nNote: The most important words in the last sentence are \u201cmore difficult.\u201d These\nrestrictions can prevent most of the more obvious ways of trying to cause damage\nto a client\u2019s system, but it\u2019s impossible to be absolutely sure that a clever program-\nmer cannot somehow work around those restrictions. Sun has asked the Net at\nlarge to try to break Java\u2019s security and to create an applet that can work around the\nrestrictions imposed on it. If a hole is found, Sun will patch it. You\u2019ll learn about\nmore issues in Java security on Day 21.\nCreating Applets\nFor the most part, all the Java programs you\u2019ve created up to this point have been Java\napplications\u2014simple programs with a single main() method that created objects, set instance\nvariables, and ran methods. Today and in the days following, you\u2019ll be creating applets\n131\n030-4s CH08.i 131 1\/29\/96, 9:18 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 mww 12.12.95 Ch 8 LP#2 MTWRFSS\nDDAAYY\n8 Java Applet Basics\nexclusively, so you should have a good grasp of how an applet works, the sorts of features an\napplet has, and where to start when you first create your own applets. Without further ado, let\u2019s\nget on with it.\nTo create an applet, you create a subclass of the class Applet, in the java.applet package. The\nApplet class provides behavior to enable your applet not only to work within the browser itself,\nbut also to take advantage of the capabilities of AWT to include UI elements, to handle mouse\nand keyword events, and to draw to the screen. Although your applet can have as many \u201chelper\u201d\nclasses as it needs, it\u2019s the main applet class that triggers the execution of the applet. That initial\napplet class always has a signature like this:\npublic class myClass extends java.applet.Applet {\n...\n}\nNote the public keyword. Java requires that your applet subclass be declared public. Again, this\nis true only of your main applet class; any helper classes you create can be public or private as\nyou wish. Public, private, and other forms of access control are described on Day 15.\nWhen Java encounters your applet in a Web page, it loads your initial applet class over the\nnetwork, as well as any other helper classes that first class uses. Unlike with applications, where\nJava calls the main() method directly on your initial class, when your applet is loaded, Java creates\nan instance of that class, and all the system-based methods are sent to that instance. Different\napplets on the same page, or on different pages that use the same class, use different instances,\nso each one can behave differently from other applets running on the same system.\nMajor Applet Activities\nTo create a basic Java application, your class has to have one method, main(), with a specific\nsignature. Then, when your application starts up, main is executed, and from main you can set\nup the behavior that your programs need. Applets are similar but more complicated. Applets\nhave many different activities that correspond to various major events in the life cycle of the\napplet\u2014for example, initialization, painting, or mouse events. Each activity has a corresponding\nmethod, so when an event occurs, the browser or other Java-capable tool calls those specific\nmethods.\nBy default, none of those activity methods have any definitions; to provide behavior for those\nevents you must override the appropriate method in your applet\u2019s subclass. You don\u2019t have to\noverride all of them, of course; different applet behavior requires different methods to be\noverridden.\nYou\u2019ll learn about the various important methods to override as the week progresses, but, for a\ngeneral overview, here are five of the more important methods in an applet\u2019s execution:\ninitialization, starting, stopping, destroying, and painting.\n132\n030-4s CH08.i 132 1\/29\/96, 9:18 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 Ch 8 LP#3 Sams.net Learning\nCenter\nabcd\nInitialization\nInitialization occurs when the applet is first loaded (or reloaded). Initialization can include\n8\ncreating the objects it needs, setting up an initial state, loading images or fonts, or setting\nparameters. To provide behavior for the initialization of your applet, override the init()\nmethod:\npublic void init() {\n...\n}\nStarting\nAfter an applet is initialized, it is started. Starting can also occur if the applet was previously\nstopped. For example, an applet is stopped if the reader follows a link to a different page, and\nit is started again when the reader returns to this page. Note that starting can occur several times\nduring an applet\u2019s life cycle, whereas initialization happens only once. To provide startup\nbehavior for your applet, override the start() method:\npublic void start() {\n...\n}\nFunctionality that you put in the start() method might include starting up a thread to control\nthe applet, sending the appropriate messages to helper objects, or in some way telling the applet\nto begin running. You\u2019ll learn more about starting applets on Day 10.\nStopping\nStopping and starting go hand in hand. Stopping occurs when the reader leaves the page that\ncontains a currently running applet. By default, when the reader leaves a page, the applet\ncontinues running, using up system resources. By overriding stop, you can suspend execution\nof the applet and then restart it if the applet is viewed again. To stop an applet\u2019s execution, use\nthe stop() method:\npublic void stop() {\n...\n}\nDestroying\nDestroying sounds more violent than it is. Destroying enables the applet to clean up after itself\njust before it or the browser exits\u2014for example, to kill any running threads or to release any other\nrunning objects. Generally, you won\u2019t want to override destroy unless you have specific\nresources that need to be released\u2014for example, threads that the applet has created. To provide\nclean up behavior for your applet, override the destroy() method:\n133\n030-4s CH08.i 133 1\/29\/96, 9:19 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 mww 12.12.95 Ch 8 LP#2 MTWRFSS\nDDAAYY\n8 Java Applet Basics\npublic void destroy() {\n...\n}\nTechnical Note: How is destroy() different from finalize(), which was described\non Day 7? First, destroy() applies only to applets. finalize() is a more general-\npurpose way for a single object of any type to clean up after itself.\nThe other difference is that destroy() is always called when the applet has finished\nexecuting, either because the browser is exiting or because the applet is being\nreloaded. finalize() is not guaranteed to be executed.\nPainting\nPainting is how an applet actually draws something on the screen, be it text, a line, a colored\nbackground, or an image. Painting can occur many hundreds of times during an applet\u2019s life\ncycle\u2014for example, once after the applet is initialized, if the browser is placed behind another\nwindow on the screen and then brought forward again, if the browser window is moved to a\ndifferent position on the screen, or perhaps repeatedly in the case of animations. You override\nthe paint() method for your applet to have an actual appearance on the screen. The paint()\nmethod looks like this:\npublic void paint(Graphics g) {\n...\n}\nNote that unlike the other major methods in this section, paint() takes an argument, an instance\nof the class Graphics. This object is created and passed to paint by the browser, so you don\u2019t have\nto worry about it. However, you will have to make sure that the Graphics class (part of the\njava.awt package) gets imported into your applet code, usually through an import statement at\nthe top of your Java file:\nimport java.awt.Graphics;\nA Simple Applet\nOn Day 2, you created a simple applet called HelloAgainApplet (this was the one with the big\nred Hello Again). There, you created and used that applet as an example of creating a subclass.\nLet\u2019s go over the code for that applet again, this time looking at it slightly differently in light of\nthe things you just learned about applets. Listing 8.1 shows the code for that applet.\n134\n030-4s CH08.i 134 1\/29\/96, 9:19 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 Ch 8 LP#3 Sams.net Learning\nCenter\nabcd\nType\nListing 8.1. The Hello Again applet.\n8\n1: import java.awt.Graphics;\n2: import java.awt.Font;\n3: import java.awt.Color;\n4:\n5: public class HelloAgainApplet extends java.applet.Applet {\n6:\n7: Font f = new Font(\u201cTimesRoman\u201d,Font.BOLD,36);\n8:\n9: public void paint(Graphics g) {\n10: g.setFont(f);\n11: g.setColor(Color.red);\n12: g.drawString(\u201cHello again!\u201d, 5, 50);\n13: }\n14: }\nAnalysis This applet overrides paint(), one of the major methods described in the previous section.\nBecause the applet doesn\u2019t actually execute (all it does is print a couple of words to the\nscreen), and there\u2019s not really anything to initialize, you don\u2019t need a start() or a stop()\nor an init() method.\nThe paint method is where the real work of this applet (what little work goes on) really occurs.\nThe Graphics object passed into the paint() method holds that graphics state\u2014that is, the\ncurrent features of the drawing surface. Lines 10 and 11 set up the default font and color for this\ngraphics state (here, the font object help in the f instance variable, and an object representing\nthe color red that\u2019s stored in the Color class\u2019s variable red).\nLine 12 then draws the string \u201cHello Again!\u201d by using the current font and color at the position\n5, 50. Note that the 0 point for y is at the top left of the applet\u2019s drawing surface, with positive\ny moving downward, so 50 is actually at the bottom of the applet. Figure 8.1 shows how the\napplet\u2019s bounding box and the string are drawn on the page.\nFigure 8.1. 0,0\nDrawing the applet.\n50\n5\n135\n030-4s CH08.i 135 1\/29\/96, 9:20 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 mww 12.12.95 Ch 8 LP#2 MTWRFSS\nDDAAYY\n8 Java Applet Basics\nIncluding an Applet on a Web Page\nAfter you create a class or classes that contain your applet and compile them into class files as\nyou would any other Java program, you have to create a Web page that will hold that applet by\nusing the HTML language. There is a special HTML tag for including applets in Web pages;\nJava-capable browsers use the information contained in that tag to locate the compiled class files\nand execute the applet itself. In this section, you\u2019ll learn about how to put Java applets in a Web\npage and how to serve those files to the Web at large.\nNote: The following section assumes you have at least a passing understanding of\nwriting HTML pages. If you need help in this area, you may find the book Teach\nYourself Web Publishing with HTML in 14 Days useful. It is also from Sams.Net\n(and also written by one of the authors of this book).\nThe <APPLET> Tag\nTo include an applet on a Web page, use the <APPLET> tag. <APPLET> is a special extension to\nHTML for including applets in Web pages. Listing 8.2 shows a very simple example of a Web\npage with an applet included in it.\nType\nListing 8.2. A simple HTML page.\n1: <HTML>\n2: <HEAD>\n3: <TITLE>This page has an applet on it<\/TITLE>\n4: <\/HEAD>\n5: <BODY>\n6: <P>My second Java applet says:\n7: <BR>\n8: <APPLET CODE=\u201dHelloAgainApplet.class\u201d WIDTH=200 HEIGHT=50>\n9: There would be an applet here if your browser\n10: supported Java.\n11: <\/APPLET>\n12: <\/BODY>\n13: <\/HTML>\nAnalysis There are three things to note about the <APPLET> tag in this page:\nnn The CODE attribute indicates the name of the class file that loads this applet, including\nthe .class extension. In this case, the class file must be in the same directory as this\n136\n030-4s CH08.i 136 1\/29\/96, 9:21 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 Ch 8 LP#3 Sams.net Learning\nCenter\nabcd\nHTML file. To indicate applets are in a different directory, use CODEBASE, described\nlater today.\n8\nnn WIDTH and HEIGHT are required and used to indicate the bounding box of the applet\u2014\nthat is, how big a box to draw for the applet on the Web page. Be sure you set WIDTH\nand HEIGHT to be an appropriate size for the applet; depending on the browser, if your\napplet draws outside the boundaries of the space you\u2019ve given it, you may not be able\nto see or get to those parts of the applet outside the bounding box.\nnn The text between the <APPLET> and <\/APPLET> tags is displayed by browsers that do\nnot understand the <APPLET> tag (which includes most browsers that are not Java-\ncapable). Because your page may be viewed in many different kinds of browsers, it is a\nvery good idea to include alternate text here so that readers of your page who don\u2019t\nhave Java will see something other than a blank line. Here, you include a simple\nstatement that says There would be an applet here if your browser supported\nJava.\nNote that the <APPLET> tag, like the <IMG> tag, is not itself a paragraph, so it should be enclosed\ninside a more general text tag, such as <P> or one of the heading tags (<H1> , <H2>, and so on).\nTesting the Result\nNow with a class file and an HTML file that refers to your applet, you should be able to load\nthat HTML file into your Java-capable browser (using either the Open Local... dialog item or\na file URL, or by indicating the filename on a command line). The browser loads and parses your\nHTML file, and then loads and executes your applet class.\nFigure 8.2 shows the Hello Again applet, in case you\u2019ve forgotten what it looks like.\nFigure 8.2.\nThe Hello Again applet.\nMaking Java Applets Available to the Web\nAfter you have an applet and an HTML file, and you\u2019ve verified that everything is working\ncorrectly on your local system, the last step is making that applet available to the World Wide\nWeb at large so that anyone with a Java-capable browser can view that applet.\n137\n030-4s CH08.i 137 1\/29\/96, 9:21 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 mww 12.12.95 Ch 8 LP#2 MTWRFSS\nDDAAYY\n8 Java Applet Basics\nJava applets are served by a Web server the same way that HTML files, images, and other media\nare. You don\u2019t need special server software to make Java applets available to the Web; you don\u2019t\neven need to configure your server to handle Java files. If you have a Web server up and running,\nor space on a Web server available to you, all you have to do is move your HTML and compiled\nclass files to that server, as you would any other file.\nIf you don\u2019t have a Web server, you have to rent space on one or set one up yourself. (Web server\nsetup and administration, as well as other facets of Web publishing in general, are outside the\nscope of this book.)\nMore About the <APPLET> Tag\nIn its simplest form, by using CODE, WIDTH, and HEIGHT, the <APPLET> tag merely creates a space\nof the appropriate size and then loads and plays the applet in that space. The <APPLET> tag,\nhowever, does include several attributes that can help you better integrate your applet into the\noverall design of your Web page.\nNote: The attributes available for the <APPLET> tag are almost identical to those for\nthe HTML <IMG> tag.\nALIGN\nThe ALIGN attribute defines how the applet will be aligned on the page. This attribute can have\none of nine values: LEFT, RIGHT, TOP, TEXTTOP, MIDDLE, ABSMIDDLE, BASELINE, BOTTOM, and\nABSBOTTOM.\nIn the case of ALIGN=LEFT and ALIGN=RIGHT, the applet is placed at the left or right margins of the\npage, respectively, and all text following that applet flows in the space to the right or left of that\napplet. The text will continue to flow in that space until the end of the applet, or you can use\na line break tag (<BR>) with the CLEAR attribute to start the left line of text below that applet. The\nCLEAR attribute can have one of three values: CLEAR=LEFT starts the text at the next clear left\nmargin, CLEAR=RIGHT does the same for the right margin, and CLEAR=ALL starts the text at the next\nline where both margins are clear.\nFor example, here\u2019s a snippet of HTML code that aligns an applet against the left margin, has\nsome text flowing alongside it, and then breaks at the end of the paragraph so that the next bit\nof text starts below the applet:\n138\n030-4s CH08.i 138 1\/29\/96, 9:21 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 Ch 8 LP#3 Sams.net Learning\nCenter\nabcd\n<P><APPLET CODE=\u201dHelloAgainApplet\u201d WIDTH=300 HEIGHT=200\nALIGN=LEFT>Hello Again!<\/APPLET>\nTo the left of this paragraph is an applet. It\u2019s a 8\nsimple, unassuming applet, in which a small string is\nprinted in red type, set in 36 point Times bold.\n<BR CLEAR=ALL>\n<P>In the next part of the page, we demonstrate how\nunder certain conditions, styrofoam peanuts can be\nused as a healthy snack.\nFigure 8.3 shows how this applet and the text surrounding it might appear in a Java-capable\nbrowser.\nFigure 8.3.\nAn applet aligned left.\nFor smaller applets, you may want to include your applet within a single line of text. To do this,\nthere are seven values for ALIGN that determine how the applet is vertically aligned with the text:\nnn ALIGN=TEXTTTOP aligns the top of the applet with the top of the tallest text in the line.\nnn ALIGN=TOP aligns the applet with the topmost item in the line (which may be another\napplet, or an image, or the top of the text).\nnn ALIGN=ABSMIDDLE aligns the middle of the applet with the middle of the largest item in\nthe line.\nnn ALIGN=MIDDLE aligns the middle of the applet with the middle of the baseline of the\ntext.\nnn ALIGN=BASELINE aligns the bottom of the applet with the baseline of the text.\nALIGN=BASELINE is the same as ALIGN=BOTTOM, but ALIGN=BASELINE is a more descriptive\nname.\nnn ALIGN=ABSBOTTOM aligns the bottom of the applet with the lowest item in the line\n(which may be the baseline of the text or another applet or image).\nFigure 8.4 shows the various alignment options, where the line is an image and the arrow is a\nsmall applet.\n139\n030-4s CH08.i 139 1\/29\/96, 9:22 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 mww 12.12.95 Ch 8 LP#2 MTWRFSS\nDDAAYY\n8 Java Applet Basics\nFigure 8.4.\nApplet alignment options.\nHSPACE and VSPACE\nThe HSPACE and VSPACE attributes are used to set the amount of space, in pixels, between an applet\nand its surrounding text. HSPACE controls the horizontal space (the space to the left and right of\nthe applet). VSPACE controls the vertical space (the space above and below). For example, here\u2019s\nthat sample snippet of HTML with vertical space of 10 and horizontal space of 50:\n<P><APPLET CODE=\u201dHelloAgainApplet\u201d WIDTH=300 HEIGHT=200\nALIGN=LEFT VSPACE=10 HSPACE=50>Hello Again!<\/APPLET>\nTo the left of this paragraph is an applet. It\u2019s a\nsimple, unassuming applet, in which a small string is\nprinted in red type, set in 36 point Times bold.\n<BR CLEAR=ALL>\n<P>In the next part of the page, we demonstrate how\nunder certain conditions, styrofoam peanuts can be\nused as a healthy snack.\nThe result in a typical Java browser might look like that in Figure 8.5.\n140\n030-4s CH08.i 140 1\/29\/96, 9:22 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 Ch 8 LP#3 Sams.net Learning\nCenter\nabcd\nFigure 8.5.\nVertical and horizontal\n8\nspace.\n50\n10\n50\nCODE and CODEBASE\nCODE is used to indicate the name of the class file that holds the current applet. If CODE is used\nalone in the <APPLET> tag, the class file is searched for in the same directory as the HTML file\nthat references it.\nIf you want to store your class files in a different directory than that of your HTML files, you\nhave to tell the Java-capable browser where to find those class files. To do this, you use CODEBASE.\nCODE contains only the name of the class file; CODEBASE contains an alternate pathname where\nclasses are contained. For example, if you store your class files in a directory called \/classes, which\nis in the same directory as your HTML files, CODEBASE is the following:\n<APPLET CODE=\u201dmyclass.class\u201d CODEBASE=\u201dclasses\u201d\nWIDTH=100 HEIGHT=100>\nPassing Parameters to Applets\nWith Java applications, you can pass parameters to your main() routine by using arguments on\nthe command line. You can then parse those arguments inside the body of your class, and the\napplication acts accordingly based on the arguments it is given.\nApplets, however, don\u2019t have a command line. How do you pass in different arguments to an\napplet? Applets can get different input from the HTML file that contains the <APPLET> tag\nthrough the use of applet parameters. To set up and handle parameters in an applet, you need\ntwo things:\nnn A special parameter tag in the HTML file\nnn Code in your applet to parse those parameters\n141\n030-4s CH08.i 141 1\/29\/96, 9:23 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 mww 12.12.95 Ch 8 LP#2 MTWRFSS\nDDAAYY\n8 Java Applet Basics\nApplet parameters come in two parts: a name, which is simply a name you pick, and a value,\nwhich determines the value of that particular parameter. So, for example, you can indicate the\ncolor of text in an applet by using a parameter with the name color and the value red. You can\ndetermine an animation\u2019s speed using a parameter with the name speed and the value 5.\nIn the HTML fie that contains the embedded applet, you indicate each parameter using the\n<PARAM> tag, which has two attributes for the name and the value, called (surprisingly enough),\nNAME and VALUE. The <PARAM> tag goes inside the opening and closing <APPLET> tags:\n<APPLET CODE=\u201dMyApplet.class\u201d WIDTH=100 HEIGHT=100>\n<PARAM NAME=font VALUE=\u201dTimesRoman\u201d>\n<PARAM NAME=size VALUE=\u201d36\">\nA Java applet appears here.<\/APPLET>\nThis particular example defines two parameters to the MyApplet applet: one whose name is font\nand whose value is TimesRoman, and one whose name is size and whose value is 36.\nThose parameters are passed to your applet when it is loaded. In the init() method for your\napplet, you can then get hold of those parameters by using the getParameter method.\ngetParameter takes one argument\u2014a string representing the name of the parameter you\u2019re\nlooking for\u2014and returns a string containing the corresponding value of that parameter. (Like\narguments in Java applications, all the parameter values are converted to strings.) To get the\nvalue of the font parameter from the HTML file, you might have a line such as this in your\ninit() method:\nString theFontName = getParameter(\u201cfont\u201d);\nNote: The names of the parameters as specified in <PARAM> and the names of the\nparameters in getParameter must match identically, including having the same\nupper and lower case. In other words, <PARAM= NAME=\u201dname\u201d> is different from\n<PARAM NAME=\u201dName\u201d>. If your parameters are not being properly passed to your\napplet, make sure the parameter names match.\nNote that if a parameter you expect has not been specified in the HTML file, getParameter\nreturns null. Most often, you will want to test for a null parameter and supply a reasonable\ndefault:\nif (theFontName == null)\ntheFontName = \u201cCourier\u201d\nKeep in mind also that because getParameter returns strings, if you want a parameter to be some\nother object or type, you have to convert it yourself. To parse the size parameter from that same\nHTML file and assign it to an integer variable called theSize, you might use the following lines:\n142\n030-4s CH08.i 142 1\/29\/96, 9:23 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 Ch 8 LP#3 Sams.net Learning\nCenter\nabcd\nint theSize;\nString s = getParameter(\u201csize\u201d);\nif (s == null) 8\ntheSize = 12;\nelse theSize = Integer.parseInt(s);\nGet it? Not yet? Let\u2019s create an example of an applet that uses this technique. You\u2019ll modify the\nHelloAgainApplet so that it says hello to a specific name, for example \u201cHello Bill\u201d or \u201cHello\nAlice\u201d. The name is passed into the applet through an HTML parameter.\nLet\u2019s start with the original HelloAgainApplet class:\nimport java.awt.Graphics;\nimport java.awt.Font;\nimport java.awt.Color;\npublic class MoreHelloApplet extends java.applet.Applet {\nFont f = new Font(\u201cTimesRoman\u201d,Font.BOLD,36);\npublic void paint(Graphics g) {\ng.setFont(f);\ng.setColor(Color.red);\ng.drawString(\u201cHello Again!\u201d, 5, 50);\n}\n}\nThe first thing you need to add in this class is a place for the name. Because you\u2019ll need that name\nthroughout the applet, let\u2019s add an instance variable for the name, just after the variable for the\nfont:\nString name;\nTo set a value for the name, you have to get the parameter. The best place to handle parameters\nto an applet is inside an init() method. The init() method is defined similarly to paint()\n(public, with no arguments, and a return type of void). Make sure when you test for a parameter\nthat you test for a value of null. The default, in this case, if a name isn\u2019t indicated, is to say hello\nto \u201cLaura\u201d:\npublic void init() {\nthis.name = getParameter(\u201cname\u201d);\nif (this.name == null)\nthis.name = \u201cLaura\u201d;\n}\nOne last thing to do now that you have the name from the HTML parameters is to modify the\nname so that it\u2019s a complete string\u2014that is, to tack \u201cHello \u201c onto the beginning, and an\nexclamation point onto the end. You could do this in the paint method just before printing the\nstring to the screen. Here it\u2019s done only once, however, whereas in paint it\u2019s done every time\nthe screen is repainted\u2014in other words, it\u2019s slightly more efficient to do it inside init() instead:\nthis.name = \u201cHello \u201c + this.name + \u201c!\u201d;\n143\n030-4s CH08.i 143 1\/29\/96, 9:23 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 mww 12.12.95 Ch 8 LP#2 MTWRFSS\nDDAAYY\n8 Java Applet Basics\nAnd now, all that\u2019s left is to modify the paint() method. The original drawString method\nlooked like this:\ng.drawString(\u201cHello Again!\u201d, 5, 50);\nTo draw the new string you have stored in the name instance variable, all you need to do is\nsubstitute that variable for the literal string:\ng.drawString(this.name, 5, 50);\nListing 8.3 shows the final result of the MoreHelloApplet class. Compile it so that you have a class\nfile ready.\nType\nListing 8.3. The MoreHelloApplet class.\n1: import java.awt.Graphics;\n2: import java.awt.Font;\n3: import java.awt.Color;\n4:\n5: public class MoreHelloApplet extends java.applet.Applet {\n6:\n7: Font f = new Font(\u201cTimesRoman\u201d,Font.BOLD,36);\n8: String name;\n9:\n10: public void init() {\n11: this.name = getParameter(\u201cname\u201d);\n12: if (this.name == null)\n13: this.name = \u201cLaura\u201d;\n14:\n15: this.name = \u201cHello \u201c + this.name + \u201c!\u201d;\n16: }\n17:\n18: public void paint(Graphics g) {\n19: g.setFont(f);\n20: g.setColor(Color.red);\n21: g.drawString(this.name, 5, 50);\n22: }\n23: }\nNow, let\u2019s create the HTML file that contains this applet. Listing 8.4 shows a new Web page\nfor the MoreHelloApplet applet.\nType\nListing 8.4. The HTML file for the MoreHelloApplet applet.\n1: <HTML>\n2: <HEAD>\n3: <TITLE>Hello!<\/TITLE>\n4: <\/HEAD>\n5: <BODY>\n144\n030-4s CH08.i 144 1\/29\/96, 9:24 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 Ch 8 LP#3 Sams.net Learning\nCenter\nabcd\n6: <P>\n7: <APPLET CODE=\u201dMoreHelloApplet.class\u201d WIDTH=300 HEIGHT=50>\n8: <PARAM NAME=name VALUE=\u201dBonzo\u201d> 8\n9: Hello to whoever you are!\n10: <\/APPLET>\n11: <\/BODY>\n12: <\/HTML>\nAnalysis Note the <APPLET> tag, which points to the class file for the applet with the appropriate\nwidth and height (300 and 50). Just below it (line 8) is the <PARAM> tag, which you use to\npass in the name. Here, the NAME parameter is simply name, and the value is the strong\n\u201cBonzo\u201d.\nLoading up this HTML file produces the result shown in Figure 8.6.\nFigure 8.6.\nThe result of\nMoreHelloApplet, first try.\nLet\u2019s try a second example. Remember that in the code for MoreHelloApplet, if no name is\nspecified, the default is the name \u201cLaura\u201d. Listing 8.5 creates an HTML file with no parameter\ntag for name.\nType Listing 8.5. Another HTML File for the\nMoreHelloApplet applet.\n1: <HTML>\n2: <HEAD>\n3: <TITLE>Hello!<\/TITLE>\n4: <\/HEAD>\n5: <BODY>\n6: <P>\n7: <APPLET CODE=\u201dMoreHelloApplet.class\u201d WIDTH=300 HEIGHT=50>\n8: Hello to whoever you are!\n9: <\/APPLET>\n10: <\/BODY>\n11: <\/HTML>\nHere, because no name was supplied, the applet uses the default, and the result is what you might\nexpect (see Figure 8.7).\n145\n030-4s CH08.i 145 1\/29\/96, 9:24 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 mww 12.12.95 Ch 8 LP#2 MTWRFSS\nDDAAYY\n8 Java Applet Basics\nFigure 8.7.\nThe result of\nMoreHelloApplet,\nsecond try.\nSummary\nApplets are probably the most common use of the Java language today. Applets are more\ncomplicated than many Java applications because they are executed and drawn inline with a Web\npage. Applets can more easily provide easy access to the graphics, user interface, and events\nsystems in the Web browser itself. Today, you learned the basics of creating applets, including\nthe following things:\nnn All applets you develop using Java inherit from the Applet class, part of the java.applet\npackage. The Applet class provides basic behavior for how the applet will be integrated\nwith and react to the browser and various forms of input from that browser and the\nperson running it. By subclassing Applet, you have access to all that behavior.\nnn Applets have five main methods, which are used for the basic activities an applet\nperforms during its life cycle: init(), start(), stop(), destroy(), and paint().\nAlthough you don\u2019t need to override all these methods, these are the most common\nmethods you\u2019ll see repeated in many of the applets you\u2019ll create in this book and in\nother sample programs.\nnn To run a compiled applet class file, you include it in an HTML Web page by using\nthe <APPLET> tag. When a Java-capable browser comes across <APPLET>, it loads and\nplays the applet described in that tag. Note that to publish Java applets on the World\nWide Web alongside HTML files you do not need special server software; any plain\nold Web server will do just fine.\nnn Unlike applications, applets do not have a common line on which to pass arguments,\nso those arguments must be passed into the applet through the HTML file that\ncontains it. You indicate parameters in an HTML file by using the <PARAM> tag inside\nthe opening and closing <APPLET> tags. <PARAM> has two attributes: NAME for the name\nof the parameter, and VALUE for its value. Inside the body of your applet (usually in\ninit()), you can then gain access to those parameters using the getParameter method.\n146\n030-4s CH08.i 146 1\/29\/96, 9:25 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 Ch 8 LP#3 Sams.net Learning\nCenter\nabcd\nQ&A\n8\nQ In the first part of today\u2019s lesson, you say that applets are downloaded from\nrandom Web servers and run on the client\u2019s system. What\u2019s to stop an applet\ndeveloper from creating an applet that deletes all the files on that system, or in\nsome other way compromises the security of the system?\nA Recall that Java applets have several restrictions that make it difficult for most of the\nmore obvious malicious behavior to take place. For example, because Java applets\ncannot read or write files on the client system, they cannot delete files or read system\nfiles that might contain private information. Because they cannot run programs on the\nclient\u2019s system, they cannot, for example, use the system\u2019s mail system to mail files to\nsomeone elsewhere on the network.\nIn addition, Java\u2019s very architecture makes it difficult to circumvent these restrictions.\nThe language itself, the Java compiler, and the Java interpreter all have checks to make\nsure that no one has tried to sneak in bogus code or play games with the system itself.\nYou\u2019ll learn more about these checks at the end of this book.\nOf course, no system can claim to be entirely secure, and the fact that Java applets are\nrun on the client\u2019s system makes them especially ripe for suspicion.\nQ Wait a minute. If I can\u2019t read or write files or run programs on the system the\napplet is running on, doesn\u2019t that mean I basically can\u2019t do anything other than\nsimple animations and flashy graphics? How can I save state in an applet? How\ncan I create, say, a word processor or a spreadsheet as a Java applet?\nA For everyone who doesn\u2019t believe that Java is secure enough, there is someone who\nbelieves that Java\u2019s security restrictions are too severe for just these reasons. Yes, Java\napplets are limited because of the security restrictions. But given the possibility for\nabuse, I believe that it\u2019s better to err on the side of being more conservative as far as\nsecurity is concerned. Consider it a challenge.\nKeep in mind, also, that Java applications have none of the restrictions that Java\napplets do, but because they are also compiled to bytecode, they are portable across\nplatforms. It may be that the thing you want to create would make a much better\napplication than an applet.\nQ I have an older version of HotJava. I followed all the examples in this section,\nbut HotJava cannot read my applets (it seems to ignore that they exist). What\u2019s\ngoing on?\n147\n030-4s CH08.i 147 1\/29\/96, 9:25 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 mww 12.12.95 Ch 8 LP#2 MTWRFSS\nDDAAYY\n8 Java Applet Basics\nA You most likely have an alpha version of HotJava. Recall that significant changes were\nmade to the Java API and how Java applets are written between alpha and beta. The\nresults of these changes are that browsers that support alpha applets cannot read beta\napplets, and vice versa. The HTML tags are even different, so an older browser just\nskips over newer applets, and vice versa.\nBy the time you read this, there may be a new version of HotJava with support for\nbeta. If not, you can use Netscape 2.0 or the JDK\u2019s applet viewer to view applets\nwritten to the beta specification.\nQ I noticed in a page about the <APPLET> tag that there\u2019s also a NAME attribute. You\ndidn\u2019t discuss it here.\nA NAME is used when you have multiple applets on a page that need to communicate with\neach other. You\u2019ll learn about this on Day 12.\nQ I have an applet that takes parameters and an HTML file that passes it those\nparameters. But when my applet runs, all I get are null values. What\u2019s going on\nhere?\nA Do the names of your parameters (in the NAME attribute) match exactly with the names\nyou\u2019re testing for in getParameter? They must be exact, including case, for the match\nto be made. Make sure also that your <PARAM> tags are inside the opening and closing\n<APPLET> tags, and that you haven\u2019t misspelled anything.\n148\n030-4s CH08.i 148 1\/29\/96, 9:26 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 Ch 8 LP#3 Sams.net Learning\nCenter\nabcd\n9\n9\n9\nS\nS\nWEEK\nF 2\nR\nW\nGraphics, Fonts,\nT\nand Color\nM\nby Laura Lemay\n149\n030-4s CH09.i 149 1\/29\/96, 9:27 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 MTWRFSS\nDDAAYY\n9 Graphics, Fonts, and Color\nNow you have a basic understanding of how applets work. For the remainder of this week you\u2019ll\ncover the sorts of things you can do with applets with the built-in Java class libraries, and how\nyou can combine them to produce interesting effects. You\u2019ll start today with how to draw to the\nscreen\u2014that is, how to produce lines and shapes with the built-in graphics primitive, how to\nprint text using fonts, and how to use and modify color in your applets. Today you\u2019ll learn,\nspecifically:\nnn How the graphics system works in Java: the Graphics class, the coordinate system used\nto draw to the screen, and how applets paint and repaint\nnn Using the Java graphics primitives, including drawing and filling lines, rectangles,\novals, and arcs\nnn Creating and using fonts, including how to draw characters and strings and how to\nfind out the metrics of a given font for better layout\nnn All about color in Java, including the Color class and how to set the foreground\n(drawing) and background color for your applet\nNote: Today\u2019s lesson discusses many of the basic operations available to you with\nthe Java class libraries regarding graphics, fonts, and color. However, today\u2019s lesson,\nas well as all of this book, is also intended to be more of an introduction and an\noverview than an exhaustive description of all the features available to you. Be sure\nto check out the Java API documentation for more information on the classes\ndescribed today.\nThe Graphics Class\nWith Java\u2019s graphics capabilities, you can draw lines, shapes, characters, and images to the screen\ninside your applet. Most of the graphics operations in Java are methods defined in the Graphics\nclass. You don\u2019t have to create an instance of Graphics in order to draw something in your applet;\nin your applet\u2019s paint() method (which you learned about yesterday), you are given a Graphics\nobject. By drawing on that object, you draw onto your applet and the results appear on screen.\nThe Graphics class is part of the java.awt package, so if your applet does any painting (as it usually\nwill), make sure you import that class at the beginning of your Java file:\nimport java.awt.Graphics;\npublic class MyClass extended java.applet.Applet {\n...\n}\n150\n030-4s CH09.i 150 1\/29\/96, 9:28 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 Sams.net Learning\nCenter\nabcd\nThe Graphics Coordinate System\nTo draw an object on the screen, you call one of the drawing methods available in the Graphics\nclass. All the drawing methods have arguments representing endpoints, corners, or starting\nlocations of the object as values in the applet\u2019s coordinate system\u2014for example, a line starts at\nthe points 10,10 and ends at the points 20,20.\nJava\u2019s coordinate system has the origin (0,0) in the top left corner. Positive x values are to the\n9\nright, and positive y values are down. All pixel values are integers; there are no partial or fractional\npixels. Figure 9.1 shows how you might draw a simple square by using this coordinate system.\nFigure 9.1. 0,0 +X\nThe Java graphics coordi-\nnate system.\n20,20\n60,60\n+Y\nJava\u2019s coordinate system is different from many painting and layout programs that have their\nx and y in the bottom left. If you\u2019re not used to working with this upside-down graphics system,\nit may take some practice to get familiar with it.\nDrawing and Filling\nThe Graphics class provides a set of simple built-in graphics primitives for drawing, including\nlines, rectangles, polygons, ovals, and arcs.\nNote: Bitmap images, such as GIF files, can also be drawn by using the Graphics\nclass. You\u2019ll learn about this tomorrow.\n151\n030-4s CH09.i 151 1\/29\/96, 9:28 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 MTWRFSS\nDDAAYY\n9 Graphics, Fonts, and Color\nLines\nTo draw straight lines, use the drawLine method. drawLine takes four arguments: the x and y\ncoordinates of the starting point and the x and y coordinates of the ending point.\npublic void paint(Graphics g) {\ng.drawLine(25,25,75,75);\n}\nFigure 9.2 shows the result of this snippet of code.\nFigure 9.2.\nDrawing lines.\nRectangles\nThe Java graphics primitives provide not just one, but three kinds of rectangles:\nnn Plain rectangles\nnn Rounded rectangles, which are rectangles with rounded corners\nnn Three-dimensional rectangles, which are drawn with a shaded border\nFor each of these rectangles, you have two methods to choose from: one that draws the rectangle\nin outline form, and one that draws the rectangle filled with color.\nTo draw a plain rectangle, use either the drawRect or fillRect methods. Both take four\narguments: the x and y coordinates of the top left corner of the rectangle, and the width and\nheight of the rectangle to draw. For example, the following paint() method draws two squares:\nthe left one is an outline and the right one is filled (Figure 9.3 shows the result):\npublic void paint(Graphics g) {\ng.drawRect(20,20,60,60);\ng.fillRect(120,20,60,60);\n}\nRounded rectangles are, as you might expect, rectangles with rounded edges. The drawRoundRect\nand fillRoundRect methods to draw rounded rectangles are similar to regular rectangles except\nthat rounded rectangles have two extra arguments for the width and height of the angle of the\n152\n030-4s CH09.i 152 1\/29\/96, 9:29 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 Sams.net Learning\nCenter\nabcd\ncorners. Those two arguments determine how far along the edges of the rectangle the arc for the\ncorner will start; the first for the angle along the horizontal plane, the second for the vertical.\nLarger values for the angle width and height make the overall rectangle more rounded; values\nequal to the width and height of the rectangle itself produce a circle. Figure 9.4 shows some\nexamples of rounded corners.\nFigure 9.3.\n9\nRectangles.\nFigure 9.4. 30\nRounded corners. 5\n10\n5\n20\n20\nHere\u2019s a paint method that draws two rounded rectangles: one as an outline with a rounded\ncorner 10 pixels square; the other, filled, with a rounded corner 20 pixels square (Figure 9.5 shows\nthe resulting squares):\npublic void paint(Graphics g) {\ng.drawRoundRect(20,20,60,60,10,10);\ng.fillRoundRect(120,20,60,60,20,20);\n}\n153\n030-4s CH09.i 153 1\/29\/96, 9:29 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 MTWRFSS\nDDAAYY\n9 Graphics, Fonts, and Color\nFigure 9.5.\nRounded rectangles.\nFinally, there are three-dimensional rectangles. These rectangles aren\u2019t really 3D; instead, they\nhave a shadow effect that makes them appear either raised or indented from the surface of the\napplet. Three-dimensional rectangles have four arguments for the x and y of the start position\nand the width and height of the rectangle. The fifth argument is a boolean indicating whether\nthe 3D effect is to raise the rectangle (true) or indent it (false). As with the other rectangles,\nthere are also different methods for drawing and filling: draw3DRect and fill3DRect. Here\u2019s code\nto produce two of them\u2014the left one indented, the right one raised (Figure 9.6 shows the result):\npublic void paint(Graphics g) {\ng.draw3DRect(20,20,60,60,true);\ng.draw3DRect(120,20,60,60,false);\n}\nFigure 9.6.\nThree-dimensional\nrectangles.\nNote: In the current beta version of the Java developer\u2019s kit, it is very difficult to\nsee the 3D effect on 3D rectangles, due to a very small line width. (In fact, I\nenhanced Figure 9.6 to better show the effect.) If you are having troubles with 3D\nrectangles, this may be why. Drawing 3D rectangles in any color other than black\nmakes them easier to see.\n154\n030-4s CH09.i 154 1\/29\/96, 9:30 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 Sams.net Learning\nCenter\nabcd\nPolygons\nPolygons are shapes with an unlimited number of sides. To draw a polygon, you need a set of\nx and y coordinates, and the drawing method then starts at one, draws a line to the second, then\na line to the third, and so on.\nAs with rectangles, you can draw an outline or a filled polygon (the drawPolygon and fillPolygon\nmethods, respectively). You also have a choice of how you want to indicate the list of\n9\ncoordinates\u2014either as arrays of x and y coordinates or as an instance of the Polygon class.\nUsing the first method, the drawPolygon and fillPolygon methods take three arguments:\nnn An array of integers representing x coordinates\nnn An array of integers representing y coordinates\nnn An integer for the total number of points\nThe x and y arrays should, of course, have the same number of elements.\nHere\u2019s an example of drawing a polygon\u2019s outline by using this method (Figure 9.7 shows the\nresult):\npublic void paint(Graphics g) {\nint exes[] = { 39,94,97,142,53,58,26 };\nint whys[] = { 33,74,36,70,108,80,106 };\nint pts = exes.length;\ng.drawPolygon(exes,whys,pts);\n}\nFigure 9.7.\nA polygon.\nNote that Java does not automatically close the polygon; if you want to complete the shape, you\nhave to include the starting point of the polygon at the end of the array. Drawing a filled polygon,\nhowever, joins the starting and ending points.\n155\n030-4s CH09.i 155 1\/29\/96, 9:30 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 MTWRFSS\nDDAAYY\n9 Graphics, Fonts, and Color\nThe second way of calling drawPolygon and fillPolygon is to use a Polygon object. The Polygon\nclass is useful if you intend to add points to the polygon or if you\u2019re building the polygon on the\nfly. The Polygon class enables you to treat the polygon as an object rather than having to deal\nwith individual arrays.\nTo create a polygon object you can either create an empty polygon:\nPolygon poly = new Polygon();\nor create a polygon from a set of points using integer arrays, as in the previous example:\nint exes[] = { 39,94,97,142,53,58,26 };\nint whys[] = { 33,74,36,70,108,80,106 };\nint pts = exes.length;\nPolygon poly = new Polygon(exes,whys,pts);\nOnce you have a polygon object, you can append points to the polygon as you need to:\npoly.addPoint(20,35);\nThen, to draw the polygon, just use the polygon object as an argument to drawPolygon or\nfillPolygon. Here\u2019s that previous example, rewritten this time with a Polygon object. You\u2019ll also\nfill this polygon rather than just drawing its outline (Figure 9.8 shows the output):\npublic void paint(Graphics g) {\nint exes[] = { 39,94,97,142,53,58,26 };\nint whys[] = { 33,74,36,70,108,80,106 };\nint pts = exes.length;\nPolygon poly = new Polygon(exes,whys,pts);\ng.fillPolygon(poly);\n}\nFigure 9.8.\nAnother polygon.\nOvals\nUse ovals to draw ellipses or circles. Ovals are just like rectangles with overly rounded corners.\nIn fact, you draw them using the same four arguments: the x and y of the top corner, and the\n156\n030-4s CH09.i 156 1\/29\/96, 9:31 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 Sams.net Learning\nCenter\nabcd\nwidth and height of the oval itself. Note that, because you\u2019re drawing an oval, the starting point\nis some distance to the left and up from the actual outline of the oval itself. Again, if you think\nof it as a rectangle, it\u2019s easier to place.\nAs with the other drawing operations, the drawOval method draws an outline of an oval, and the\nfillOval method draws a filled oval.\nHere\u2019s an example of two ovals, a circle and an ellipse (Figure 9.9 shows how these two ovals\n9\nappear on screen):\npublic void paint(Graphics g) {\ng.drawOval(20,20,60,60);\ng.fillOval(120,20,100,60);\n}\nFigure 9.9.\nOvals.\nArc\nOf the drawing operations, arcs are the most complex to construct, which is why I saved them\nfor last. An arc is a part of a oval; in fact, the easiest way to think of an arc is as a section of a\ncomplete oval. Figure 9.10 shows some arcs.\nFigure 9.10.\nArcs.\n157\n030-4s CH09.i 157 1\/29\/96, 9:31 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 MTWRFSS\nDDAAYY\n9 Graphics, Fonts, and Color\nThe drawArc method takes six arguments: the starting corner, the width and height, the angle\nat which to start the arc, and the degrees to draw it before stopping. Once again, there is a drawArc\nmethod to draw the arc\u2019s outline and the fillArc to fill the arc. Filled arcs are drawn as if they\nwere sections of a pie; instead of joining the two endpoints, both endpoints are joined to the\ncenter of the circle.\nThe important thing to understand about arcs is that you\u2019re actually formulating the arc as an\noval and then drawing only some of that. The starting corner and width and height are not the\nstarting point and width and height of the actual arc as drawn on the screen; they\u2019re the width\nand height of the full ellipse of which the arc is a part. Those first points determine the size and\nshape of the arc; the last two arguments (for the degrees) determine the starting and ending\npoints.\nLet\u2019s start with a simple arc, a C shape on a circle as shown in Figure 9.11.\nFigure 9.11.\nA C arc.\nTo construct the method to draw this arc, the first thing you do is think of it as a complete circle.\nThen you find the x and y coordinates and the width and height of that circle. Those four values\nare the first four arguments to the drawArc or fillArc methods. Figure 9.12 shows how to get\nthose values from the arc.\nFigure 9.12. 100\nConstructing a circular arc.\n100\n158\n030-4s CH09.i 158 1\/29\/96, 9:32 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 Sams.net Learning\nCenter\nabcd\nTo get the last two arguments, think in degrees around the circle. Zero degrees is at 3 o\u2019clock,\n90 degrees is at 12 o\u2019clock, 180 at 9 o\u2019clock, and 270 at 6 o\u2019clock. The start of the arc is the degree\nvalue of the start of the arc. In this example, the starting point is the top of the C at 90 degrees;\n90 is the fifth argument.\nThe sixth and last argument is another degree value indicating how far around the circle to sweep\nand the direction to go in (it\u2019s not the ending degree angle, as you might think). In this case,\nbecause you\u2019re going halfway around the circle, you\u2019re sweeping 180 degrees\u2014and 180 is 9\ntherefore the last argument in the arc. The important part is that you\u2019re sweeping 180 degrees\ncounterclockwise, which is in the positive direction in Java. If you are drawing a backwards C,\nyou sweep 180 degrees in the negative direction, and the last argument is \u2013180. See Figure 9.13\nfor the final illustration of how this works.\nNote: It doesn\u2019t matter which side of the arc you start with; because the shape of\nthe arc has already been determined by the complete oval it\u2019s a section of, starting\nat either endpoint will work.\nFigure 9.13. 90\u00b0\nArcs on circles.\n90\u00b0\n180\u00b0 0\u00b0\n180\u00b0\n270\u00b0\nHere\u2019s the code for this example; you\u2019ll draw an outline of the C and a filled C to its right, as\nshown in Figure 9.14:\npublic void paint(Graphics g) {\ng.drawArc(20,20,60,60,90,180);\ng.fillArc(120,20,60,60,90,180);\n}\nCircles are an easy way to visualize arcs on circles; arcs on ellipses are slightly more difficult. Let\u2019s\ngo through this same process to draw the arc shown in Figure 9.15.\n159\n030-4s CH09.i 159 1\/29\/96, 9:32 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 MTWRFSS\nDDAAYY\n9 Graphics, Fonts, and Color\nFigure 9.14.\nTwo circular arcs.\nFigure 9.15.\nAn elliptical arc.\nLike the arc on the circle, this arc is a piece of a complete oval, in this case, an elliptical oval. By\ncompleting the oval that this arc is a part of, you can get the starting points and the width and\nheight arguments for the drawArc or fillArc method (Figure 9.16).\nFigure 9.16. 140\nArcs on ellipses.\n30\nThen, all you need is to figure out the starting angle and the angle to sweep. This arc doesn\u2019t\nstart on a nice boundary such as 90 or 180 degrees, so you\u2019ll need some trial and error. This arc\nstarts somewhere around 25 degrees, and then sweeps clockwise about 130 degrees (Figure\n9.17).\nFigure 9.17. 90\u00b0\nStarting and ending points.\n25\u00b0\n180\u00b0 0\u00b0\n-130\u00b0\n270\u00b0\n160\n030-4s CH09.i 160 1\/29\/96, 9:33 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 Sams.net Learning\nCenter\nabcd\nWith all portions of the arc in place, you can write the code. Here\u2019s the Java code for this arc,\nboth drawn and filled (note in the filled case how filled arcs are drawn as if they were pie sections):\npublic void paint(Graphics g) {\ng.drawArc(10,20,150,50,25,-130);\ng.fillArc(10,80,150,50,25,-130);\n}\nFigure 9.18 shows the two elliptical arcs.\n9\nFigure 9.18.\nTwo elliptical arcs.\nTo summarize, here are the steps to take to construct arcs in Java:\nnn Think of the arc as a slice of a complete oval.\nnn Construct the full oval with the starting point and the width and height (it often helps\nto draw the full oval on the screen to get an idea of the right positioning).\nnn Determine the starting angle for the beginning of the arc.\nnn Determine how far to sweep the arc and in which direction (counterclockwise\nindicates positive values, clockwise indicates negatives).\nA Simple Graphics Example\nHere\u2019s an example of an applet that uses many of the built-in graphics primitives to draw a\nrudimentary shape. In this case, it\u2019s a lamp with a spotted shade (or a sort of cubist mushroom,\ndepending on your point of view). Listing 9.1 has the complete code for the lamp; Figure 9.19\nshows the resulting applet.\n161\n030-4s CH09.i 161 1\/29\/96, 9:33 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 MTWRFSS\nDDAAYY\n9 Graphics, Fonts, and Color\nFigure 9.19.\nThe Lamp applet.\nType\nListing 9.1. The Lamp class.\n1: import java.awt.*;\n2:\n3: public class Lamp extends java.applet.Applet {\n4:\n5: public void paint(Graphics g) {\n6: \/\/ the lamp platform\n7: g.fillRect(0,250,290,290);\n8:\n9: \/\/ the base of the lamp\n10: g.drawLine(125,250,125,160);\n11: g.drawLine(175,250,175,160);\n12:\n13: \/\/ the lamp shade, top and bottom edges\n14: g.drawArc(85,157,130,50,-65,312);\n15: g.drawArc(85,87,130,50,62,58);\n16:\n17: \/\/ lamp shade, sides\n18: g.drawLine(85,177,119,89);\n19: g.drawLine(215,177,181,89);\n20:\n21: \/\/ dots on the shade\n22: g.fillArc(78,120,40,40,63,-174);\n162\n030-4s CH09.i 162 1\/29\/96, 9:34 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 Sams.net Learning\nCenter\nabcd\n23: g.fillOval(120,96,40,40);\n24: g.fillArc(173,100,40,40,110,180);\n25: }\n26: }\nCopying and Clearing\n9\nOnce you\u2019ve drawn a few things on the screen, you may want to move them around or clear the\nentire applet. The Graphics class provides methods for doing both these things.\nThe copyArea method copies a rectangular area of the screen to another area of the screen.\ncopyArea takes six arguments: the x and y of the top corner of the rectangle to copy, the width\nand the height of that rectangle, and the distance in the x and y directions to which to copy it.\nFor example, this line copies a square area 100 pixels on a side 100 pixels directly to its right:\ng.copyArea(0,0,100,100,100,0);\nTo clear a rectangular area, use the clearRect method. clearRect, which takes the same four\narguments as the drawRect and fillRect methods, fills the given rectangle with the current\nbackground color of the applet (you\u2019ll learn how to set the current background color later on\ntoday).\nTo clear the entire applet, you can use the size() method, which returns a Dimension object\nrepresenting the width and height of the applet. You can then get to the actual values for width\nand height by using the width and height instance variables:\ng.clearRect(0,0,this.size().width,this.height());\nText and Fonts\nThe Graphics class also enables you to print text on the screen, in conjunction with the Font class,\nand, sometimes, the Font metrics class. The Font class represents a given font\u2014its name, style,\nand point size\u2014and Font metrics gives you information about that font (for example, the actual\nheight or width of a given character) so that you can precisely lay out text in your applet.\nNote that the text here is static text, drawn to the screen once and intended to stay there. You\u2019ll\nlearn about entering text from the keyboard later on this week.\nCreating Font Objects\nTo draw text to the screen, first you need to create an instance of the Font class. Font objects\nrepresent an individual font\u2014that is, its name, style (bold, italic), and point size. Font names\nare strings representing the family of the font, for example, \u201cTimesRoman\u201d, \u201cCourier\u201d, or\n163\n030-4s CH09.i 163 1\/29\/96, 9:34 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 MTWRFSS\nDDAAYY\n9 Graphics, Fonts, and Color\n\u201cHelvetica\u201d. Font styles are constants defined by the Font class; you can get to them using class\nvariables\u2014for example, Font.PLAIN, Font.BOLD, or Font.ITALIC. Finally, the point size is the size\nof the font, as defined by the font itself; the point size may or may not be the height of the\ncharacters.\nTo create an individual font object, use these three arguments to the Font class\u2019s new constructor:\nFont f = new Font(\u201cTimesRoman\u201d, Font.BOLD, 24);\nThis example creates a font object for the TimesRoman BOLD font, in 24 points. Note that like most\nJava classes, you have to import this class before you can use it.\nFont styles are actually integer constants that can be added to create combined styles; for\nexample, Font.BOLD + Font.ITALIC produces a font that is both bold and italic.\nThe fonts you have available to you in your applet depend on the system on which the applet\nis running. Currently, although there is a mechanism in Java to get a list of fonts (see the\ngetFontList method, defined in the java.awt.Toolkit class), it appears not to be working\ncurrently in the beta version of the JDK. Once these capabilities work, it is possible to get a list\nof fonts on the system and to be able to make choices based on that list; for now, to make sure\nyour applet is completely compatible across systems, it\u2019s a very good idea to limit the fonts you\nuse in your applets to \u201cTimesRoman\u201d, \u201cHelvetica\u201d, and \u201cCourier\u201d. If Java can\u2019t find a font you\nwant to use, it will substitute some default font, usually Courier.\nDrawing Characters and Strings\nWith a font object in hand, you can draw text on the screen using the methods drawChars and\ndrawString. First, though, you need to set the current font to your font object using the setFont\nmethod.\nThe current font is part of the graphics state that is kept track of by the Graphics object on which\nyou\u2019re drawing. Each time you draw a character or a string to the screen, that text is drawn by\nusing the current font. To change the font of the text, first change the current font. Here\u2019s a\npaint() method that creates a new font, sets the current font to that font, and draws the string\n\u201cThis is a big font.\u201d, starting from the point 10,100.\npublic void paint(Graphics g) {\nFont f = new Font(\u201cTimesRoman\u201d, Font.PLAIN,72);\ng.setFont(f);\ng.drawString(\u201cThis is a big font.\u201d,10,100);\n}\nThis should all look familiar to you; this is how the Hello applets throughout this book were\nproduced.\nThe latter two arguments to drawString determine the point where the string will start. The x\nvalue is the start of the leftmost edge of the text; y is the baseline for the entire string.\n164\n030-4s CH09.i 164 1\/29\/96, 9:35 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 Sams.net Learning\nCenter\nabcd\nSimilar to drawString is the drawChars method that, instead of taking a string as an argument,\ntakes an array of characters. drawChars has five arguments: the array of characters, an n integer\nrepresenting the first character in the array to draw, another integer for the last character in the\narray to draw (all characters between the first and last are drawn), and the x and y for the starting\npoint. Most of the time, drawString is more useful than drawChars.\nListing 9.2 shows an applet that draws several lines of text in different fonts; Figure 9.20 shows\nthe result. 9\nType\nListing 9.2. Many different fonts.\n1: import java.awt.Font;\n2: import java.awt.Graphics;\n3:\n4: public class ManyFonts extends java.applet.Applet {\n5:\n6: public void paint(Graphics g) {\n7: Font f = new Font(\u201cTimesRoman\u201d, Font.PLAIN, 18);\n8: Font fb = new Font(\u201cTimesRoman\u201d, Font.BOLD, 18);\n9: Font fi = new Font(\u201cTimesRoman\u201d, Font.ITALIC, 18);\n10: Font fbi = new Font(\u201cTimesRoman\u201d, Font.BOLD + Font.ITALIC, 18);\n11:\n12: g.setFont(f);\n13: g.drawString(\u201cThis is a plain font\u201d, 10, 25);\n14: g.setFont(fb);\n15: g.drawString(\u201cThis is a bold font\u201d, 10, 50);\n16: g.setFont(fi);\n17: g.drawString(\u201cThis is an italic font\u201d, 10, 75);\n18: g.setFont(fbi);\n19: g.drawString(\u201cThis is a bold italic font\u201d, 10, 100);\n20: }\n21:\n22: }\nFigure 9.20.\nThe output of the\nManyFonts applet.\n165\n030-4s CH09.i 165 1\/29\/96, 9:35 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 MTWRFSS\nDDAAYY\n9 Graphics, Fonts, and Color\nFinding Out Information About a Font\nSometimes, you may want to make decisions in your Java program based on the qualities of the\ncurrent font\u2014for example, its point size, or the total height of its characters. You can find out\nsome basic information about fonts and font objects by using simple methods on Graphics and\non the Font objects. Table 9.1 shows some of these methods:\nTable 9.1. Font methods.\nMethod Name In Object Action\ngetFont() Graphics Returns the current font object as previously set by\nsetFont()\ngetName() Font Returns the name of the font as a string\ngetSize() Font Returns the current font size (an integer)\ngetStyle() Font Returns the current style of the font (styles are integer\nconstants: 0 is plain, 1 is bold, 2 is italic, 3 is bold italic)\nisPlain() Font Returns true or false if the font\u2019s style is plain\nisBold() Font Returns true or false if the font\u2019s style is bold\nisItalic() Font Returns true or false if the font\u2019s style is italic\nFor more detailed information about the qualities of the current font (for example, the length\nor height of given characters), you need to work with font metrics. The FontMetrics class\ndescribes information specific to a given font: the leading between lines, the height and width\nof each character, and so on. To work with these sorts of values, you create a FontMetrics object\nbased on the current font by using the applet method getFontMetrics:\nFont f = new Font(\u201cTimesRoman\u201d, Font.BOLD, 36);\nFontMetrics fmetrics = getFontMetrics(f);\ng.setfont(f);\nTable 9.2 shows some of the things you can find out using font metrics. All these methods should\nbe called on a FontMetrics object.\nTable 9.2. Font metrics methods.\nMethod Name Action\nstringWidth() Given a string, returns the full width of that string, in pixels\ncharWidth() Given a character, returns the width of that character\n166\n030-4s CH09.i 166 1\/29\/96, 9:36 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 Sams.net Learning\nCenter\nabcd\nMethod Name Action\ngetAscent() Returns the ascent of the font, that is, the distance between the\nfont\u2019s baseline and the top of the characters\ngetDescent() Returns the descent of the font\u2014that is, the distance between the\nfont\u2019s baseline and the bottoms of the characters (for characters such\nas p and q that drop below the baseline)\ngetLeading() Returns the leading for the font, that is, the spacing betweenthe 9\ndescent of one line and the ascent of another line\ngetHeight() Returns the total height of the font, which is the sum of the ascent,\ndescent, and leading value\nAs an example of the sorts of information you can use with font metrics, Listing 9.3 shows the\nJava code for an applet that automatically centers a string horizontally and vertically inside an\napplet. The centering position is different depending on the font and font size; by using font\nmetrics to find out the actual size of a string, you can draw the string in the appropriate place.\nNote the applet.size() method here, which returns the width and height of the overall applet\narea as a Dimension object. You can then get to the individual width and height by using the width\nand height instance variables.\nFigure 9.21 shows the result (less interesting than if you actually compile and experiment with\nvarious applet sizes).\nType\nListing 9.3. Centering a string.\n1: import java.awt.Font;\n2: import java.awt.Graphics;\n3: import java.awt.FontMetrics;\n4:\n5: public class Centered extends java.applet.Applet {\n6:\n7: public void paint(Graphics g) {\n8: Font f = new Font(\u201cTimesRoman\u201d, Font.PLAIN, 36);\n9: FontMetrics fm = getFontMetrics(f);\n10: g.setFont(f);\n11:\n12: String s = \u201cThis is how the world ends.\u201d;\n13: int xstart = (this.size().width - fm.stringWidth(s)) \/ 2;\n14: int ystart = (this.size().height - fm.getHeight()) \/ 2;\n15:\n16: g.drawString(s, xstart, ystart);\n17: }\n18:}\n167\n030-4s CH09.i 167 1\/29\/96, 9:37 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 MTWRFSS\nDDAAYY\n9 Graphics, Fonts, and Color\nFigure 9.21.\nThe centered text.\nColor\nDrawing black lines and tests on a gray background is all very nice, but being able to use different\ncolors is much nicer. Java provides methods and behaviors for dealing with color in general\nthrough the Color class, and also provides methods for setting the current foreground and\nbackground colors so that you can draw with the colors you created.\nJava\u2019s abstract color model uses 24-bit color, wherein a color is represented as a combination of\nred, green, and blue values. Each component of the color can have a number between 0 and 255.\n0,0,0 is black, 255,255,255 is white, and Java can represent millions of colors between as well.\nJava\u2019s abstract color model maps onto the color model of the platform Java is running on, which\nusually has only 256 colors or fewer from which to choose. If a requested color in a color object\nis not available for display, the resulting color may be mapped to another or dithered, depending\non how the browser viewing the color implemented it, and depending on the platform on which\nyou\u2019re running. In other words, although Java gives the capability of managing millions of\ncolors, very few may actually be available to you in real life.\nUsing Color Objects\nTo draw an object in a particular color, you must create an instance of the Color class to represent\nthat color. The Color class defines a set of standard color objects, stored in class variables, that\nenable you quickly to get a color object for some of the more popular colors. For example,\nColor.red gives you a Color object representing red (RGB values of 255, 0, and 0), Color.white\ngives you a white color (RGB values of 255, 255, and 255), and so on. Table 9.3 shows the\nstandard colors defined by variables in the Color class.\nTable 9.3. Standard colors.\nColor Name RGB Value\nColor.white 255,255,255\nColor.black 0,0,0\nColor.lightGray 192,192,192\nColor.gray 128,128,128\nColor.darkGray 64,64,64\n168\n030-4s CH09.i 168 1\/29\/96, 9:37 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 Sams.net Learning\nCenter\nabcd\nColor Name RGB Value\nColor.red 255,0,0\nColor.green 0,255,0\nColor.blue 0,0,255\nColor.yellow 255,255,0\nColor.magenta 255,0,255\n9\nColor.cyan 0,255,255\nColor.pink 255,175,175\nColor.orange 255,200,0\nIf the color you want to draw in is not one of the standard color objects, fear not. You can create\na color object for any combination of red, green, and blue, as long as you have the values of the\ncolor you want. Just create a new color object:\nColor c = new Color(140,140,140);\nThis line of Java code creates a color object representing a dark grey. You can use any\ncombination of red, green, and blue values to construct a color object.\nAlternatively, you can also create a color object using three floats from 0.0 to 1.0:\nColor c = new Color(0.34,1.0,0.25)\nTesting and Setting the Current Colors\nTo draw an object or text using a color object, you have to set the current color to be that color\nobject, just as you have to set the current font to the font in which you want to draw. Use the\nsetColor method (a method for Graphics objects) to do this:\ng.setColor(Color.green);\nAfter setting the current color, all drawing operations will occur in that color.\nIn addition to setting the current color for the graphics context, you can also set the background\nand foreground colors for the applet itself by using the setBackground and setForeground\nmethods. Both of these methods are defined in the java.awt.Component class, which Applet\u2014\nand therefore your classes\u2014automatically inherits.\nThe setBackground method sets the background color of the applet, which is usually a dark grey.\nIt takes a single argument, a color object:\nsetBackground(Color.white);\n169\n030-4s CH09.i 169 1\/29\/96, 9:38 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 MTWRFSS\nDDAAYY\n9 Graphics, Fonts, and Color\nThe setForeground method also takes a single color as an argument, and affects everything that\nhas been drawn on the applet, regardless of the color in which it has been drawn. You can use\nsetForeground to change the color of everything in the applet at once, rather than having to\nredraw everything:\nsetForeground(Color.black);\nIn addition to the setColor, setForeground, and setBackground methods, there are correspond-\ning \u201cget\u201d methods that enable you to retrieve the current graphics color, background, or\nforeground. Those methods are getColor (defined in Graphics objects), getForeground (defined\nin Applet), and getBackground (also in Applet). You can use these methods to choose colors\nbased on existing colors in the applet:\nsetForeground(g.getColor());\nA Single Color Example\nListing 9.4 shows the code for an applet that fills the applet\u2019s drawing area with square boxes,\neach of which has a randomly chosen color in it. It\u2019s written so that it can handle any size of applet\nand automatically fill the area with the right number of boxes.\nType\nListing 9.4. Random color boxes.\n1: import java.awt.Graphics;\n2: import java.awt.Color;\n3:\n4: public class ColorBoxes extends java.applet.Applet {\n5:\n6: public void paint(Graphics g) {\n7: int rval, gval, bval;\n8:\n9: for (int j = 30; j < (this.size().height -25); j += 30)\n10: for (int i = 5; i < (this.size().width -25); i+= 30) {\n11: rval = (int)Math.floor(Math.random() * 256);\n12: gval = (int)Math.floor(Math.random() * 256);\n13: bval = (int)Math.floor(Math.random() * 256);\n14:\n15: g.setColor(new Color(rval,gval,bval));\n16: g.fillRect(i,j,25,25);\n17: g.setColor(Color.black);\n18: g.drawRect(i-1,j-1,25,25);\n19: }\n20: }\n21: }\nAnalysis The two for loops are the heart of this example; the first one draws the rows, and the second\ndraws the individual boxes within the row. When a box is drawn, the random color is\n170\n030-4s CH09.i 170 1\/29\/96, 9:39 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 Sams.net Learning\nCenter\nabcd\ncalculated first, and then the box is drawn. A black outline is drawn around each box, because\nsome of them tend to blend into the background of the applet.\nBecause this paint method generates new colors each time the applet is painted, you can\nregenerate the colors by moving the window around or by covering the applet\u2019s window with\nanother one. Figure 9.22 shows the final applet (although given that this picture is black and\nwhite, you can\u2019t get the full effect of the multicolored squares).\n9\nFigure 9.22.\nThe random colors applet.\nSummary\nYou present something on the screen by painting inside your applet: shapes, graphics, text, or\nimages. Today, you learned the basics of how to paint, including using the graphics primitives\nto draw rudimentary shapes, using fonts and font metrics to draw text, and using Color objects\nto change the color of what you\u2019re drawing on the screen. It\u2019s this foundation in painting that\nenables you to do animation inside an applet (which basically involves just painting repeatedly\nto the screen) and to work with images. These are topics you\u2019ll learn about tomorrow.\nQ&A\nQ In all the examples you show, and in all the tests I\u2019ve made, the graphics primi-\ntives, such as drawLine and drawRect, produce lines that are one pixel wide. How\ncan I draw thicker lines?\nA In the current state of the Java Graphics class, you can\u2019t; no methods exist for chang-\ning the default line width. If you really need a thicker line, you have to draw multiple\nlines one pixel apart to produce that effect.\nQ I wrote an applet to use Helvetica. It worked fine on my system, but when I run\nit on my friend\u2019s system, everything is in Courier. Why?\n171\n030-4s CH09.i 171 1\/29\/96, 9:39 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 MTWRFSS\nDDAAYY\n9 Graphics, Fonts, and Color\nA Your friend most likely doesn\u2019t have the Helvetica font installed on his or her system.\nWhen Java can\u2019t find a font, it substitutes a default font instead\u2014in your case,\nCourier. The best way to deal with this is to query the font list. As I\u2019m writing this,\nhowever, querying the font list doesn\u2019t yet work, so your safest bet is to stick with\neither Times Roman or Courier in your applets.\nQ I tried out that applet that draws boxes with random colors, but each time it\ndraws, a lot of the boxes are the same color. If the colors are truly random, why is\nit doing this?\nA Two reasons. The first is that the random number generator I used in that code (from\nthe Math class) isn\u2019t a very good random number generator; in fact, the documentation\nfor that method says as much. For a better random number generator, use the Random\nclass from the java.util package.\nThe second, more likely, reason is that there just aren\u2019t enough colors available in your\nbrowser or on your system to draw all the colors that the applet is generating. If your\nsystem can\u2019t produce the wide range of colors available using the Color class, or if the\nbrowser has allocated too many colors for other things, you may end up with duplicate\ncolors in the boxes, depending on how the browser and the system has been written to\nhandle that. Usually your applet won\u2019t use quite so many colors, so you won\u2019t run\ninto this problem quite so often.\n172\n030-4s CH09.i 172 1\/29\/96, 9:40 PM\nP2\/V4sqc 6 TY Java in 21 Days 030-4 ayanna 12.15.95 Ch 9 LP#3 Sams.net Learning\nCenter\nabcd\n10\n10\n10\nS\nS\nWEEK\nF 2\nR\nW\nSimple Animation\nT\nand Threads\nM\nby Laura Lemay\n173\n030-4s CH10.i 173 1\/29\/96, 9:42 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 10 LP#3 MTWRFSS\nDDAAYY\n10 Simple Animation and Threads\nThe first thing I ever saw Java do was an animation: a large red \u201cHi there!\u201d that ran across the\nscreen from the right to left. Even that simple form of animation was enough to make me stop\nand think, \u201cthis is really cool.\u201d\nThat sort of simple animation takes only a few methods to implement in Java, but those few\nmethods are the basis for any Java applet that you want to update the screen dynamically.\nStarting with simple animations is a good way to build up to the more complicated applets.\nToday, you\u2019ll learn the fundamentals of animation in Java: how the various parts of the system\nall work together so that you can create moving figures and dynamic updateable applets.\nSpecifically, you\u2019ll explore the following:\nnn How Java animations work\u2014the paint() and repaint() methods, starting and\nstopping dynamic applets, and how to use and override these methods in your own\napplets\nnn Threads\u2014what they are and how they can make your applets more well-behaved with\nother applets and with the Java system in general\nnn Reducing animation flicker, a common problem with animation in Java\nThroughout today, you\u2019ll also work with lots of examples of real applets that create animations\nor perform some kind of dynamic movement.\nCreating Animation in Java\nAnimation in Java involves two steps: constructing a frame of animation, and then asking Java\nto paint that frame. Repeat as necessary to create the illusion of movement. The basic, static\napplets that you created yesterday taught you how to accomplish the first part; all that\u2019s left is\nhow to tell Java to paint a frame.\nPainting and Repainting\nThe paint() method, as you learned yesterday, is called by Java whenever the applet needs to\nbe painted\u2014when the applet is initially drawn, when the window containing it is moved, or\nwhen another window is moved from over it. You can also, however, ask Java to repaint the\napplet at a time you choose. So, to change the appearance of what is on the screen, you construct\nthe image or \u201cframe\u201d you want to paint, and then ask Java to paint this frame. If you do this\nrepeatedly, and fast enough, you get animation inside your Java applet. That\u2019s all there is to it.\nWhere does all this take place? Not in the paint() method itself. All paint() does is put dots\non the screen. paint(), in other words, is responsible only for the current frame of the animation\nat a time. The real work of changing what paint() does, of modifying the frame for an\nanimation, actually occurs somewhere else in the definition of your applet.\n174\n030-4s CH10.i 174 1\/29\/96, 9:43 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 10 LP#3 Sams.net Learning\nCenter\nabcd\nIn that \u201csomewhere else,\u201d you construct the frame (set variables for paint() to use, create color\nor font or other objects that paint() will need), and then call the repaint() method. repaint()\nis the trigger that causes Java to call paint() and causes your frame to get drawn.\nTechnical Note: Because a Java applet can contain many different components\nthat all need to be painted (as you\u2019ll learn later on this week), and in fact, applets\nare embedded inside a larger Java application that also paints to the screen in\nsimilar ways, when you call repaint() (and therefore paint()) you\u2019re not actually\nimmediately drawing to the screen as you do in other window or graphics toolkits.\nInstead, repaint() is a request for Java to repaint your applet as soon as it can.\nMuch of the time, the delay between the call and the actual repaint is negligible.\n10\nStarting and Stopping\nan Applet\u2019s Execution\nRemember start() and stop() from Day 8? These are the methods that trigger your applet to\nstart and stop running. You didn\u2019t use start() and stop() yesterday, because the applets on that\nday did nothing except paint once. With animations and other Java applets that are actually\nprocessing and running over time, you\u2019ll need to make use of start() and stop() to trigger the\nstart of your applet\u2019s execution, and to stop it from running when you leave the page that\ncontains that applet. For most applets, you\u2019ll want to override start and stop for just this reason.\nThe start() method triggers the execution of the applet. You can either do all the applet\u2019s work\ninside that method, or you can call other object\u2019s methods in order to do so. Usually, start()\nis used to create and begin execution of a thread so the applet can run in its own time.\nstop(), on the other hand, suspects an applet\u2019s execution so when you move off the page on\nwhich the applet is displaying, it doesn\u2019t keep running and using up system resources. Most of\nthe time when you create a start() method, you should also create a corresponding stop().\nPutting It Together\nExplaining how to do Java animation in text is more of a task than actually showing you how\nit works in code. An example or two will help make the relationship between all these methods\nclearer.\nListing 10.1 shows a sample applet that, at first glance, uses basic applet animation to display\nthe date and time and constantly updates it every second, creating a very simple animated digital\nclock (a frame from that clock is shown in Figure 10.1).\n175\n030-4s CH10.i 175 1\/29\/96, 9:44 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 10 LP#3 MTWRFSS\nDDAAYY\n10 Simple Animation and Threads\nThe words \u201cat first glance\u201d in the previous paragraph are very important: this applet doesn\u2019t\nwork! However, despite the fact that it doesn\u2019t work, you can still learn a lot about basic\nanimation with it, so working through the code will still be valuable. In the next section, you\u2019ll\nlearn just what\u2019s wrong with it.\nSee whether you can figure out what\u2019s going on with this code before you go on to the analysis.\nType\nListing 10.1. The Date applet.\n1: import java.awt.Graphics;\n2: import java.awt.Font;\n3: import java.util.Date;\n4:\n5: public class DigitalClock extends java.applet.Applet {\n6:\n7: Font theFont = new Font(\u201cTimesRoman\u201d,Font.BOLD,24);\n8: Date theDate;\n9:\n10: public void start() {\n11: while (true) {\n12: theDate = new Date();\n13: repaint();\n14: try { Thread.sleep(1000); }\n15: catch (InterruptedException e) { }\n16: }\n17: }\n18:\n19: public void paint(Graphics g) {\n20: g.setFont(theFont);\n21: g.drawString(theDate.toString(),10,50);\n22: }\n23: }\nFigure 10.1.\nThe digital clock.\nAnalysis Think you\u2019ve got the basic idea? Let\u2019s go through it, line by line.\nLines 7 and 8 define two basic instance variables: theFont and theDate, which hold objects\nrepresenting the current font and the current date, respectively. More about these later.\n176\n030-4s CH10.i 176 1\/29\/96, 9:44 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 10 LP#3 Sams.net Learning\nCenter\nabcd\nThe start() method triggers the actual execution of the applet. Note the while loop inside this\nmethod; given that the test (true) always returns true, the loop never exits. A single animation\nframe is constructed inside that while loop, with the following steps:\nnn The Date class represents a date and time (Date is part of the java.util package\u2014note\nthat it was specifically imported in line three). Line 12 creates a new instance of the\nDate class, which holds the current date and time, and assigns it to the theDate\ninstance variable.\nnn The repaint() method is called.\nnn Lines 14 and 15, as complicated as they look, do nothing except pause for 1000\nmilliseconds (one second) before the loop repeats. The sleep() method there, part of\nthe Thread class, is what causes the applet to pause. Without a specific sleep()\nmethod, the applet would run as fast as it possibly could, which, for faster computer 10\nsystems, might be too fast for the eye to see. Using sleep() enables you to control\nexactly how fast the animation takes place. The try and catch stuff around it enables\nJava to manage errors if they occur. try and catch are called exceptions and are\ndescribed on Day 18, next week.\nOn to the paint() method. Here, inside paint(), all that happens is that the current font (in\nthe variable theFont) is set, and the date itself is printed to the screen (note that you have to call\nthe toString() method to convert the date to a string). Because paint() is called repeatedly with\nwhatever value happens to be in theDate, the string is updated every second to reflect the new\ndate.\nThere are a few things to note about this example. First, you might think it would be easier to\ncreate the new Date object inside the paint() method. That way you could use a local variable\nand not need an instance variable to pass the Date object around. Although doing things that\nway creates cleaner code, it also results in a less efficient program. The paint() method is called\nevery time a frame needs to be changed. In this case, it\u2019s not that important(), but in an\nanimation that needs to change frames very quickly, the paint() method has to pause to create\nthat new object every time. By leaving paint() to do what it does best\u2014painting the screen\u2014\nand calculating new objects before hand, you can make painting as efficient as possible. This is\nprecisely the same reason why the Font object is also in an instance variable.\nThreads: What They Are\nand Why You Need Them\nDepending on your experience with operating systems and with environments within those\nsystems, you may or may not have run into the concept of threads. Let\u2019s start from the beginning\nwith some definitions.\n177\n030-4s CH10.i 177 1\/29\/96, 9:45 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 10 LP#3 MTWRFSS\nDDAAYY\n10 Simple Animation and Threads\nWhen a program runs, it starts executing, runs its initialization code, calls methods or\nprocedures, and continues running and processing until it\u2019s complete or until the program is\nexited. That program uses a single thread\u2014where the thread is a single locus of control for the\nprogram.\nMultithreading, as in Java, enables several different execution threads to run at the same time\ninside the same program, in parallel, without interfering with each other.\nHere\u2019s a simple example. Suppose you have a long computation near the start of a program\u2019s\nexecution. This long computation may not be needed until later on in the program\u2019s\nexecution\u2014it\u2019s actually tangential to the main point of the program, but it needs to get done\neventually. In a single-threaded program, you have to wait for that computation to finish before\nthe rest of the program can continue running. In a multithreaded system, you can put that\ncomputation into its own thread, enabling the rest of the program to continue running\nindependently.\nUsing threads in Java, you can create an applet so that it runs in its own thread, and it will happily\nrun all by itself without interfering with any other part of the system. Using threads, you can\nhave lots of applets running at once on the same page. Depending on how many you have, you\nmay eventually exhaust the system so that all of them will run slower, but all of them will run\nindependently.\nEven if you don\u2019t have lots of applets, using threads in your applets is good Java programming\npractice. The general rule of thumb for well-behaved applets: whenever you have any bit of\nprocessing that is likely to continue for a long time (such as an animation loop, or a bit of code\nthat takes a long time to execute), put it in a thread.\nThe Problem with the Digital Clock Applet\nThat Digital Clock applet in the last section doesn\u2019t use threads. Instead, you put the while loop\nthat cycles through the animation directly into the start() method so that when the applet starts\nrunning it keeps going until you quit the browser or applet viewer. Although this may seem like\na good way to approach the problem, the digital clock won\u2019t work because the while loop in the\nstart() method is monopolizing all the resources in the system\u2014including painting. If you try\ncompiling and running the digital clock applet, all you get is a blank screen. You also won\u2019t be\nable to stop the applet, because there\u2019s no way a stop() method can ever be called.\nThe solution to this problem is to rewrite the applet to use threads. Threads enable this applet\nto animate on its own without interfering with other system operations, enable it to be started\nand stopped, and enable you to run it in parallel with other applets.\n178\n030-4s CH10.i 178 1\/29\/96, 9:45 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 10 LP#3 Sams.net Learning\nCenter\nabcd\nWriting Applets with Threads\nHow do you create an applet that uses threads? There are several things you need to do.\nFortunately, none of them are difficult, and a lot of the basics of using threads in applets is just\nboilerplate code that you can copy and paste from one applet to another. Because it\u2019s so easy,\nthere\u2019s almost no reason not to use threads in your applets, given the benefits.\nThere are four modifications you need to make to create an applet that uses threads:\nnn Change the signature of your applet class to include the words implements Runnable.\nnn Include an instance variable to hold this applet\u2019s thread.\nnn Modify your start() method to do nothing but spawn a thread and start it running.\nnn Create a run() method that contains the actual code that starts your applet running.\n10\nThe first change is to the first line of your class definition. You\u2019ve already got something like this:\npublic class MyAppletClass extends java.applet.Applet {\n...\n}\nYou need to change it to the following (I\u2019ve put it on two lines so it\u2019ll fit on this page; it can be\neither like this or on one line depending on your preference):\npublic class MyAppletClass extends java.applet.Applet implements Runnable {\n...\n}\nWhat does this do? It includes support for the Runnable interface in your applet. If you think\nway back to Day 2, you\u2019ll remember that interfaces are a way to collect method names common\nto different classes, which can then be mixed in and implemented inside different classes that\nneed to implement that behavior. Here, the Runnable interface includes the behavior your applet\nneeds to run a thread; in particular, it gives you a default definition for the run() method.\nThe second step is to add an instance variable to hold this applet\u2019s thread. Call it anything you\nlike; it\u2019s a variable of the type Thread (Thread is a class in java.lang, so you don\u2019t have to import\nit):\nThread runner;\nThird, add a start() method or modify the existing one so that it does nothing but create a new\nthread and start it running. Here\u2019s a typical example of a start() method:\npublic void start() {\nif (runner == null); {\nrunner = new Thread(this);\nrunner.start();\n}\n}\n179\n030-4s CH10.i 179 1\/29\/96, 9:45 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 10 LP#3 MTWRFSS\nDDAAYY\n10 Simple Animation and Threads\nIf you modify start() to do nothing but spawn a thread, where does the body of your applet\ngo? It goes into a new method, run(), which looks like this:\npublic void run() {\n\/\/ what your applet actually does\n}\nrun() can contain anything you want to run in the separate thread: initialization code, the actual\nloop for your applet, or anything else that needs to run in its own thread. You also can create\nnew objects and call methods from inside run(), and they\u2019ll also run inside that thread. The run\nmethod is the real heart of your applet.\nFinally, now that you\u2019ve got threads running and a start method to start them, you should add\na stop() method to suspend execution of that thread (and therefore whatever the applet is doing\nat the time) when the reader leaves the page. stop(), like start(), is usually something along\nthese lines:\npublic void stop() {\nif (runner != null) {\nrunner.stop();\nrunner = null;\n}\n}\nThe stop() method here does two things: it stops the thread from executing and also sets the\nthread\u2019s variable (runner) to null. Setting the variable to null makes the Thread object it\npreviously contained available for garbage collection so that the applet can be removed from\nmemory after a certain amount of time. If the reader comes back to this page and this applet,\nthe start method creates a new thread and starts up the applet once again.\nAnd that\u2019s it! Four basic modifications, and now you have a well-behaved applet that runs in its\nown thread.\nFixing The Digital Clock\nRemember the problems you had with the Digital Clock applet at the beginning of this section?\nLet\u2019s fix them so you can get an idea of how a real applet with threads looks. You\u2019ll follow the\nfour steps outlined in the previous section.\nFirst, modify the class definition to include the Runnable interface (the class is renamed to\nDigitalThreads instead of DigitalClock):\npublic class DigitalThreads extends java.applet.Applet\nimplements Runnable {\n...\nSecond, add an instance variable for the Thread:\nThread runner;\n180\n030-4s CH10.i 180 1\/29\/96, 9:46 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 10 LP#3 Sams.net Learning\nCenter\nabcd\nFor the third step, swap the way you did things. Because the bulk of the applet is currently in\na method called start(), but you want it to be in a method called run(), rather than do a lot\nof copying and pasting, just rename the existing start() to run():\npublic void run() {\nwhile (true) {\n...\nFinally, add the boilerplate start() and stop() methods:\npublic void start() {\nif (runner == null); {\nrunner = new Thread(this);\nrunner.start();\n}\n}\n10\npublic void stop() {\nif (runner != null) {\nrunner.stop();\nrunner = null;\n}\n}\nYou\u2019re finished! One applet converted to use threads in less than a minute flat. The code for the\nfinal applet appears in Listing 10.2.\nType\nListing 10.2. The fixed digital clock applet.\n1: import java.awt.Graphics;\n2: import java.awt.Font;\n3: import java.util.Date;\n4:\n5: public class DigitalThreads extends java.applet.Applet\n6: implements Runnable {\n7:\n8: Font theFont = new Font(\u201cTimesRoman\u201d,Font.BOLD,24);\n9: Date theDate;\n10: Thread runner;\n11:\n12: public void start() {\n13: if (runner == null); {\n14: runner = new Thread(this);\n15: runner.start();\n16: }\n17: }\n18:\n19: public void stop() {\n20: if (runner != null) {\n21: runner.stop();\n22: runner = null;\n23: }\n24: }\ncontinues\n181\n030-4s CH10.i 181 1\/29\/96, 9:46 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 10 LP#3 MTWRFSS\nDDAAYY\n10 Simple Animation and Threads\nListing 10.2. continued\n25:\n26: public void run() {\n27: while (true) {\n28: theDate = new Date();\n29: repaint();\n30: try { Thread.sleep(1000); }\n31: catch (InterruptedException e) { }\n32: }\n33: }\n34:\n35: public void paint(Graphics g) {\n36: g.setFont(theFont);\n37: g.drawString(theDate.toString(),10,50);\n38: }\n39: }\n40:\nReducing Animation Flicker\nIf you\u2019ve been following along with this book and trying the examples as you go, rather than\nreading this book on the airplane or in the bathtub, you may have noticed that when the date\nprogram runs every once in a while, there\u2019s an annoying flicker in the animation. (Not that\nthere\u2019s anything wrong with reading this book in the bathtub, but you won\u2019t see the flicker if\nyou do that, so just trust me\u2014there\u2019s a flicker.) This isn\u2019t a mistake or an error in the program;\nin fact, that flicker is a side effect of creating animations in Java. Because it is really annoying,\nhowever, you\u2019ll learn how to reduce flicker in this part of today\u2019s lesson so that your animations\nrun cleaner and look better on the screen.\nFlicker and How to Avoid It\nFlicker is caused by the way Java paints and repaints each frame of an applet. At the beginning\nof today\u2019s lesson, you learned that when you call the repaint() method, repaint() calls paint().\nThat\u2019s not precisely true. A call to paint() does indeed occur in response to a repaint(), but\nwhat actually happens are the following steps:\n1. The call to repaint() results in a call to the method update().\n2. The update() method clears the screen of any existing contents (in essence, fills it with\nthe current background color), and then calls paint().\n3. The paint() method then draws the contents of the current frame.\nIt\u2019s Step 2, the call to update(), that causes animation flicker. Because the screen is cleared\nbetween frames, the parts of the screen that don\u2019t change alternate rapidly between being painted\nand being cleared. Hence, flickering.\n182\n030-4s CH10.i 182 1\/29\/96, 9:47 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 10 LP#3 Sams.net Learning\nCenter\nabcd\nThere are two major ways to avoid flicker in your Java applets:\nnn Override update() either not to clear the screen at all, or to clear only the parts of the\nscreen you\u2019ve changed.\nnn Override both update() and paint(), and use double-buffering.\nIf the second way sounds complicated, that\u2019s because it is. Double-buffering involves drawing\nto an offscreen graphics surface and then copying that entire surface to the screen. Because it\u2019s\nmore complicated, you\u2019ll explore that one tomorrow. Today, let\u2019s cover the easier solution:\noverriding update.\nHow to Override Update\n10\nThe cause of flickering lies in the update() method. To reduce flickering, therefore, override\nboth update() and paint(). Here\u2019s what the default version of update() does (in the Component\nclass, which you\u2019ll learn more about on Day 13):\npublic void update(Graphics g) {\ng.setColor(getBackground());\ng.fillRect(0, 0, width, height);\ng.setColor(getForeground());\npaint(g);\n}\nBasically, update() clears the screen (or, to be exact, fills the applet\u2019s bounding rectangle with\nthe background color), sets things back to normal, and then calls paint(). When you override\nupdate(), you have to keep these two things in mind and make sure that your version of update()\ndoes something similar. In the next two sections, you\u2019ll work through some examples of\noverriding update() in different cases to reduce flicker.\nSolution One: Don\u2019t Clear the Screen\nThe first solution to reducing flicker is not to clear the screen at all. This works only for some\napplets, of course. Here\u2019s an example of an applet of this type. The ColorSwirl applet prints a\nsingle string to the screen (\u201cAll the swirly colors\u201d), but that string is presented in different\ncolors that fade into each other dynamically. This applet flickers terribly when it\u2019s run. Listing\n10.3 shows the source for this applet, and Figure 10.2 shows the result.\nType\nListing 10.3. The ColorSwirl applet.\n1: import java.awt.Graphics;\n2: import java.awt.Color;\n3: import java.awt.Font;\n4:\ncontinues\n183\n030-4s CH10.i 183 1\/29\/96, 9:48 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 10 LP#3 MTWRFSS\nDDAAYY\n10 Simple Animation and Threads\nListing 10.3. continued\n5: public class ColorSwirl extends java.applet.Applet\n6: implements Runnable {\n7:\n8: Font f = new Font(\u201cTimesRoman\u201d,Font.BOLD,48);\n9: Color colors[] = new Color[50];\n10: Thread runThread;\n11:\n12: public void start() {\n13: if (runThread == null) {\n14: runThread = new Thread(this);\n15: runThread.start();\n16: }\n17: }\n18:\n19: public void stop() {\n20: if (runThread != null) {\n21: runThread.stop();\n22: runThread = null;\n23: }\n24: }\n25:\n26: public void run() {\n27:\n28: \/\/ initialize the color array\n29: float c = 0;\n30: for (int i = 0; i < colors.length; i++) {\n31: colors[i] =\n32: Color.getHSBColor(c, (float)1.0,(float)1.0);\n33: c += .02;\n34: }\n35:\n36: \/\/ cycle through the colors\n37: int i = 0;\n38: while (true) {\n39: setForeground(colors[i]);\n40: repaint();\n41: i++;\n42: try { Thread.sleep(50); }\n43: catch (InterruptedException e) { }\n44: if (i == colors.length ) i = 0;\n45: }\n46: }\n47:\n48: public void paint(Graphics g) {\n49: g.setFont(f);\n50: g.drawString(\u201cAll the Swirly Colors\u201d, 15,50);\n51: }\n52: }\n184\n030-4s CH10.i 184 1\/29\/96, 9:48 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 10 LP#3 Sams.net Learning\nCenter\nabcd\nFigure 10.2.\nThe ColorSwirl applet.\nAnalysis There are three new things to note about this applet that might look strange to you:\nnn When the applet starts, the first thing you do (in lines 28 through 34) is to create an\narray of Color objects that contains all the colors the text will display. By creating all\nthe colors beforehand you can then just draw text in, one at a time; it\u2019s faster to\nprecompute all the colors at once.\nnn To create the different colors, a method in the Color class called getHSBColor() creates 10\na color object based on values for hue, saturation, and brightness, rather than the\nstandard red, green, and blue. This is easier; by incrementing the hue value and\nkeeping saturation and brightness constant you can create a range of colors without\nhaving to know the RGB for each one. If you don\u2019t understand this, don\u2019t worry\nabout it; it\u2019s just an easy way to create the color array.\nnn The applet then cycles through the array of colors, setting the foreground to each one\nin turn and calling repaint. When it gets to the end of the array, it starts over again\n(line 44), so the process repeats over and over ad infinitum.\nNow that you understand what the applet does, let\u2019s fix the flicker. Flicker here results because\neach time the applet is painted, there\u2019s a moment where the screen is cleared. Instead of the text\ncycling neatly from red to a nice pink to purple, it\u2019s going from red to grey, to pink to grey, to\npurple to grey, and so on\u2014not very nice looking at all.\nBecause the screen clearing is all that\u2019s causing the problem, the solution is easy: override\nupdate() and remove the part where the screen gets cleared. It doesn\u2019t really need to get cleared\nanyhow, because nothing is changing except the color of the text. With the screen clearing\nbehavior removed from update(), all update needs to do is call paint(). Here\u2019s what the\nupdate() method looks like in this applet:\npublic void update(Graphics g) {\npaint(g);\n}\nWith that\u2014with one small three-line addition\u2014no more flicker. Wasn\u2019t that easy?\n185\n030-4s CH10.i 185 1\/29\/96, 9:49 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 10 LP#3 MTWRFSS\nDDAAYY\n10 Simple Animation and Threads\nSolution Two: Redraw\nOnly What You Have To\nFor some applets, it won\u2019t be quite that easy. Here\u2019s another example. In this applet, called\nCheckers, a red oval (a checker piece) moves from a black square to a white square, as if on a\ncheckerboard. Listing 10.4 shows the code for this applet, and Figure 10.3 shows the applet\nitself.\nType\nListing 10.4. The Checkers applet.\n1: import java.awt.Graphics;\n2: import java.awt.Color;\n3:\n4: public class Checkers extends java.applet.Applet\n5: implements Runnable {\n6:\n7: Thread runner;\n8: int xpos;\n9:\n10: public void start() {\n11: if (runner == null); {\n12: runner = new Thread(this);\n13: runner.start();\n14: }\n15: }\n16:\n17: public void stop() {\n18: if (runner != null) {\n19: runner.stop();\n20: runner = null;\n21: }\n22: }\n23:\n24: public void run() {\n25: setBackground(Color.blue);\n26: while (true) {\n27: for (xpos = 5; xpos <= 105; xpos+=4) {\n28: repaint();\n29: try { Thread.sleep(100); }\n30: catch (InterruptedException e) { }\n31: }\n32: for (xpos = 105; xpos > 5; xpos -=4) {\n33: repaint();\n34: try { Thread.sleep(100); }\n35: catch (InterruptedException e) { }\n36: }\n37: }\n38: }\n39:\n40: public void paint(Graphics g) {\n41: \/\/ Draw background\n42: g.setColor(Color.black);\n186\n030-4s CH10.i 186 1\/29\/96, 9:49 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 10 LP#3 Sams.net Learning\nCenter\nabcd\n43: g.fillRect(0,0,100,100);\n44: g.setColor(Color.white);\n45: g.fillRect(101,0,100,100);\n46:\n47: \/\/ Draw checker\n48: g.setColor(Color.red);\n49: g.fillOval(xpos,5,90,90);\n50: }\n51: }\nFigure 10.3.\nThe Checkers applet.\n10\nAnalysis Here\u2019s a quick run-through of what this applet does: an instance variable, xpos, keeps track\nof the current starting position of the checker (because it moves horizontally, the y stays\nconstant and the x changes). In the run() method, you change the value of x and repaint,\nwaiting 50 milliseconds between each move. The checker moves from one side of the screen to\nthe other and then moves back (hence the two for loops in that method).\nIn the actual paint() method, the background squares are painted (one black and one white),\nand then the checker is drawn at its current position.\nThis applet, like the Swirling Colors applet, also has a terrible flicker. (In line 25, the background\nis blue to emphasize it, so if you run this applet you\u2019ll definitely see the flicker.)\nHowever, the solution to solving the flicker problem for this applet is more difficult than for the\nlast one, because you actually want to clear the screen before the next frame is drawn. Otherwise,\nthe red checker won\u2019t have the appearance of leaving one position and moving to another; it\u2019ll\njust leave a red smear from one side of the checkerboard to the other.\nHow do you get around this? You still clear the screen, in order to get the animation effect, but,\nrather than clearing the entire screen, you clear only the part that you actually changed. By\nlimiting the redraw to only a small area, you can eliminate much of the flicker you get from\nredrawing the entire screen.\n187\n030-4s CH10.i 187 1\/29\/96, 9:50 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 10 LP#3 MTWRFSS\nDDAAYY\n10 Simple Animation and Threads\nTo limit what gets redrawn, you need a couple of things. First, you need a way to restrict the\ndrawing area so that each time paint() is called, only the part that needs to get redrawn actually\ngets redrawn. Fortunately, this is easy by using a mechanism called clipping.\nNEW* Clipping, part of the graphics class, enables you to restrict the drawing area to a small\nTERM portion of the full screen; although the entire screen may get instructions to redraw, only\nthe portions inside the clipping area are actually drawn.\nThe second thing you need is a way to keep track of the actual area to redraw. Both the left and\nright edges of the drawing area change for each frame of the animation (one side to draw the new\noval, the other to erase the bit of the oval left over from the previous frame), so to keep track of\nthose two x values, you need instance variables for both the left side and the right.\nWith those two concepts in mind, let\u2019s start modifying the Checkers applet to redraw only what\nneeds to be redrawn. First, you\u2019ll add instance variables for the left and right edges of the drawing\narea. Let\u2019s call those instance variables ux1 and ux2 (u for update), where ux1 is the left side of\nthe area to draw and ux2 the right.\nint ux1,ux2;\nNow let\u2019s modify the run() method so that it keeps track of the actual area to be drawn, which\nyou would think is easy\u2014just update each side for each iteration of the animation. Here,\nhowever, things can get complicated because of the way Java uses paint() and repaint().\nThe problem with updating the edges of the drawing area with each frame of the animation is\nthat for every call to repaint() there may not be an individual corresponding paint(). If system\nresources get tight (because of other programs running on the system or for any other reason),\npaint() may not get executed immediately and several calls to paint() may queue up waiting\nfor their turn to change the pixels on the screen. In this case, rather than trying to make all those\ncalls to paint() in order (and be potentially behind all the time), Java catches up by executing\nonly the most recent call to paint() and skips all the others.\nIf you update the edges of the drawing area with each repaint(), and a couple of calls to paint()\nare skipped, you end up with bits of the drawing surface not being updated and bits of the oval\nleft behind. There\u2019s a simple way around this: update the leading edge of the oval each time the\nframe updates, but only update the trailing edge if the most recent paint has actually occurred.\nThis way, if a couple of calls to paint() get skipped, the drawing area will get larger for each\nframe, and when paint() finally gets caught up, everything will get repainted correctly.\nYes, this is horrifyingly complex. If I could have written this applet simpler, I would have, but\nwithout this mechanism the applet will not get repainted correctly. Let\u2019s step through it slowly\nin the code so you can get a better grasp of what\u2019s going on at each step.\nLet\u2019s start with run(), where each frame of the animation takes place. Here\u2019s where you calculate\neach side of the drawing area based on the old position of the oval and the new position of the\n188\n030-4s CH10.i 188 1\/29\/96, 9:51 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 10 LP#3 Sams.net Learning\nCenter\nabcd\noval. When the oval is moving toward the left side of the screen, this is easy. The value of ux1\n(the left side of the drawing area) is the previous oval\u2019s x position (xpos), and the value of ux2\nis the x position of the current oval plus the width of that oval (90 pixels in this example).\nHere\u2019s what the old run() method looked like, to refresh your memory:\npublic void run() {\nsetBackground(Color.blue);\nwhile (true) {\nfor (xpos = 5; xpos <= 105; xpos+=4) {\nrepaint();\ntry { Thread.sleep(100); }\ncatch (InterruptedException e) { }\n}\nfor (xpos = 105; xpos > 5; xpos -=4) {\nrepaint();\n10\ntry { Thread.sleep(100); }\ncatch (InterruptedException e) { }\n}\n}\n}\nIn the first for loop in the run() method, where the oval is moving towards the right, you first\nupdate ux2 (the right edge of the drawing area):\nux2 = xpos + 90;\nThen, after the repaint() has occurred, you update ux1 to reflect the old x position of the oval.\nHowever, you want to update this value only if the paint actually happened. How can you tell\nif the paint actually happened? You can reset ux1 in paint() to a given value (0), and then test\nto see whether you can update that value or whether you have to wait for the paint() to occur:\nif (ux1 == 0) ux1 = xpos;\nHere\u2019s the new, completed for loop for when the oval is moving to the right:\nfor (xpos = 5; xpos <= 105; xpos+=4) {\nux2 = xpos + 90;\nrepaint();\ntry { Thread.sleep(100); }\ncatch (InterruptedException e) { }\nif (ux1 == 0) ux1 = xpos;\n}\nWhen the oval is moving to the left, everything flips. ux1, the left side, is the leading edge of the\noval that gets updated every time, and ux2, the right side, has to wait to make sure it gets updated.\nSo, in the second for loop, you first update ux1 to be the x position of the current oval:\nux1 = xpos;\nThen, after the repaint() is called, you test to make sure the paint happened and update ux2:\nif (ux2 == 0) ux2 = xpos + 90;\n189\n030-4s CH10.i 189 1\/29\/96, 9:51 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 10 LP#3 MTWRFSS\nDDAAYY\n10 Simple Animation and Threads\nHere\u2019s the new version of the secod for loop inside run():\nfor (xpos = 105; xpos > 5; xpos -=4) {\nux1 = xpos;\nrepaint();\ntry { Thread.sleep(100); }\ncatch (InterruptedException e) { }\nif (ux2 == 0) ux2 = xpos + 90;\n}\nThose are the only modifications run() needs. Let\u2019s override update to limit the region that is\nbeing painted to the left and right edges of the drawing area that you set inside run(). To clip\nthe drawing area to a specific rectangle, use the clipRect() method. clipRect(), like drawRect(),\nfillRect(), and clearRect(), is defined for graphics objects and takes four arguments: x and\ny starting positions, and width and height of the region.\nHere\u2019s where ux1 and ux2 come into play. ux1 is the x point of the top corner of the region; then\nuse ux2 to get the width of the region by subtracting ux1 from that value. Finally, to finish\nupdate(), you call paint():\npublic void update(Graphics g) {\ng.clipRect(ux1, 5, ux2 - ux1, 95);\npaint(g);\n}\nNote that with the clipping region in place, you don\u2019t have to do anything to the actual paint()\nmethod. paint() goes ahead and draws to the entire screen each time, but only the areas inside\nthe clipping region actually get changed on screen.\nYou need to update the trailing edge of each drawing area inside paint() in case several calls to\npaint() were skipped. Because you are testing for a value of 0 inside run(), you merely reset ux1\nand ux2 to 0 after drawing everything:\nux1 = ux2 = 0;\nThose are the only changes you have to make to this applet in order to draw only the parts of\nthe applet that changed (and to manage the case where some frames don\u2019t get updated\nimmediately). Although this doesn\u2019t totally eliminate flickering in the animation, it does reduce\nit a great deal. Try it and see. Listing 10.5 shows the final code for the Checkers applet.\nType\nListing 10.5. The final Checkers applet.\n1: import java.awt.Graphics;\n2: import java.awt.Color;\n3:\n4: public class Checkers2 extends java.applet.Applet implements Runnable {\n5:\n6: Thread runner;\n7: int xpos;\n190\n030-4s CH10.i 190 1\/29\/96, 9:52 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 10 LP#3 Sams.net Learning\nCenter\nabcd\n8: int ux1,ux2;\n9:\n10: public void start() {\n11: if (runner == null); {\n12: runner = new Thread(this);\n13: runner.start();\n14: }\n15: }\n16:\n17: public void stop() {\n18: if (runner != null) {\n19: runner.stop();\n20: runner = null;\n21: }\n22: }\n23:\n24: public void run() {\n10\n25: setBackground(Color.blue);\n26: while (true) {\n27: for (xpos = 5; xpos <= 105; xpos+=4) {\n28: ux2 = xpos + 90;\n29: repaint();\n30: try { Thread.sleep(100); }\n31: catch (InterruptedException e) { }\n32: if (ux1 == 0) ux1 = xpos;\n33: }\n34: for (xpos = 105; xpos > 5; xpos -=4) {\n35: ux1 = xpos;\n36: repaint();\n37: try { Thread.sleep(100); }\n38: catch (InterruptedException e) { }\n39: if (ux2 == 0) ux2 = xpos + 90;\n40: }\n41: }\n42: }\n43: public void update(Graphics g) {\n44: g.clipRect(ux1, 5, ux2 - ux1, 95);\n45: paint(g);\n46: }\n47:\n48: public void paint(Graphics g) {\n49: \/\/ Draw background\n50: g.setColor(Color.black);\n51: g.fillRect(0,0,100,100);\n52: g.setColor(Color.white);\n53: g.fillRect(101,0,100,100);\n54:\n55: \/\/ Draw checker\n56: g.setColor(Color.red);\n57: g.fillOval(xpos,5,90,90);\n58:\n59: \/\/ reset the drawing area\n60: ux1 = ux2 = 0;\n61: }\n62:}\n191\n030-4s CH10.i 191 1\/29\/96, 9:52 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 10 LP#3 MTWRFSS\nDDAAYY\n10 Simple Animation and Threads\nSummary\nCongratulations on getting through Day 10! This day was a bit rough; you\u2019ve learned a lot, and\nit all might seem overwhelming. You learned about a plethora of methods to use and override:\nstart(), stop(), paint(), repaint(), run(), and update()\u2014and you got a solid foundation in\ncreating and using threads.\nAfter today, you\u2019re over the worst hurdles in terms of understanding applets. Other than\nhandling bitmap images, which you\u2019ll learn about tomorrow, you now have the basic\nbackground to create just about any animation you want in Java.\nQ&A\nQ Why all the indirection with paint and repaint and update and all that? Why not\nhave a simple paint method that just puts stuff on the screen when you want it\nthere?\nA The Java AWT toolkit enables you to nest drawable surfaces within other drawable\nsurfaces. When a paint takes place, all the parts of the system are redrawn, starting\nfrom the outermost surface and moving downward into the most nested one. Because\nthe drawing of your applet takes place at the same time everything else is drawn, your\napplet doesn\u2019t get any special treatment. Your applet will be painted when everything\nelse is painted. Although with this system you sacrifice some of the immediacy of\ninstant painting, it enables your applet to co-exist with the rest of the system more\ncleanly.\nQ Are Java threads like threads on other systems?\nA Java threads have been influenced by other thread systems, and if you\u2019re used to\nworking with threads, many of the concepts in Java threads will be very familiar to\nyou. You learned the basics today; you\u2019ll learn more next week on Day 17.\nQ When an applet uses threads, I just have to tell the thread to start and it starts,\nand tell it to stop and it stops? That\u2019s it? I don\u2019t have to test anything in my loops\nor keep track of its state? Is just stops?\nA It just stops. When you put your applet into a thread, Java can control the execution\nof your applet much more readily. By causing the thread to stop, your applet just\nstops running, and then resumes when the thread starts up again. Yes, it\u2019s all auto-\nmatic. Neat, isn\u2019t it?\n192\n030-4s CH10.i 192 1\/29\/96, 9:53 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 10 LP#3 Sams.net Learning\nCenter\nabcd\nQ The Swirling Colors applet seems to display only five or six colors. What\u2019s going\non here?\nA This is the same problem that you ran into yesterday wherein, on some systems, there\nmight not be enough colors to be able to display all of them reliably. If you\u2019re running\ninto this problem, other than upgrading your hardware, you might try quitting other\napplications running on your system that use color. Other browsers or color tools in\nparticular might be hogging colors that Java wants to be able to use.\nQ Even with the changes you made, the Checkers applet still flickers.\nA And, unfortunately, it will continue to do so. Reducing the size of the drawing area by\nusing clipping does significantly reduce the flickering, but it doesn\u2019t stop it entirely.\nFor many applets, using either of the methods described today may be enough to\nreduce animation flicker to the point where your applet works right. To get totally 10\nflicker-free animation, you\u2019ll use a technique called double-buffering, which you\u2019ll\nlearn about tomorrow.\n193\n030-4s CH10.i 193 1\/29\/96, 9:53 PM\nP2\/V4sqc 8 TY Java in 21 Days 030-4 andy 12.27.95 Ch 10 LP#3 Sams.net Learning\nCenter\nabcd\n11\n11\nS\nS\nWEEK\n11\nF 2\nR\nW\nMore Animation,\nT\nImages, and Sound\nM\nby Laura Lemay\n195\n030-4s CH11.i 195 1\/29\/96, 9:54 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 11 LP#3 MTWRFSS\nDDAAYY\n11 More Animation, Images, and Sound\nAnimations are fun and easy to do in Java, but there\u2019s only so much you can do with the built-\nin Java methods for lines and fonts and colors. For really interesting animations, you have to\nprovide your own images for each frame of the animation\u2014and having sounds is nice, as well.\nToday, you\u2019ll do more with animations, incorporating images and sounds into Java applets.\nSpecifically, you\u2019ll explore the following topics:\nnn Using images\u2014getting them from the server, loading them into Java, and displaying\nthem in your applet\nnn Creating animations by using images, including an extensive example\nnn Using sounds\u2014getting them and playing them at the appropriate times\nnn Sun\u2019s Animator applet\u2014an easy way to organize animations and sounds in Java\nnn Double-buffering\u2014hardcore flicker avoidance\nRetrieving and Using Images\nBasic image handling in Java is easy. The Image class in java.awt provides abstract methods to\nrepresent common image behavior, and special methods defined in Applet and Graphics give\nyou everything you need to load and display images in your applet as easily as drawing a rectangle.\nIn this section, you\u2019ll learn about how to get and draw images in your Java applets.\nGetting Images\nTo display an image in your applet, you first must load that image over the net into your Java\nprogram. Images are stored as separate files from your Java class files, so you have to tell Java\nwhere to find them.\nThe Applet class provides a method called getImage, which loads an image and automatically\ncreates an instance of the Image class for you. To use it, all you have to do is import the\njava.awt.Image class, and then give getImage the URL of the image you want to load. There are\ntwo ways of doing the latter step:\nnn The getImage method with a single argument (an object of type URL) retrieves the\nimage at that URL.\nnn The getImage method with two arguments: the base URL (also a URL object) and a\nstring representing the path or filename of the actual image (relative to the base).\nAlthough the first way may seem easier (just plug in the URL as a URL object), the second is more\nflexible. Remember, because you\u2019re compiling Java files, if you include a hard-coded URL of an\nimage and then move your files around to a different location, you have to recompile all your\nJava files.\n196\n030-4s CH11.i 196 1\/29\/96, 9:55 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 11 LP#3 Sams.net Learning\nCenter\nabcd\nThe latter form, therefore, is usually the one to use. The Applet class also provides two methods\nthat will help with the base URL argument to getImage:\nnn The getDocumentBase() method returns a URL object representing the directory of the\nHTML file that contains this applet. So, for example, if the HTML file is located at\nhttp:\/\/www.myserver.com\/htmlfiles\/javahtml\/, getDocumentBase returns a URL\npointing to that path.\nnn The getCodeBase() method returns a string representing the directory in which this\napplet is contained\u2014which may or may not be the same directory as the HTML file,\ndepending on whether the CODEBASE attribute in <APPLET> is set or not.\nWhether you use getDocumentBase() or getCodebase() depends on whether your images are\nrelative to your HTML files or relative to your Java class files. Use whichever one applies better\nto your situation. Note that either of these methods is more flexible than hard-coding a URL\nor pathname into the getImage method; using either getDocumentBase or getCodeBase enables\nyou to move your HTML files and applets around and Java can still find your images.\nHere are a few examples of getImage, to give you an idea of how to use it. This first call to getImage\nretrieves the file at that specific URL (\u201chttp:\/\/www.server.com\/files\/image.gif\u201d). If any part\n11\nof that URL changes, you have to recompile your Java applet to take the new path into account:\nImage img = getImage(\nnew URL(\u201chttp:\/\/www.server.com\/files\/image.gif\u201d));\nIn the following form of getImage, the image.gif file is in the same directory as the HTML files\nthat refer to this applet:\nImage img = getImage(getDocumentBase(), \u201cimage.gif\u201d)\nIn this similar form, the file image.gif is in the same directory as the applet itself:\nImage img = getImage(getCodeBase(), \u201cimage.gif\u201d)\nIf you have lots of image files, it\u2019s common to put them into their own subdirectory. This form\nof getImage looks for the file image.gif in the directory images, which, in turn, is in the same\ndirectory as the Java applet:\nImage img = getImage(getCodeBase(), \u201cimages\/image.gif\u201d)\nIf Java can\u2019t find the file you\u2019ve indicated, getImage returns null. Your program will continue\nto run\u2014you just won\u2019t see that image on your screen when you try to draw it.\nNote: Currently, Java supports images in the GIF and JPEG formats. Other image\nformats may be available later; however, for now, your images should be in either\nGIF or JPEG.\n197\n030-4s CH11.i 197 1\/29\/96, 9:55 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 11 LP#3 MTWRFSS\nDDAAYY\n11 More Animation, Images, and Sound\nDrawing Images\nAll that stuff with getImage does nothing except go off and retrieve an image and stuff it into\nan instance of the Image class. Now that you have an image, you have to do something with it.\nThe most likely thing you\u2019re going to want to do is display it as you would a rectangle or a text\nstring. The Graphics class provides two methods to do just that, both called drawImage.\nThe first version of drawImage takes four arguments: the image to display, the x and y positions\nof the top left corner, and this:\nvoid paint() {\ng.drawImage(img, 10, 10, this);\n}\nThis first form does what you would expect it to: it draws the image in its original dimensions\nwith the top left corner at the given x and y positions. Listing 11.1 shows the code for a very\nsimple applet that loads in an image called ladybug.gif and displays it. Figure 11.1 shows the\nobvious result.\nType\nListing 11.1. The Ladybug applet.\n1: import java.awt.Graphics;\n2: import java.awt.Image;\n3:\n4: public class LadyBug extends java.applet.Applet {\n5:\n6: Image bugimg;\n7:\n8: public void init() {\n9: bugimg = getImage(getCodeBase(),\n10: \u201cimages\/ladybug.gif\u201d);\n11: }\n12:\n13: public void paint(Graphics g) {\n14: g.drawImage(bugimg,10,10,this);\n15: }\n16: }\nAnalysis The second form of drawImage takes six arguments: the image to draw, the x and y\ncoordinates, a width and height of the image bounding box, and this. If the width and\nheight arguments for the bounding box are smaller or larger than the actual image, the\nimage is automatically scaled to fit. Using those extra arguments enables you to squeeze and\nexpand images into whatever space you need them to fit in (keep in mind, however, that there\nmay be some image degradation from scaling it smaller or larger than its intended size).\nOne helpful hint for scaling images is to find out the size of the actual image that you\u2019ve loaded,\nso you can then scale it to a specific percentage and avoid distortion in either direction. Two\nmethods defined for the Image class enable you do this: getWidth() and getHeight(). Both take\n198\n030-4s CH11.i 198 1\/29\/96, 9:56 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 11 LP#3 Sams.net Learning\nCenter\nabcd\na single argument, an instance of ImageObserver, which is used to track the loading of the image\n(more about this later). Most of the time, you can use just this as an argument to either\ngetWidth() or getHeight().\nFigure 11.1.\nThe Ladybug image.\n11\nIf you stored the ladybug image in a variable called bugimg, for example, this line returns the\nwidth of that image, in pixels:\ntheWidth = bugimg.getWidth(this);\nListing 11.2 shows another use of the ladybug image, this time scaled several times to different\nsizes (Figure 11.2 shows the result).\nType\nListing 11.2. More Ladybugs, scaled.\n1: import java.awt.Graphics;\n2: import java.awt.Image;\n3:\n4: public class LadyBug2 extends java.applet.Applet {\n5:\n6: Image bugimg;\n7:\n8: public void init() {\n9: bugimg = getImage(getCodeBase(),\n10: \u201cimages\/ladybug.gif\u201d);\n11: }\n12:\n13: public void paint(Graphics g) {\n14: int iwidth = bugimg.getWidth(this);\n15: int iheight = bugimg.getHeight(this);\n16: int xpos = 10;\n17:\n18: \/\/ 25 %\ncontinues\n199\n030-4s CH11.i 199 1\/29\/96, 9:57 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 11 LP#3 MTWRFSS\nDDAAYY\n11 More Animation, Images, and Sound\nListing 11.2. continued\n19: g.drawImage(bugimg,xpos,10,\n20: iwidth \/ 4, iheight \/ 4, this);\n21:\n22: \/\/ 50 %\n23: xpos += (iwidth \/ 4) + 10;\n24: g.drawImage(bugimg, xpos , 10,\n25: iwidth \/ 2, iheight \/ 2, this);\n26:\n27: \/\/ 100%\n28: xpos += (iwidth \/ 2) + 10;\n29: g.drawImage (bugimg, xpos, 10, this);\n30:\n31: \/\/ 150% x, 25% y\n32: g.drawImage(bugimg, 10, iheight + 30,\n33: (int)(iwidth * 1.5), iheight \/ 4, this);\n34: }\n35: }\nFigure 11.2.\nThe second Ladybug applet.\nAnalysis I\u2019ve been steadfastly ignoring mentioning that last argument to drawImage: the mysterious\nthis, which also appears as an argument to getWidth() and getHeight(). Why is this\nargument used? Its official use is to pass in an object that functions as an ImageObserver\n(that is, an object that implements the ImageObserver interface). Image observers enable you\nto watch the progress of how far along an image is in the loading process and to make decisions\n200\n030-4s CH11.i 200 1\/29\/96, 9:58 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 11 LP#3 Sams.net Learning\nCenter\nabcd\nwhen the image is only fully or partially loaded. The Applet class, which your applet inherits\nfrom, contains default behavior for watching for images that should work in the majority of\ncases\u2014hence, the this argument to drawImage(), getWidth(), and getHeight(). The only\nreason you\u2019ll want to use an alternate argument in its place is if you are tracking lots of images\nloading synchronously. See the java.awt.image.ImageObserver class for more details.\nModifying Images\nIn addition to the basics and handling images described in this section, the java.awt.image\npackage provides more classes and interfaces that enable you to modify images and their internal\ncolors, or to create bitmap images by hand. Most of these classes require background knowledge\nin image processing, including a good grasp of color models and bitwise operations. All these\nthings are outside the scope of an introductory book on Java, but if you have this background\n(or you\u2019re interested in trying it out), the classes in java.awt.image will be helpful to you. Take\na look at the example code for creating and using images that comes with the Java development\nkit for examples of how to use the image classes.\n11\nCreating Animation Using Images\nCreating animations by using images is much the same as creating images by using fonts, colors,\nor shapes\u2014you use the same methods, the same procedures for painting, repainting, and\nreducing flicker that you learned about yesterday. The only difference is that you have a stack\nof images to flip through rather than a set of painting methods.\nProbably the best way to show you how to use images for animation is simply to walk through\nan example. Here\u2019s an extensive one of an animation of a small cat called Neko.\nAn Example: Neko\nNeko was a small Macintosh animation\/game written and drawn by Kenji Gotoh in 1989.\n\u201cNeko\u201d is Japanese for \u201ccat,\u201d and the animation is of a small kitten that chases the mouse pointer\naround the screen, sleeps, scratches, and generally acts cute. The Neko program has since been\nported to just about every possible platform, as well as rewritten as a popular screensaver.\nFor this example, you\u2019ll implement a small animation based on the original Neko graphics.\nBecause the original Neko the cat was autonomous (it could \u201csense\u201d the edges of the window\nand turn and run in a different direction), this applet merely causes Neko to run in from the left\nside of the screen, stop in the middle, yawn, scratch its ear, sleep a little, and then run off to the\nright.\n201\n030-4s CH11.i 201 1\/29\/96, 9:58 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 11 LP#3 MTWRFSS\nDDAAYY\n11 More Animation, Images, and Sound\nNote: This is by far the largest of the applets discussed in this book, and if I either\nprint it here and then describe it, or build it up line by line, you\u2019ll be here for days.\nInstead, I\u2019m going to describe the parts of this applet independently, and I\u2019m going\nto leave out the basics\u2014the stuff you learned yesterday about starting and stopping\nthreads, what the run() method does, and so on. All the code is printed later today\nso that you can put it all together.\nBefore you begin writing Java code to construct an animation, you should have all the images\nthat form the animation itself. For this version of Neko there are nine of them (the original has\n36), as shown in Figure 11.3.\nFigure 11.3.\nThe images for Neko.\nI\u2019ve stored these images in a subdirectory of my applet directory called, appropriately, images.\nWhere you store your images isn\u2019t all the important, but you should take note of where you\u2019ve\nput them because you\u2019ll need that information\nNow, onto the applet. The basic idea of animation by using images is that you have a set of\nimages, and you display them one at a time, rapidly, so they give the appearance of movement.\nThe easiest way to manage this in Java is to store the images in an array of class Image, and then\nto have a special variable that stores a reference to the current image.\nTechnical Note: The java.util class contains a class (HashTable) that implements\na hash table. For large amounts of images, a hash table is faster to find and retrieve\nimages from than an array is. Because you have a relatively small amount of images\nhere, and because arrays are easier to deal with, I\u2019ll use an array here.\nFor the Neko applet, you\u2019ll include instance variables to implement both these things: an array\nto hold the images called nekopics, and a variable of type Image to hold the current image:\nImage nekopics[] = new Image[9];\nImage currentimg;\nBecause you\u2019ll need to pass the position of the current image around between the methods in\nthis applet, you\u2019ll also need to keep track of the current x and y positions. The y stays constant\nfor this particular applet, but the x may vary. let\u2019s add two instance variables for those two\npositions:\n202\n030-4s CH11.i 202 1\/29\/96, 9:59 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 11 LP#3 Sams.net Learning\nCenter\nabcd\nint xpos;\nint ypos = 50;\nNow, onto the body of the applet. During the applet\u2019s initialization, you\u2019ll read in all the images\nand store them in the nekopics array. This is the sort of operation that works especially well in\nan init() method.\nGiven that you have nine images with nine different filenames, you could do a separate call to\ngetImage for each one. You can save at least a little typing, however, by creating an array of the\nfile names (nekosrc, an array of strings) and then just using a for loop to iterate over each one.\nHere\u2019s the init() method for the Neko applet that loads all the images into the nekopics array:\npublic void init() {\nString nekosrc[] = { \u201cright1.gif\u201d, \u201cright2.gif\u201d,\n\u201cstop.gif\u201d, \u201cyawn.gif\u201d, \u201cscratch1.gif\u201d,\n\u201cscratch2.gif\u201d,\u201dsleep1.gif\u201d, \u201csleep2.gif\u201d,\n\u201cawake.gif\u201d };\nfor (int i=0; i < nekopics.length; i++) {\nnekopics[i] = getImage(getCodeBase(),\n\u201cimages\/\u201d + nekosrc[i]);\n}\n} 11\nNote here in the call to getImage that the directory these images are stored in is included as part\nof the path.\nWith the images loaded, the next step is to start animating the bits of the applet. You do this\ninside the applet\u2019s thread\u2019s run() method. In this applet, Neko does five main things:\nnn Runs in from the left side of the screen\nnn Stops in the middle and yawns\nnn Scratches four times\nnn Sleeps\nnn Wakes up and runs off to the right side of the screen\nBecause you could animate this applet by merely painting the right image to the screen at the\nright time, it makes more sense to write this applet so that many of Neko\u2019s activities are\ncontained in individual methods. This way, you can reuse some of the activities (the animation\nof Neko running, in particular) if you want Neko to do things in a different order.\nLet\u2019s start by creating a method to make Neko run. Because you\u2019re going to be using this one\ntwice, making it generic is a good plan. Let\u2019s create the nekorun method, which takes two\narguments: the x position to start, and the x position to end. Neko then runs between those two\npositions (the y remains constant).\nThere are two images that represent Neko running; so, to create the running effect, you need\nto alternate between those two images (stored in positions 0 and 1 of the image array), as well\n203\n030-4s CH11.i 203 1\/29\/96, 10:00 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 11 LP#3 MTWRFSS\nDDAAYY\n11 More Animation, Images, and Sound\nas move them across the screen. The moving part is a simple for loop between the start and\nend arguments, setting the global x position to the current loop value. Swapping the images\nmeans merely testing to see which one is active at any turn of the loop and assigning the other\none to the current image. Finally, at each new frame, you\u2019ll call repaint and sleep for a bit.\nActually, given that during this animation there will be a lot of sleeping of various intervals, it\nmakes sense to create a method that does the sleeping for the appropriate time interval. Call it\npause\u2014here\u2019s its definition:\nvoid pause(int time) {\ntry { Thread.sleep(time); }\ncatch (InterruptedException e) { }\n}\nBack to the nekorun method. To summarize, nekorun iterates from the start position to the end\nposition. For each turn of the loop, it sets the current x position, sets currentimg to the right\nanimation frame, calls repaint, and pauses. Got it? Here\u2019s the definition of nekorun:\nvoid nekorun(int start, int end) {\nfor (int i = start; i < end; i+=10) {\nthis.xpos = i;\n\/\/ swap images\nif (currentimg == nekopics[0])\ncurrentimg = nekopics[1];\nelse if (currentimg == nekopics[1])\ncurrentimg = nekopics[0];\nrepaint();\npause(150);\n}\n}\nNote that in that second line you increment the loop by ten pixels. Why ten pixels, and not, say,\nfive or eight? The answer is determined mostly through trial and error to see what looks right.\nTen seems to work best for the animation. When you write your own animations, you have to\nplay with both the distances and the sleep times until you get an animation you like.\nSpeaking of repaint, let\u2019s cover the paint() method, which paints each frame. Here the paint\nmethod is trivially simple; all paint is responsible for is painting the current image at the current\nx and y positions. All that information is stored in global variables, so the paint method has only\na single line in it:\npublic void paint(Graphics g) {\ng.drawImage(currentimg, xpos, ypos, this);\n}\nNow let\u2019s back up to the run() method, where the main processing of this animation is\nhappening. You\u2019ve created the nekorun method; in run you\u2019ll call that method with the\nappropriate values to make Neko run from the right edge of the screen to the center:\n204\n030-4s CH11.i 204 1\/29\/96, 10:00 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 11 LP#3 Sams.net Learning\nCenter\nabcd\n\/\/ run from one side of the screen to the middle\nnekorun(0, this.size().width \/ 2);\nThe second major thing Neko does in this animation is stop and yawn. You have a single frame\nfor each of these things (in positions 2 and 3 in the array), so you don\u2019t really need a separate\nmethod for them. All you need to do is set the appropriate image, call repaint(), and pause for\nthe right amount of time. This example pauses for a second each time for both stopping and\nyawning\u2014again, using trial and error. Here\u2019s the code:\n\/\/ stop and pause\ncurrentimg = nekopics[2];\nrepaint();\npause(1000);\n\/\/ yawn\ncurrentimg = nekopics[3];\nrepaint();\npause(1000);\nLet\u2019s move on to the third part of the animation: scratching. There\u2019s no horizontal for this part\nof the animation. You alternate between the two scratching images (stored in positions 4 and\n5 of the image array). Because scratching is a distinct action, however, let\u2019s create a separate\n11\nmethod for it.\nThe nekoscratch method takes a single argument: the number of times to scratch. With that\nargument, you can iterate, and then, inside the loop, alternate between the two scratching images\nand repaint each time:\nvoid nekoscratch(int numtimes) {\nfor (int i = numtimes; i > 0; i--) {\ncurrentimg = nekopics[4];\nrepaint();\npause(150);\ncurrentimg = nekopics[5];\nrepaint();\npause(150);\n}\n}\nInside the run method, you can then call nekoscratch with an argument of four:\n\/\/ scratch four times\nnekoscratch(4);\nOnward! After scratching, Neko sleeps. Again, you have two images for sleeping (in positions\n6 and 7 of the array), which you\u2019ll alternate a certain number of times. Here\u2019s the nekosleep\nmethod, which takes a single number argument, and animates for that many \u201cturns\u201d:\nvoid nekosleep(int numtimes) {\nfor (int i = numtimes; i > 0; i--) {\ncurrentimg = nekopics[6];\n205\n030-4s CH11.i 205 1\/29\/96, 10:00 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 11 LP#3 MTWRFSS\nDDAAYY\n11 More Animation, Images, and Sound\nrepaint();\npause(250);\ncurrentimg = nekopics[7];\nrepaint();\npause(250);\n}\n}\nCall nekosleep in the run() method like this:\n\/\/ sleep for 5 \u201cturns\u201d\nnekosleep(5);\nFinally, to finish off the applet, Neko wakes up and runs off to the right side of the screen. wake\nup is your last image in the array (position eight), and you can reuse the nekorun method to finish:\n\/\/ wake up and run off\ncurrentimg = nekopics[8];\nrepaint();\npause(500);\nnekorun(xpos, this.size().width + 10);\nThere\u2019s one more thing left to do to finish the applet. The images for the animation all have white\nbackgrounds. Drawing those images on the default applet background (a medium grey) means\nan unsightly white box around each image. To get around the problem, merely set the applet\u2019s\nbackground to white at the start of the run() method:\nsetBackground(Color.white);\nGot all that? There\u2019s a lot of code in this applet, and a lot of individual methods to accomplish\na rather simple animation, but it\u2019s not all that complicated. The heart of it, as in the heart of all\nJava animations, is to set up the frame and then call repaint() to enable the screen to be drawn.\nNote that you don\u2019t do anything to reduce the amount of flicker in this applet. It turns out that\nthe images are small enough, and the drawing area also small enough, that flicker is not a problem\nfor this applet. It\u2019s always a good idea to write your animations to do the simplest thing first, and\nthen add behavior to make them run cleaner.\nTo finish up this section, Listing 11.3 shows the complete code for the Neko applet.\nType\nListing 11.3. The final Neko applet.\n36: import java.awt.Graphics;\n37: import java.awt.Image;\n38: import java.awt.Color;\n39:\n40: public class Neko extends java.applet.Applet\n41: implements Runnable {\n42:\n43: Image nekopics[] = new Image[9];\n44: Image currentimg;\n45: Thread runner;\n46: int xpos;\n206\n030-4s CH11.i 206 1\/29\/96, 10:01 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 11 LP#3 Sams.net Learning\nCenter\nabcd\n47: int ypos = 50;\n48:\n49: public void init() {\n50: String nekosrc[] = { \u201cright1.gif\u201d, \u201cright2.gif\u201d,\n51: \u201cstop.gif\u201d, \u201cyawn.gif\u201d, \u201cscratch1.gif\u201d,\n52: \u201cscratch2.gif\u201d,\u201dsleep1.gif\u201d, \u201csleep2.gif\u201d,\n53: \u201cawake.gif\u201d };\n54:\n55: for (int i=0; i < nekopics.length; i++) {\n56: nekopics[i] = getImage(getCodeBase(),\n57: \u201cimages\/\u201d + nekosrc[i]);\n58: }\n59:\n60: public void start() {\n61: if (runner == null) {\n62: runner = new Thread(this);\n63: runner.start();\n64: }\n65: }\n66:\n67: public void stop() {\n68: if (runner != null) {\n69: runner.stop();\n70: runner = null;\n71: } 11\n72: }\n73:\n74: public void run() {\n75:\n76: setBackground(Color.white);\n77:\n78: \/\/ run from one side of the screen to the middle\n79: nekorun(0, this.size().width \/ 2);\n80:\n81: \/\/ stop and pause\n82: currentimg = nekopics[2];\n83: repaint();\n84: pause(1000);\n85:\n86: \/\/ yawn\n87: currentimg = nekopics[3];\n88: repaint();\n89: pause(1000);\n90:\n91: \/\/ scratch four times\n92: nekoscratch(4);\n93:\n94: \/\/ sleep for 5 \u201cturns\u201d\n95: nekosleep(5);\n96:\n97: \/\/ wake up and run off\n98: currentimg = nekopics[8];\n99: repaint();\n100: pause(500);\n101: nekorun(xpos, this.size().width + 10);\ncontinues\n207\n030-4s CH11.i 207 1\/29\/96, 10:01 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 11 LP#3 MTWRFSS\nDDAAYY\n11 More Animation, Images, and Sound\nListing 11.3. continued\n102: }\n103:\n104: void nekorun(int start, int end) {\n105: for (int i = start; i < end; i+=10) {\n106: this.xpos = i;\n107: \/\/ swap images\n108: if (currentimg == nekopics[0])\n109: currentimg = nekopics[1];\n110: else if (currentimg == nekopics[1])\n111: currentimg = nekopics[0];\n112: else currentimg = nekopics[0];\n113:\n114: repaint();\n115: pause(150);\n116: }\n117: }\n118:\n119: void nekoscratch(int numtimes) {\n120: for (int i = numtimes; i > 0; i--) {\n121: currentimg = nekopics[4];\n122: repaint();\n123: pause(150);\n124: currentimg = nekopics[5];\n125: repaint();\n126: pause(150);\n127: }\n128: }\n129:\n130: void nekosleep(int numtimes) {\n131: for (int i = numtimes; i > 0; i--) {\n132: currentimg = nekopics[6];\n133: repaint();\n134: pause(250);\n135: currentimg = nekopics[7];\n136: repaint();\n137: pause(250);\n138: }\n139:\n140: void pause(int time) {\n141: try { Thread.sleep(time); }\n142: catch (InterruptedException e) { }\n143: }\n144:\n145: public void paint(Graphics g) {\n146: g.drawImage(currentimg, xpos, ypos, this);\n147: }\n148: }\n208\n030-4s CH11.i 208 1\/29\/96, 10:02 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 11 LP#3 Sams.net Learning\nCenter\nabcd\nRetrieving and Using Sounds\nJava has built-in support for playing sounds in conjunction with running animations or for\nsounds on their own. In fact, support for sound, like support for images, is built into the Applet\nand awt classes, so using sound in your Java applets is as easy as loading and using images.\nCurrently, the only sound format that Java supports is Sun\u2019s AU format, sometimes called m -\nlaw format. AU files tend to be smaller than sound files in other formats, but the sound quality\nis not very good. If you\u2019re especially concerned with sound quality, you may want your sound\nclips to be references in the traditional HTML way (as links to external files) rather than included\nin a Java applet.\nThe simplest way to retrieve and play a sound is through the play() method, part of the Applet\nclass and therefore available to you in your applets. The play() method is similar to the getImage\nmethod in that it takes one of two forms:\nnn play with one argument, a URL object, loads and plays the given audio clip at that\nURL.\nnn play() with two arguments, one a base URL and one a pathname, loads and plays that\n11\naudio file. The first argument can most usefully be either a call to getDocumentBase()\nor getCodeBase().\nFor example, the following line of code retrieves and plays the sound meow.au, which is\ncontained in the audio directory. The audio directory, in turn, is located in the same directory\nas this applet:\nplay(getCodeBase(), \u201caudio\/meow.au\u201d);\nThe play method retrieves and plays the given sound as soon as possible after it is called. If it\ncan\u2019t find the sound, you won\u2019t get an error; you just won\u2019t get any audio when you expect it.\nIf you want to play a sound repeatedly, start and stop the sound clip, or run the clip as a loop\n(play it over and over), things are slightly more complicated\u2014but not much more so. In this case,\nyou use the applet method getAudioClip() to load the sound clip into an instance of the class\nAudioClip (part of java.applet\u2014don\u2019t forget to import it) and then operate directly on that\nAudioClip object.\nSuppose, for example, that you have a sound loop that you want to play in the background of\nyour applet. In your initialization code, you can use this line to get the audio clip:\nAudioClip clip = getAudioClip(getCodeBase(),\n\u201caudio\/loop.au\u201d);\nThen, to play the clip once, use the play method:\nclip.play();\n209\n030-4s CH11.i 209 1\/29\/96, 10:02 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 11 LP#3 MTWRFSS\nDDAAYY\n11 More Animation, Images, and Sound\nTo stop a currently playing sound clip, use the stop() method:\nclip.stop();\nTo loop the clip (play it repeatedly), use the loop() method:\nclip.loop();\nIf the getAudioClip method can\u2019t find the sound you indicate, or can\u2019t load it for any reason,\nthe AudioClip variable is set to null. It\u2019s a good idea to test for this case in your code before trying\nto play the audio clip\u2014, because trying to call the play(), stop(), and loop() methods on a null\nobject will result in an error (actually, an exception).\nIn your applet, you can play as many audio clips as you need; all the sounds you use play\nconcurrently as your applet executes.\nNote that if you use a background sound\u2014a sound clip that loops repeatedly\u2014that sound clip\nwill not stop playing automatically when you suspend the applet\u2019s thread. This means that even\nif your reader moves to another page, the first applet\u2019s sounds will continue to play. You can fix\nthis problem by stopping the applet\u2019s background sound in your stop() method:\npublic void stop() {\nif (runner != null) {\nif (bgsound!= null)\nbgsound.stop();\nrunner.stop();\nrunner = null;\n}\n}\nListing 11.4 shows a simple framework for an applet that plays two sounds: the first, a\nbackground sound called loop.au, plays repeatedly. The second, a horn honking (beep.au) plays\nevery five seconds. (I won\u2019t bother giving you a picture of this applet, because it doesn\u2019t actually\ndisplay anything other than a simple string to the screen).\nType\nListing 11.4. The AudioLoop applet.\n1: import java.awt.Graphics;\n2: import java.applet.AudioClip;\n3:\n4: public class AudioLoop extends java.applet.Applet\n5: implements Runnable {\n6:\n7: AudioClip bgsound;\n8: AudioClip beep;\n9: Thread runner;\n10:\n11: public void start() {\n12: if (runner == null) {\n13: runner = new Thread(this);\n14: runner.start();\n210\n030-4s CH11.i 210 1\/29\/96, 10:03 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 11 LP#3 Sams.net Learning\nCenter\nabcd\n15: }\n16: }\n17:\n18: public void stop() {\n19: if (runner != null) {\n20: if (bgsound != null) bgsound.stop();\n21: runner.stop();\n22: runner = null;\n23: }\n24: }\n25:\n26: public void init() {\n27: bgsound = getAudioClip(getCodeBase(),\u201daudio\/loop.au\u201d);\n28: beep = getAudioClip(getCodeBase(), \u201caudio\/beep.au\u201d);\n29: }\n30:\n31: public void run() {\n32: if (bgsound != null) bgsound.loop();\n33: while (runner != null) {\n34: try { Thread.sleep(5000); }\n35: catch (InterruptedException e) { }\n36: if (bgsound != null) beep.play();\n37: }\n38: }\n39: 11\n40: public void paint(Graphics g) {\n41: g.drawString(\u201cPlaying Sounds....\u201d, 10, 10);\n42: }\n43: }\nSun\u2019s Animator Applet\nBecause most Java animations have a lot of code in common, being able to reuse all that code\nas much as possible makes creating animations with images and sounds much easier, particular\nfor Java developers who aren\u2019t as good at the programming side of Java. For just this reason, Sun\nprovides an Animator class as part of the standard Java release.\nThe Animator applet provides a simple, general-purpose animation interface. You compile the\ncode and create an HTML file with the appropriate parameters for the animation. Using the\nAnimator applet, you can do the following:\nnn Create an animation loop, that is, an animation that plays repeatedly.\nnn Add a soundtrack to the applet.\nnn Add sounds to be played at individual frames.\nnn Indicate the speed at which the animation is to occur.\nnn Specify the order of the frames in the animation\u2014which means that you can reuse\nframes that repeat during the course of the animation.\n211\n030-4s CH11.i 211 1\/29\/96, 10:03 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 11 LP#3 MTWRFSS\nDDAAYY\n11 More Animation, Images, and Sound\nEven if you don\u2019t intend to use Sun\u2019s Animator code, it\u2019s a great example of how animations\nwork in Java and the sorts of clever tricks you can use in a Java applet.\nThe Animator class is part of the Java distribution (in the demo directory), or you can find out\nmore information about it at the Java home page, http:\/\/java.sun.com.\nMore About Flicker: Double-Buffering\nYesterday, you learned two simple ways to reduce flickering in animations. Although you\nlearned specifically about animations using drawing, flicker can also result from animations\nusing images. In addition to the two flicker-reducing methods described yesterday, there is one\nother way to reduce flicker in an application: double-buffering.\nNEW* With double-buffering, you create a second surface (offscreen, so to speak), do all your\nTERM painting to that offscreen surface, and then draw the whole surface at once onto the actual\napplet (and onto the screen) at the end\u2014rather than drawing to the applet\u2019s actual graphics\nsurface. Because all the work actually goes on behind the scenes, there\u2019s no opportunity for\ninterim parts of the drawing process to appear accidentally and disrupt the smoothness of the\nanimation.\nDouble-buffering isn\u2019t always the best solution. If your applet is suffering from flicker, try\noverriding update and drawing only portions of the screen first; that may solve your problem.\nDouble-buffering is less efficient than regular buffering, and also takes up more memory and\nspace, so if you can avoid it, make an effort to do so. In terms of nearly eliminating animation\nflicker, however, double-buffering works exceptionally well.\nCreating Applets with Double-Buffering\nTo execute double-buffering, you need two things: an image to draw on and a graphics context\nfor that image. Those two together mimic the effect of the applet\u2019s drawing surface: the graphics\ncontext (an instance of Graphics) to provide the drawing methods, such as drawImage and\ndrawString, and the Image to hold the dots that get drawn.\nThere are four major steps to adding double-buffering to your applet. First, your offscreen image\nand graphics context need to be stored in instance variables so that you can pass them to the\npaint() method. Declare the following instance variables in your class definition:\nImage offscreenImage;\nGraphics offscreenGraphics;\nSecond, during the initialization of the applet, you\u2019ll create an Image and a Graphics object and\nassign them to these variables (you have to wait until initialization so you know how big they\u2019re\ngoing to be). The createImage method gives you an instance of Image, which you can then send\nthe getGraphics() method in order to get a new graphics context for that image:\n212\n030-4s CH11.i 212 1\/29\/96, 10:04 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 11 LP#3 Sams.net Learning\nCenter\nabcd\noffscreenImage = createImage(this.size().width,\nthis.size().height);\noffscreenGraphics = offscreenImage.getGraphics();\nNow, whenever you have to draw to the screen (usually in your paint method), rather than\ndrawing to paint\u2019s graphics, draw to the offscreen graphics. For example, to draw an image called\nimg at position 10,10, use this line:\noffscreenGraphics.drawImage(img,10,10,this);\nFinally, at the end of your paint method, after all the drawing to the offscreen image is done,\nadd the following line to print the offscreen buffer to the real screen:\ng.drawImage(offscreenImage, 0, 0, this);\nOf course, you most likely will want to override update so that it doesn\u2019t clear the screen between\npaintings:\npublic void update(Graphics g) {\npaint(g);\n}\nLet\u2019s review those four steps:\n11\nnn Add instance variables to hold the image and graphics contexts for the offscreen\nbuffer.\nnn Create an image and a graphics context when your applet is initialized.\nnn Do all your applet painting to the offscreen buffer, not the applet\u2019s drawing surface.\nnn At the end of your paint method, draw the offscreen buffer to the real screen.\nAn Example: Checkers Revisited\nYesterday\u2019s example featured the animated moving red oval to demonstrate animation flicker\nand how to reduce it. Even with the operations you did yesterday, however, the Checkers applet\nstill flashed occasionally. Let\u2019s revise that applet to include double-buffering.\nFirst, add the instance variables for the offscreen image and its graphics context:\nImage offscreenImg;\nGraphics offscreenG;\nSecond, add an init method to initialize the offscreen buffer:\npublic void init() {\noffscreenImg = createImage(this.size().width,\nthis.size().height);\noffscreenG = offscreenImg.getGraphics();\n}\n213\n030-4s CH11.i 213 1\/29\/96, 10:05 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 11 LP#3 MTWRFSS\nDDAAYY\n11 More Animation, Images, and Sound\nThird, modify the paint method to draw to the offscreen buffer instead of to the main graphics\nbuffer:\npublic void paint(Graphics g) {\n\/\/ Draw background\noffscreenG.setColor(Color.black);\noffscreenG.fillRect(0,0,100,100);\noffscreenG.setColor(Color.white);\noffscreenG.fillRect(100,0,100,100);\n\/\/ Draw checker\noffscreenG.setColor(Color.red);\noffscreenG.fillOval(xpos,5,90,90);\ng.drawImage(offscreenImg,0,0,this);\n}\nNote that you\u2019re still clipping the main graphics rectangle in the update method, as you did\nyesterday; you don\u2019t have to change that part. The only part that is relevant is that final paint\nmethod wherein everything is drawn offscreen before finally being displayed.\nSummary\nThree major topics were the focus of today\u2019s lesson. First, you learned about using images in your\napplets\u2014locating them, loading them, and using the drawImage method to display them, either\nat their normal size or scaled to different sizes. You also learned how to create animations using\nimages.\nSecondly, you learned how to use sounds, which can be included in your applets any time you\nneed them\u2014at specific moments, or as background sounds that can be repeated while the applet\nexecutes. You learned how to locate, load, and play sounds both using the play() and the\ngetAudioClip() methods.\nFinally, you learned about double-buffering, a technique that enables you virtually to eliminate\nflicker in animations, at some expense of animation efficiency and speed. Using images and\ngraphics contexts, you can create an offscreen buffer to draw to, the result of which is then\ndisplayed to the screen at the last possible moment.\n214\n030-4s CH11.i 214 1\/29\/96, 10:05 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 11 LP#3 Sams.net Learning\nCenter\nabcd\nQ&A\nQ In the Neko program, you put the image loading into the init() method. It\nseems to me that it might take Java a long time to load all those images, and\nbecause init() isn\u2019t in the main thread of the applet, there\u2019s going to be a\ndistinct pause there. Why not put the image loading at the beginning of the run()\nmethod instead?\nA There are sneaky things going on behind the scenes. The getImage method doesn\u2019t\nactually load the image; in fact, it returns an Image object almost instantaneously, so it\nisn\u2019t taking up a large amount of processing time during initialization. The image data\nthat getImage points to isn\u2019t actually loaded until the image is needed. This way, Java\ndoesn\u2019t have to keep enormous images around in memory if the program is going to\nuse only a small piece. Instead, it can just keep a reference to that data and retrieve\nwhat it needs later.\nQ I wrote an applet to do a background sound using the getAudioClip() and loop()\nmethods. The sounds works great, but it won\u2019t stop. I\u2019ve tried suspending the\ncurrent thread and killing, but the sound goes on.\n11\nA I mentioned this as a small note in the section on sounds; background sounds don\u2019t\nrun in the main thread of the applet, so if you stop the thread, the sound keeps going.\nThe solution is easy\u2014in the same method where you stop the thread, also stop the\nsound, like this:\nrunner.stop() \/\/stop the thread\nbgsound.stop() \/\/also stop the sound\nQ If I use double-buffering, do I still have to clip to a small region of the screen?\nBecause double-buffering eliminates flicker, it seems easier to draw the whole\nframe every time.\nA Easier, yes, but less efficient. Drawing only part of the screen not only reduces flicker,\nit also limits the amount of work your applet has to do in the paint() method. The\nfaster the paint() method works, the faster and smoother your animation will run.\nUsing clip regions and drawing only what is necessary is a good practice to follow in\ngeneral\u2014not just if you have a problem with flicker.\n215\n030-4s CH11.i 215 1\/29\/96, 10:06 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 11 LP#3 Sams.net Learning\nCenter\nabcd\n12\n12\nS\nS\nWEEK\nF 2\nR\nW 12\nManaging Simple\nT\nEvents and\nM\nInteractivity\nby Laura Lemay\n217\n030-4s CH12.i 217 1\/29\/96, 10:08 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 12 LP#3 MTWRFSS\nDDAAYY\n12 Managing Simple Events and Interactivity\nJava events are part of the Java AWT (Abstract Windowing Toolkit) package. An event is the\nway that the AWT communicates to you, as the programmer, and to other Java AWT\ncomponents that something has happened. That something can be input from the user (mouse\nmovements or clicks, keypresses), changes in the system environment (a window opening or\nclosing, the window being scrolled up or down), or a host of other things that might, in some\nway, be interesting to the operation of the program.\nNote: Java\u2019s Abstract Windowing Toolkit is a package of classes that implements\nmost common UI components, such as windows, buttons, menus, and so on. It is\nalso specifically the AWT, and not Java, that generates and manages events.\nIn other words, whenever just about anything happens to a Java AWT component, including\nan applet, an event is generated. Some events are handled by the AWT or by the browser without\nyour needing to do anything. paint() methods, for example, are generated and handled by the\nbrowser\u2014all you have to do is tell the AWT what you want painted when it gets to your part\nof the window. Some events, however\u2014for example, a mouse click inside the boundaries of\nyour applet\u2014you may need to know about. Writing your Java programs to handle these kinds\nof events enables you to get input from the user and have your applet change its behavior based\non that input.\nToday, you\u2019ll learn about managing simple events, including the following basics:\nnn Mouse clicks\nnn Mouse movements, including mouse dragging\nnn Keyboard actions\nYou\u2019ll also learn about the handleEvent() method, which is the basis for collecting, handling,\nand passing on events of all kinds from your applet to other UI components in the window or\nin your applet itself. Tomorrow, you\u2019ll learn how to combine events with the AWT to create a\ncomplete interface for your applet.\nMouse Clicks\nLet\u2019s start with the most common event you might be interested in: mouse clicks. Mouse-click\nevents occur when your user clicks the mouse somewhere in the body of your applet. You can\nintercept mouse clicks to do very simple things\u2014for example, to toggle the sound on and off\nin your applet, to move to the next slide in a presentation, or to clear the screen and start over\u2014\nor you can use mouse clicks in conjunction with mouse movements to perform more complex\nmotions inside your applet.\n218\n030-4s CH12.i 218 1\/29\/96, 10:09 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 12 LP#3 Sams.net Learning\nCenter\nabcd\nmouseDown and mouseUp\nWhen you click the mouse once, the AWT generates two events: a mouseDown event when the\nmouse button is pressed, and a mouseUp event when the button is released. Why two individual\nevents for a single mouse action? Because you may want to do different things for the \u201cdown\u201d\nand the \u201cup.\u201d For example, look at a pull-down menu. The mouseDown extends the menu, and\nthe mouseUp selects an item (with mouseDrags between\u2014but you\u2019ll learn about that one later).\nIf you have only one event for both actions (mouseUp and mouseDown), you cannot implement\nthat sort of user interaction.\nHandling mouse events in your applet is easy\u2014all you have to do is override the right method\ndefinition in your applet. That method will be called when that particular event occurs. Here\u2019s\nan example of the method signature for a mouseDown event:\npublic boolean mouseDown(Event evt, int x, int y) {\n...\n}\nThe mouseDown() method (and the mouseUp() method as well) takes three parameters: the event\nitself and the x and y coordinates where the mouseDown or mouseUp event occurred.\nThe event argument is an instance of the class Event. All system events generate an instance of\nthe Event class, which contains information about where and when the event took place, the kind\nof event it is, and other information that you might want to know about this event. Sometimes\nhaving a handle to that event object is useful, as you\u2019ll discover later on in this section.\nThe x and the y coordinates of the event, as passed in through the x and y arguments, are 12\nparticularly nice to know because you can use them to determine precisely where the mouse click\ntook place.\nFor example, here\u2019s a simple method that prints out information about a mouseDown when it\noccurs:\npublic boolean mouseDown(Event evt, int x, int y) {\nSystem.out.println(\u201cMouse down at \u201c + x + \u201c,\u201d + y);\nreturn true;\n}\nBy including this method in your applet, every time your user clicks the mouse inside your\napplet, this message will get printed.\nNote that this method, unlike the other system methods you\u2019ve studied this far, returns a\nboolean value instead of not returning anything (void). This will become important tomorrow\nwhen you create user interfaces and then manage input to these interfaces; having an event\nhandler return true or false determines whether a given UI component can intercept an event\nor whether it needs to pass it on to the enclosing component. The general rule is that if your\nmethod deals with the event, it should return true, which for the focus of today\u2019s lesson is almost\nalways the case.\n219\n030-4s CH12.i 219 1\/29\/96, 10:09 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 12 LP#3 MTWRFSS\nDDAAYY\n12 Managing Simple Events and Interactivity\nThe second half of the mouse click is the mouseUp() method, which is called when the mouse\nbutton is released. To handle a mouseUp event, add the mouseUp() method to your applet.\nmouseUp() looks just like mouseDown():\npublic boolean mouseUp(Event evt, int x, int y) {\n....\n}\nAn Example: Spots\nIn this section, you\u2019ll create an example of an applet that uses mouse events\u2014mouseDown events\nin particular. The Spots applet starts with a blank screen and then sits and waits. When you click\nthe mouse on that screen, a blue dot is drawn. You can place up to ten dots on the screen. Figure\n12.1 shows the Spots applet.\nFigure 12.1.\nThe Spots applet.\nLet\u2019s start from the beginning and build this applet, starting from the initial class definition:\nimport java.awt.Graphics;\nimport java.awt.Color;\nimport java.awt.Event;\npublic class Spots extends java.applet.Applet {\nfinal int MAXSPOTS = 10;\nint xspots[] = new int[MAXSPOTS];\n220\n030-4s CH12.i 220 1\/29\/96, 10:10 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 12 LP#3 Sams.net Learning\nCenter\nabcd\nint yspots[] = new int[MAXSPOTS];\nint currspots = 0;\n}\nThis class uses three other AWT classes: Graphics, Color, and Event. That last class, Event, needs\nto be imported in any applets that use events. The class has four instance variables: a constant\nto determine the maximum number of spots that can be drawn, two arrays to store the x and\ny coordinates of the spots that have already been drawn, and an integer to keep track of the\nnumber of the current spot.\nNote: This class doesn\u2019t include the implements Runnable words in its definition.\nAs you\u2019ll see later on as you build this applet, it also doesn\u2019t have a run() method.\nWhy not? Because it doesn\u2019t actually do anything on its own\u2014all it does is wait for\ninput and then do stuff when input happens. There\u2019s no need for threads if your\napplet isn\u2019t actively doing something all the time.\nLet\u2019s start with the init() method, which has one line, to set the background to white:\npublic void init() {\nsetBackground(Color.white);\n}\nSet the background here, instead of in paint(), because paint() is called repeatedly each time\n12\na new spot is added. Because you really need to set the background only once, putting it in the\npaint() method unnecessarily slows down that method. Putting it here is a much better idea.\nThe main action of this applet occurs on the mouseDown() method, so let\u2019s add that one now:\npublic boolean mouseDown(Event evt, int x, int y) {\nif (currspots < MAXSPOTS)\naddspot(x,y);\nelse System.out.println(\u201cToo many spots.\u201d);\nreturn true;\n}\nWhen the mouse click occurs, the mouseDown() method tests to see whether there are less than\nten spots. If so, it calls the addspot() method (which you\u2019ll write soon). If not, it just prints an\nerror message. Finally, it returns true, because all the event methods have to return a boolean\nvalue (usually true).\nWhat does addspot() do? It adds the coordinates of the spot to the arrays that store the\ncoordinates, increments the currspots variable, and then calls repaint():\nvoid addspot(int x,int y) {\nxspots[currspots] = x;\nyspots[currspots] = y;\n221\n030-4s CH12.i 221 1\/29\/96, 10:10 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 12 LP#3 MTWRFSS\nDDAAYY\n12 Managing Simple Events and Interactivity\ncurrspots++;\nrepaint();\n}\nYou may be wondering why you have to keep track of all the past spots in addition to the current\nspot. The reason is because of repaint(): each time you paint the screen, you have to paint all\nthe old spots in addition to the newest spot. Otherwise, each time you painted a new spot, the\nolder spots would get erased. Now, on to the paint() method:\npublic void paint(Graphics g) {\ng.setColor(Color.blue);\nfor (int i = 0; i < currspots; i++) {\ng.fillOval(xspots[i] -10, yspots[i] -10,20,20);\n}\n}\nInside paint, you just loop through the spots you\u2019ve stored in the xspots and yspots arrays,\npainting each one (actually, painting them a little to the right and upward so that the spot is\npainted around the mouse pointer rather than below and to the right).\nThat\u2019s it! That\u2019s all you need to create an applet that handles mouse clicks. Everything else is\nhandled for you. You have to add the appropriate behavior to mouseDown() or mouseUp() to\nintercept and handle that event. Listing 12.1 shows the full text for the Spots applet.\nType\nListing 12.1. The Spots applet.\n1: import java.awt.Graphics;\n2: import java.awt.Color;\n3: import java.awt.Event;\n4:\n5: public class Spots extends java.applet.Applet {\n6:\n7: final int MAXSPOTS = 10;\n8: int xspots[] = new int[MAXSPOTS];\n9: int yspots[] = new int[MAXSPOTS];\n10: int currspots = 0;\n11:\n12: public void init() {\n13: setBackground(Color.white);\n14: }\n15:\n16: public boolean mouseDown(Event evt, int x, int y) {\n17: if (currspots < MAXSPOTS)\n18: addspot(x,y);\n19: else System.out.println(\u201cToo many spots.\u201d);\n20: return true;\n21: }\n22:\n23: void addspot(int x,int y) {\n24: xspots[currspots] = x;\n25: yspots[currspots] = y;\n26: currspots++;\n27: repaint();\n222\n030-4s CH12.i 222 1\/29\/96, 10:11 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 12 LP#3 Sams.net Learning\nCenter\nabcd\n28: }\n29:\n30: public void paint(Graphics g) {\n31: g.setColor(Color.blue);\n32: for (int i = 0; i < currspots; i++) {\n33: g.fillOval(xspots[i] -10, yspots[i] -10,20,20);\n34: }\n35: }\n36: }\nMouse Movements\nEvery time the mouse is moved a single pixel in any direction, a mouse move event is generated.\nThere are two mouse movement events: mouse drags, where the movement occurs with the\nmouse button pressed down, and plain mouse movements, where the mouse button isn\u2019t\npressed.\nTo manage mouse movement events, use the mouseDrag() and mouseMove() methods.\nmouseDrag and mouseMove\nThe mouseDrag() and mouseMove() methods, when included in your applet code, intercept and\nhandle mouse movement events. The mouseMove() method, for plain mouse pointer movements\nwithout the mouse button pressed, looks much like the mouse-click methods:\n12\npublic boolean mouseMove(Event evt, int x, int y) {\n...\n}\nThe mouseDrag() method handles mouse movements made with the mouse button pressed\ndown (a complete dragging movement consists of a mouseDown event, a series of mouseDrag events\nfor each pixel the mouse is moved, and a mouseUp even when the button is released). The\nmouseDrag() method looks like this:\npublic boolean mouseDrag(Event evt, int x, int y) {\n...\n}\nmouseEnter and mouseExit\nFinally, there are the mouseEnter() and mouseExit() methods. These two methods are called\nwhen the mouse pointer enters the applet or when it exits the applet. (In case you\u2019re wondering\nwhy you might need to know this, it\u2019s more useful on components of user interfaces that you\nmight put inside an applet. You\u2019ll learn more about UI tomorrow).\n223\n030-4s CH12.i 223 1\/29\/96, 10:12 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 12 LP#3 MTWRFSS\nDDAAYY\n12 Managing Simple Events and Interactivity\nBoth mouseEnter() and mouseExit() have similar signatures\u2014three arguments: the event object\nand the x and y coordinates of the point where the mouse entered or exited the applet.\npublic boolean mouseEnter(Event evt, int x, int y) {\n...\n}\npublic boolean mouseExit(Event evt, int x, int y) {\n...\n}\nAn Example: Drawing Lines\nExamples always help to make concepts more concrete. In this section you\u2019ll create an applet that\nenables you to draw straight lines on the screen by dragging from the startpoint to the endpoint.\nFigure 12.2 shows the applet at work.\nFigure 12.2.\nDrawing Lines.\nAs with the Spots applet (on which this applet is based), let\u2019s start with the basic definition and\nwork our way through it. Listing 12.2 shows the top of the Lines applet.\nType\nListing 12.2. The top of the Lines applet.\n1: import java.awt.Graphics;\n2: import java.awt.Color;\n3: import java.awt.Event;\n224\n030-4s CH12.i 224 1\/29\/96, 10:13 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 12 LP#3 Sams.net Learning\nCenter\nabcd\n4: import java.awt.Point;\n5:\n6: public class Lines extends java.applet.Applet {\n7:\n8: final int MAXLINES = 10;\n9: Point starts[] = new Point[MAXLINES]; \/\/ starting points\n10: Point ends[] = new Point[10]; \/\/ ending points\n11: Point anchor; \/\/ start of current line\n12: Point currentpoint; \/\/ current end of line\n13: int currline = 0; \/\/ number of lines\n14:\n15: public void init() {\n16: setBackground(Color.white);\n17: }\n18:\nAnalysis Compared to Spots, this applet added a few extra things. Unlike Spots, which keeps track\nof individual integer coordinates, this one keeps track of Point objects. Points represent an\nx and a y coordinate, encapsulated in a single object. To deal with points, you import the\nPoint class (line 4) and set up a bunch of instance variables that hold points:\nnn The starts array holds points representing the starts of lines already drawn.\nnn The ends array holds the endpoints of those same lines.\nnn anchor holds the starting point of the line currently being drawn.\nnn currentpoint holds the current endpoint of the line currently being drawn.\nnn currline holds the current number of lines (to make sure you don\u2019t go over 12\nMAXLINES).\nFinally, the init() method (lines 15 through 17), as in the Spots applet, sets the background\nof the applet to white.\nThe three main events this applet deals with are mouseDown(), to set the anchor point for the\ncurrent line, mouseDrag(), to animate the current line as it\u2019s being drawn, and mouseUp(), to set\nthe ending point for the new line. Given that you have instance variables to hold each of these\nvalues, it\u2019s merely a matter of plugging the right variables into the right methods. Here\u2019s\nmouseDown(), which sets the anchor point:\npublic boolean mouseDown(Event evt, int x, int y) {\nanchor = new Point(x,y);\nreturn true;\n}\nWhile the mouse is being dragged to draw the line, the applet animates the line being drawn.\nAs you draw the mouse around, the new line moves with it from the anchor point to the tip of\nthe mouse. The mouseDrag event contains the current point each time the mouse moves, so use\nthat method to keep track of the current point (and to repaint for each movement so the line\n\u201canimates\u201d):\n225\n030-4s CH12.i 225 1\/29\/96, 10:14 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 12 LP#3 MTWRFSS\nDDAAYY\n12 Managing Simple Events and Interactivity\npublic boolean mouseDrag(Event evt, int x, int y) {\ncurrentpoint = new Point(x,y);\nrepaint();\nreturn true;\n}\nThe new line doesn\u2019t get added to the arrays of old lines until the mouse button is released. Here\u2019s\nmouseUp(), which tests to make sure you haven\u2019t exceeded the maximum number of lines before\ncalling the addline() method (described next):\npublic boolean mouseUp(Event evt, int x, int y) {\nif (currline < MAXLINES)\naddline(x,y);\nelse System.out.println(\u201cToo many lines.\u201d);\nreturn true;\n}\nThe addline() method is where the arrays of lines get updated and where the applet is repainted\nto take the new line into effect:\nvoid addline(int x,int y) {\nstarts[currline] = anchor;\nends[currline] = new Point(x,y);\ncurrline++;\ncurrentpoint = null;\nrepaint();\n}\nNote that in this line you also set currentpoint to null. Why? Because the current line in\nprocess is over. By setting currentpoint to null, you can test for that value in the paint()\nmethod.\nPainting the applet means drawing all the old lines stored in the starts and ends arrays, as well\nas drawing the current line in process (whose endpoints are in anchor and currentpoint,\nrespectively). To show the animation of the current line, draw it in blue. Here\u2019s the paint()\nmethod for the Lines applet:\npublic void paint(Graphics g) {\n\/\/ Draw existing lines\nfor (int i = 0; i < currline; i++) {\ng.drawLine(starts[i].x, starts[i].y,\nends[i].x, ends[i].y);\n}\n\/\/ draw current line\ng.setColor(Color.blue);\nif (currentpoint != null)\ng.drawLine(anchor.x,anchor.y,\ncurrentpoint.x,currentpoint.y);\n}\nIn paint, when you\u2019re drawing the current line, you test first to see whether currentpoint is null.\nIf it is, the applet isn\u2019t in the middle of drawing a line, so there\u2019s no reason to try drawing a line\n226\n030-4s CH12.i 226 1\/29\/96, 10:14 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 12 LP#3 Sams.net Learning\nCenter\nabcd\nthat doesn\u2019t exist. By testing for currentpoint (and by setting currentpoint to null in the\naddline() method), you can paint only what you need.\nThat\u2019s it\u2014just 60 lines of code and a few basic methods, and you have a very basic drawing\napplication in your Web browser. Listing 12.3 shows the full text of the Lines applet so that you\ncan put the pieces together.\nType\nListing 12.3. The Lines applet.\n1: import java.awt.Graphics;\n2: import java.awt.Color;\n3: import java.awt.Event;\n4: import java.awt.Point;\n5:\n6: public class Lines extends java.applet.Applet {\n7:\n8: final int MAXLINES = ;\n9: Point starts[] = new Point[MAXLINES]; \/\/ starting points\n10: Point ends[] = new Point[10]; \/\/ endingpoints\n11: Point anchor; \/\/ start of current line\n12: Point currentpoint; \/\/ current end of line\n13: int currline = 0; \/\/ number of lines\n14:\n15: public void init() {\n16: setBackground(Color.white);\n17: }\n18:\n19: public boolean mouseDown(Event evt, int x, int y) {\n20: anchor = new Point(x,y);\n21: return true; 12\n22: }\n23:\n24: public boolean mouseUp(Event evt, int x, int y) {\n25: if (currline < MAXSPOTS)\n26: addline(x,y);\n27: else System.out.println(\u201cToo many lines.\u201d);\n28: return true;\n29: }\n30:\n31: public boolean mouseDrag(Event evt, int x, int y) {\n32: currentpoint = new Point(x,y);\n33: repaint();\n34: return true;\n35: }\n36:\n37: void addline(int x,int y) {\n38: starts[currline] = anchor;\n39: ends[currline] = new Point(x,y);\n40: currline++;\n41: currentpoint = null;\n42: repaint();\n43: }\n44:\n45: public void paint(Graphics g) {\n227\n030-4s CH12.i 227 1\/29\/96, 10:15 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 12 LP#3 MTWRFSS\nDDAAYY\n12 Managing Simple Events and Interactivity\nListing 12.3. continued\n46:\n47: \/\/ Draw existing lines\n48: for (int i = 0; i < currline; i++) {\n49: g.drawLine(starts[i].x, starts[i].y,\n50: ends[i].x, ends[i].y);\n51: }\n52:\n53: \/\/ draw current line\n54: g.setColor(Color.blue);\n55: if (currentpoint != null)\n56: g.drawLine(anchor.x,anchor.y,\n57: currentpoint.x,currentpoint.y);\n58: }\n59: }\nKeyboard Events\nKeyboard events are generated whenever users press a key on the keyboard. By using key events,\nyou can get hold of the values of the keys they pressed to perform an action or merely to get\ncharacter input from the users of your applet.\nThe keyDown Method\nTo capture a keyboard event, use the keyDown() method:\npublic boolean keyDown(Event evt, int key) {\n...\n}\nThe keys generated by keyDown events (and passed into keyDown() as the key argument) are\nintegers representing ASCII character values, which include alphanumeric characters, function\nkeys, tabs, returns, and so on. To use them as characters (for example, to print them), you need\nto cast them to characters:\ncurrentchar = (char)key;\nHere\u2019s a simple example of a keyDown() method that does nothing but print the key you just\ntyped in both its ASCII and character representation:\npublic boolean keyDown(Event evt, int key) {\nSystem.out.println(\u201cASCII value: \u201c + key);\nSystem.out.println(\u201cCharacter: \u201c + (char)key);\nreturn true;\n}\n228\n030-4s CH12.i 228 1\/29\/96, 10:16 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 12 LP#3 Sams.net Learning\nCenter\nabcd\nDefault Keys\nThe Event class provides a set of class variables that refer to several standard nonalphanumeric\nkeys, such as the arrow keys. If your interface uses these keys, you can provide more readable code\nby testing for these names in your keyDown() method rather than testing for their numeric values.\nFor example, to test whether the up arrow was pressed, you might use the following snippet of\ncode:\nif (key == Event.UP) {\n...\n}\nBecause the values these class variables hold are integers, you also can use the switch statement\nto test for them.\nTable 12.1 shows the standard event class variables for various keys and the actual keys they\nrepresent.\nTable 12.1. Standard keys defined by the event class.\nClass Variable Represened Key\nEvent.HOME The Home key\nEvent.END The End key\nEvent.PGUP The Page Up key\nEvent.PGDN The Page Down key\n12\nEvent.UP The up arrow\nEvent.DOWN The down arrow\nEvent.LEFT The left arrow\nEvent.RIGHT The right arrow\nAn Example: Entering, Displaying, and\nMoving Characters\nLet\u2019s look at an applet that demonstrates keyboard events. This one enables you to type a\ncharacter, and it displays that character in the center of the applet window. You then can move\nthat character around on the screen by using the arrow keys. Typing another character at any\ntime changes the character as it\u2019s currently displayed. Figure 12.3 shows an example.\n229\n030-4s CH12.i 229 1\/29\/96, 10:16 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 12 LP#3 MTWRFSS\nDDAAYY\n12 Managing Simple Events and Interactivity\nFigure 12.3.\nThe Keys applet.\nThis applet is actually less complicated than the previous applets you\u2019ve used. This one has only\nthree methods: init(), keyDown(), and paint(). The instance variables are also simpler, because\nthe only things you need to keep track of are the x and y positions of the current character and\nthe values of that character itself. Here\u2019s the top of this class definition:\nimport java.awt.Graphics;\nimport java.awt.Event;\nimport java.awt.Font;\npublic class Keys extends java.applet.Applet {\nchar currkey;\nint currx;\nint curry;\nThe init() method is responsible for three things: setting the background color, setting the\napplet\u2019s font (here, 36 point Helvetica bold), and setting the beginning position for the character\n(the middle of the screen, minus a few points to nudge it up and to the right):\npublic void init() {\ncurrx = (this.size().width \/ 2) -8; \/\/ default\ncurry = (this.size().height \/ 2) -16;\nsetBackground(Color.white);\nsetFont(new Font(\u201cHelvetica\u201d,Font.BOLD,36));\n}\n230\n030-4s CH12.i 230 1\/29\/96, 10:17 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 12 LP#3 Sams.net Learning\nCenter\nabcd\nBecause this applet\u2019s behavior is based on keyboard input, the keyDown() method is where most\nof the work of the applet takes place:\npublic boolean keyDown(Event evt, int key) {\nswitch (key) {\ncase Event.DOWN:\ncurry += 5;\nbreak;\ncase Event.UP:\ncurry -= 5;\nbreak;\ncase Event.LEFT:\ncurrx -= 5;\nbreak;\ncase Event.RIGHT:\ncurrx += 5;\nbreak;\ndefault:\ncurrkey = (char)key;\n}\nrepaint();\nreturn true;\n}\nIn the center of the keyDown() applet is a switch statement that tests for different key events. If\nthe event is an arrow key, the appropriate change is made to the character\u2019s position. If the event\nis any other key, the character itself is changed. The method finishes up with a repaint() and\nreturns true.\nThe paint() method here is almost trivial; just display the current character at the current 12\nposition. However, note that when the applet starts up, there\u2019s no initial character and nothing\nto draw, so you have to take that into account. The currkey variable is initialized to 0, so you\npaint the applet only if currkey has an actual value:\npublic void paint(Graphics g) {\nif (currkey != 0) {\ng.drawString(String.valueOf(currkey), currx,curry);\n}\n}\nListing 12.4 shows the complete source for the Keys applet:\nType\nListing 12.4. The Keys applet.\n1: import java.awt.Graphics;\n2: import java.awt.Event;\n3: import java.awt.Font;\n4:\n5: public class Keys extends java.applet.Applet {\n6:\n7: char currkey;\n8: int currx;\ncontinues\n231\n030-4s CH12.i 231 1\/29\/96, 10:18 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 12 LP#3 MTWRFSS\nDDAAYY\n12 Managing Simple Events and Interactivity\nListing 12.4. continued\n9: int curry;\n10:\n11: public void init() {\n12: currx = (this.size().width \/ 2) -8; \/\/ default\n13: curry = (this.size().height \/ 2) -16;\n14:\n15: setBackground(Color.white);\n16: setFont(new Font(\u201cHelvetica\u201d,Font.BOLD,36));\n17: }\n18:\n19: public boolean keyDown(Event evt, int key) {\n20: switch (key) {\n21: case Event.DOWN:\n22: curry += 5;\n23: break;\n24: case Event.UP:\n25: curry -= 5;\n26: break;\n27: case Event.LEFT:\n28: currx -= 5;\n29: break;\n30: case Event.RIGHT:\n31: currx += 5;\n32: break;\n33: default:\n34: currkey = (char)key;\n35: }\n36:\n37: repaint();\n38: return true;\n39: }\n40:\n41: public void paint(Graphics g) {\n42: if (currkey != 0) {\n43: g.drawString(String.valueOf(currkey), currx,curry);\n44: }\n45: }\n46: }\nTesting for Modifier Keys\nShift, control, and meta are modifier keys. They don\u2019t generate key events themselves, but when\nyou get an ordinary mouse or keyboard event, you can test to see whether those keys were held\ndown when the event occurred. Sometimes it may be obvious\u2014shifted alphanumeric keys\nproduce different key events than unshifted ones, for example. For other events, however\u2014\nmouse events in particular\u2014you may want to handle an event with a modifier key held down\ndifferently from a regular version of that event.\n232\n030-4s CH12.i 232 1\/29\/96, 10:18 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 12 LP#3 Sams.net Learning\nCenter\nabcd\nThe Event class provides three methods for testing whether or not a modifier key is held down:\nshiftDown(), metaDown(), and controlDown(). All return boolean values based on whether that\nmodifier key is indeed held down. You can use these three methods in any of the event handling\nmethods (mouse or keyboard) by calling them on the event object passed into that method:\npublic boolean mouseDown(Event evt, int x, int y ) {\nif (evt.shiftDown)\n\/\/ handle shift-click\nelse \/\/ handle regular click\n}\nThe AWT Event Handler\nThe default methods you\u2019ve learned about today for handling basic events in applets are actually\ncalled by a generic event handler method called handleEvent(). The handleEvent() method is\nhow the AWT generically deals with events that occur between application components and\nevents based on user input.\nIn the default handleEvent() method, basic events are processed and the methods you learned\nabout today are called. To handle events other than those mentioned here, to change the default\nevent handling behavior, or to create and pass around your own events, you need to override\nhandleEvent in your own Java programs. The handleEvent() method looks like this:\npublic boolean handleEvent(Event evt) {\n...\n}\n12\nTo test for specific events, examine the ID instance variable of the Event object that gets passed\nin. The event ID is an integer, but fortunately, the Event class defines a whole set of event IDs\nas class variables that you can test for in the body of the handleEvent. Because these class variables\nare integer constants, a switch statement works particularly well. For example, here\u2019s a simple\nhandleEvent() method to print out debugging information about mouse events:\npublic boolean handleEvent(Event evt) {\nswitch (evt.id) {\ncase Event.MOUSE_DOWN:\nSystem.out.println(\u201cMouseDown: \u201c +\nevt.x + \u201c,\u201d + evt.y);\nreturn true;\ncase Event.MOUSE_UP:\nSystem.out.println(\u201cMouseUp: \u201c +\nevt.x + \u201c,\u201d + evt.y);\nreturn true;\ncase Event.MOUSE_MOVE:\nSystem.out.println(\u201cMouseMove: \u201c +\nevt.x + \u201c,\u201d + evt.y);\nreturn true;\ncase Event.MOUSE_DRAG:\nSystem.out.println(\u201cMouseDown: \u201c +\nevt.x + \u201c,\u201d + evt.y);\n233\n030-4s CH12.i 233 1\/29\/96, 10:19 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 12 LP#3 MTWRFSS\nDDAAYY\n12 Managing Simple Events and Interactivity\nreturn true;\ndefault:\nreturn false;\n}\n}\nYou can test for the following keyboard events:\nnn Event.KEYPRESS is generated when a key is pressed (the same as the keyDown()\nmethod).\nnn Event.KEYRELEASE is generated when a key is released.\nnn Event.KEYACTION is generated when a key action (a press and a release) occurs.\nYou can test for these mouse events:\nnn Event.MOUSE_DOWN is generated when the mouse button is pressed (the same as the\nmouseDown() method).\nnn Event.MOUSE_UP is generated when the mouse button is released (the same as the\nmouseUp() method).\nnn Event.MOUSE_MOVE is generated when the mouse is moved (the same as the mouseMove()\nmethod).\nnn Event.MOUSE_DRAG is generated when the mouse is moved with the button pressed (the\nsame as the mouseDrag() method).\nnn Event.MOUSE_ENTER is generated when the mouse enters the applet (or a component of\nthat applet). You can also use the mouseEnter() method.\nnn Event.MOUSE_EXIT is generated when the mouse exits the applet. You can also use the\nmouseExit() method.\nIn addition to these events, the Event class has a whole suite of methods for handling UI\ncomponents. You\u2019ll learn more about these events tomorrow.\nNote that if you override handleEvent() in your class, none of the default event handling\nmethods you learned about today will get called unless you explicitly call them in the body of\nhandleEvent(), so be careful if you decide to do this. One way to get around this is to test for\nthe event you\u2019re interested in, and if that event isn\u2019t it, to call super.handleEvent() so that the\nsuperclass that defines handleEvent() can process things. Here\u2019s an example of how to do this:\npublic boolean handleEvent(Event evt) {\nif (evt.id == Event.MOUSE_DOWN) {\n\/\/ process the mouse down\nreturn true;\n} else {\nreturn super.handleEvent(evt);\n}\n}\n234\n030-4s CH12.i 234 1\/29\/96, 10:19 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 12 LP#3 Sams.net Learning\nCenter\nabcd\nSummary\nHandling events in Java\u2019s Abstract Windowing Toolkit (AWT) is easy. Most of the time, all you\nneed to do is stick the right method in your applet code, and your applet intercepts and handles\nthat method. Here are some of the basic events you can manage in this way:\nnn Mouse clicks\u2014mouseUp() and mouseDown() methods for each part of a mouse click.\nnn Mouse movements\u2014mouseMove() and mouseDrag() for mouse movement with the\nmouse button released and pressed, respectively, as well as mouseEnter() and\nmouseExit() for when the mouse enters and exits the applet area.\nnn keyDown for when a key on the keyboard is pressed.\nAll events in the AWT generate an Event object; inside that object, you can find out information\nabout the event, when it occurred, and its x and y coordinates (if applicable). You can also test\nthat event to see whether a modifier key was pressed when the event occurred, by using the\nshiftDown(), controlDown(), and metaDown() methods.\nFinally, there is the handleEvent(), the \u201cparent\u201d of the individual event methods. The\nhandleEvent() method is actually what the Java system calls to manage events; the default\nimplementation calls the individual method events where necessary. To override how methods\nare managed in your applet, override handleEvent.\nQ&A\n12\nQ In the Spots applet, the spot coordinates are stored in arrays, which have a\nlimited size. How can I modify this applet so that it will drawn an unlimited\nnumber of spots?\nA You can do one of a couple things:\nThe first thing to do is test, in your addspot() method, whether the number of spots\nhas exceeded MAXSPOTS. Then create a bigger array, copy the elements of the old array\ninto that bigger array (use the System.arraycopy() method to do that), and reassign\nthe x and y arrays to that new, bigger array.\nThe second thing to do is to use the Vector class. Vector, part of the java.util package,\nimplements an array that is automatically growable\u2014sort of like a linked list is in\nother languages. The disadvantage of Vector is that to put something into Vector, it\nhas to be an actual object. This means you\u2019ll have to cast integers to Integer objects,\nand then extract their values from Integer objects to treat them as integers again. The\nVector class enables you to add and remove objects to the end of Vector just as you\ncan in an array (by using method calls, rather than array syntax). Check it out.\n235\n030-4s CH12.i 235 1\/29\/96, 10:20 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 12 LP#3 MTWRFSS\nDDAAYY\n12 Managing Simple Events and Interactivity\nQ mouseDown() and mouseUp() seem to apply to only a single mouse button. How can\nI determine which button on the mouse has been pressed?\nA At the moment, you can\u2019t. AWT assumes that you\u2019re using only one mouse button, or\nif you have a mouse with multiple buttons, that you\u2019re using only the left one.\nAlthough this provides some limitations on the kinds of actions you can perform in\nyour applet, it does provide a cross-platform solution. Remember\u2014 different systems\nhave different mice, so writing your applet to do something specific with the right\nmouse button isn\u2019t a good idea if the people running your applet are using\nMacintoshes and have only one mouse button. If you really want to have different\nmouse actions perform different things, test for modifier keys in your mouseDown() and\nmouseUp() methods.\nQ What\u2019s a meta key?\nA It\u2019s popular in Unix systems, and often mapped to Alt on most keyboards. Because\nShift and Ctrl are much more popular and widespread, it\u2019s probably a good idea to\nbase your interfaces on those modifier keys if you can.\nQ How do I test to see whether the Return key has been pressed?\nA Return (line feed) is character 10; Enter (carriage return) is character 13. Note that\ndifferent platforms may send different keys for the actual key marked Return. In\nparticular, Unix systems send line feeds, Macintoshes send carriage returns, and DOS\nsystems send both. So, to provide a cross-platform behavior, you may want to test for\nboth line feed and carriage return.\nThe word from the Java team is that a Return is a Return is a Return regardless of the\nplatform. However, at the time of this writing, it is questionable whether or not this is\ncurrently true in the Java developer\u2019s kit. You may want to check the API documenta-\ntion for the Event class to see whether this has changed in the interim.\nQ I looked at the API for the Event class, and there are many more event types\nlisted there than the ones you mention today.\nA Yes. The Event class defines many different kinds of events, both for general user\ninput, such as the mouse and keyboard events you learned about here, and also events\nfor managing changes to the state of user interface components, such as windows and\nscroll bars. Tomorrow, you\u2019ll learn about those other events.\n236\n030-4s CH12.i 236 1\/29\/96, 10:21 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 12 LP#3 Sams.net Learning\nCenter\nabcd\n13\n13\nS\nS\nWEEK\nF 2\nR\nW\nThe Java Abstract\nT\nWindowing Toolkit\nM 13\nby Laura Lemay\n237\n030-4s CH13.i 237 1\/29\/96, 10:33 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 MTWRFSS\nDDAAYY\n13 The Java Abstract Windowing Toolkit\nFor the past five days you\u2019ve concentrated on creating applets that do very simple things: display\ntext, play an animation or a sound, or enable very basic interactions with the user. Once you get\npast that point, however, you may want to start creating more complex applets that behave like\nreal applications, embedded in a Web page\u2014applets that start to look like real GUI applications\nwith buttons, menus, text fields and other elements of a real application.\nIt\u2019s this sort of real work in Java applets and applications that Java\u2019s Abstract Windowing\nToolkit, or AWT, was designed for. You\u2019ve actually been using the AWT all along, as you might\nhave guessed from the classes you\u2019ve been importing. The Applet class and most of the classes\nyou\u2019ve been using this week are all integral parts of the AWT. In fact, the HotJava browser is\nalso written in Java and uses the AWT as well.\nThe AWT provides the following:\nnn A full set of UI widgets and other components, including windows, menus, buttons,\ncheckboxes, text fields, scrollbars, and scrolling lists\nnn Support for UI \u201ccontainers,\u201d which can contain other embedded containers or UI\nwidgets\nnn An event system for managing system and user events between and among parts of the\nAWT\nnn Mechanisms for laying out components in a way that enables platform-independent\nUI design\nToday, you\u2019ll learn about how to use all these things in your Java applets. Tomorrow, you\u2019ll learn\nabout creating windows, menus, and dialogs, which enable you to pop up separate windows\nfrom the browser window. In addition, you can use the AWT in stand-alone applications, so\neverything you\u2019ve learned so far this week can still be used. If you find the framework of the Web\nbrowser too limiting, you can take your AWT background and start writing full-fledged Java\napplications.\nToday, however, you\u2019ll continue focusing on applets.\nNote: This is by far the most complex lesson so far. There\u2019s a lot to cover and a lot\nof code to go through today, so if it starts becoming overwhelming, you might\nwant to take two days (or more) for this one.\nAn AWT Overview\nThe basic idea behind the AWT is that a Java window is a set of nested components, starting\nfrom the outermost window all the way down to the smallest UI component. Components can\n238\n030-4s CH13.i 238 1\/29\/96, 10:33 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 Sams.net Learning\nCenter\nabcd\ninclude things you can actually see on the screen, such as windows, menubars, buttons, and text\nfields, and they can also include containers, which in turn can contain other components. Figure\n13.1 shows how a sample page in a Java browser might include several different components,\nall of which are managed through the AWT.\nThis nesting of components within containers within other components creates a hierarchy of\ncomponents, from the smallest checkbox inside an applet to the overall window on the screen.\nThe hierarchy of components determines the arrangement of items on the screen and inside\nother items, the order in which they are painted, and how events are passed from one component\nto another.\nFigure 13.1. Window\nAWT components.\nMenubar\nApplet More\npanels\nPanel\nText field\nCanvas\nLabel\n13\nThese are the major components you can work with in the AWT:\nnn Containers. Containers are generic AWT components that can contain other compo-\nnents, including other containers. The most common form of container is the panel,\nwhich represents a container that can be displayed on screen. Applets are a form of\npanel (in fact, the Applet class is a subclass of the Panel class).\nnn Canvases. A canvas is a simple drawing surface. Although you can draw on panels (as\nyou\u2019ve been doing all along), canvases are good for painting images or other graphics\noperations.\nnn UI components. These can include buttons, lists, simple popup menus, checkboxes, test\nfields, and other typical elements of a user interface.\n239\n030-4s CH13.i 239 1\/29\/96, 10:33 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 MTWRFSS\nDDAAYY\n13 The Java Abstract Windowing Toolkit\nnn Window construction components. These include windows, frames, menubars, and\ndialogs. These are listed separately from the other UI components because you\u2019ll use\nthese less often\u2014particularly in applets. In applets, the browser provides the main\nwindow and menubar, so you don\u2019t have to use these. Your applet may create a new\nwindow, however, or you may want to write your own Java application that uses these\ncomponents.\nThe classes inside the java.awt package are written and organized to mirror the abstract structure\nof containers, components, and individual UI components. Figure 13.2 shows some of the class\nhierarchy that makes up the main classes in the AWT. The root of most of the AWT components\nis the class Component, which provides basic display and event handling features. The classes\nContainer, Canvas, TextComponent, and many of the other UI components inherit from\nComponent. Inheriting from the Container class are objects that can contain other AWT\ncomponents\u2014the Panel and Window classes, in particular. Note that the java.applet.Applet\nclass, even though it lives in its own package, inherits from Panel, so your applets are an integral\npart of the hierarchy of components in the AWT system.\nFigure 13.2.\nComponent\nA partial AWT class\nhierarchy.\nCanvas Container TextComponent Button\nPanel Window TextField\nApplet Frame Dialog\nA graphical user interface-based application that you write by using the AWT can be as complex\nas you like, with dozens of nested containers and components inside each other. AWT was\ndesigned so that each component can play its part in the overall AWT system without needing\nto duplicate or keep track of the behavior of other parts in the system.\nThe Basic User Interface Components\nThe simplest form of AWT component is the basic UI component. You can create and add these\nto your applet without needing to know anything about creating containers or panels\u2014your\napplet, even before you start painting and drawing and handling events, is already an AWT\ncontainer. Because an applet is a container, you can put other AWT components\u2014such as UI\ncomponents or other containers\u2014into it.\n240\n030-4s CH13.i 240 1\/29\/96, 10:33 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 Sams.net Learning\nCenter\nabcd\nIn this section, you\u2019ll learn about the basic UI components: labels, buttons, checkboxes, choice\nmenus, and text fields. In each case, the procedure for creating the component is the same\u2014you\nfirst create the component, and then add it to the panel that holds it, at which point it is displayed\non the screen. To add a component to a panel (such as your applet, for example), use the add()\nmethod:\npublic void init() {\nButton b = new Button(\u201cOK\u201d);\nadd(b);\n}\nNote that where the component appears in the panel depends on the layout that panel is defined\nto have. The default layout for panels such as applets is FlowLayout, with a centered alignment,\nwhich means that components are added from left to right in rows, and then row by row as they\nfit, with each row centered. This explains why some of the examples in this section look a little\nfunny. You\u2019ll learn more about panels and layouts in the next section.\nNote also that each of these components has an action associated with it\u2014that is, something that\ncomponent does when it\u2019s activated. Actions generally trigger events or other activities in your\napplet (often called callbacks in other window toolkits). In this section, you\u2019ll focus on creating\nthe components themselves; you\u2019ll learn about adding actions to them later in today\u2019s lesson.\nOn to the components!\nLabels\nThe simplest form of UI component is the label.\nNEW* Labels are, effectively, text strings that you can use to label other UI components.\nTERM\nThe advantages that a label has over an ordinary text string is that it follows the layout of the given\n13\npanel, and you don\u2019t have to worry about repainting it every time the panel is redrawn. Labels\nalso can be easily aligned within a panel, enabling you to attach labels to other UI components\nwithout knowing exact pixel positions.\nTo create a label, use one of the following constructors:\nnn Label() creates an empty label, with its text aligned left.\nnn Label(String) creates a label with the given text string, also aligned left.\nnn Label(String, int) creates a label with the given text string and the given alignment.\nThe available alignments are stored in class variables in Label, making them easier to\nremember: Label.RIGHT, Label.LEFT, and Label.CENTER.\nThe label\u2019s font is determined by the overall font for the component (as set by the setFont()\nmethod).\n241\n030-4s CH13.i 241 1\/29\/96, 10:33 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 MTWRFSS\nDDAAYY\n13 The Java Abstract Windowing Toolkit\nHere\u2019s some simple code to create a few labels. Figure 13.3 shows how this looks on screen:\nadd(new Label(\u201caligned left \u201c));\nadd(new Label(\u201caligned center\u201d, Label.CENTER));\nadd(new Label(\u201c aligned right\u201d, Label.RIGHT));\nFigure 13.3.\nLabels.\nOnce you have a label object, you can use methods defined in the Label class to get and set the\nvalues of the text as shown in Table 13.1.\nTable 13.1. Label methods.\nMethod Action\ngetText() Returns a string containing this label\u2019s text\nsetText(String) Changes the text of this label\ngetAlignment() Returns an integer representing the alignment of this label:\n0 is Label.LEFT, 1 is Label.CENTER, 2 is Label.RIGHT\nsetAlignment(int) Changes the alignment of this label to the given integer or class\nvariable\nButtons\nThe second user interface component to explore is the button.\nNEW* Buttons are simple UI components that trigger some action in your interface when they\nTERM are pressed. For example, a calculator applet might have buttons for each number and\noperator, or a dialog box might have buttons for \u201cOK\u201d and \u201cCancel.\u201d\nTo create a button, use one of the following constructors:\nnn Button() creates an empty button with no label.\nnn Button(String) creates a button with the given string object as a label.\n242\n030-4s CH13.i 242 1\/29\/96, 10:33 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 Sams.net Learning\nCenter\nabcd\nOnce you have a button object, you can get the value of the button\u2019s label by using the\ngetLabel() method and set the label using the setLabel(String) methods.\nFigure 13.4 shows some simple buttons, created using the following code:\nadd(new Button(\u201cRewind\u201d));\nadd(new Button(\u201cPlay\u201d));\nadd(new Button(\u201cFast Forward\u201d));\nadd(new Button(\u201cStop\u201d));\nFigure 13.4.\nButtons.\nCheckboxes\nCheckboxes can be selected or deselected to provide options.\nNEW* Checkboxes are user interface components that have two states: on and off (or checked and\nTERM unchecked, selected and unselected, true and false, and so on). Unlike buttons, checkboxes\nusually don\u2019t trigger direct actions in a UI but, instead, are used to indicate optional features of\nsome other action.\nCheckboxes can be used in two ways:\nnn Nonexclusive, meaning that given a series of checkboxes, any of them can be selected.\nnn Exclusive, meaning that within one series, only one checkbox can be selected at a time.\nThe latter kind of checkboxes are called radio buttons or checkbox groups, and are described in\nthe next section.\n13\nNonexclusive checkboxes can be created by using the Checkbox class. You can create a checkbox\nby using one of the following constructors:\nnn Checkbox() creates an empty checkbox, unselected.\nnn Checkbox(String) creates a checkbox with the given string as a label.\nnn Checkbox(String, null, boolean) creates a checkbox that is either selected or\nunselected based on whether the boolean argument is true or false, respectively. (The\nnull is used as a placeholder for a group argument. Only radio buttons have groups, as\nyou\u2019ll learn in the next section).\nTable 13.2 lists the checkbox methods; Figure 13.5 shows a few simple checkboxes (only\nUnderwear is selected), generated using the following code:\n243\n030-4s CH13.i 243 1\/29\/96, 10:34 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 MTWRFSS\nDDAAYY\n13 The Java Abstract Windowing Toolkit\nadd(new Checkbox(\u201cShoes\u201d));\nadd(new Checkbox(\u201cSocks\u201d));\nadd(new Checkbox(\u201cPants\u201d));\nadd(new Checkbox(\u201cUnderwear\u201d, null, true));\nadd(new Checkbox(\u201cShirt\u201d));\nFigure 13.5.\nCheckboxes.\nTable 13.2. Checkbox methods.\nMethod Action\ngetLabel() Returns a string containing this checkbox\u2019s label\nsetLabel(String) Changes the text of the checkbox\u2019s label\ngetState() Returns true or false, based on whether the checkbox is selected\nor not\nsetState(boolean) Changes the checkbox\u2019s state to selected (true) or unselected\n(false)\nRadio Buttons\nRadio buttons are a variation on the checkbox.\nNEW* Radio buttons have the same appearance as checkboxes, but only one in a series can be\nTERM selected at a time.\nTo create a series of radio buttons, first create an instance of CheckboxGroup:\nCheckboxGroup cbg = new CheckboxGroup();\n244\n030-4s CH13.i 244 1\/29\/96, 10:34 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 Sams.net Learning\nCenter\nabcd\nThen create and add the individual checkboxes, using the group as the second argument, and\nwhether or not that checkbox is selected (only one in the series can be selected):\nadd(new Checkbox(\u201cYes\u201d, cbg, true);\nadd(new Checkbox(\u201cno\u201d, cbg, false);\nHere\u2019s a simple example (the results of which are shown in Figure 13.6):\nCheckboxGroup cbg = new CheckboxGroup();\nadd(new Checkbox(\u201cRed\u201d, cbg, true));\nadd(new Checkbox(\u201cBlue\u201d, cbg, false));\nadd(new Checkbox(\u201cYellow\u201d, cbg, false));\nadd(new Checkbox(\u201cGreen\u201d, cbg, false));\nadd(new Checkbox(\u201cOrange\u201d, cbg, false));\nadd(new Checkbox(\u201cPurple\u201d, cbg, false));\nFigure 13.6.\nRadio buttons.\nAll the checkbox methods defined in the previous section can be used with the checkboxes in\nthe group. In addition, you can use the getCheckboxGroup() and setCheckboxGroup() methods 13\nto access and change the group of any given checkbox.\nFinally, the getCurrent() and setCurrent(Checkbox) methods, defined in the checkbox group,\ncan be used to get or set the currently selected checkbox.\nChoice Menus\nThe choice menu is a more complex UI component than labels, buttons, or checkboxes.\nNEW* Choice menus are popup (or pulldown) menus that enable you to select an item from that\nTERM menu. The menu then displays that choice on the screen.\nTo create a choice menu, create an instance of the Choice class, and then use the addItem()\nmethod to add individual items to it in the order in which they should appear:\n245\n030-4s CH13.i 245 1\/29\/96, 10:34 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 MTWRFSS\nDDAAYY\n13 The Java Abstract Windowing Toolkit\nChoice c = new Choice();\nc.addItem(\u201cApples\u201d);\nc.addItem(\u201cOranges\u201d);\nc.addItem(\u201cStrawberries\u201d);\nc.addItem(\u201cBlueberries\u201d);\nc.addItem(\u201cBananas\u201d);\nFinally, add the entire choice menu to the panel in the usual way:\nadd(c);\nFigure 13.7 shows a simple choice menu generated from code in the previous example:\nFigure 13.7.\nChoice menus.\nTip: Choice menus enable only one selection per menu. If you want to select\nmultiple items, use a scrolling list instead.\nOnce your choice menu is created, regardless of whether it\u2019s added to a panel, you can continue\nto add items to that menu by using the addItem() method. Table 13.3 shows some other\nmethods that may be useful in working with choice menus.\nTable 13.3. Choice menu methods.\nMethod Action\ngetItem(int) Returns the string item at the given position (items inside a choice\nbegin at 0, same as arrays)\ncountItems() Returns the number of items in the menu\ngetSelectedIndex() Returns the index position of the item that\u2019s selected\n246\n030-4s CH13.i 246 1\/29\/96, 10:34 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 Sams.net Learning\nCenter\nabcd\nMethod Action\ngetSelectedItem() Returns the currently selected item as a string\nselect(int) Selects the item at the given position\nselect(String) Selects the item with that string\nText Fields\nUnlike the UI components up to this point, which enable you to select only among several\noptions to perform an action, text fields allow you to enter any values.\nNEW* Text fields enable your reader to enter text.\nTERM\nTo create a text field, use one of the following constructors:\nnn TextField() creates an empty TextField 0 characters wide.\nnn TextField(int) creates an empty text field with the given width in characters.\nnn TextField(String) creates a text field 0 characters wide, initialized with the given\nstring.\nnn TextField(String, int) creates a text field with the given width in characters and\ncontaining the given string. If the string is longer than the width, you can select and\ndrag portions of the text within the field and the box will scroll left or right.\nFor example, the following line creates a text field 30 characters wide with the string \u201cEnter Your\nName\u201d as its initial contents.\nTextField tf = new TextField(\u201cEnter Your Name\u201d,30);\nadd(tf);\n13\nTip: Text fields include only the editable field itself. You usually need to include a\nlabel with a text field to indicate what belongs in that text field.\nNote: Text fields are different from text areas; text fields are limited in size and are\nbest used for one-line items, whereas text areas have scrollbars and are better for\nlarger text windows. Both can be edited and enable selections with the mouse.\nYou\u2019ll learn about text areas later today.\n247\n030-4s CH13.i 247 1\/29\/96, 10:34 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 MTWRFSS\nDDAAYY\n13 The Java Abstract Windowing Toolkit\nYou can also create a text field that obscures the characters typed into it\u2014for example, for\npassword fields. To do this, first create the text fields itself, and then use the setEchoCharacter()\nmethod to set the character that is echoed on the screen. Here is an example:\nTextField tf = new TextField(30);\ntf.setEchoCharacter(\u2019*\u2019);\nFigure 13.8 shows three text boxes (and labels) that were created by using the following code:\nadd(new Label(\u201cEnter your Name\u201d));\nadd(new TextField(\u201cyour name here\u201d,45));\nadd(new Label(\u201cEnter your phone number\u201d));\nadd(new TextField(12));\nadd(new Label(\u201cEnter your password\u201d));\nTextField t = new TextField(20);\nt.setEchoCharacter(\u2018*\u2019);\nadd(t);\nFigure 13.8.\nText fields.\nText fields inherit from the class TextComponent and have a whole suite of methods, both\ninherited from that class and defined in its own class, that may be useful to you in your Java\nprograms. Table 13.4 shows a selection of those methods.\nTable 13.4. Text field methods.\nMethod Action\ngetText() Returns the text this text field contains (as a string)\nsetText(String) Puts the given text string into the field\ngetColumns() Returns the width of this text field\nselect(int, int) Selects the text between the two integer positions (positions\nstart from 0)\nselectAll() Selects all the text in the field\n248\n030-4s CH13.i 248 1\/29\/96, 10:34 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 Sams.net Learning\nCenter\nabcd\nMethod Action\nisEditable() Returns true or false based on whether the text is editable or\nnot\nsetEditable(boolean) True (the default) enables text to be edited; false freezes the text\ngetEchoChar() Returns the character used for masking input\nechoCharIsSet() Returns true or false whether the field has a masking character\nor not\nPanels and Layout\nYou know at this point that an AWT panel can contain UI components or other panels. The\nquestion now is how those components are actually arranged and displayed on the screen.\nIn other windowing systems, UI components are often arranged using hard-coded pixel\nmeasurements\u2014put text field tf at 10,30, for example\u2014the same way you used the graphics\noperations to paint squares and ovals on the screen. In the AWT, the window may be displayed\non many different windowing systems on many different screens and with many different kinds\nof fonts with different font metrics. Therefore, you need a more flexible method of arranging\ncomponents on the screen so that a layout that looks nice on one platform isn\u2019t a jumbled\nunusable mess on another.\nFor just this purpose, Java has layout managers, insets, and hints that each component can\nprovide for helping lay out the screen.\nNote that the nice thing about AWT components and user interface items is that you don\u2019t have\nto paint them\u2014the AWT system manages all that for you. If you have graphical components\nor images, or you want to create animations inside panels, you still have to do that by hand, but\n13\nfor most of the basic components, all you have to do is put them on the screen and Java will\nhandle the rest.\nLayout Managers\nThe actual appearance of the AWT components on the screen is determined by two things: the\norder in which they are added to the panel that holds them, and the layout manager that panel\nis currently using to lay out the screen. The layout manager determines how portions of the\nscreen will be sectioned and how components within that panel will be placed.\nNote that each panel on the screen can have its own layout manager. By nesting panels within\npanels, and using the appropriate layout manager for each one, you can often arrange your UI\nto group and arrange components in a way that is both functionally useful and also looks good\n249\n030-4s CH13.i 249 1\/29\/96, 10:34 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 MTWRFSS\nDDAAYY\n13 The Java Abstract Windowing Toolkit\non a variety of platforms and windowing systems. You\u2019ll learn about nesting panels in a later\nsection.\nThe AWT provides four basic layout managers: FlowLayout, GridLayout, BorderLayout, and\nCardLayout. To create a layout manager for a given panel, use the setLayout() method for that\npanel:\npublic void init() {\nthis.setLayout(new FlowLayout());\n}\nSetting the default layout manager, like defining the user interface components, is best done\nduring the applet or class\u2019s initialization, which is why it\u2019s included here.\nOnce the layout manager is set, you can start adding components to the panel. The order in\nwhich components are added is often significant, depending on which layout manager is\ncurrently active. Read on for information about the specific layout managers and how they\npresent components within the panel to which they apply.\nThe following sections describe the four basic Java AWT layout managers.\nThe FlowLayout Class\nThe FlowLayout class is the most basic of layouts. Using the flow layout, components are added\nto the panel one at a time, row by row. If a component doesn\u2019t fit onto a row, it\u2019s wrapped onto\nthe next row. The flow layout also has an alignment, which determines the alignment of each\nrow. By default, each row is aligned centered. Figure 13.9 shows a flow layout at its best\u2014a\nsimple row of buttons, centered on a line.\nFigure 13.9.\nFlow layout.\n250\n030-4s CH13.i 250 1\/29\/96, 10:35 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 Sams.net Learning\nCenter\nabcd\nTo create a basic flow layout with a centered alignment, use the following line of code in your\npanel\u2019s initialization (because this is the default pane layout, you don\u2019t need to include this line\nif that is your intent):\nsetLayout(new FlowLayout());\nTo create a flow layout with an alignment other than centered, add the FlowLayout.RIGHT or\nFlowLayout.LEFT class variable as an argument:\nsetLayout(new FlowLayout(FlowLayout.LEFT));\nYou can also set horizontal and vertical gap values by using flow layouts. The gap is the number\nof pixels between components in a panel; by default, the horizontal and vertical gap values are\nthree pixels, which can be very close indeed. Horizontal gap spreads out components to the left\nand to the right, vertical gap to the top and bottom of each component. Add integer arguments\nto the flow layout constructor to increase the gap (a layout gap of 10 points in both the horizontal\nand vertical directions is shown in Figure 13.10):\nsetLayout(new FlowLayout(FlowLayout.LEFT),10,10);\nFigure 13.10.\nFlow layout with a gap of\n10 points.\n13\nGrid Layouts\nGrid layouts use a layout that offers more control over the placement of components inside a\npanel. Using a grid layout, you portion off the area of the panel into rows and columns. Each\ncomponent you then add to the panel is placed in a \u201ccell\u201d of the grid, starting from the top row\nand progressing through each row from left to right (here\u2019s where the order of calls to the add()\nmethod are very relevant to how the screen is laid out). By using grid layouts and nested grids,\n251\n030-4s CH13.i 251 1\/29\/96, 10:35 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 MTWRFSS\nDDAAYY\n13 The Java Abstract Windowing Toolkit\nyou can often approximate the use of hard-coded pixel values to place your UI components\nprecisely where you want them. Figure 13.11 shows a grid layout with three columns and three\nrows.\nFigure 13.11.\nGrid layout.\nTo create a grid layout, indicate the number of rows and columns you want the grid to have when\nyou create a new instance of the GridLayout class:\nsetLayout(new GridLayout(3,3));\nGrid layouts can also have a horizontal and vertical gap between components; to create gaps, add\nthose pixel values:\nsetLayout(new GridLayout(3,3,10,15));\nFigure 13.12 shows a grid layout with a 10-pixel horizontal gap and a 15-pixel vertical gap.\nGrid bag layouts, as implemented by the GridBagLayout class, are variations on grid layouts. Grid\nbag layouts also enable you to lay out your user interface elements in a rectangular grid, but with\ngrid bag layouts you have much more control over the presentation of each element in the grid.\nGrid bag layouts use a helper class, GridBagConstraints, to indicate how each cell in the grid is\nto be formatted.\nNote: The GridBagLayout and GridBagConstraints classes were added to the Java\nDeveloper\u2019s Kit just before this book went to press. For a much better description\nof grid bag layouts, see the API documentation for those classes that comes with\nthe JDK.\n252\n030-4s CH13.i 252 1\/29\/96, 10:35 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 Sams.net Learning\nCenter\nabcd\nFigure 13.12.\nGrid layouts with horizontal\nand vertical gap.\nBorder Layouts\nBorder layouts behave differently from flow and grid layouts. When you add a component to\na panel that uses a border layout, you indicate its placement as a geographic direction: north,\nsouth, east, west, and center (see Figure 13.13). The components around all the edges are laid\nout with as much size as they need; the component in the center, if any, gets any space left over.\nFigure 13.13.\nBorder layout.\n13\nTo use a border layout, you create it as you do the other layouts:\nsetLayout(new BorderLayout());\n253\n030-4s CH13.i 253 1\/29\/96, 10:35 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 MTWRFSS\nDDAAYY\n13 The Java Abstract Windowing Toolkit\nThen you add the individual components by using a special add() method: the first argument\nto add() is a string indicating the position of the component within the layout:\nadd(\u201cNorth\u201d, new TextField(\u201cTitle\u201d,50));\nadd(\u201cSouth\u201d, new TextField(\u201cStatus\u201d,50));\nYou can also use this form of add() for the other layout managers; the string argument will just\nbe ignored if it\u2019s not needed.\nBorder layouts can also have horizontal and vertical gaps. Note that the north and south\ncomponents extend all the way to the edge of the panel, so the gap will result in less space for\nthe east, right, and center components. To add gaps to a border layout, include those pixel values\nas before:\nsetLayout(new BorderLayout(10,10));\nCard Layouts\nCard layouts are different from the other layouts. Unlike with the other three layouts, when you\nadd components to a card layout, they are not all displayed on the screen at once. Card layouts\nare used to produce slide shows of components, one at a time. If you\u2019ve ever used the HyperCard\nprogram on the Macintosh, you\u2019ve worked with the same basic idea.\nGenerally when you create a card layout, the components you add to it will be other container\ncomponents\u2014usually panels. You can then use different layouts for those individual \u201ccards\u201d so\nthat each screen has its own look.\nWhen you add each \u201ccard\u201d to the panel, you can give it a name. Then you can use methods\ndefined on the CardLayout class to move back and forth between different cards in the layout.\nFor example, here\u2019s how to create a card layout containing three cards:\nsetLayout(new CardLayout());\nPanel one = new Panel()\nadd(\u201cfirst\u201d, one);\nPanel two = new Panel()\nadd(\u201csecond\u201d, two);\nPanel three = new Panel()\nadd(\u201cthird\u201d, three);\nshow(this, \u201csecond\u201d);\nInsets\nWhereas horizontal gap and vertical gap are used to determine the amount of space between\ncomponents in a panel, insets are used to determine the amount of space around the panel itself.\nThe insets class provides values for the top, bottom, left, and right insets, which are then used\nwhen the panel itself is drawn. Figure 13.14 shows an inset in a GridLayout.\n254\n030-4s CH13.i 254 1\/29\/96, 10:35 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 Sams.net Learning\nCenter\nabcd\nInsets\nFigure 13.14.\nInsets.\nTo include an inset, override the insets() method in your class (your Applet class or other class\nthat serves as a panel):\npublic Insets insets() {\nreturn new Insets(10,10,10,10);\n}\nThe arguments to the Insets constructor provide pixel insets for the top, bottom, left, and right\nedges of the panel. This particular example provides an inset of 10 pixels on all four sides of the\npanel.\nHandling UI Actions and Events\n13\nIf you stopped reading today\u2019s lesson right now, you could go out and create an applet that had\nlots of little UI components, nicely laid out on the screen with the proper layout manager, gap,\nand insets. If you did stop right here, however, your applet would be really dull, because none\nof your UI components would actually do anything when they were pressed or typed into or\nselected.\nFor your UI components to do something when they are activated, you need to hook up the UI\u2019s\naction with an operation.\nTesting for an action by a UI component is a form of event management\u2014the things you learned\nyesterday about events will come in handy here. In particular, UI components produce the\nspecial kind of event called an action. To intercept an action by any UI component, you define\nan action() method in your applet or class:\n255\n030-4s CH13.i 255 1\/29\/96, 10:35 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 MTWRFSS\nDDAAYY\n13 The Java Abstract Windowing Toolkit\npublic boolean action(Event evt, Object arg) {\n...\n}\nThe action() method should look familiar to the basic mouse and keyboard event methods.\nLike those methods, it gets passed the event object that represents this event. It also gets an extra\nobject, which can be of any type of object. What\u2019s that second argument for?\nThe second argument to the action method depends on the UI component that\u2019s generating the\nevent. The basic definition is that it\u2019s any arbitrary argument\u2014when a component generates an\nevent, it can pass along any extra information that might later be needed. Because that extra\ninformation may be useful for you, it\u2019s passed on through the action() method.\nAll the basic UI components (except for labels, which have no action) have different actions and\narguments:\nnn Buttons create actions when they are selected, and a button\u2019s argument is the label of\nthe button.\nnn Checkboxes, both exclusive and nonexclusive, generate actions when a box is checked.\nThe argument is always true.\nnn Choice menus generate an action when a menu item is selected, and the argument is\nthat item.\nnn Text fields create actions when the user presses Return inside that text field. Note that\nif the user tabs to a different text field or uses the mouse to change the input focus, an\naction is not generated. Only a Return triggers the action.\nNote that with actions, unlike with ordinary events, you can have many different kinds of objects\ngenerating the event, as opposed to a single event such as a mouseDown. To deal with those\ndifferent UI components and the actions they generate, you have to test for the type of object\nthat called the event in the first place inside the body of your action() method. That object is\nstored in the event\u2019s target instance variable, and you can use the instanceof operator to find\nout what kind of UI component sent it:\npublic boolean action(Event evt, Object arg) {\nif (evt.target instanceof TextField)\nhandleText(evt.target);\nelse if (evt.target instanceof Choice)\nhandleChoice(arg);\n...\n}\nAlthough you can handle UI actions in the body of the action() method, it\u2019s much more\ncommon simply to define a handler method and call that method from action() instead. Here,\nthere are two handler methods: one to handle the action on the text field (handleText()) and\none to handle the action on the choice menu (handleChoice()). Depending on the action you\nwant to handle, you may also want to pass on the argument from the action, the UI component\nthat sent it, or any other information that the event might contain.\n256\n030-4s CH13.i 256 1\/29\/96, 10:36 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 Sams.net Learning\nCenter\nabcd\nHere\u2019s a simple applet that has five buttons labeled with colors. The action() method tests for\na button action and then passes off the word to a method called changeColor(), which changes\nthe background color of the applet based on which button was pressed (see Figure 13.15 to see\nthe applet in action):\nimport java.awt.*;\npublic class ButtonActionsTest extends java.applet.Applet {\npublic void init() {\nsetBackground(Color.white);\nadd(new Button(\u201cRed\u201d));\nadd(new Button(\u201cBlue\u201d));\nadd(new Button(\u201cGreen\u201d));\nadd(new Button(\u201cWhite\u201d));\nadd(new Button(\u201cBlack\u201d));\n}\npublic boolean action(Event evt, Object arg) {\nif (evt.target instanceof Button)\nchangeColor((String)arg);\nreturn true;\n}\nvoid changeColor(String bname) {\nif (bname.equals(\u201cRed\u201d)) setBackground(Color.red);\nelse if (bname.equals(\u201cBlue\u201d)) setBackground(Color.blue);\nelse if (bname.equals(\u201cGreen\u201d)) setBackground(Color.green);\nelse if (bname.equals(\u201cWhite\u201d)) setBackground(Color.white);\nelse setBackground(Color.black);\n}\n}\nFigure 13.15.\nThe ButtonAction applet.\n13\n257\n030-4s CH13.i 257 1\/29\/96, 10:36 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 MTWRFSS\nDDAAYY\n13 The Java Abstract Windowing Toolkit\nNesting Panels and Components\nAdding UI components to individual applets is fun, but applets begin to turn into lots of fun\nwhen you begin working with nested panels. By nesting different panels inside your applet, and\npanels inside those panels, you can create different layouts for different parts of the overall applet\narea, isolate background and foreground colors and fonts to individual parts of an applet, and\nmanage the design of your UI components much more cleanly and simply. The more complex\nthe layout of your applet, the more likely you\u2019re going to want to use nested panels.\nNested Panels\nPanels, as you\u2019ve already learned, are components that can be actually displayed on screen;\nPanel\u2019s superclass Container provides the generic behavior for holding other components inside\nit. The Applet class, which your applets all inherit from, is a subclass of Panel. To nest other\npanels inside an applet, you merely create a new panel and add it to the applet, just as you would\nadd any other UI component:\nsetLayout(new GridLayout(1,2,10,10));\nPanel panel1 = new Panel();\nPanel panel2 = new Panel();\nadd(panel1);\nadd(panel2);\nYou can then set up an independent layout for those subpanels and add AWT components to\nthem (including still more subpanels) by calling the add() method in the appropriate panel:\npanel1.setLayout(new FlowLayout());\npanel1.add(new Button(\u201cUp\u201d));\npanel1.add(new Button(\u201cDown\u201d));\nAlthough you can do all this in a single class, it\u2019s common in applets that make heavy use of the\npanels to factor out the layout and behavior of the subpanels into separate classes, and to\ncommunicate between the panels by using method calls. You\u2019ll look at an extensive example of\nthis later on in today\u2019s lesson.\nEvents and Nested Panels\nWhen you create applets with nested panels, those panels form a hierarchy from the outermost\npanel (the applet, usually), to the innermost UI component. This hierarchy is important to how\neach component in an applet interacts with the other components in the applet or with the\nbrowser that contains that applet; in particular, the component hierarchy determines the order\nin which components are painted to the screen.\nMore importantly, the hierarchy also affects event handling, particularly for user input events\nsuch as mouse and keyboard events.\n258\n030-4s CH13.i 258 1\/29\/96, 10:36 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 Sams.net Learning\nCenter\nabcd\nEvents are received by the innermost component in the component hierarchy and passed up the\nchain to the root. Suppose, for example, that you have an applet with a subpanel that can handle\nmouse events (using the mouseDown() and mouseUp() methods) and that panel contains a button.\nClicking on the button means that the button receives the event before the panel does; if the\nbutton isn\u2019t interested in that mouseDown(), the event gets passed to the panel, which can then\nprocess it or pass it further up the hierarchy.\nRemember the discussion about the basic event methods yesterday? You learned that the basic\nevent methods all return boolean values. Those boolean values become important when you\u2019re\ntalking about handling events or passing them on.\nAn event handling method, whether it is the set of basic event methods or the more generic\nhandleEvent(), can do one of three things, given any random event:\nnn Not be interested in the event (this is usually true only for handleEvent(), which\nreceives all the events generated by the system). If this is the case, the event is passed\non up the hierarchy until a component processes it (or it is ignored altogether). In this\ncase, the event handling method should return false.\nnn Intercept the event, process it, and return true. In this case, the event stops with that\nevent method. Recall that this is the case with the basic mouseDown() and keyDown()\nmethods that you learned about yesterday.\nnn Intercept the method, process it, and pass it on to the next event handler. This is a\nmore unusual case, but you may create a user interface by using nested components\nthat will want to do this. In this case, the event method should return false to pass\nthe event on to the next handler in the chain.\nMore UI Components\nOnce you master the basic UI components and how to add them to panels and manage their 13\nevents, you can add more UI components. In this section, you\u2019ll learn about text areas, scrolling\nlists, scrollbars, and canvases.\nNote that the UI components in this section do not produce actions, so you can\u2019t use the\naction() method to handle their behavior. Instead, you have to use a generic handleEvent()\nmethod to test for specific events that these UI components generate. You\u2019ll learn more about\nthis in the next section.\nText Areas\nText areas are like text fields, except they have more functionality for handling large amounts\nof text. Because text fields are limited in size and don\u2019t scroll, they are better for one-line\n259\n030-4s CH13.i 259 1\/29\/96, 10:36 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 MTWRFSS\nDDAAYY\n13 The Java Abstract Windowing Toolkit\nresponses and text entry; text areas can be any given width and height and have scrollbars in\ndefault, so you can deal with larger amounts of text more easily.\nTo create a text area, use one of the following constructors:\nnn TextArea() creates an empty text area 0 rows long and 0 characters wide. Given that a\ntext area with no dimensions can\u2019t be displayed, you should make sure you change the\ndimensions of this new text area before adding it to a panel (or just use the next\nconstructor instead).\nnn TextArea(int, int) creates an empty text area with the given rows and columns\n(characters).\nnn TextArea(String) creates a text area displaying the given string, 0 rows by 0 columns.\nnn TextArea(String, int, int) creates a text area by displaying the given string and with\nthe given dimensions.\nFigure 13.16 shows a simple text area generated from the following code:\nString str = \u201cOnce upon a midnight dreary, while I pondered, weak and weary,\\n\u201d +\n\u201cOver many a quaint and curious volume of forgotten lore,\\n\u201d +\n\u201cWhile I nodded, nearly napping, suddenly there came a tapping,\\n\u201d +\n\u201cAs of some one gently rapping, rapping at my chamber door.\\n\u201d +\n\u201c\\\u201d\u2019Tis some visitor,\\\u201d I muttered, \\\u201dtapping at my chamber door-\\n\u201d;\nadd(new TextArea(str,10,60));\nFigure 13.16.\nA text area.\nBoth text areas and text fields inherit from the TextComponent class, so a lot of the behavior for\ntext fields (particularly getting and setting text and selections) is usable on text areas as well (refer\nto Table 13.4). Text areas also have a number of their own methods that you may find useful.\nTable 13.5 shows a sampling of those methods.\n260\n030-4s CH13.i 260 1\/29\/96, 10:36 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 Sams.net Learning\nCenter\nabcd\nTable 13.5. Text area methods.\nMethod Action\ngetColumns() Returns the width of the text area, in characters or\ncolumns\ngetRows() Returns the number of rows in the text area (not the\nnumber of rows of text that the text area contains)\ninsertText(String, int) Inserts the string at the given position in the text (text\npositions start at 0)\nreplaceText(String, int, int) Replace the text between the given integer positions\nwith the new string\nScrolling Lists\nRemember the choice menu, which enables you to choose one of several different options? A\nscrolling list is functionally similar to a choice menu in that it lets you pick several options from\na list. Scrolling lists differ in two significant ways:\nnn Scrolling lists are not popup menus. They\u2019re lists of items in which you can choose\none or more items from a list. If the number of items is larger than the list box, a\nscrollbar is automatically provided so that you can see the other items.\nnn A scrolling list can be defined to accept only one item at a time (exclusive), or multiple\nitems (nonexclusive).\nTo create a scrolling list, create an instance of the List class and then add individual items to\nthat list. The List class has two constructors:\nnn List() creates an empty scrolling list that enables only one selection at a time. 13\nnn List(int, boolean) creates a scrolling list with the given number of visible lines on\nthe screen (you\u2019re unlimited as to the number of actual items you can add to the list).\nThe boolean argument indicates whether this list enables multiple selections (true) or\nnot (false).\nAfter creating a List object, add items to it using the addItem() method and then add the list\nitself to the panel that contains it. Here\u2019s an example, the result of which is shown in Figure\n13.17:\nList lst = new List(5, true);\nlst.addItem(\u201cHamlet\u201d);\nlst.addItem(\u201cClaudius\u201d);\n261\n030-4s CH13.i 261 1\/29\/96, 10:36 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 MTWRFSS\nDDAAYY\n13 The Java Abstract Windowing Toolkit\nlst.addItem(\u201cGertrude\u201d);\nlst.addItem(\u201cPolonius\u201d);\nlst.addItem(\u201cHoratio\u201d);\nlst.addItem(\u201cLaertes\u201d);\nlst.addItem(\u201cOphelia\u201d);\nadd(lst);\nFigure 13.17.\nA scrolling list.\nTable 13.6 shows some of the methods available to scrolling lists. See the API documentation\nfor a complete set.\nTable 13.6. Scrolling list methods.\nMethod Action\ngetItem(int) Returns the string item at the given position\ncountItems() Returns the number of items in the menu\ngetSelectedIndex() Returns the index position of the item that\u2019s selected (used for\nlists that enable only single selections)\ngetSelectedIndexes() Returns an array of index positions (used for lists that enable\nmultiple selections)\ngetSelectedItem() Returns the currently selected item as a string\ngetSelectedItems() Returns an array of strings containing all the selected items\nselect(int) Selects the item at the given position\nselect(String) Selects the item with that string\nScrollbars and Sliders\nText areas and scrolling lists come with their own scrollbars, which are built into those UI\ncomponents and enable you to manage both the body of the area or the list and its scrollbar as\na single unit. You can also create individual scrollbars, or sliders, to manipulate a range of values.\n262\n030-4s CH13.i 262 1\/29\/96, 10:36 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 Sams.net Learning\nCenter\nabcd\nScrollbars are used to select a value between a maximum and a minimum value. To change the\ncurrent value of that scrollbar, you can use three different parts of the scrollbar (see Figure\n13.18):\nnn Arrows on either end, which increment or decrement the values by some small unit (1\nby default).\nnn A range in the middle, which increments or decrements the value by a larger amount\n(10 by default).\nnn A box in the middle, often called an elevator or thumb, whose position shows where in\nthe range of values the current value is located. Moving this box with the mouse\ncauses an absolute change in the value, based on the position of the box within the\nscrollbar.\nFigure 13.18.\nScrollbar parts.\nArrow (\u2013 1)\nBox (elevator, thumb)\nRange (\u2013 10)\nChoosing any of these visual elements causes a change in the scrollbar\u2019s value; you don\u2019t have\nto update anything or handle any events. All you have to do is give the scrollbar a maximum and 13\nminimum, and Java will handle the rest.\nTo create a scrollbar, you can use one of three constructors:\nnn Scrollbar() creates a scrollbar with 0, 0 as its initial maximum and initial minimum\nvalues, in a vertical orientation.\nnn Scrollbar(int) creates a scrollbar with 0, 0 as its initial maximum and initial mini-\nmum values. The argument represents an orientation, for which you can use the class\nvariables Scrollbar.HORIZONTAL and Scrollbar.VERTICAL.\nnn Scrollbar(int, int, int, int, int) creates a scrollbar with the following arguments\n(each one is an integer, and must be presented in this order):\nThe first argument is the orientation of the scrollbar: Scrollbar.HORIZONTAL and\nScrollbar.VERTICAL.\n263\n030-4s CH13.i 263 1\/29\/96, 10:37 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 MTWRFSS\nDDAAYY\n13 The Java Abstract Windowing Toolkit\nThe second argument is the initial value of the scrollbar, which should be a value\nbetween the scrollbar\u2019s maximum and minimum values.\nThe third argument is the the overall width (or height, depending on the orientation)\nof the scrollbar\u2019s box. In user interface design, a larger box implies that a larger\namount of the total range is currently showing (applies best to things such as windows\nand text areas).\nThe fourth and fifth arguments are the minimum and maximum values for the\nscrollbar.\nHere\u2019s a simple example of a scrollbar that increments a single value (see Figure 13.19). The label\nto the left of the scrollbar is updated each time the scrollbar\u2019s value changes:\nimport java.awt.*;\npublic class SliderTest extends java.applet.Applet {\nLabel l;\npublic void init() {\nl = new Label(\u201c0\u201d);\nadd(l);\nadd(new Scrollbar(Scrollbar.HORIZONTAL, 1, 0, 1, 100));\n}\npublic boolean handleEvent(Event evt) {\nif (evt.target instanceof Scrollbar) {\nint v = ((Scrollbar)evt.target).getValue();\nl.setText(String.valueOf(v));\n}\nreturn true;\n}\n}\nFigure 13.19.\nA scrollbar.\nThe Scrollbar class provides several methods for managing the values within scrollbars (see\nTable 13.7).\nTable 13.7. Scrollbar methods.\nMethod Action\ngetMaximum() Returns the maximum value\ngetMinimum() Returns the minimum value\n264\n030-4s CH13.i 264 1\/29\/96, 10:37 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 Sams.net Learning\nCenter\nabcd\nMethod Action\ngetOrientation() Returns the orientation of this scrollbar:\n0 for vertical, 1 for horizontal\ngetValue() Returns the scrollbar\u2019s current value\nsetValue(int) Sets the current value of the scrollbar\nCanvases\nAlthough you can draw on most AWT components, such as panels, canvases do little except let\nyou draw on them. They can\u2019t contain other components, but they can accept events, and you\ncan create animations and display images on them. Canvases, in other words, should be used for\nmuch of the stuff you learned about earlier this week.\nNEW* A canvas is a component that you can draw on.\nTERM\nTo create a canvas, use the Canvas class and add it to a panel as you would any other component:\nCanvas can = new Canvas();\nadd(can);\nMore UI Events\nYesterday, you learned about some basic event types that are generated from user input to the\nmouse or the keyboard. These event types are stored in the Event object as the event ID, and can\nbe tested for in the body of a handleEvent() method by using class variables defined in Event.\nFor many basic events, such as mouseDown() and keyDown(), you can define methods for those\nevents to handle the event directly. You learned a similar mechanism today for UI actions where\n13\ncreating an action() method handled a specific action generated by a UI component.\nThe most general way of managing events, however, continues to be the handleEvent() method.\nFor events relating to scrollbars and scrolling lists, the only way to intercept these events is to\noverride handleEvent().\nTo intercept a specific event, test for that event\u2019s ID. The available IDs are defined as class\nvariables in the Event class, so you can test them by name. You learned about some of the basic\nevents yesterday; Table 13.8 shows additonal events that may be useful to you for the\ncomponents you\u2019ve learned about today (or that you might find useful in general).\n265\n030-4s CH13.i 265 1\/29\/96, 10:37 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 MTWRFSS\nDDAAYY\n13 The Java Abstract Windowing Toolkit\nTable 13.8. Additional events.\nEvent ID What It Represents\nACTION_EVENT Generated when a UI component action occurs\nKEY_ACTION Generated when text field action occurs\nLIST_DESELECT Generated when an item in a scrolling list is deselected\nLIST_SELECT Generated when an item in a scrolling list is selected\nSCROLL_ABSOLUTE Generated when a scrollbar\u2019s box has been moved\nSCROLL_LINE_DOWN Generated when a scrollbar\u2019s bottom endpoint (or left endpoint) is\nselected\nSCROLL_LINE_UP Generated when a scrollbar\u2019s top endpoint (or right endpoint) is\nselected\nSCROLL_PAGE_DOWN Generated when the scrollbar\u2019s field below (or to the left of) the\nbox is selected\nSCROLL_PAGE_UP Generated when the scrollbar\u2019s field above (or to the right of) the\nbox is selected\nA Complete Example:\nRGB to HSB Converter\nLet\u2019s take a break here from theory and smaller examples to create a larger, more complex\nexample that puts together much of what you\u2019ve learned so far. The following applet example\ndemonstrates layouts, nesting panels, creating user interface components, and catching and\nhandling actions, as well as using multiple classes to put together a single applet. In short, it\u2019s\nprobably the most complex applet you\u2019ll create so far.\nFigure 13.20 shows the applet you\u2019ll be creating in this example. The ColorTest applet enables\nyou to pick colors based on RGB (red, green, and blue) and HSB (hue, saturation, and\nbrightness) values.\nFigure 13.20.\nThe ColorTest applet.\n266\n030-4s CH13.i 266 1\/29\/96, 10:37 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 Sams.net Learning\nCenter\nabcd\nThe ColorTest applet has three main parts: a colored box on the left side and two groups of text\nfields on the right. The first group indicates RGB values, the right, HSB. By changing any of\nthe values in any of the text boxes, the colored box is updated to the new color, as are the values\nin the other group of text boxes.\nThis applet uses two classes:\nnn ColorTest, which inherits from Applet. This is the controlling class for the applet\nitself.\nnn ColorControls, which inherits from Panel. You\u2019ll create this class to represent a group\nof three text fields and to handle actions from those text fields. Two instances of this\nclass, one for the RGB values and one for the HSB ones, will be created and added to\nthe applet.\nLet\u2019s work through this step by step, because it\u2019s very complicated and can get confusing. All the\ncode for this applet will be shown at the end of this section.\nCreate the Applet Layout\nThe best way to start creating an applet that uses AWT components is to worry about the layout\nfirst and then worry about the functionality. When dealing with the layout, you also should start\nwith the outermost panel first and work inward.\nMaking a sketch of your UI design can help you figure out how to organize the panels inside your\napplet or window to best take advantage of layout and space. Figure 13.21 shows the ColorTest\napplet with a grid drawn over it so that you can get an idea of how the panels and embedded\npanels work.\nFigure 13.21.\nThe ColorTest applet panels 13\nand components.\nCreate the Panel Layout\nLet\u2019s start with the outermost panel\u2014the applet itself. This panel has three parts: the color box\non the left, the RGB text fields in the middle, and the HSB fields on the right.\nBecause this is the applet, your ColorTest class will be the applet class and inherit from Applet.\nYou\u2019ll also import the AWT classes here (note that because you use so many of them in this\nprogram, it\u2019s easiest to just import the entire package):\n267\n030-4s CH13.i 267 1\/29\/96, 10:38 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 MTWRFSS\nDDAAYY\n13 The Java Abstract Windowing Toolkit\nimport java.awt.*;\npublic class ColorTest extends java.applet.Applet {\n...\n}\nLet\u2019s start with the init() method, where all the basic initialization and layout takes place. There\nare four major steps:\n1. Set the layout for the big parts of the panel. Although a flow layout would work, a\ngrid layout with one row and three columns is a much better idea.\n2. Create the three components of this applet: a canvas for the color box and two\nsubpanels for the text fields.\n3. Add those components to the applet.\n4. Finally, initialize the default color and update all the panels to reflect that default\ncolor.\nBefore you do any of that, let\u2019s set up instance variables to hold the three major components of\nthis applet. You need to keep hold of these objects so you can update things when a value changes.\nThe color box is easy\u2014it\u2019s just a canvas. Call it swatch.\nCanvas swatch;\nNow onto the subpanels. There are two of them, and although they have different labels and\nvalues, they\u2019re essentially the same panel. You could just create code for each one here, but you\u2019d\nend up duplicating a lot of the same code. This is a perfect opportunity, therefore, to create\nanother class to represent the subpanels with the text fields on them. Call them ColorControls\n(you\u2019ll get around to creating the class later) and define two variables, RGBcontrols and\nHSBcontrols, to hold them:\nColorControls RGBcontrols, HSBcontrols;\nBack to the init() method. Step one is the layout. Let\u2019s use a grid layout and a gap of ten points\nto separate each of the components:\nsetLayout(new GridLayout(1,3,10,10));\nStep two is creating the components, the canvas first. You have an instance variable to hold that\none:\nswatch = new Canvas();\nYou need to create two instances of your as-of-yet nonexistent ColorControls panels here as well,\nbut you don\u2019t know exactly what you need to create them yet, so let\u2019s put in some basic\nconstructors and fill in the details later:\nRGBcontrols = new ColorControls()\nHSBcontrols = new ColorControls();\n268\n030-4s CH13.i 268 1\/29\/96, 10:38 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 Sams.net Learning\nCenter\nabcd\nStep three is adding them to the panel.\nadd(swatch);\nadd(RGBcontrols);\nadd(HSBcontrols);\nWhile you\u2019re working on layout, add an inset just for fun\u2014ten points along all the edges:\npublic Insets insets() {\nreturn new Insets(10,10,10,10);\n}\nGot it so far? Now you have a skeleton init() method and an insets() method in your\nColorTest class. Let\u2019s move on now to creating the subpanel layout\u2014to creating thatC olorControls\nclass.\nDefine the Subpanels\nThe ColorControls class will have behavior for laying out and handling the subpanels that\nrepresent the RGB and HSB values for the color. ColorControls doesn\u2019t need to be a subclass\nof Applet because it isn\u2019t actually an applet, it\u2019s just a panel. Define it to inherit from Panel:\nclass ColorControls extends Panel {\n...\n}\nNote: You can put the ColorControls class in the same file as the ColorTest class.\nYou haven\u2019t been doing this so far because the applets and applications you\u2019ve been\ncreating had only one class. If you remember way back to Day 1, however, you\nlearned that you can have multiple class definitions in a single file as long as only\none of those definitions is declared public. In this case, the ColorTest class is\npublic (it\u2019s an applet, so it has to be), but the ColorControls class doesn\u2019t need to 13\nbe, so everything works out fine.\nYou need a couple of instance variables in this class. The first thing you need is a hook back up\nto the applet class that contains this panel. Why? The applet class is the class that oversees how\nthe subcomponents work, so it\u2019s going to be the class that updates everything. Eventually, you\u2019re\ngoing to have to call a method in that class to indicate that something in this panel has changed.\nWithout an actual reference to that outer class, there\u2019s no way to do this. So, instance variable\nnumber one is a reference to the class ColorTest:\nColorTest outerparent;\nIf you figure that the applet class is the one that\u2019s going to be updating everything, that class is\ngoing to need a way to get hold of the pieces inside this class. In particular, it\u2019s going to be\n269\n030-4s CH13.i 269 1\/29\/96, 10:38 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 MTWRFSS\nDDAAYY\n13 The Java Abstract Windowing Toolkit\ninterested in the individual text fields, so you\u2019re going to need instance variables to hold those.\nThis creates three of them:\nTextField f1, f2, f3;\nNow for the constructor for this class. Again, this isn\u2019t an applet, so you don\u2019t use init(); all\nyou need is a constructor method.\nWhat do you need inside that constructor? You need to set the layout for the subpanel, create\nthe text fields, and add them to the panel. The goal here is to make the ColorControls class\ngeneric enough so that you can use it for both the RGB fields and the HSB fields.\nThe two different panels differ in two respects: the labels for the text fields, and the initial values\nfor the text fields. That\u2019s six values to get before you can create the object. You can pass those\nsix values in through the constructors in ColorTest. You also need one more. Because you need\nthat hook back to the applet class, you should also pass in a reference to that object as part of\nthe constructor.\nYou now have seven arguments to the basic constructor for the ColorControls class. Here\u2019s the\nsignature for that constructor:\nColorControls(ColorTest target,\nString l1, String l2, String l3,\nint v1, int v2, int v3) {\n}\nGiven those arguments, you can assign the right values to your instance variables:\nouterparent = target;\nf1 = new TextField(String.valueOf(v1),10);\nf2 = new TextField(String.valueOf(v2),10);\nf3 = new TextField(String.valueOf(v3),10);\nNote that because the first argument to the TextField constructor is a string, and the values that\nyou passed in were integers, you have to use the valueOf() class method (defined in String) to\nconvert the integer to a string before creating each text field.\nNext, you create the layout for this panel. You also use a grid layout for these subpanels, as you\ndid for the applet panel, but this time the grid will have three rows (one for each of the text field\nand label pairs) and two columns (one for the labels and one for the fields).\nGiven the 3-by-2 grid, you can now add the text fields and labels to that panel. Note that by\nseparating the labels and the text fields into separate cells in the grid, you can align the labels,\ncreating a nice aligned layout.\nadd(new Label(l1, Label.RIGHT));\nadd(f1);\nadd(new Label(l2, Label.RIGHT));\nadd(f2);\n270\n030-4s CH13.i 270 1\/29\/96, 10:38 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 Sams.net Learning\nCenter\nabcd\nadd(new Label(l3, Label.RIGHT));\nadd(f3);\nFinally (because I like insets), you\u2019ll inset the contents of the subpanel a bit\u2014only on the top\nand bottom edges\u2014by including an insets() method:\npublic Insets insets() {\nreturn new Insets(10,10,0,0);\n}\nYou\u2019re almost there. You have 98 percent of the layout in place and ready to go, but you\u2019re\nmissing two things: creating the ColorControls objects in ColorTest, and initializing everything\nso that all the components have the right values.\nFor both, you need to go back to the ColorTest class and the init() method you defined there.\nLet\u2019s start with the initialization part, because that\u2019s easy. The default color is black. Set up a local\nvariable to hold that color object:\nColor theColor = new Color(0,0,0);\nTo set the initial color of the color box, all you need to do is set its background:\nswatch.setBackground(theColor);\nNow, let\u2019s finally tackle initializing those subpanels. The constructor for ColorControls has\nseven arguments: the ColorTest object, three labels (strings), and three initial values for the text\nfields (integers). Let\u2019s do the RGB controls first, because you can easily extract the initial red,\ngreen, and blue values out of the Color object:\nRGBcontrols = new ColorControls(this, \u201cRed\u201d, \u201cGreen\u201d, \u201cBlue\u201d,\ntheColor.getRed(), theColor.getGreen(),\ntheColor.getBlue());\nThings get complicated on the HSB side of the panel. The Color class provides you with a\nmethod to get the HSB values out of a Color object, but there are two problems:\n13\nnn The RGBtoHSB() method is a single class method that insists on returning an array of\nthe three values.\nnn The HSB values are measured in floating-point values. I prefer to think of HSB as\nintegers, wherein the hue is a degree value around a color wheel (0 through 360), and\nsaturation and brightness are percentages from 0 to 100. Having HSB as integer values\nalso enables you to have a generic subpanel, as was the intent.\nInitializing the HSB subpanel is going to be a little difficult.\nFirst, let\u2019s extract those HSB values. Given that the method takes three RGB arguments\u2014an\narray of three floats\u2014and returns an array of three floats, you have to go through this process\nto get those values:\nfloat[] HSB = Color.RGBtoHSB(theColor.getRed(),\ntheColor.getGreen(), theColor.getBlue(),(new float[3]));\n271\n030-4s CH13.i 271 1\/29\/96, 10:38 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 MTWRFSS\nDDAAYY\n13 The Java Abstract Windowing Toolkit\nNow you have an array of floats, where HSB[0] is the hue, HSB[1] is the saturation, and HSB[2]\nis the brightness. You can now (finally!) initialize the HSB side of the applet, making sure that\nwhen you pass those HSB values into the subpanel, you multiply them by the right values (360\nfor the hues, 100 for the saturation and the brightness) and convert them to integers:\nHSBcontrols = new ColorControls(this,\n\u201cHue\u201d, \u201cSaturation\u201d, \u201cBrightness\u201d,\n(int)(HSB[0] * 360), (int)(HSB[1] * 100),\n(int)(HSB[2] * 100));\nReady to give up? Fear not\u2014you\u2019ve done the hard part. From here, it\u2019s (mostly) easy. Once you\nhave your layout working, you can compile your Java program and see how it looks. None of\nyour UI components actually does anything, but perfecting the layout is half the battle.\nHandle the Actions\nAfter creating the layout, you set up actions with the UI components so that when the user\ninteracts with the applet, the applet can respond.\nThe action of this applet occurs when the user changes a value in any of the text fields. By causing\nan action in a text field, the color changes, the color box updates to the new color, and the values\nof the fields in the opposite subpanel change to reflect the new color.\nThe ColorTest class is responsible for actually doing the updating, because it keeps track of all\nthe subpanels. You should be tracking and intercepting events in the subpanel in which they\noccur, however. Because the action of the applet is an actual text action, you can use an action()\nmethod to intercept it:\npublic boolean action(Event evt, Object arg) {\nif (evt.target instanceof TextField) {\nthis.outerparent.update(this);\nreturn true;\n}\nelse return false;\n}\nIn the action() method, you test to make sure the action was indeed generated by a text field\n(because there are only text fields available, that\u2019s the only action you\u2019ll get, but it\u2019s a good idea\nto test for it anyhow). If so, call the update() method, defined in ColorTest, to update the applet\nto reflect all the new values. Because the outer applet is responsible for doing all the updating,\nthis is precisely why you need that hook back to the applet\u2014so you can call the right method\nat the right time.\nUpdate the Result\nThe only part left now is to update all the values and the color swatch if one of the values changes.\nFor this, you define the update() method in the ColorTest class. This update() method takes\n272\n030-4s CH13.i 272 1\/29\/96, 10:39 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 Sams.net Learning\nCenter\nabcd\na single argument\u2014the ColorControls instance that contains the changed value (you get that\nargument from the action() method in the subpanel).\nNote: Won\u2019t this update() method interfere with the system\u2019s update() method?\nNope. Remember, methods can have the same names, but different signatures and\ndefinitions. Because this update() has a single argument of type ColorControls, it\ndoesn\u2019t interfere with the other version of update().\nThe update() method is responsible for updating all the panels in the applet. To know which\npanel to update, you need to know which panel changed. You can find out by testing to see\nwhether the argument you got passed is the same as the subpanels you have stored in the\nRGBcontrols and HSBcontrols instance variables:\nvoid update(ColorControls in) {\nif (in == RGBcontrols) { \/\/ the change was in RGB\n...\n}\nelse { \/\/ change was in HSB\n}\nThis test is the heart of the update() method. Let\u2019s start with that first case\u2014a number has been\nchanged in the RGB text fields. So now, based on those new RGB values, you have to generate\na new color object and update the values on the HSB panel. To reduce some typing, you create\na few local variables to hold some basic values. In particular, the values of the text fields are\nstrings, and you get into them by accessing the text field instance variables for the ColorControls\npanel (f1, f2, f3) and then using the getText() method to extract the actual values. Extract those\nvalues and store them in string variables so that you don\u2019t have to keep typing:\nString v1 = in.f1.getText(); 13\nString v2 = in.f2.getText();\nString v3 = in.f3.getText();\nGiven those string values for RGB, you now create a color object by converting those strings to\nintegers:\nColor c;\nc = new Color(Integer.parseInt(v1),Integer.parseInt(v2),\nInteger.parseInt(v3));\nNote: This part of the example isn\u2019t very robust; it assumes that the user has indeed\nentered real numbers into the text fields. A better version of this would test to make\nsure that no parsing errors had occurred (I was trying to keep this example small).\n273\n030-4s CH13.i 273 1\/29\/96, 10:39 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 MTWRFSS\nDDAAYY\n13 The Java Abstract Windowing Toolkit\nWhen you have a color object, you can update the color swatch:\nswatch.setBackground(c);\nThe next step is to update the HSB panel to the new HSB values. Doing this in the init()\nmethod is no fun at all, and it\u2019s even less fun here. To do this, you call RGBtoHSB to get the floating-\npoint values, convert them to integers with the right values, convert them to strings, and then\nput them back into the text fields for the HSB subpanel. Got all that? Here\u2019s the code:\nfloat[] HSB = Color.RGBtoHSB(c.getRed(),c.getGreen(),\nc.getBlue(), (new float[3]));\nHSB[0] *= 360;\nHSB[1] *= 100;\nHSB[2] *= 100;\nHSBcontrols.f1.setText(String.valueOf((int)HSB[0]));\nHSBcontrols.f2.setText(String.valueOf((int)HSB[1]));\nHSBcontrols.f3.setText(String.valueOf((int)HSB[2]));\nThe second part of the update() method is called when a value on the HSB side of the panel is\nchanged. This is the \u201celse\u201d in the if-else that determines what to update, given a change.\nBelieve it or not, it\u2019s easier to update RGB values given HSB than it is to do it the other way\naround. First, convert the string values from the HSB text fields to integers by using these lines:\nint f1 = Integer.parseInt(v1);\nint f2 = Integer.parseInt(v2);\nint f3 = Integer.parseInt(v3);\nThere\u2019s a class method in the Color class that creates a new color object when given three HSB\nvalues. The catch is that those values are floats, and they\u2019re not the values you currently have.\nTo call getHSBColor() (that\u2019s the name of the method), convert the integers to floats and divide\nby the right amounts:\nc = Color.getHSBColor((float)f1 \/ 360, (float)f2 \/ 100, (float)f3\/100);\nNow that you have a color object, the rest is easy. Set the color swatch:\nswatch.setBackground(c);\nThen update the RGB text fields with the new RGB values from the color object:\nRGBcontrols.f1.setText(String.valueOf(c.getRed()));\nRGBcontrols.f2.setText(String.valueOf(c.getGreen()));\nRGBcontrols.f3.setText(String.valueOf(c.getBlue()));\nThe Complete Source Code\nListing 13.1 shows the complete source code; often it\u2019s easier to figure out what\u2019s going on in\nthis applet when it\u2019s all in one place and you can follow the method calls and how values are\npassed back and forth. Start with the init() method in applet, and go from there.\n274\n030-4s CH13.i 274 1\/29\/96, 10:39 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 Sams.net Learning\nCenter\nabcd\nType\nListing 13.1. The ColorTest applet.\nimport java.awt.*;\npublic class ColorTest extends java.applet.Applet {\nColorControls RGBcontrols, HSBcontrols;\nCanvas swatch;\npublic void init() {\nColor theColor = new Color(0,0,0);\nfloat[] HSB = Color.RGBtoHSB(theColor.getRed(),\ntheColor.getGreen(), theColor.getBlue(),\n(new float[3]));\nsetLayout(new GridLayout(1,3,10,10));\n\/\/ The color swatch\nswatch = new Canvas();\nswatch.setBackground(theColor);\n\/\/ the control panels\nRGBcontrols = new ColorControls(this,\n\u201cRed\u201d, \u201cGreen\u201d, \u201cBlue\u201d,\ntheColor.getRed(), theColor.getGreen(),\ntheColor.getBlue());\nHSBcontrols = new ColorControls(this,\n\u201cHue\u201d, \u201cSaturation\u201d, \u201cBrightness\u201d,\n(int)(HSB[0] * 360), (int)(HSB[1] * 100),\n(int)(HSB[2] * 100));\nadd(swatch);\nadd(RGBcontrols);\nadd(HSBcontrols);\n}\npublic Insets insets() { 13\nreturn new Insets(10,10,10,10);\n}\nvoid update(ColorControls in) {\nColor c;\nString v1 = in.f1.getText();\nString v2 = in.f2.getText();\nString v3 = in.f3.getText();\nif (in == RGBcontrols) { \/\/ change to RGB\nc = new Color(Integer.parseInt(v1),\nInteger.parseInt(v2),\nInteger.parseInt(v3));\nswatch.setBackground(c);\ncontinues\n275\n030-4s CH13.i 275 1\/29\/96, 10:39 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 MTWRFSS\nDDAAYY\n13 The Java Abstract Windowing Toolkit\nListing 13.1. continued\nfloat[] HSB = Color.RGBtoHSB(c.getRed(),c.getGreen(),\nc.getBlue(), (new float[3]));\nHSB[0] *= 360;\nHSB[1] *= 100;\nHSB[2] *= 100;\nHSBcontrols.f1.setText(String.valueOf((int)HSB[0]));\nHSBcontrols.f2.setText(String.valueOf((int)HSB[1]));\nHSBcontrols.f3.setText(String.valueOf((int)HSB[2]));\n}\nelse { \/\/ change to HSB\nint f1 = Integer.parseInt(v1);\nint f2 = Integer.parseInt(v2);\nint f3 = Integer.parseInt(v3);\nc = Color.getHSBColor((float)f1 \/ 360,\n(float)f2 \/ 100, (float)f3\/100);\nswatch.setBackground(c);\nRGBcontrols.f1.setText(String.valueOf(c.getRed()));\nRGBcontrols.f2.setText(String.valueOf(\nc.getGreen()));\nRGBcontrols.f3.setText(String.valueOf(c.getBlue()));\n}\n}\n}\nclass ColorControls extends Panel {\nTextField f1, f2, f3;\nColorTest outerparent;\nColorControls(ColorTest target,\nString l1, String l2, String l3,\nint v1, int v2, int v3) {\nthis.outerparent = target;\nsetLayout(new GridLayout(3,4,10,10));\nf1 = new TextField(String.valueOf(v1),10);\nf2 = new TextField(String.valueOf(v2),10);\nf3 = new TextField(String.valueOf(v3),10);\nadd(new Label(l1, Label.RIGHT));\nadd(f1);\nadd(new Label(l2, Label.RIGHT));\nadd(f2);\nadd(new Label(l3, Label.RIGHT));\nadd(f3);\n}\npublic Insets insets() {\nreturn new Insets(10,10,0,0);\n}\npublic boolean action(Event evt, Object arg) {\nif (evt.target instanceof TextField) {\n276\n030-4s CH13.i 276 1\/29\/96, 10:39 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 Sams.net Learning\nCenter\nabcd\nthis.outerparent.update(this);\nretrue true;\n}\nelse return false;\n}\n}\nSummary\nThe Java AWT, or Abstract Windowing Toolkit, is a package of Java classes and interfaces for\ncreating full-fledged access to a window-based graphical user interface system, with mechanisms\nfor graphics display, event management, text and graphics primitives, user interface compo-\nnents, and cross-platform layout. The AWT is used by the HotJava browser itself for all its\nfunctionality. Applets are also an integral part of the AWT toolkit.\nToday has been a big day; the lesson has brought together everything you\u2019ve learned up to this\npoint about simple applet management and added a lot more about creating applets, panels, and\nuser interface components and managing the interactions between all of them. With the\ninformation you got today and the few bits that you\u2019ll learn tomorrow, you can create cross-\nplatform Java applications that do just about anything you want.\nQ&A\nQ You\u2019ve mentioned a lot about the Component and Container classes, but it looks\nlike the only Container objects that ever get created are Panels. What do the\nComponent and Container classes give me?\nA Those classes factor out the behavior for components (generic AWT components) and\ncontainers (components that can contain other components). Although you don\u2019t\n13\nnecessarily create direct instances of these classes, you can create subclasses of them if\nyou want to add behavior to the AWT that the default classes do not provide. As with\nmost of the Java classes, any time you need a superclass\u2019s behavior, don\u2019t hesitate to\nextend that class by using your own subclass.\nQ Can I put a UI component at a specific x and y position on the screen?\nA By using the existing layout managers supplied with the AWT toolkit, no. This is\nactually a good thing because you don\u2019t know what kind of display environment your\napplet will be run under, what kind of fonts are installed, or what kind of fonts are\nbeing currently used. By using the layout managers provided with the AWT, you can\nbe sure that every portion of your window will be viewable and readable and usable.\nYou can\u2019t guarantee that with hard-coded layouts.\n277\n030-4s CH13.i 277 1\/29\/96, 10:40 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 MTWRFSS\nDDAAYY\n13 The Java Abstract Windowing Toolkit\nQ I was exploring the AWT package, and I saw this subpackage called peer. There\u2019s\nalso references to the peer classes sprinkled throughout the API documentation.\nWhat do peers do?\nA Peers are responsible for the platform-specific parts of the AWT. For example, when\nyou create a Java AWT window, you have an instance of the Window class that provides\ngeneric Window behavior, and then you have an instance of WindowPeer that creates\nthe very specific window for that platform\u2014a motif window under X windows, a\nMacintosh-style window under the Macintosh, or a Windows 95 window under\nWindows 95. The peers also handle communication between the window system and\nthe Java window itself. By separating the generic component behavior (the AWT\nclasses) from the actual system implementation and appearance (the peer classes), you\ncan focus on providing behavior in your Java application and let the Java implementa-\ntion deal with the platform-specific details.\nQ There\u2019s a whole lot of functionality in the AWT that you haven\u2019t talked about\nhere. Why?\nA Given that even a basic introduction took this long, I figured that if I put in even\nmore detail than I already have that this book would turn into Teach Yourself Java in\n21 Days Plus a Few Extra for the AWT Stuff.\nAs it is, I\u2019ve left windows, menus, and dialog until tomorrow, so you\u2019ll have to wait\nfor those. But you can find out about a lot of the other features of AWT merely by\nexploring the API documentation. Start with the Applet class and examine the sorts of\nmethods you can call. Then look at Panel, from which applet inherits\u2014you have all\nthat class\u2019s functionality as well. The superclass of Panel is Container, which provides\nstill more interesting detail. Component comes next. Explore the API and see what you\ncan do with it. You might find something interesting.\n278\n030-4s CH13.i 278 1\/29\/96, 10:40 PM\nP2\/V4sqc 7 TY Java in 21 Days 030-4 sdv 12.22.95 Ch 13 LP#3 Sams.net Learning\nCenter\nabcd\n14\n14\nS\nS\nWEEK\nF 2\nR\nW\nWindows,\nT\nNetworking, and\nM\nOther Tidbits\n14\nby Laura Lemay\n279\n030-4s CH14.i 279 1\/29\/96, 10:41 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 MTWRFSS\nDDAAYY\n14 Windows, Networking, and Other Tidbits\nHere you are on the last day of the second week, and you\u2019re just about finished with applets and\nthe AWT. With the information you\u2019ll learn today, you can create a wide variety of applets and\napplications using Java. Next week\u2019s lessons provide more of the advanced stuff that you\u2019ll need\nif you start doing really serious work in Java.\nToday, to finish up this week, there are three very different topics:\nnn Windows, menus, and dialog boxes\u2014the last of the AWT classes that enable you to\npop up real windows from applets, and to create stand-alone Java applications that\nhave their own windows\nnn Networking\u2014how to load new HTML files from an applet-capable browser, how to\nretrieve files from Web sites, and some basics on how to work with generic sockets in\nJava\nnn Extra tidbits\u2014the smaller stuff that didn\u2019t fit in anywhere else, but that might be\nuseful to you as you write your Java applets and applications\nWindows, Menus, and Dialog Boxes\nToday, you\u2019ll finish up the last bits of the AWT that didn\u2019t fit into yesterday\u2019s lesson. In addition\nto all the graphics, events, UI, and layout mechanisms that the AWT provides, it also provides\nwindows, menus, and dialog boxes, enabling to you create fully featured applications either as\npart of your applet or independently for stand-alone Java applications.\nFrames\nThe AWT Window class enables you to create windows that are independent of the browser\nwindow containing the applet\u2014that is, separate popup windows with their own titles, resize\nhandles, and menubars.\nThe Window class provides basic behavior for windows. Most commonly, instead of using the\nWindow class, you\u2019ll use Window\u2019s subclasses, Frame and Dialog. The Frame class enables you to\ncreate a fully functioning window with a menubar. Dialog is a more limited window for dialog\nboxes. You\u2019ll learn more about dialog boxes later on in this section.\nTo create a frame, use one of the following constructors:\nnn new Frame() creates a basic frame without a title.\nnn new Frame(String) creates a basic frame with the given title.\nFrames are containers, just like panels are, so you can add other components to them just as you\nwould regular panels, using the add() method. The default layout for windows is BorderLayout:\nwin = new Frame(\u201cMy Cool Window\u201d);\nwin.setLayout(new BorderLayout(10,20));\n280\n030-4s CH14.i 280 1\/29\/96, 10:41 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 Sams.net Learning\nCenter\nabcd\nwin.add(\u201cNorth\u201d, new Button(\u201cstart\u201d));\nwin.add(\u201cCenter\u201d, new Button(\u201cMove\u201d));\nTo set a size for the new window, use the resize() method. To set a location for where the\nwindow appears, use the move() method. Note that the location() method can tell you where\nthe applet window is on the screen so that you can pop up the extra window in a relative position\nto that window (all these methods are defined for all containers, so you can use them for applets,\nwindows, and the components inside them, subject to the current layout):\nwin.resize(100,200);\nDimension d = location();\nwin.move(d.width + 50, d.height + 50);\nWhen you initially create a window, it\u2019s invisible. You need to use the show() method to make\nthe window appear on the screen (you can use hide() to hide it again):\nwin.show();\nListing 14.1 shows an example of a simple applet with a popup window (both the applet and\nthe window are shown in Figure 14.1). The applet has two buttons: one to show the window,\nand one to hide the window. The window itself, created from a subclass called MyFrame has a\nsingle label: \u201cThis is a Window.\u201d You\u2019ll use this basic window and applet all through this section,\nso the more you understand what\u2019s going on here the easier it will be later.\nType\nListing 14.1. A popup window.\npublic class GUI extends java.applet.Applet {\nFrame window;\npublic void init() {\nadd(new Button(\u201cOpen Window\u201d));\nadd(new Button(\u201cClose Window\u201d));\nwindow = new MyFrame(\u201cA Popup Window\u201d);\nwindow.resize(150,150);\nwindow.show();\n}\npublic boolean action(Event evt, Object arg) {\nif (evt.target instanceof Button) {\nString label = (String)arg;\nif (label.equals(\u201cOpen Window\u201d)) {\n14\nif (!window.isShowing())\nwindow.show();\n}\nelse if (label == \u201cClose Window\u201d) {\nif (window.isShowing())\nwindow.hide();\n}\nreturn true;\n}\ncontinues\n281\n030-4s CH14.i 281 1\/29\/96, 10:41 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 MTWRFSS\nDDAAYY\n14 Windows, Networking, and Other Tidbits\nListing 14.1. continued\nelse return false;\n}\n}\nclass MyFrame extends Frame {\nLabel l;\nMyFrame(String title) {\nsuper(title);\nsetLayout(new GridLayout(1,1));\nl = new Label(\u201cThis is a Window\u201d, Label.CENTER);\nadd(l);\n}\nFigure 14.1.\nWindows.\nMenus\nEach new window you create can have its own menubar along the top of the screen. Each\nmenubar can have a number of menus, and each menu, in turn, can have menu items. The AWT\nprovides classes for all these things called, respectively, MenuBar, Menu, and MenuItem.\nMenus and Menubars\nTo create a menubar for a given window, create a new instance of the class MenuBar:\nMenuBar mb = new MenuBar();\nTo set this menubar as the default menu for the window, use the setMenuBar() method on the\nwindow:\nwindow.setMenuBar(mb);\n282\n030-4s CH14.i 282 1\/29\/96, 10:42 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 Sams.net Learning\nCenter\nabcd\nAdd individual menus (File, Edit, and so on) to the menubar by creating them and then adding\nthem to the menubar:\nMenu m = new Menu(\u201cFile\u201d);\nmb.add(m);\nSome systems enable you to indicate a special help menu, which may be drawn on the right side\nof the menubar. You can indicate that a specific menu is the help menu by using the\nsetHelpMenu() method. The given menu should already be added to the menu itself:\nMenu hm = new Menu(\u201cHelp\u201d);\nmb.add(hm);\nmb.setHelpMenu(hm);\nIf, for any reason, you want to prevent a user from selecting a menu, you can use the disable()\ncommand on that menu (and the enable() command to make it available again):\nm.disable();\nMenu Items\nThere are four kinds of items you can add to individual menus:\nnn Instances of the class MenuItem, for regular menu items\nnn Instances of the class CheckBoxMenuItem, for toggled menu items\nnn Other menus, with their own menu items\nnn Separators, for lines that separate groups of items on menus\nRegular menu items are added by using the MenuItem class. Add them to a menu using the add()\nmethod:\nMenu m = new Menu(\u201cTools\u201d);\nm.add(new MenuItem(\u201cInfo\u201d));\nm.add(new MenuItem(\u201cColors\u201d));\nm.add(new MenuItem(\u201cSizes\u201d));\nSubmenus can be added simply by creating a new instance of Menu and adding it to the first menu.\nYou can then add items to that menu:\nMenu sb = new Menu(\u201cSizes\u201d);\nm.add(sb);\n14\nsb.add(new MenuItem(\u201cSmall\u201d));\nsb.add(new MenuItem(\u201cMedium\u201d));\nsb.add(new MenuItem(\u201cLarge\u201d));\nThe CheckBoxMenuItem class creates a menu item with a checkbox on it, enabling the menu state\nto be toggled on and off (selecting it once makes the checkbox appear selected; selecting it again\nunselects the checkbox). Create and add a checkbox menu item the same way you create and add\nregular menu items:\n283\n030-4s CH14.i 283 1\/29\/96, 10:42 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 MTWRFSS\nDDAAYY\n14 Windows, Networking, and Other Tidbits\nCheckboxMenuItem coords =\nnew CheckboxMenuItem(\u201cShow Coordinates\u201d);\nm.add(coords);\nFinally, to add a separator to a menu (a line used to separate groups of items in a menu), create\nand add a menu item with the label \u201c-\u201d.\nMenuItem msep = new MenuItem(\u201c-\u201d);\nm.add(msep);\nAny menu item can be disabled by using the disable() method and enabled again using\nenable(). Disabled menu items cannot be selected:\nMenuItem mi = new MenuItem(\u201cFill\u201d);\nm.addItem(mi);\nmi.disable();\nMenu Actions\nThe act of selecting a menu item causes an action event to be generated. You can handle that\naction the same way you handle other action methods\u2014by overriding action(). Both regular\nmenu items and checkbox menu items have actions that generate an extra argument representing\nthe label for that menu. You can use that label to determine which action to take. Note, also,\nthat because CheckBoxMenuItem is a subclass of MenuItem, you don\u2019t have to treat that menu item\nas a special case:\npublic boolean action(Event evt, Object arg) {\nif (evt.target instanceof MenuItem) {\nString label = (String)arg;\nif (label.equals(\u201cShow Coordinates\u201d)) toggleCoords();\nelse if (label.equals(\u201cFill\u201d)) fillcurrentArea();\nreturn true;\n}\nelse return false;\n}\nAn Example\nLet\u2019s add a menu to the window you created in the previous section. Add it to the constructor\nmethod in the MyFrame class (Figure 14.2 shows the resulting menu):\nMyFrame(String title) {\nsuper(title);\nMenuBar mb = new MenuBar();\nMenu m = new Menu(\u201cColors\u201d);\nm.add(new MenuItem(\u201cRed\u201d));\nm.add(new MenuItem(\u201cBlue\u201d));\nm.add(new MenuItem(\u201cGreen\u201d));\nm.add(new MenuItem(\u201c-\u201d));\nm.add(new CheckboxMenuItem(\u201cReverse Text\u201d));\nmb.add(m);\n284\n030-4s CH14.i 284 1\/29\/96, 10:43 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 Sams.net Learning\nCenter\nabcd\nmb.setHelpMenu(m);\nsetMenuBar(mb);\n...\n}\nThis menu has four items: one each for the colors red, blue, and green (which, when selected,\nchange the background of the window), and one checkbox menu item for reversing the color\nof the text (to white). To handle these menu items, you need an action() method:\npublic boolean action(Event evt, Object arg) {\nif (evt.target instanceof MenuItem) {\nString label = (String)arg;\nif (label.equals(\u201cRed\u201d)) setBackground(Color.red);\nelse if (label.equals(\u201cBlue\u201d)) setBackground(Color.blue);\nelse if (label.equals(\u201cGreen\u201d)) setBackground(Color.green);\nelse if (label.equals(\u201cReverse Text\u201d)) {\nif (getForeground() == Color.black)\nsetForeground(Color.white);\nelse setForeground(Color.black);\n}\nreturn true;\n}\nelse return false;\n}\nFigure 14.2.\nA menu.\n14\nDialog Boxes\nDialog boxes are functionally similar to frames in that they pop up new windows on the screen.\nHowever, dialog boxes are intended to be used for transient windows\u2014for example, windows\nthat let you know about warnings, windows that ask you for specific information, and so on.\nDialogs don\u2019t usually have titlebars or many of the more general features that windows have\n(although you can create one with a titlebar), and they can be made nonresizable or modal.\n285\n030-4s CH14.i 285 1\/29\/96, 10:43 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 MTWRFSS\nDDAAYY\n14 Windows, Networking, and Other Tidbits\nNEW* A modal dialog prevents input to any of the other windows on the screen until that dialog\nTERM is dismissed.\nThe AWT provides two kinds of dialog boxes: the Dialog class, which provides a generic dialog,\nand FileDialog, which produces a platform-specific dialog to choose files to save or open.\nTo create a generic dialog, use one of these constructors:\nnn Dialog(Frame, boolean) creates an initially invisible dialog, attached to the current\nframe, which is either modal (true) or not (false).\nnn Dialog(Frame, String, boolean) is the same as the previous constructor, with the\naddition of a titlebar and a title indicated by the string argument.\nNote that because you have to give a dialog a Frame argument, you can attach dialogs only to\nwindows that already exist independently of the applet itself.\nThe dialog window, like the frame window, is a panel on which you can lay out and draw UI\ncomponents and perform graphics operations, just as you would any other panel. Like other\nwindows, the dialog is initially invisible, but you can show it with show() and hide it with hide().\nLet\u2019s add a dialog to that same example with the popup window. You\u2019ll add a menu item for\nchanging the text of the window, which brings up the Enter Text dialog box (see Figure 14.3).\nFigure 14.3.\nThe Enter Text dialog.\nTo add this dialog, first add a menu item to that window (the constructor method for the MyFrame\nclass) to change the text the popup window displays:\nm.add(new MenuItem(\u201cSet Text...\u201d));\nIn that same method, you can create the dialog and lay out the parts of it (it\u2019s invisible by default,\nso you can do whatever you want to it and it won\u2019t appear on screen until you show it):\ndl = new Dialog(this, \u201cEnter Text\u201d,true);\ndl.setLayout(new GridLayout(2,1,30,30));\n286\n030-4s CH14.i 286 1\/29\/96, 10:43 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 Sams.net Learning\nCenter\nabcd\ntf = new TextField(l.getText(),20);\ndl.add(tf);\ndl.add(new Button(\u201cOK\u201d));\ndl.resize(150,75);\nThe action of choosing the menu item you just added brings up the dialog; choosing the OK\nbutton dismisses it. So you need to add behavior to this class\u2019s action method so that the dialog\nworks right. To the menu item tests, add a line for the new menu item:\nif (evt.target instanceof MenuItem) {\nif (label.equals(\u201cRed\u201d)) setBackground(Color.red);\nif (label.equals(\u201cBlue\u201d)) setBackground(Color.blue);\nif (label.equals(\u201cGreen\u201d)) setBackground(Color.green);\nif (label.equals(\u201cSet Text...\u201d)) dl.show();\n}\nThen, because OK is a button, you have to add a special case for that button separate from the\nmenu items. In this special case, set the text of the window to the text that was typed into the\ntext field, and then hide the dialog again:\nif (evt.target instanceof Button) {\nif (label.equals(\u201cOK\u201d)) {\nl.setText(tf.getText());\ndl.hide();\n}\n}\nFile Dialogs\nFileDialog provides a basic file open\/save dialog box that enables you to access the file system.\nThe FileDialog class is system-independent, but depending on the platform, the standard Open\nFile dialog is brought up.\nNote: For applets, you can bring up the file dialog, but due to security restrictions\nyou can\u2019t do anything with it (or, if you can, access to any files on the local system\nis severely restricted). FileDialog is much more useful in stand-alone applications.\nTo create a file dialog, use the following constructors: 14\nnn FileDialog(Frame, String) creates an Open File dialog, attached to the given frame,\nwith the given title. This form creates a dialog to load a file.\nnn FileDialog(Frame, String, int) also creates a file dialog, but that integer argument is\nused to determine whether the dialog is for loading a file or saving a file (the only\ndifference is the labels on the buttons; the file dialog does not actually open or save\nanything). The possible options for the mode argument are FileDialog.LOAD and\nFileDialog.SAVE.\n287\n030-4s CH14.i 287 1\/29\/96, 10:44 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 MTWRFSS\nDDAAYY\n14 Windows, Networking, and Other Tidbits\nAfter you create a FileDialog instance, use show() to display it:\nFileDialog fd = new FileDialog(this, \u201cFileDialog\u201d);\nfd.show();\nWhen the reader chooses a file in the file dialog and dismisses it, you can then get to the file they\nchose by using the getDirectory() and getFile() methods; both return strings indicating the\nvalues the reader chose. You can then open that file by using the stream and file handling\nmethods (which you\u2019ll learn about next week) and then read from or write to that file.\nWindow Events\nYesterday, you learned about writing your own event handler methods, and you noted that the\nEvent class defines many standard events for which you can test. Window events are part of that\nlist, so if you use windows, these events may be of interest to you. Table 14.1 shows those events.\nTable 14.1: Window Events from the Event Class.\nWINDOW_DESTROY Generated when a window is destroyed (for example, when the\nbrowser or applet viewer has quit)\nWINDOW_EXPOSE Generated when the window is brought forward from behind other\nwindows\nWINDOW_ICONIFY Generated when the window is iconified\nWINDOW_DEICONIFY Generated when the window is restored from an icon\nWINDOW_MOVED Generated when the window is moved\nUsing AWT Windows\nin Stand-Alone Applications\nBecause frames are general-purpose mechanisms for creating AWT windows with panels, you\ncan use them in your stand-alone Java applications and easily take advantage of all the applet\ncapabilities you learned about this week. To do this, write your application as if it were an applet\n(inheriting from the Applet class and using threads, graphics, and UI components as necessary),\nand then add a main() method. Here\u2019s one for a class called MyAWTClass:\npublic static void main(String args[]) {\nFrame f = new Frame(\u201cMy Window\u201d);\nMyAWTClass mac = new MyAWTClass();\nmac.init();\nmac.start();\nf.add(\u201cCenter\u201d, mac);\n288\n030-4s CH14.i 288 1\/29\/96, 10:44 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 Sams.net Learning\nCenter\nabcd\nf.resize(300, 300);\nf.show();\n}\nThis main() method does five things:\nnn It creates a new frame to hold the applet.\nnn It creates an instance of the class that defines that method.\nnn It duplicates the applet environment calls to init() and start().\nnn It adds the applet to the frame and resizes the frame to be 300 pixels square.\nnn It shows the frame on the screen.\nBy using this mechanism, you can create a Java program that can function equally well as an\napplet or an application\u2014just include init() for applets and main() for applications.\nIf you do create an application that uses this mechanism, be careful of your init() methods that\nget parameters from an HTML file. When you run an applet as an application, you don\u2019t have\nthe HTML parameters passed into the init() method. Pass them in as command-line\narguments, instead, and handle them in your main() method. Then set a flag so that the init()\nmethod doesn\u2019t try to read parameters that don\u2019t exist.\nNetworking in Java\nNetworking is the capability of making connections from your applet or application to a system\nover the network. Networking in Java involves classes in the java.net package, which provide\ncross-platform abstractions for simple networking operations, including connecting and\nretrieving files by using common Web protocols and creating basic Unix-like sockets. Used in\nconjunction with input and output streams (which you\u2019ll learn much more about next week),\nreading and writing files over the network becomes as easy as reading or writing to files on the\nlocal disk.\nThere are restrictions, of course. Java applets cannot read or write from the disk on the machine\nthat\u2019s running them. Depending on the browser, Java applets may not be able to connect to\nsystems other than the one upon which they were originally stored. Even given these restrictions,\nyou can still accomplish a great deal and take advantage of the Web to read and process\ninformation over the net. 14\nThis section describes three ways you can communicate with systems on the net:\nnn showDocument(), which enables an applet to tell the browser to load and link to\nanother page on the Web\nnn openStream(), a method that opens a connection to a URL and enables you to extract\ndata from that connection\n289\n030-4s CH14.i 289 1\/29\/96, 10:45 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 MTWRFSS\nDDAAYY\n14 Windows, Networking, and Other Tidbits\nnn The socket classes, Socket and ServerSocket, which enable you to open standard\nsocket connections to hosts and read to and write from those connections\nCreating Links Inside Applets\nProbably the easiest way to use networking inside an applet is to tell the browser running that\napplet to load a new page. You can use this, for example, to create animated image maps that,\nwhen clicked, load a new page.\nTo link to a new page, you create a new instance of the class URL. You saw some of this when\nyou worked with images, but let\u2019s go over it a little more thoroughly here.\nThe URL class represents a uniform resource locator. To create a new URL, you can use one of\nfour different forms:\nnn URL(String, String, int, String) creates a new URL object, given a protocol (http,\nftp, gopher, file), a host name (www.lne.com, ftp.netcom.com), a port number (80 for\nhttp), and a filename or pathname.\nnn URL(String, String, String) does the same thing as the previous form, minus the\nport number.\nnn URL(URL, String) creates a URL, given a base path and a relative path. For the base,\nyou can use getDocumentBase() for the URL of the current HTML file, or\ngetCodeBase for the URL of the Java class file. The relative path will be tacked onto\nthe last directory in those base URLs (just like with images and sounds).\nnn URL(String) creates a URL object from a URL string (which should include the\nprotocol, hostname, and filename).\nFor that last one (creating a URL from a string), you have to catch a malformed URL exception,\nso surround the URL constructor with a try...catch:\nString url = \u201chttp:\/\/www.yahoo.com\/\u201d;\ntry { theURL = new URL(url); }\ncatch ( MalformedURLException e) {\nSystem.out.println(\u201cBad URL: \u201c + theURL);\n}\nGetting a URL object is the hard part. Once you have one, all you have to do is pass it to the\nbrowser. Do this by using this single line of code, where theURL is the URL object to link to:\ngetAppletContext().showDocument(theURL);\nThe browser that contains your URL will then load and display the document at that URL.\nListing 14.2 shows a simple applet that displays three buttons that represent important Web\nlocations (the buttons are shown in Figure 14.4). Clicking on the buttons causes the document\nto be loaded to the locations to which those buttons refer.\n290\n030-4s CH14.i 290 1\/29\/96, 10:45 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 Sams.net Learning\nCenter\nabcd\nType\nListing 14.2. Bookmark buttons.\nimport java.awt.*;\nimport java.net.URL;\nimport java.net.MalformedURLException;\npublic class ButtonLink extends java.applet.Applet {\nBookmark bmlist[] = new Bookmark[3];\npublic void init() {\nbmlist[0] = new Bookmark(\u201cLaura\u2019s Home Page\u201d,\n\u201chttp:\/\/www.lne.com\/lemay\/\u201d);\nbmlist[1] = new Bookmark(\u201cYahoo\u201d,\n\u201chttp:\/\/www.yahoo.com\u201d);\nbmlist[2]= new Bookmark(\u201cJava Home Page\u201d,\n\u201chttp:\/\/java.sun.com\u201d);\nsetLayout(new GridLayout(bmlist.length,1,10,10));\nfor (int i = 0; i < bmlist.length; i++) {\nadd(new Button(bmlist[i].name));\n}\n}\npublic boolean action(Event evt, Object arg) {\nif (evt.target instanceof Button) {\nLinkTo((String)arg);\nreturn true;\n}\nelse retrurn false;\n}\nvoid LinkTo(String name) {\nURL theURL = null;\nfor (int i = 0; i < bmlist.length; i++) {\nif (name.equals(bmlist[i].name))\ntheURL = bmlist[i].url;\n}\nif (theURL != null)\ngetAppletContext().showDocument(theURL);\n}\n}\nclass Bookmark {\nString name;\nURL url;\n14\nBookmark(String name, String theURL) {\nthis.name = name;\ntry { this.url = new URL(theURL); }\ncatch ( MalformedURLException e) {\nSystem.out.println(\u201cBad URL: \u201c + theURL);\n}\n}\n}\n291\n030-4s CH14.i 291 1\/29\/96, 10:46 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 MTWRFSS\nDDAAYY\n14 Windows, Networking, and Other Tidbits\nFigure 14.4.\nBookmark buttons.\nAnalysis Two classes make up this applet: the first implements the actual applet itself, the second\nis a class representing a bookmark. Bookmarks have two parts: a name and a URL.\nThis particular applet creates three bookmark instances and stores them in an array of\nbookmarks (this applet could be easily modified to make bookmarks as parameters from an\nHTML file). For each bookmark, a button is created whose label is the value of the bookmark\u2019s\nname.\nWhen the buttons are pressed, the linkTo() method is called, which tells the browser to load\nthe URL referenced by that bookmark.\nOpening Web Connections\nRather than asking the browser to just load the contents of a file, sometimes you might want to\nget hold of that file\u2019s contents so that your applet can use them. If the file you want to grab is\nstored on the Web, and can be accessed using the more common URL forms (http, ftp, and so\non), your applet can use the URL class to get it.\nNote that for security reasons, applets can connect back only to the same host from which they\noriginally loaded. This means that if you have your applets stored on a system called\nwww.myhost.com, the only machine your applet can open a connection to will be that same host\n(and that same host name, so be careful with host aliases). If the file the applet wants to retrieve\nis on that same system, using URL connections is the easiest way to get it.\n292\n030-4s CH14.i 292 1\/29\/96, 10:46 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 Sams.net Learning\nCenter\nabcd\nopenStream()\nURL defines a method called openStream(), which opens a network connection using the given\nURL and returns an instance of the class InputStream (part of the java.io package). If you\nconvert that stream to a DataInputStream (with a BufferedInputStream in the middle for better\nperformance), you can then read characters and lines from that stream (you\u2019ll learn all about\nstreams on Day 19). For example, these lines open a connection to the URL stored in the variable\ntheURL, and then read and echo each line of the file to the standard output:\ntry {\nInputStream in = theURL.openStream();\nDataInputStream data = new DataInputStream(\nnew BufferedInputStream(in);\nString line;\nwhile ((line = data.readLine()) != null) {\nSystem.out.println(\u201cline\u201d);\n}\n}\ncatch (IOException e) {\nSystem.out.println(\u201cIO Error: \u201c + e.getMessage());\n}\nNote: You need to wrap all those lines in a try...catch statement to catch\nIOException exceptions.\nHere\u2019s an example of an applet that uses the openStream() method to open a connection to a\nWeb site, reads a file from that connection (Edgar Allen Poe\u2019s poem \u201cThe Raven\u201d), and displays\nthe result in a text area. Listing 14.3 shows the code; Figure 14.5 shows the result after the file\nhas been read.\nType\nListing 14.3. The GetRaven class.\n1: import java.awt.*;\n2: import java.io.DataInputStream;\n3: import java.io.BufferedInputStream;\n4: import java.io.IOException;\n14\n5: import java.net.URL;\n6: import java.net.URLConnection;\n7: import java.net.MalformedURLException;\n8:\n9: public class GetRaven extends java.applet.Applet\n10: implements Runnable {\ncontinues\n293\n030-4s CH14.i 293 1\/29\/96, 10:47 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 MTWRFSS\nDDAAYY\n14 Windows, Networking, and Other Tidbits\nListing 14.3. continued\n11:\n12: URL theURL;\n13: Thread runner;\n14: TextArea ta = new TextArea(\u201cGetting text...\u201d,30,70);\n15:\n16: public void init() {\n17:\n18: String url = \u201chttp:\/\/www.lne.com\/Web\/Java\/raven.txt\u201d;\n19: try { this.theURL = new URL(url); }\n20: catch ( MalformedURLException e) {\n21: System.out.println(\u201cBad URL: \u201c + theURL);\n22: }\n23: add(ta);\n24: }\n25:\n26: public Insets insets() {\n27: return new Insets(10,10,10,10);\n28: }\n29:\n30: public void start() {\n31: if (runner == null) {\n32: runner = new Thread(this);\n33: runner.start();\n34: }\n35: }\n36:\n37: public void stop() {\n38: if (runner != null) {\n39: runner.stop();\n40: runner = null;\n41: }\n42: }\n43:\n44: public void run() {\n45: InputStream conn = null;\n46: DataInputStream data = null;\n47: String line;\n48: StringBuffer buf = new StringBuffer();\n49:\n50: try {\n51: conn = this.theURL.openStream();\n52: data = new DataInputStream(new BufferedInputStream(\n53: conn));\n54:\n55: while ((line = data.readLine()) != null) {\n56: buf.append(line + \u201c\\n\u201d);\n57: }\n58:\n59: ta.setText(buf.toString());\n60: }\n61: catch (IOException e) {\n62: System.out.println(\u201cIO Error:\u201d + e.getMessage());\n63: }\n64: }\n65: }\n294\n030-4s CH14.i 294 1\/29\/96, 10:47 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 Sams.net Learning\nCenter\nabcd\nFigure 14.5.\nThe GetRaven class.\nAnalysis The init() method (lines 16 to 24) sets up the URL and the text area in which that file\nwill be displayed. The URL could be easily passed into the applet via an HTML parameter;\nhere, it\u2019s just hard-coded for simplicity.\nBecause it might take some time to load the file over the network, you put that routine into its\nown thread and use the familiar start(), stop(), and run() methods to control that thread.\nInside run() (lines 44 to 64), the work takes place. Here, you initialize a bunch of variables\nand then open the connection to the URL (using the openStream() method in line 51). Once\nthe connection is open, you set up an input stream in lines 52 to 56 and read from it, line by\nline, putting the result into an instance of StringBuffer (a string buffer is a modifiable string).\nOnce all the data has been read, line 59 converts the StringBuffer object into a real string and\nthen puts that result in the text area.\nOne other thing to note about this example is that the part of the code that opened a network 14\nconnection, read from the file, and created a string is surrounded by a try and catch statement.\nIf any errors occur while you\u2019re trying to read or process the file, these statements enable you to\nrecover from them without the entire program crashing (in this case, the program exits with an\nerror, because there\u2019s little else to be done if the applet can\u2019t read the file). try and catch give\nyou the capability of handling and recovering from errors. You\u2019ll learn more about exceptions\non Day 18.\n295\n030-4s CH14.i 295 1\/29\/96, 10:47 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 MTWRFSS\nDDAAYY\n14 Windows, Networking, and Other Tidbits\nThe URLconnection Class\nURL\u2019s openStream() method is actually a simplified use of the URLconnection class. URLconnection\nprovides a way to retrieve files by using URLs\u2014on Web or FTP sites, for example.U RLconnection\nalso enables you to create output streams if the protocol allows it.\nTo use a URL connection, you first create a new instance of the class URLconnection, set its\nparameters (whether it enables writing, for example), and then use the connect() method to\nopen the connection. Keep in mind that, with a URL connection, the class handles the protocol\nfor you based on the first part of the URL, so you don\u2019t have to make specific requests to retrieve\na file; all you have to do is read it.\nSockets\nFor networking applications beyond what the URL and URLconnection classes offer (for example,\nfor other protocols or for more general networking applications), Java provides the Socket and\nServerSocket classes as an abstraction of standard socket programming techniques.\nNote: I don\u2019t have the space to give you a full explanation of how socket program-\nming works. If you haven\u2019t worked with sockets before, see whether openStream()\nwill meet your needs. If you really need to do more, any book that discusses socket\nprogramming will give you the background you need to work with Java\u2019s sockets.\nThe Socket class provides a client-side socket interface similar to standard Unix sockets. To open\na connection, create a new instance of Socket (where hostname is the host to connect to, and\nportnum is the port number):\nSocket connection = new Socket(hostname, portnum);\nNote: If you use sockets in an applet, you are still subject to the security restrictions\nabout where you can connect.\nOnce the socket is open, you can use input and output streams to read and write from that socket\n(you\u2019ll learn all about input and output streams on Day 19):\nDataInputStream in = new DataInputStream(\nnew BufferedInputStream(connection.getInputStream()));\nDataOutputStream out= new DataOutputStream(\nnew BufferedOutputStream(connection.getOutputStream()));\n296\n030-4s CH14.i 296 1\/29\/96, 10:48 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 Sams.net Learning\nCenter\nabcd\nOnce you\u2019re done with the socket, don\u2019t forget to close it (this also closes all the input and ouput\nstreams you may have set up for that socket):\nconnection.close();\nServer-side sockets work similarly, with the exception of the accept() method. A server socket\nlistens on a TCP port for a connection for a client; when a client connects to that port, the\naccept() method accepts a connection from that client. By using both client and server sockets,\nyou can create applications that communicate with each other over the network.\nTo create a server socket and bind it to a port, create a new instance of ServerSocket with the\nport number:\nServerSocket sconnection = new ServerSocket(8888);\nTo listen on that port (and to accept a connection from any clients if one is made), use the\naccept() method:\nsconnection.accept();\nOnce the socket connection is made, you can use input and output streams to read to and write\nfrom the client.\nSee the java.net package for more information about Java sockets.\nOther Applet Hints\nOn this, the last section of the last day of the second week, let\u2019s finish up with some small hints\nthat didn\u2019t fit in anywhere else: using showStatus() to print messages in the browser\u2019 status\nwindow, providing applet information, and communicating between multiple applets on the\nsame page.\nThe showStatus Method\nThe showStatus() method, available in the applet class, enables you to display a string in the\nstatus bar of the browser, which contains the applet. You can use this for printing error, link,\nhelp, or other status messages:\n14\ngetAppletContext().showStatus(\u201cChange the color\u201d);\nThe getAppletContext() method enables your applet to access features of the browser that\ncontains it. You already saw a use of this with links, wherein you could use the showDocument()\nmethod to tell the browser to load a page. showStatus() uses that same mechanism to print status\nmessages.\n297\n030-4s CH14.i 297 1\/29\/96, 10:49 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 MTWRFSS\nDDAAYY\n14 Windows, Networking, and Other Tidbits\nNote: showStatus() may not be supported in all browsers, so do not depend on it\nfor your applet\u2019s functionality or interface. It is a useful way of communicating\noptional information to your user\u2014if you need a more reliable method of commu-\nnication, set up a label in your applet and update it to reflect changes in its message.\nApplet Information\nThe AWT gives you a mechanism for associating information with your applet. Usually, there\nis a mechanism in the browser viewing the applet to view display information. You can use this\nmechanism to sign your name or your organization to your applet, or to provide contact\ninformation so that users can get hold of you if they want.\nTo provide information about your applet, override the getAppletInfo() method:\npublic String getAppletInfo() {\nreturn \u201cGetRaven copyright 1995 Laura Lemay\u201d;\n}\nCommunicating Between Applets\nSometimes you want to have an HTML page that has several different applets on it. To do this,\nall you have to do is include several different iterations of the applet tag\u2014the browser will create\ndifferent instances of your applet for each one that appears on the HTML page.\nWhat if you want to communicate between those applets? What if you want a change in one\napplet to affect the other applets in some way?\nThe best way to do this is to use the applet context to get to different applets on the same page.\nYou\u2019ve already seen the use of the getAppletContext() method for several other uses; you can\nalso use it to get hold of the other applets on the page. For example, to call a method in all the\napplets on a page (including the current applet), use the getApplets() method and a for loop\nthat looks something like this:\nfor (Enumeration e = getAppletContext().getApplets();\ne.hasMoreElements();) {\nApplet current = (Applet)(e.nextElement());\nsendMessage(current);\n}\nThe getApplets() method returns an Enumeration object with a list of the applets on the page.\nIterating over the Enumeration object in this way enables you to access each element in the\nEnumeration in turn.\n298\n030-4s CH14.i 298 1\/29\/96, 10:49 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 Sams.net Learning\nCenter\nabcd\nIf you want to call a method in a specific applet, it\u2019s slightly more complicated. To do this, you\ngive your applets a name and then refer to them by name inside the body of code for that applet.\nTo give an applet a name, use the NAME parameter in your HTML file:\n<P>This applet sends information:\n<APPLET CODE=\u201dMyApplet.class\u201d WIDTH=100 HEIGHT=150\nNAME=\u201dsender\u201d> <\/APPLET>\n<P>This applet receives information from the sender:\n<APPLET CODE=\u201dMyApplet.class\u201d WIDTH=100 HEIGHT=150\nNAME=\u201dreceiver\u201d> <\/APPLET>\nTo get a reference to another applet on the same page, use the getApplet() method from the\napplet context with the name of that applet. This gives you a reference to the applet of that name.\nYou can then refer to that applet as if it were just another object: call methods, set its instance\nvariables, and so on:\n\/\/ get ahold of the receiver applet\nApplet receiver = getAppletContext().getApplet(\u201creceiver\u201d);\n\/\/ tell it to update itself.\nreciever.update(text, value);\nIn this example, you use the getApplet() method to get a reference to the applet with the name\nreceiver. Given that reference, you can then call methods in that applet as if it were just another\nobject in your own environment. Here, for example, if both applets have an update() method,\nyou can tell receiver to update itself by using the information the current applet has.\nNaming your applets and then referring to them by using the methods described in this section\nenables your applets to communicate and stay in sync with each other, providing uniform\nbehavior for all the applets on your page.\nSummary\nCongratulations! Take a deep breath\u2014you\u2019re finished with Week 2. This week has been full of\nuseful information about creating applets and using the Java AWT classes to display, draw,\nanimate, process input, and create fully fledged interfaces in your applets.\nToday, you finished exploring applets and the AWT by learning about three concepts.\nFirst, you learned about windows, frames, menus, and dialogs, which enable you to create a\n14\nframework for your applets\u2014or enable your Java applications to take advantage of applet\nfeatures.\nSecond, you head a brief introduction to Java networking through some of the classes in the\njava.net package. Applet networking includes things as simple as pointing the browser to\nanother page from inside your applet, but can also include retrieving files from the Web by using\n299\n030-4s CH14.i 299 1\/29\/96, 10:49 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 MTWRFSS\nDDAAYY\n14 Windows, Networking, and Other Tidbits\nstandard Web protocols (http, ftp, and so on). For more advanced networking capabilities, Java\nprovides basic socket interfaces that can be used to implement many basic network-oriented\napplets\u2014client-server interactions, chat sessions, and so on.\nFinally, you finished up with the tidbits\u2014small features of the Java AWT and of applets that\ndidn\u2019t fit anywhere else, including showStatus(), producing information for your applet, and\ncommunicating between multiple applets on a single page.\nQ&A\nQ When I create popup windows using the appletviewer, they all show up with this\nbig red bar that says Warning: applet window. What does this mean?\nA The warning is to tell you (and the users of your applet) that the window being\ndisplayed was generated by an applet, and not by the browser itself. This is a security\nfeature to keep an applet programmer from popping up a window that masquerades as\na browser window and, for example, asks users for their passwords.\nThere\u2019s nothing you can do to hide or obscure the warning.\nQ What good is having a file dialog box if you can\u2019t read or write files from the\nlocal file system?\nA Applets can\u2019t read or write from the local file system, but because you can use AWT\ncomponents in Java applications as well as applets, the file dialog box is very useful for\nthat purpose.\nQ How can I mimic an HTML form submission in a Java applet?\nA Currently, applets make it difficult to do this. The best (and easiest way) is to use GET\nnotation to get the browser to submit the form contents for you.\nHTML forms can be submitted in two ways: by using the GET request, or by using\nPOST. If you use GET, your form information is encoded in the URL itself, something\nlike this:\nhttp:\/\/www.blah.com\/cgi-bin\/myscript?foo=1&bar=2&name=Laura\nBecause the form input is encoded in the URL, you can write a Java applet to mimic a\nform, get input from the user, and then construct a new URL object with the form\ndata included on the end. Then just pass that URL to the browser by using\ngetAppletContext().showDocument(), and the browser will submit the form results\nitself. For simple forms, this is all you need.\n300\n030-4s CH14.i 300 1\/29\/96, 10:50 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 Sams.net Learning\nCenter\nabcd\nQ How can I do POST form submissions?\nA You\u2019ll have to mimic what a browser does to send forms using POST: open a socket to\nthe server and send the data, which looks something like this (the exact format is\ndetermined by the HTTP protocol; this is only a subset of it):\nPOST \/cgi-bin\/mailto.cgi HTTP\/1.0\nContent-type: application\/x-www-form-urlencoded\nContent-length: 36\n{your encoded form data here}\nIf you\u2019ve done it right, you get the CGI form output back from the server. It\u2019s then up\nto your applet to handle that output properly. Note that if the output is in HTML,\nthere really isn\u2019t a way to pass that output to the browser that is running your applet.\nIf you get back a URL, however, you can redirect the browser to that URL.\nQ showStatus doesn\u2019t work in my browser. How can I give my readers status\ninformation?\nA As you learned in the section on showStatus(), whether or not a browser supports\nshowStatus() is up to that browser. If you must have status-like behavior in your\napplet, consider creating a status label in the applet itself that is updated with the\ninformation you need to present.\n14\n301\n030-4s CH14.i 301 1\/29\/96, 10:50 PM\nP2\/V4sqc 5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 14 LP#4 S\nWEESams\nK.net Learning\nCenter\nabcd\nS\nF\n3\n15\nE\nR\nW C\n16\nN\nT\nM A\nL 17\nG\n18\nA\nnn Modifiers\nMethod and variable access control\nT\nnn Packages and Interfaces\n19\nHiding classes\nA\nDesign versus implementation inheritance\nnn Exceptions\nProper throw statements\n20\nUsing the finally clause\nnn Multithreading\nSynchronization problems\nMore about Point\nnn Java Streams 21\nInput and output, flush() and close()\nnn Native Methods and Libraries\nBuilt-in optimizations\nGenerating header and stub files\n303\n030-4s AAG 03 303 1\/29\/96, 8:17 PM\nP2\/V4\/sqc8 TY Java in 21 Days 030-4 Everly 12.11.95 AAG 3 LP#2 MTWRFSS WWEEEEKK\n3 Week 3 at a Glance\nnn Under the Hood\nJava bytecodes\nSecurity and consistency checking\nGarbage collection\n304\n030-4s AAG 03 304 1\/29\/96, 8:17 PM\nP2\/V4\/sqc8 TY Java in 21 Days 030-4 Everly 12.11.95 AAG 3 LP#2 Sams.net Learning\nCenter\nabcd\n15\n15\n15\nS\nS\nWEEK\nF 3\nR\nW\nModifiers\nT\nM\nby Charles L. Perkins\n305\n030-4s CH15.i 305 1\/29\/96, 10:58 AM\nP2\/V4 \/SQC5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 15 LP#3 MTWRFSS\nDDAAYY\n15 Modifiers\nOnce you begin to program Java for a while, you\u2019ll discover that making all your classes,\nmethods, and variables public can become quite annoying. The larger your program becomes,\nand the more you reuse your classes for new projects, the more you will want some sort of control\nover their visibility. One of the large-scale solutions to this problem, packages, must wait until\ntomorrow, but today you\u2019ll explore what you can do within a class.\nToday, you\u2019ll learn how to create and use the following:\nnn Methods and variables that control their access by other classes\nnn Class variables and methods\nnn Constant variables, classes that cannot be subclassed, and methods that cannot be\noverridden\nnn Abstract classes and methods\nNEW* Modifiers are prefixes that can be applied in various combinations to the methods and\nTERM variables within a class and, some, to the class itself.\nThere is a long and varied list of modifiers. The order of modifiers is irrelevant to their\nmeaning\u2014your order can vary and is really a matter of taste. Pick a style and then be consistent\nwith it throughout all your classes. Here is the recommended order:\n<access> static abstract synchronized <unusual> final native\nwhere <access> can be public, protected, or private, and <unusual> includes volatile and\ntransient.\nNote: As of the beta release, threadsafe has been replaced by volatile. Both have\nto do with multithreading; no more will be said about them here (see Day 18).\ntransient is a special modifier used to declare a variable to be outside the persistent\npart of an object. This makes persistent object storage systems easier to implement\nin Java, and though the compiler supports it, it is not used by the current Java\nsystem. Several reserved keywords (byvalue, future, and generic, for example) may\nend up being <unusual> modifiers in later releases of Java. In the beta system, none\nof these unusual modifiers appears in the source code for the standard Java library\nclasses.\nAll the modifiers are essentially optional; none have to appear in a declaration. Good style\nsuggests adding as many as are needed to best describe the intended use of, and restrictions on,\nwhat you\u2019re declaring. In some special situations (inside an interface, for example, as described\ntomorrow), certain modifiers are implicitly defined for you, and you needn\u2019t type them\u2014they\nwill be assumed to be there.\n306\n030-4s CH15.i 306 1\/29\/96, 10:58 AM\nP2\/V4 \/SQC5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 15 LP#3 Sams.net Learning\nCenter\nabcd\nThe synchronized modifier is covered on Day 18; it has to do with multithreaded methods. The\nnative modifier is covered on Day 20; it specifies that a method is implemented in the native\n15\nlanguage of your computer (usually C), rather than in Java. How <access> modifiers apply to\nclasses is covered tomorrow.\nMethod and Variable Access Control\nAccess control is about controlling visibility. When a method or variable is visible to another\nclass, its methods can reference (call or modify) that method or variable. To \u201cprotect\u201d a method\nor variable from such references, you use the four levels of visibility described in the next\nsections. Each, in turn, is more restrictive, and thus provides more protection than the one\nbefore it.\nThe Four P\u2019s of Protection\nLearning your four P\u2019s (public, package, protected, and private) comes down to understanding\nthe fundamental relationships that a method or variable within a class can have to the other\nclasses in the system.\npublic\nBecause any class is an island unto itself, the first of these relationships builds on the distinction\nbetween the inside and the outside of the class. Any method or variable is visible to the class in\nwhich it is defined, but what if you want to make it visible to all the classes outside this class?\nThe answer is obvious: simply declare the method or variable to have public access. Almost every\nmethod and variable defined in the rest of this book has been declared, for simplicity\u2019s sake,\npublic. When you use any of the examples provided in your own code, you\u2019ll probably decide\nto restrict this access further. Because you\u2019re just learning now, it\u2019s not a bad idea to begin with\nthe widest possible access you can imagine and then narrow it down as you gain design\nexperience, until the access that each of your variables and methods should have becomes second\nnature. Here are some examples of public declarations:\npublic class APublicClass {\npublic int aPublicInt;\npublic String aPublicString;\npublic float aPublicMethod() {\n. . .\n}\n}\n307\n030-4s CH15.i 307 1\/29\/96, 10:59 AM\nP2\/V4 \/SQC5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 15 LP#3 MTWRFSS\nDDAAYY\n15 Modifiers\nNote: The two (or more) spaces after the prefix of modifiers and type in these\ndeclarations are intentional. They make finding the variable or method name\nwithin each line a little easier. Further in the book, you\u2019ll see that the type and the\nname are sometimes separately lined up in a column to make it even more evident\nwhat is what. When you get enough modifiers on a line, you\u2019ll begin to appreciate\nthese small touches.\nA variable or method with public access has the widest possible visibility. Anyone can see it.\nAnyone can use it. Of course, this may not always be what you want\u2014which brings us to the\nnext level of protection.\npackage\nIn C, there is the notion of hiding a name so that only the functions within a given source file\ncan see it. In Java, source files are replaced by the more explicit notion of packages, which can\ngroup classes (you learn about these tomorrow). For now, all you need to know is that the\nrelationship you want to support is of a class to its fellow implementors of one piece of a system,\nlibrary, or program (or to any other grouping of related classes). This defines the next level of\nincreased protection and narrowed visibility.\nDue to an idiosyncrasy of the Java language, this next level of access has no precise name. It is\nindicated by the lack of any access modifier in a declaration. Historically, it has been called\nvarious suggestive names, including \u201cfriendly\u201d and \u201cpackage.\u201d The latter usage seems most\nappropriate and is the one used here. Perhaps in a later release of the system, it will be possible\nto say package explicitly, but for now it is simply the default protection when none has been\nspecified.\nNote: Why would anyone want to make more typing for themselves and explicitly\nsay package? It is a matter of consistency and clarity. If you have a pattern of\ndeclarations with varying access modifier prefixes, you may always want the\nmodifier to be stated explicitly, both for the reader\u2019s benefit and because, in some\ncontexts, different \u201cdefault\u201d levels of protection are being assumed, and you want\nthe compiler to notice your intentions and warn you of any conflicts.\n308\n030-4s CH15.i 308 1\/29\/96, 10:59 AM\nP2\/V4 \/SQC5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 15 LP#3 Sams.net Learning\nCenter\nabcd\nMost of the declarations you\u2019ve seen in the past two weeks have used this default level of\nprotection. Here\u2019s a reminder of what they look like:\n15\npublic class ALessPublicClass {\nint aPackageInt = 2;\nString aPackageString = \u201ca 1 and a \u201c;\nfloat aPackageMethod() { \/\/ no access modifier means \u201cpackage\u201d\n. . .\n}\n}\npublic class AClassInTheSamePackage {\npublic void testUse() {\nALessPublicClass aLPC = new ALessPublicClass();\nSystem.out.println(aLPC.aPackageString + aLPC.aPackageInt);\naLPC.aPackageMethod(); \/\/ all of these are A.O.K.\n}\n}\nNote: If a class from any other package tried to access aLPC the way that\nAClassInTheSamePackage does in this example, it would generate compile-time\nerrors. (You\u2019ll learn how to create such classes tomorrow.)\nWhy was package made a default? When you\u2019re designing a large system and you partition your\nclasses into work groups to implement smaller pieces of that system, the classes often need to\nshare a lot more with one another than with the outside world. The need for this level of sharing\nis common enough that it was made the default level of protection.\nWhat if you have some details of your implementation that you don\u2019t want to share with these\n\u201cfriends\u201d? The answer to this question leads us naturally to the next level of protection.\nprotected\nThe third relationship is between a class and its present and future subclasses. These subclasses\nare much closer to a parent class than to any other \u201coutside\u201d classes for the following reasons:\nnn Subclasses are usually more intimately aware of the internals of a parent class.\nnn Subclasses are often written by you or by someone to whom you\u2019ve given your source\ncode.\nnn Subclasses frequently need to modify or enhance the representation of the data within\na parent class.\n309\n030-4s CH15.i 309 1\/29\/96, 10:59 AM\nP2\/V4 \/SQC5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 15 LP#3 MTWRFSS\nDDAAYY\n15 Modifiers\nNo one else is allowed the privilege of this level of access; they must be content with the public\nface that the class presents.\nTo support the level of intimacy reserved for subclasses, modern programming languages have\ninvented an intermediate level of access between the previous two levels and full privacy. This\nlevel gives more protection and narrows visibility still further, but still allows subclasses full\naccess. In Java, this level of protection is called, appropriately enough, protected:\npublic class AProtectedClass {\nprotected int aProtectedInt = 4;\nprotected String aProtectedString = \u201cand a 3 and a \u201c;\nprotected float aProtectedMethod() {\n. . .\n}\n}\npublic class AProtectedClassSubclass extends AProtectedClass {\npublic void testUse() {\nAProtectedClass aPC = new AProtectedClass();\nSystem.out.println(aPC.aProtectedString + aPC.aProtectedInt);\naPC.aProtectedMethod(); \/\/ all of these are A.O.K.\n}\n}\npublic class AnyClassInTheSamePackage {\npublic void testUse() {\nAProtectedClass aPC = new AProtectedClass();\nSystem.out.println(aPC.aProtectedString + aPC.aProtectedInt);\naPC.aProtectedMethod(); \/\/ NONE of these are legal\n}\n}\nEven though AnyClassInTheSamePackage is in the same package as AProtectedClass, it is not a\nsubclass of it (it\u2019s a subclass of Object). Only subclasses are allowed to see, and use, protected\nvariables and methods.\nOne of the most striking examples of the need for this special level of access is when you are\nsupporting a public abstraction with your class. As far as the outside world is concerned, you have\na simple, public interface (via methods) to whatever abstraction you\u2019ve built for your users. A\nmore complex representation, and the implementation that depends on it, is hidden inside.\nWhen subclasses extend and modify this representation, or even just your implementation of\nit, they need to get to the underlying, concrete representation and not simply to the abstraction:\npublic class SortedList {\nprotected BinaryTree theBinaryTree;\n. . .\npublic Object[] theList() {\nreturn theBinaryTree.asArray();\n310\n030-4s CH15.i 310 1\/29\/96, 10:59 AM\nP2\/V4 \/SQC5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 15 LP#3 Sams.net Learning\nCenter\nabcd\n}\npublic void add(Object o) { 15\ntheBinaryTree.addObject(o);\n}\n}\npublic class InsertSortedList extends SortedList {\npublic void insert(Object o, int position) {\ntheBinaryTree.insertObject(o, position);\n}\n}\nWithout being able to access theBinaryTree directly, the insert() method has to get the list as\nan array of Objects, via the public method theList(), allocate a new, bigger array, and insert the\nnew object by hand. By \u201cseeing\u201d that its parent is using a BinaryTree to implement the sorted\nlist, it can call upon BinaryTree\u2019s built-in method insertObject() to get the job done.\nSome languages, such as CLU, have experimented with more explicit ways of \u201craising\u201d and\n\u201clowering\u201d your level of abstraction to solve this same problem in a more general way. In Java,\nprotected solves only a part of the problem, by allowing you to separate the concrete from the\nabstract; the rest is up to you.\nprivate\nThe final relationship comes full circle, back to the distinction between the inside and outside\nof the class. private is the most narrowly visible, highest level of protection that you can get\u2014\nthe diametric opposite of public. private methods and variables cannot be seen by any class\nother than the one in which they are defined:\npublic class APrivateClass {\nprivate int aPrivateInt;\nprivate String aPrivateString;\nprivate float aPrivateMethod() {\n. . .\n}\n}\nThis may seem extremely restrictive, but it is, in fact, a commonly used level of protection. Any\nprivate data, internal state, or representations unique to your implementation\u2014anything that\nshouldn\u2019t be directly shared with subclasses\u2014is private. Remember that an an object\u2019s primary\njob is to encapsulate its data\u2014to hide it from the world\u2019s sight and limit its manipulation. The\nbest way to do that is to make as much data as private as possible. Your methods can always be\nless restrictive, as you\u2019ll see below, but keeping a tight rein on your internal representation is\nimportant. It separates design from implementation, minimizes the amount of information one\nclass needs to know about another to get its job done, and reduces the extent of the code changes\nyou need when your representation changes.\n311\n030-4s CH15.i 311 1\/29\/96, 10:59 AM\nP2\/V4 \/SQC5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 15 LP#3 MTWRFSS\nDDAAYY\n15 Modifiers\nThe Conventions\nfor Instance Variable Access\nA good rule of thumb is that unless an instance variable is constant (you\u2019ll soon see how to specify\nthis), it should almost certainly be private. If you don\u2019t do this, you have the following problem:\npublic class AFoolishClass {\npublic String aUsefulString;\n. . . \/\/ set up the useful value of the string\n}\nThis class may have thought of setting up aUsefulString for the use of other classes, expecting\nthem to (only) read it. Because it isn\u2019t private, however, they can say:\nAFoolishClass aFC = new AFoolishClass();\naFC.aUsefulString = \u201coops!\u201d;\nBecause there is no way to specify separately the level of protection for reading from and writing\nto instance variables, they should almost always be private.\nNote: The careful reader may notice that this rule is violated in many examples in\nthis book. Most of these were just for clarity\u2019s sake and to make the examples\nshorter and pithier. (You\u2019ll see soon that it takes more space to do the right thing.)\nOne use cannot be avoided: the System.out.print() calls scattered throughout the\nbook must use the public variable out directly. You cannot change this final\nsystem class (which you might have written differently). You can imagine the\ndisastrous results if anyone accidentally modifies the contents of this (global)\npublic variable!\nAccessor Methods\nIf instance variables are private, how do you give access to them to the outside world? The\nanswer is to write \u201caccessor\u201d methods:\npublic class ACorrectClass {\nprivate String aUsefulString;\npublic String aUsefulString() { \/\/ \u201cget\u201d the value\nreturn aUsefulString;\n}\nprotected void aUsefulString(String s) { \/\/ \u201cset\u201d the value\naUsefulString = s;\n}\n}\n312\n030-4s CH15.i 312 1\/29\/96, 11:00 AM\nP2\/V4 \/SQC5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 15 LP#3 Sams.net Learning\nCenter\nabcd\nUsing methods to access an instance variable is one of the most frequently used idioms in object-\noriented programs. Applying it liberally throughout all your classes repays you numerous times\n15\nover with more robust and reusable programs. Notice how separating the reading and writing\nof the instance variable allows you to specify a public method to return its value and a protected\nmethod to set it. This is often a useful pattern of protections, because everyone probably needs\nto be able to ask for the value, but only you (and your subclasses) should be able to change it.\nIf it is a particularly private piece of data, you could make its \u201cset\u201d method private and its \u201cget\u201d\nmethod protected, or any other combination that suits the data\u2019s sensitivity to the light of the\noutside world.\n!\n! Warning: According to the beta language specification, it is not legal to have an\ninstance variable and method by the same name. However, the beta compiler allows\nit! Because it is unclear what the final ruling on this conflict will be, use the simple\nnaming scheme used previously for your programs. In a later release, if the compiler\nbegins complaining, you can always change the method names to something less\nclear.\nOne of the alternate conventions for the naming of accessor methods is to prepend\nthe variable name with the prefixes get and set. Besides making you type more\u2014\nfor a little less clarity\u2014this style forces you (by the capitalization conventions of\nJava) to write methods names such as setAnnoyingFirstCapitalLetter(). All this is,\nof course, a matter of taste\u2014just be consistent in using whatever convention you\nadopt.\nWhenever you want to append to your own instance variable, try writing this:\naUsefulString(aUsefulString() + \u201c some appended text\u201d);\nJust like someone outside the class, you\u2019re using accessor methods to change aUsefulString.\nWhy do this?\nYou protected the variable in the first place so that changes to your representation would not\naffect the use of your class by others, but it still will affect the use of your class by you! As in the\nabstract versus concrete discussion earlier, you should be protected from knowing too much\nabout your own representation, except in those few places that actually need to know about it.\nThen, if you must change something about aUsefulString, it will not affect every use of that\nvariable in your class (as it would without accessor methods); rather, it affects only the\nimplementations of its accessor.\n313\n030-4s CH15.i 313 1\/29\/96, 11:00 AM\nP2\/V4 \/SQC5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 15 LP#3 MTWRFSS\nDDAAYY\n15 Modifiers\nOne of the powerful side effects of maintaining this level of indirection in accessing your own\ninstance variables is that if, at some later date, some special code needs to be performed each time\naUsefulString is accessed, you can put that code in one place, and all the other methods in your\nclass (and in everyone else\u2019s) will correctly call that special code. Here\u2019s an example:\nprotected void aUsefulString(String s) { \/\/ the \u201cset\u201d method\naUsefulString = s;\nperformSomeImportantBookkeepingOn(s);\n}\nIt may seem a little difficult to get used to saying this:\nx(12 + 5 * x());\nrather than this:\nx = 12 + 5 * x;\nbut the minor inconvenience will reward you with a rosy future of reusability and easy\nmaintenance.\nClass Variables and Methods\nWhat if you want to create a shared variable that all your instances can see and use? If you use\nan instance variable, each instance has its own copy of the variable, defeating its whole purpose.\nIf you place it in the class itself, however, there is only one copy, and all the instances of the class\nshare it. This is called a class variable:\npublic class Circle {\npublic static float pi = 3.14159265F;\npublic float area(float r) {\nreturn pi * r * r;\n}\n}\nTip: Because of its historical ties, Java uses the word static to declare class vari-\nables and methods. Whenever you see the word static, remember to substitute\nmentally the word \u201cclass.\u201d\nInstances can refer to their own class variables as though they were instance variables, as in the\nlast example. Because it\u2019s public, methods in other classes can also refer to pi:\nfloat circumference = 2 * Circle.pi * r;\n314\n030-4s CH15.i 314 1\/29\/96, 11:00 AM\nP2\/V4 \/SQC5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 15 LP#3 Sams.net Learning\nCenter\nabcd\nNote: Instances of Circle can also use this form of access. In most cases, for clarity,\n15\nthis is the preferred form, even for instances. It clarifies that a class variable is being\nused, and helps the reader to know instantly where it\u2019s used and that the variable is\nglobal to all instances. This may seem pedantic, but if you try it yourself, you\u2019ll see\nthat it can make things clearer.\nBy the way, if you might change your mind later about how a class variable is\naccessed, created, and so forth, you should create instance (or even class) accessor\nmethods to hide any uses of it from these changes.\nClass methods are defined analogously. They can be accessed in the same two ways by instances\nof their class, but only via the full class name by instances of other classes. Here\u2019s a class that\ndefines class methods to help it count its own instances:\npublic class InstanceCounter {\nprivate static int instanceCount = 0; \/\/ a class variable\nprotected static int instanceCount() { \/\/ a class method\nreturn instanceCount;\n}\nprivate static void incrementCount() {\n++instanceCount;\n}\nInstanceCounter() {\nInstanceCounter.incrementCount();\n}\n}\nIn this example, an explicit use of the class name calls the method incrementCount(). Though\nthis may seem verbose, in a larger program it immediately tells the reader which object (the class,\nrather than the instance) is expected to handle the method. This is especially useful if the reader\nneeds to find where that method is declared in a large class that places all its class methods at the\ntop (the recommended practice, by the way).\nNote the initialization of instanceCount to 0. Just as an instance variable is initialized when its\ninstance is created, a class variable is initialized when its class is created. This class initialization\nhappens essentially before anything else can happen to that class, or its instances, so the class in\nthe example will work as planned.\nFinally, the conventions you learned for accessing an instance variable are applied in this example\nto access a class variable. The accessor methods are therefore class methods. (There is no \u201cset\u201d\nmethod here, just an increment method, because no one is allowed to set instanceCount\n315\n030-4s CH15.i 315 1\/29\/96, 11:01 AM\nP2\/V4 \/SQC5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 15 LP#3 MTWRFSS\nDDAAYY\n15 Modifiers\ndirectly.) Note that only subclasses are allowed to ask what the instanceCount is, because that\nis a (relatively) intimate detail. Here\u2019s a test of InstanceCounter in action:\npublic class InstanceCounterTester extends InstanceCounter {\npublic static void main(String args[]) {\nfor (int i = 0; i < 10; ++i)\nnew InstanceCounter();\nSystem.out.println(\u201cmade \u201c + InstanceCounter.instanceCount());\n}\n}\nNot shockingly, this example prints the following:\nmade 10\nThe final Modifier\nAlthough it\u2019s not the final modifier discussed, the final modifier is very versatile:\nnn When the final modifier is applied to a class, it means that the class cannot be\nsubclassed.\nnn When it is applied to a variable, it means that the variable is constant.\nnn When it is applied to a method, it means that the method cannot be overridden by\nsubclasses.\nfinal Classes\nHere\u2019s a final class declaration:\npublic final class AFinalClass {\n. . .\n}\nYou declare a class final for only two reasons. The first is security. You expect to use its instances\nas unforgeable capabilities, and you don\u2019t want anyone else to be able to subclass and create new\nand different instances of them. The second is efficiency. You want to count on instances of only\nthat one class (and no subclasses) being around in the system so that you can optimize for them.\nNote: The Java class library uses final classes extensively. You can flip through the\nclass hierarchy diagrams in Appendix B to see them (final classes are shaded darker\nthan public classes). Examples of the first reason to use final are the classes:\njava.lang.System and, from the package java.net, InetAddress and Socket. A\ngood example of the second reason is java.lang.String. Strings are so common in\nJava, and so central to it, that the run-time handles them specially.\n316\n030-4s CH15.i 316 1\/29\/96, 11:01 AM\nP2\/V4 \/SQC5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 15 LP#3 Sams.net Learning\nCenter\nabcd\nIt will be a rare event for you to create a final class yourself, although you\u2019ll have plenty of\nopportunity to be upset at certain system classes being final (thus making extending them\n15\nannoyingly difficult). Oh well, such is the price of security and efficiency. Let\u2019s hope that\nefficiency will be less of an issue soon, and some of these classes will become public once again.\nfinal Variables\nTo declare constants in Java, use final variables:\npublic class AnotherFinalClass {\npublic static final int aConstantInt = 123;\npublic final String aConstantString = \u201cHello world!\u201d;\n}\nNote: The unusual spacing in the last line of the example makes it clearer that the\ntop variable is a class variable and the bottom isn\u2019t, but that both are public and\nfinal.\nfinal class and instance variables can be used in expressions just like normal class and instance\nvariables, but they cannot be modified. As a result, final variables must be given their (constant)\nvalue at the time of declaration. These variables function like a better, typed version of the\n#define constants of C. Classes can provide useful constants to other classes via final class\nvariables such as the one discussed previously. Other classes reference them just as before:\nAnotherFinalClass.aConstantInt.\nLocal variables (those inside blocks of code surrounded by braces, for example, in while or for\nloops) can\u2019t be declared final. (This would be just a convenience, really, because final instance\nvariables work almost as well in this case.) In fact, local variables can have no modifiers in front\nof them at all:\n{\nint aLocalVariable; \/\/ I\u2019m so sad without my modifiers...\n. . .\n}\nfinal Methods\nHere\u2019s an example of using final methods:\npublic class MyPenultimateFinalClass {\npublic static final void aUniqueAndReallyUsefulMethod() {\n. . .\n}\n317\n030-4s CH15.i 317 1\/29\/96, 11:01 AM\nP2\/V4 \/SQC5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 15 LP#3 MTWRFSS\nDDAAYY\n15 Modifiers\npublic final void noOneGetsToDoThisButMe() {\n. . .\n}\n}\nfinal methods cannot be overridden by subclasses. It is a rare thing that a method truly wants\nto declare itself the final word on its own implementation, so why does this modifier apply to\nmethods?\nThe answer is efficiency. If you declare a method final, the compiler can then \u201cin-line\u201d it right\nin the middle of methods that call it, because it \u201cknows\u201d that no one else can ever subclass and\noverride the method to change its meaning. Although you might not use final right away when\nwriting a class, as you tune the system later, you may discover that a few methods have to be final\nto make your class fast enough. Almost all your methods will be fine, however, just as they are.\nThe Java class library declares a lot of commonly used methods final so that you\u2019ll benefit from\nthe speed-up. In the case of classes that are already final, this makes perfect sense and is a wise\nchoice. The few final methods declared in non-final classes will annoy you\u2014your subclasses\ncan no longer override them. When efficiency becomes less of an issue for the Java environment,\nmany of these final methods can be \u201cunfrozen\u201d again, restoring this lost flexibility to the system.\nNote: private methods are effectively final, as are all methods declared in a final\nclass. Marking these latter methods final (as the Java library sometimes does) is\nlegal, but redundant; the current compiler already treats them as final.\nIt\u2019s possible to use final methods for some of the same security reasons you use\nfinal classes, but it\u2019s a much rarer event.\nIf you use accessor methods a lot (as recommended) and are worried about efficiency, here\u2019s a\nrewrite of ACorrectClass that\u2019s much faster:\npublic class ACorrectFinalClass {\nprivate String aUsefulString;\npublic final String aUsefulString() { \/\/ now faster to use\nreturn aUsefulString;\n}\nprotected final void aUsefulString(String s) { \/\/ also faster\naUsefulString = s;\n}\n}\n318\n030-4s CH15.i 318 1\/29\/96, 11:02 AM\nP2\/V4 \/SQC5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 15 LP#3 Sams.net Learning\nCenter\nabcd\nNote: Future Java compilers will almost certainly be smart enough to \u201cin-line\u201d\n15\nsimple methods automatically, so you probably won\u2019t need to use final in such\ncases for much longer.\nabstract Methods and Classes\nWhenever you arrange classes into an inheritance hierarchy, the presumption is that \u201chigher\u201d\nclasses are more abstract and general, whereas \u201clower\u201d subclasses are more concrete and specific.\nOften, as you design a set of classes, you factor out common design and implementation into\na shared superclass. If the primary reason that a superclass exists is to act as this common, shared\nrepository, and if only its subclasses expect to be used, that superclass is called an abstract class.\nabstract classes can create no instances, but they can contain anything a normal class can\ncontain and, in addition, are allowed to prefix any of their methods with the modifier abstract.\nNon-abstract classes are not allowed to use this modifier; using it on even one of your methods\nrequires that your whole class be declared abstract. Here\u2019s an example:\npublic abstract class MyFirstAbstractClass {\nint anInstanceVariable;\npublic abstract int aMethodMyNonAbstractSubclassesMustImplement();\npublic void doSomething() {\n. . . \/\/ a normal method\n}\n}\npublic class AConcreteSubClass extends MyFirstAbstractClass {\npublic int aMethodMyNonAbstractSubclassesMustImplement() {\n. . . \/\/ we *must* implement this method\n}\n}\nand some attempted uses of these classes:\nObject a = new MyFirstAbstractClass(); \/\/ illegal, is abstract\nObject c = new AConcreteSubClass(); \/\/ OK, a concrete subclass\nNotice that abstract methods need no implementation; it is required that non-abstract\nsubclasses provide an implementation. The abstract class simply provides the template for the\nmethods, which are implemented by others later. In fact, in the Java class library, there are several\nabstract classes that have no documented subclasses in the system, but simply provide a base\nfrom which you can subclass in your own programs. If you look at the diagrams in Appendix\nB, abstract classes are shaded even darker than final classes and are quite common in the\nlibrary.\n319\n030-4s CH15.i 319 1\/29\/96, 11:02 AM\nP2\/V4 \/SQC5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 15 LP#3 MTWRFSS\nDDAAYY\n15 Modifiers\nUsing an abstract class to embody a pure design\u2014that is, nothing but abstract methods\u2014is\nbetter accomplished in Java by using an interface (discussed tomorrow). Whenever a design calls\nfor an abstraction that includes instance state and\/or a partial implementation, however, an\nabstract class is your only choice. In previous object-oriented languages, abstract classes were\nsimply a convention. They proved so valuable that Java supports them not only in the form\ndescribed here, but in the purer, richer form of interfaces, which will be described tomorrow.\nSummary\nToday, you learned how variables and methods can control their visibility and access by other\nclasses via the four P\u2019s of protection: public, package, protected, and private. You also learned\nthat, although instance variables are most often declared private, declaring accessor methods\nallows you to control the reading and writing of them separately. Protection levels allow you,\nfor example, to separate cleanly your public abstractions from their concrete representations.\nYou also learned how to create class variables and methods, which are associated with the class\nitself, and how to declare final variables, methods, and classes to represent constants, fast or\nsecure methods, and classes, respectively.\nFinally, you discovered how to declare and use abstract classes, which cannot be instantiated,\nand abstract methods, which have no implementation and must be overridden in subclasses.\nTogether, they provide a template for subclasses to fill in and act as a variant of the powerful\ninterfaces of Java that you\u2019ll study tomorrow.\nQ&A\nQ Why are there so many different levels of protection in Java?\nA Each level of protection, or visibility, provides a different view of your class to the\noutside world. One view is tailored for everyone, one for classes in your own package,\nanother for your class and its subclasses only, and the final one for just within your\nclass. Each is a logically well-defined and useful separation that Java supports directly\nin the language (as opposed to, for example, accessor methods, which are a convention\nyou must follow).\nQ Won\u2019t using accessor methods everywhere slow down my Java code?\nA Not always. Soon, Java compilers will be smart enough to make them fast automati-\ncally, but if you\u2019re concerned about speed, you can always declare accessor methods to\nbe final, and they\u2019ll be just as fast as direct instance variable accesses.\n320\n030-4s CH15.i 320 1\/29\/96, 11:02 AM\nP2\/V4 \/SQC5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 15 LP#3 Sams.net Learning\nCenter\nabcd\nQ Are class (static) methods inherited just like instance methods?\nA Yes, and no. The beta compiler still allows you to inherit them, but according to one\n15\nof the oddest changes in the beta language specifications, static (class) methods are\nnow final by default. How, then, can you ever declare a non-final class method? The\nanswer is that you can\u2019t! Inheritance of class methods is not allowed, breaking the\nsymmetry with instance methods. Because this goes against a part of Java\u2019s philosophy\n(of making everything as simple as possible) perhaps it will be reversed in a later\nrelease. For now, follow the compiler and assume that class methods are inherited\nnormally.\nQ Based on what I\u2019ve learned, it seems like final abstract or private abstract\nmethods or classes don\u2019t make sense. Are they legal?\nA Nope, they\u2019re compile-time errors, as you have guessed. To be useful, abstract\nmethods must be overridden, and abstract classes must be subclassed, but neither of\nthose two operations would be legal if they were also public or final.\nQ What about static transient or final transient?\nA Those are also compile-time errors. Because a \u201ctransient\u201d part of an object\u2019s state is\nassumed to be changing within each instance, it can not be static or final. This\nrestriction matters only in the future, though, when transient is actually used by Java.\n321\n030-4s CH15.i 321 1\/29\/96, 11:02 AM\nP2\/V4 \/SQC5 TY Java in 21 Days 030-4 colleen 12.27.95 Ch 15 LP#3 Sams.net Learning\nCenter\nabcd\n16\n16\n16\nS\nS\nWEEK\nF 3\nR\nW\nPackages and\nT\nInterfaces\nM\nby Charles L. Perkins\n323\n030-4s CH16.i 323 1\/29\/96, 11:09 AM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12\/28\/95 Ch 16 LP#3 MTWRFSS\nDDAAYY\n16 Packages and Interfaces\nWhen you examine a new language feature, you should ask yourself two questions:\n1. How can I use it to better organize the methods and classes of my Java program?\n2. How can I use it while writing the Java code in my methods?\nThe first is often called programming in the large, and the second, programming in the small.\nBill Joy, a founder of Sun Microsystems, likes to say that Java feels like C when programming\nin the small and like Smalltalk when programming in the large. What he means by that is that\nJava is familiar and powerful like any C-like language while you\u2019re coding, but has the\nextensibility and expressive power of a pure object-oriented language like Smalltalk while you\u2019re\ndesigning.\nThe separation of \u201cdesigning\u201d from \u201ccoding\u201d was one of the most fundamental advances in\nprogramming in the past few decades, and object-oriented languages such as Java implement a\nstrong form of this separation. The first part of this separation has already been described on\nprevious days: when you develop a Java program, first you design the classes and decide on the\nrelationships between these classes, and then you implement the Java code needed for each of\nthe methods in your design. If you are careful enough with both these processes, you can change\nyour mind about aspects of the design without affecting anything but small, local pieces of your\nJava code, and you can change the implementation of any method without affecting the rest of\nthe design.\nAs you begin to explore more advanced Java programming, however, you\u2019ll find that this simple\nmodel becomes too limiting. Today, you\u2019ll explore these limitations, for programming in the\nlarge and in the small, to motivate the need for packages and interfaces. Let\u2019s start with packages.\nPackages\nPackages are Java\u2019s way of doing large-scale design and organization. They are used both to\ncategorize and group classes. Let\u2019s explore why you might need to use packages.\nProgramming in the Large\nWhen you begin to develop Java programs that use a large number of classes, you will quickly\ndiscover some limitations in the model presented thus far for designing and building them.\nFor one thing, as the number of classes you build grows, the likelihood of your wanting to reuse\nthe short, simple name of some class increases. If you use classes that you\u2019ve built in the past,\nor that someone else has built for you (such as the classes in the Java library), you may not\nremember\u2014or even know\u2014that these class names are in conflict. Being able to \u201chide\u201d a class\ninside a package becomes useful.\n324\n030-4s CH16.i 324 1\/29\/96, 11:09 AM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12\/28\/95 Ch 16 LP#3 Sams.net Learning\nCenter\nabcd\nHere\u2019s a simple example of the creation of a package in a Java source file:\npackage myFirstPackage;\npublic class MyPublicClass extends ItsSuperclass {\n. . .\n}\n16\nNote: If a package statement appears in a Java source file, it must be the first thing\nin that file (except for comments and white space, of course).\nYou first declare the name of the package by using a package statement. Then you define a class,\njust as you would normally. That class, and any other classes also declared inside this same\npackage name, are grouped together. (These other classes are usually located in other, separate\nsource files.)\nPackages can be further organized into a hierarchy somewhat analogous to the inheritance\nhierarchy, where each \u201clevel\u201d usually represents a smaller, more specific grouping of classes. The\nJava class library itself is organized along these lines (see the diagrams in Appendix B). The top\nlevel is called java; the next level includes names such as io, net, util, and awt. The last has an\neven lower level, which includes the package image. The ColorModel class, located in the package\nimage, can be uniquely referred to anywhere in your Java code as java.awt.image.ColorModel.\nNote: By convention, the first level of the hierarchy specifies the (globally unique)\nname of the company that developed the Java package(s). For example, Sun\nMicrosystem\u2019s classes, which are not part of the standard Java environment, all\nbegin with the prefix sun. The standard package, java, is an exception to this rule\nbecause it is so fundamental and because it might someday be implemented by\nmultiple companies.\nStarting with the beta release, Sun has specified a more formal procedure for\npackage naming to be followed in the future. The top-level package name space\nnow reserves, for the use of this procedure, all the uppercase abbreviations used for\ntop-level domains on the Internet (EDU, COM, GOV, FR, US, and so on). These\nreserved names form the first part of all new package names, which are prefixed by\na reversed version of your domain name. By this procedure, the sun packages would\nbe called COM.sun. If you\u2019re further down in your company\u2019s or university\u2019s domain\ntree, you can keep reversing to your heart\u2019s content:\nEDU.harvard.cs.projects.ai.learning.myPackage. Because domain names are\nalready guaranteed to be unique globally, this nicely solves that thorny problem,\n325\n030-4s CH16.i 325 1\/29\/96, 11:09 AM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12\/28\/95 Ch 16 LP#3 MTWRFSS\nDDAAYY\n16 Packages and Interfaces\nand as a bonus, the applets and packages from the potentially millions of Java\nprogrammers out there will automatically be stored into a growing hierarchy below\nyour classes directory, giving you a way to find and categorize them all in a\ncomprehensible manner.\nBecause each Java class should be located in a separate source file, the grouping of classes\nprovided by a hierarchy of packages is analogous to the grouping of files into a hierarchy of\ndirectories on your file system. The Java compiler reinforces this analogy by requiring you to\ncreate a directory hierarchy under your classes directory that exactly matches the hierarchy of the\npackages you have created, and to place a class into the directory with the same name (and level)\nas the package in which it\u2019s defined.\nFor example, the directory hierarchy for the Java class library exactly mirrors its package\nhierarchy. On UNIX, for example, the class referenced as java.awt.image.ColorModel is stored\nin a file named ColorModel.class in the directory named ...\/classes\/java\/awt\/image (the ... is the\npath where Java was installed on your computer). In particular, if you have created a package\nwithin myFirstPackage called mySecondPackage, by declaring a class:\npackage myFirstPackage.mySecondPackage;\npublic class AnotherPublicClass extends AnotherSuperclass {\n. . .\n}\nthe Java source file (called AnotherPublicClass.java) must be located in a directory below the\ncurrent directory called classes\/myFirstPackage\/mySecondPackage for the compiler (javac) to\nfind it. When the compiler generates the file AnotherPublicClass.class, it places it into this same\ndirectory so that the java interpreter can find it. Both the compiler and the interpreter expect\n(and enforce) the hierarchy.\nNote: This also means that, for today\u2019s first example, the source file would be\nnamed APublicClass.java and located in the directory called classes\/\nmyFirstPackage. What happens when, as in earlier examples in the book, classes are\ndefined without a package statement? The compiler places such classes in a default,\nunnamed package, and their .java and .class files can be located in the current\ndirectory or in the classes directory below it.\nTo be more precise, any occurrence of the phrase \u201cthe current directory\u201d in this\nsection should be replaced by \u201cany of the directories listed in the class path.\u201d The\ncompiler and interpreter both search this list of paths to find any classes you\nreference.\n326\n030-4s CH16.i 326 1\/29\/96, 11:09 AM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12\/28\/95 Ch 16 LP#3 Sams.net Learning\nCenter\nabcd\nYou can specify a class path on the command line when running javac or java, or\nmore permanently, by changing a special environment variable called\nCLASSPATH. (For more details, read the documentation in your Java release.)\nProgramming in the Small 16\nWhen you refer to a class by name in your Java code, you are using a package. Most of the time\nyou aren\u2019t aware of it because many of the most commonly used classes in the system are in a\npackage that the Java compiler automatically imports for you, called java.lang. So whenever\nyou saw this, for example:\nString aString;\nsomething more interesting than you might have thought was occurring. What if you want to\nrefer to the class you created at the start of this section, the one in the package myFirstPackage?\nIf you try this:\nMyPublicClass someName;\nthe compiler complains\u2014the class MyPublicClass is not defined in the package java.lang. To\nsolve this problem, Java allows any class name to be prefixed by the name of the package in which\nit was defined to form a unique reference to the class:\nmyFirstPackage.MyPublicClass someName;\nNote: Recall that by convention, package names tend to begin with a lowercase\nletter to distinguish them from class names. Thus, for example, in the full name of\nthe built-in String class, java.lang.String, it\u2019s easier to separate the package name\nfrom the class name visually.\nSuppose you want to use a lot of classes from a package, a package with a long name, or both.\nYou don\u2019t want to have to refer to your classes as that.really.long.package.name.ClassName.\nJava allows you to \u201cimport\u201d the names of those classes into your program. They then act just as\njava.lang classes do, and you can refer to them without a prefix. For example, to use the really\nlong class name in the last example more easily, you can write the following:\nimport that.really.long.package.name.ClassName;\nClassName anObject;\n\/\/ and you can use ClassName directly as many times as you like\n327\n030-4s CH16.i 327 1\/29\/96, 11:10 AM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12\/28\/95 Ch 16 LP#3 MTWRFSS\nDDAAYY\n16 Packages and Interfaces\nNote: All import statements must appear after any package statement but before\nany class definitions. Thus, they are \u201cstuck\u201d at the top of your source file.\nWhat if you want to use several classes from that same package? Here\u2019s an attempt from a (soon-\nto-be-tired) programmer:\nthat.really.long.package.name.ClassOne first;\nthat.really.long.package.name.ClassTwo second;\nthat.really.long.package.name.ClassThree andSoOn;\nHere\u2019s one from a more savvy programmer, who knows how to import a whole package of public\nclasses:\nimport that.really.long.package.name.*;\nClassOne first;\nClassTwo second;\nClassThree andSoOn;\n!\n! Warning: The asterisk (*) in this example is not exactly the one you might use at a\ncommand prompt to specify the contents of a directory. For example, if you ask to\nlist the contents of the directory classes\/java\/awt\/*, that list includes all the .class\nfiles and subdirectories such as image and peer. Writing import java.awt.* does not\nimport subpackages such as image and peer. To import all the classes in a complex\npackage hierarchy, you must explicitly import each level of the hierarchy by hand.\nIf you plan to use a class or a package only a few times in your source file, it\u2019s probably not worth\nimporting it. The rule of thumb is to ask yourself: \u201cDoes the loss in clarity I\u2019d introduce by\nreferring to just the class name outweigh the convenience of not having to type the extra\ncharacters?\u201d If it does, don\u2019t use import. Remember that the package name lets the reader know\nwhere to find more information about the class right at the place you\u2019re using it, rather than at\nthe top of the file, where the import statements are located.\nWhat if you have the following in class A\u2019s source file?\npackage packageA;\npublic class ClassName {\n. . .\n}\npublic class ClassA {\n. . .\n}\n328\n030-4s CH16.i 328 1\/29\/96, 11:10 AM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12\/28\/95 Ch 16 LP#3 Sams.net Learning\nCenter\nabcd\nand in class B\u2019s source file you have this:\npackage packageB;\npublic class ClassName {\n. . .\n}\npublic class ClassB {\n. . . 16\n}\nThen you the write the following, somewhere else:\nimport packageA;\nimport packageB;\nClassName anObject; \/\/ which ClassName did you mean?\nThere are two possible interpretations for the class you intended, one in packageA and one in\npackageB. Because this is ambiguous, what should the poor compiler do? It generates an error,\nof course, and you have to be more explicit about which one you intended. Here\u2019s an example:\nimport packageA.*;\nimport packageB.*;\npackageA.ClassName anObject; \/\/ now OK\npackageB.ClassName anotherObject; \/\/ also OK\nClassA anAObject; \/\/ was never a problem\nClassB aBObject; \/\/ ditto\nNote: You may wonder about the numerous declarations that appear as examples\nin today\u2019s lesson. Declarations are good examples because they\u2019re the simplest\npossible way of referencing a class name. Any use of a class name (in your extends\nclause, for example, or in new ClassName()) obeys the same rules.\nHiding Classes\nThe astute reader may have noticed that the discussion of importing with an asterisk (*) stated\nthat it imported a whole package of public classes. Why would you want to have classes of any\nother kind? Take a look at this:\npackage collections;\npublic class LinkedList {\nprivate Node root;\n329\n030-4s CH16.i 329 1\/29\/96, 11:11 AM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12\/28\/95 Ch 16 LP#3 MTWRFSS\nDDAAYY\n16 Packages and Interfaces\npublic void add(Object o) {\nroot = new Node(o, root);\n}\n. . .\n}\nclass Node { \/\/ not public\nprivate Object contents;\nprivate Node next;\nNode(Object o, Node n) {\ncontents = o;\nnext = n;\n}\n. . .\n}\nNote: If this were all in one file, you might be violating one of the compiler\u2019s\nconventions: only one class should be located in each Java source file. Actually, the\ncompiler cares only about every public class being in a separate file (although it still\nis good style to use separate files for each class).\nThe goal of the LinkedList class is to provide a set of useful public methods (such as add()) to\nany other classes that might want to use them. These other classes could care less about any\nsupport classes LinkedList needs to get its job done, and would prefer to not \u201csee\u201d them when\nusing LinkedList. In addition, LinkedList may feel that the Node class is local to its implemen-\ntation and should not be seen by any other classes.\nFor methods and variables, this would be addressed by the four Ps of protection discussed\nyesterday: private, protected, package, and public, listed in order of increasing visibility.\nYou\u2019ve already explored many public classes, and because both private and protected really\nmake sense only when you\u2019re inside a class definition, you cannot put them outside of one as\npart of defining a new class. LinkedList might really like to say \u201conly classes in my source file\ncan see this class,\u201d but because, by convention, each class is located in a separate source file, this\nwould be a little-needed, over-narrow approach.\nInstead, LinkedList declares no protection modifier, which is equivalent to saying package. Now\nthe class can be seen and used only by other classes in the same package in which it was defined.\nIn this case, it\u2019s the collections package. You might use LinkedList as follows:\nimport collections.*; \/\/ only imports public classes\nLinkedList aLinkedList;\n\/* Node n; *\/ \/\/ would generate a compile-time error\naLinkedList.add(new Integer(1138));\naLinkedList.add(\u201cTHX-\u201d);\n. . .\n330\n030-4s CH16.i 330 1\/29\/96, 11:11 AM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12\/28\/95 Ch 16 LP#3 Sams.net Learning\nCenter\nabcd\nNote: You also can import or declare a LinkedList as collections.LinkedList in\nthis example. Because LinkedList refers to Node, that class is automatically loaded\nand used, and the compiler verifies that LinkedList (as part of package collec-\ntions) has the right to create and use the Node class. You still do not have that right,\nthough, just as in the example.\n16\nOne of the great powers of hidden classes is that even if you use them to introduce a great deal\nof complexity into the implementation of some public class, all the complexity is hidden when\nthat class is imported. Thus, creating a good package consists of defining a small, clean set of\npublic classes and methods for other classes to use, and then implementing them by using any\nnumber of hidden (package) support classes. You\u2019ll see another use for hidden classes later today.\nInterfaces\nInterfaces, like the abstract classes and methods you saw yesterday, provide templates of behavior\nthat other classes are expected to implement, but they are much more powerful. Let\u2019s see why\nyou might need such power.\nProgramming in the Large\nWhen you first begin to design object-oriented programs, the class hierarchy seems almost\nmiraculous. Within that single tree you can express a hierarchy of numeric types (number,\ncomplex, float, rational, integer), many simple-to-moderately-complex relationships between\nobjects and processes in the world, and any number of points along the axis from abstract\/general\nto concrete\/specific. After some deeper thought or more complex design experience, this\nwonderful tree begins to feel restrictive\u2014at times, like a straitjacket. The very power and\ndiscipline you\u2019ve achieved by carefully placing only one copy of each idea somewhere in the tree\ncan come back to haunt you whenever you need to cross-fertilize disparate parts of that tree.\nSome languages address these problems by introducing more flexible run-time power, such as\nthe code block and the perform: method of Smalltalk; others choose to provide more complex\ninheritance hierarchies, such as multiple-inheritance. With the latter complexity comes a host\nof confusing and error-prone ambiguities and misunderstandings, and with the former, a harder\ntime implementing safety and security and a harder language to explain and teach. Java has\nchosen to take neither of these paths but, in the spirit of objective-C\u2019s protocols, has adopted\na separate hierarchy altogether to gain the expressive power needed to loosen the straitjacket.\nThis new hierarchy is a hierarchy of interfaces. Interfaces are not limited to a single superclass,\nso they allow a form of multiple-inheritance. But they pass on only method descriptions to their\n331\n030-4s CH16.i 331 1\/29\/96, 11:12 AM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12\/28\/95 Ch 16 LP#3 MTWRFSS\nDDAAYY\n16 Packages and Interfaces\nchildren, not method implementations nor instance variables, which helps to eliminate many\nof the complexities of full multiple-inheritance.\nInterfaces, like classes, are declared in source files, one interface to a file. Like classes, they also\nare compiled into .class files. In fact, almost everywhere that this book has a class name in any\nof its examples or discussions, you can substitute an interface name. Java programmers often say\n\u201cclass\u201d when they actually mean \u201cclass or interface.\u201d Interfaces complement and extend the\npower of classes, and the two can be treated almost exactly the same. One of the few differences\nbetween them is that an interface cannot be instantiated: new can create only an instance of a class.\nHere\u2019s the declaration of an interface:\npackage myFirstPackage;\npublic interface MyFirstInterface extends Interface1, Interface2, ... {\n. . .\n\/\/ all methods in here will be public and abstract\n\/\/ all variables will be public, static, and final\n}\nThis example is a rewritten version of the first example in today\u2019s lesson. It now adds a new\npublic interface to the package myFirstPackage, instead of a new public class. Note that\nmultiple parents can be listed in an interface\u2019s extends clause.\nNote: If no extends clause is given, interfaces do not default to inheriting from\nObject, because Object is a class. In fact, interfaces have no \u201ctopmost\u201d interface\nfrom which they are all guaranteed to descend.\nAny variables or methods defined in a public interface are implicitly prefixed by the modifiers\nlisted in the comments. Exactly those modifiers can (optionally) appear, but no others:\npublic interface MySecondInterface {\npublic static final int theAnswer = 42; \/\/ both lines OK\npublic abstract int lifeTheUniverseAndEverything();\nlong bingBangCounter = 0; \/\/ OK, becomes public, static, final\nlong ageOfTheUniverse(); \/\/ OK, becomes public and abstract\nprotected int aConstant; \/\/ not OK\nprivate int getAnInt(); \/\/ not OK\n}\nNote: If an interface is declared non-public (that is, package), no public modifiers\nare implicitly prefixed. If you say public inside such an interface, you\u2019re making a\nreal statement of public-ness, not simply a redundant statement. It\u2019s not often,\n332\n030-4s CH16.i 332 1\/29\/96, 11:12 AM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12\/28\/95 Ch 16 LP#3 Sams.net Learning\nCenter\nabcd\nthough, that an interface is shared only by the classes inside a package, and not by\nthe classes using that package as well.\nDesign Versus Implementation Revisited\n16\nOne of the most powerful things interfaces add to Java is the capability of separating design\ninheritance from implementation inheritance. In the single-class inheritance tree, these two are\ninextricably bound. Sometimes, you want to be able to describe an interface to a class of objects\nabstractly, without having to implement a particular implementation of it yourself. You could\ncreate an abstract class, such as those described yesterday. In order for a new class to use this\ntype of \u201cinterface,\u201d however, it has to become a subclass of the abstract class and accept its\nposition in the tree. If this new class also needs to be a subclass of some other class in the tree,\nfor implementation reasons, what could it do? What if it wants to use two such \u201cinterfaces\u201d at\nonce? Watch this:\nclass FirstImplementor extends SomeClass implements MySecondInterface {\n. . .\n}\nclass SecondImplementor implements MyFirstInterface, MySecondInterface {\n. . .\n}\nThe first class above is \u201cstuck\u201d in the single inheritance tree just below the class SomeClass but\nis free to implement an interface as well. The second class is stuck just below Object but has\nimplemented two interfaces (it could have implemented any number of them). Implementing\nan interface means promising to implement all the methods specified in it.\nNote: Although an abstract class is allowed to ignore this strict requirement, and\ncan implement any subset of the methods (or even none of them), all its non-\nabstract subclasses must still obey it.\nBecause interfaces are in a separate hierarchy, they can be \u201cmixed-in\u201d to the classes in the single\ninheritance tree, allowing the designer to sprinkle an interface anywhere it is needed throughout\nthe tree. The single-inheritance class tree can thus be viewed as containing only the implemen-\ntation hierarchy; the design hierarchy (full of abstract methods, mostly) is contained in the\nmultiple-inheritance interface tree. This is a powerful way of thinking about the organization\nof your program, and though it takes a little getting used to, it\u2019s also a highly recommended one.\nLet\u2019s examine one simple example of this separation\u2014creating the new class Orange. Suppose\nyou already have a good implementation of the class Fruit, and an interface, Fruitlike, that\n333\n030-4s CH16.i 333 1\/29\/96, 11:13 AM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12\/28\/95 Ch 16 LP#3 MTWRFSS\nDDAAYY\n16 Packages and Interfaces\nrepresents what Fruits are expected to be able to do. You want an orange to be a fruit, but you\nalso want it to be a spherical object that can be tossed, rotated, and so on. Here\u2019s how to express\nit all:\ninterface Fruitlike extends Foodlike {\nvoid decay();\nvoid squish();\n. . .\n}\nclass Fruit extends Food implements Fruitlike {\nprivate Color myColor;\nprivate int daysTilIRot;\n. . .\n}\ninterface Spherelike {\nvoid toss();\nvoid rotate();\n. . .\n}\nclass Orange extends Fruit implements Spherelike {\n. . . \/\/ toss()ing may squish() me (unique to me)\n}\nYou\u2019ll use this example again later today. For now, notice that class Orange doesn\u2019t have to say\nimplements Fruitlike because, by extending Fruit, it already has!\nNote: The reverse is not true, however. Implementing an interface implies nothing\nabout the implementation hierarchy of a class. By the way, if you had used a more\ntraditional way of designing classes (though not necessarily better), the class Fruit\nwould be the interface description, as well as being the implementation.\nOne of the nice things about this structure is that you can change your mind about what class\nOrange extends (if a really great Sphere class is suddenly implemented, for example), yet class\nOrange will still understand the same two interfaces:\nclass Sphere implements Spherelike { \/\/ extends Object\nprivate float radius;\n. . .\n}\nclass Orange extends Sphere implements Fruitlike {\n. . . \/\/ users of Orange never need know about the change!\n}\nThe canonical use of the \u201cmix-in\u201d capability of interfaces is to allow several classes, scattered\nacross the single-inheritance tree, to implement the same set of methods (or even just one).\n334\n030-4s CH16.i 334 1\/29\/96, 11:13 AM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12\/28\/95 Ch 16 LP#3 Sams.net Learning\nCenter\nabcd\nAlthough these classes share a common superclass (at worst, Object), it is likely that below this\ncommon parent are many subclasses that are not interested in this set of methods. Adding the\nmethods to the parent class, or even creating a new abstract class to hold them and inserting\nit into the hierarchy above the parent, is not an ideal solution.\nInstead, use an interface to specify the method(s). It can be implemented by every class that\nshares the need and by none of the other classes that would have been forced to \u201cunderstand\u201d\nthem in the single-inheritance tree. (Design is applied only where needed.) Users of the interface 16\ncan now specify variables and arguments to be of a new interface type that can refer to any of\nthe classes that implement the interface (as you\u2019ll see below)\u2014a powerful abstraction. Some\nexamples of \u201cmix-in\u201d facilities are object persistence (via read() and write() methods),\nproducing or consuming something (the Java library does this for images), and providing\ngenerally useful constants. The last of these might look like this:\npublic interface PresumablyUsefulConstants {\npublic static final int oneOfThem = 1234;\npublic static final float another = 1.234F;\npublic static final String yetAnother = \u201c1234\u201d;\n. . .\n}\npublic class AnyClass implements PresumablyUsefulConstants {\npublic static void main(String argV[]) {\ndouble calculation = oneOfThem * another;\nSystem.out.println(\u201chello \u201c + yetAnother + calculation);\n. . .\n}\n}\nThis outputs the thoroughly meaningless hello 12341522.756, but in the process demonstrates\nthat the class AnyClass can refer directly to all the variables defined in the interface\nPresumablyUsefulConstants. Normally, you refer to such variables and constants via the class,\nas for the constant Integer.MIN_VALUE, which is provided by the Integer class. If a set of\nconstants is large or is widely used, the shortcut of being able to refer to them directly (as\noneOfThem rather than as PresumablyUsefulConstants.oneOfThem) makes it worth placing them\ninto an interface and implementing it widely.\nProgramming in the Small\nHow do you actually use these interfaces? Remember that almost everywhere that you can use\na class, you can use an interface instead. Let\u2019s try to make use of the interface MySecondInterface\ndefined previously:\nMySecondInterface anObject = getTheRightObjectSomehow();\nlong age = anObject.ageOfTheUniverse();\n335\n030-4s CH16.i 335 1\/29\/96, 11:13 AM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12\/28\/95 Ch 16 LP#3 MTWRFSS\nDDAAYY\n16 Packages and Interfaces\nOnce you declare anObject to be of type MySecondInterface, you can use anObject as the receiver\nof any message that the interface defines (or inherits). What does the previous declaration really\nmean?\nWhen a variable is declared to be of an interface type, it simply means that any object the variable\nrefers to is expected to have implemented that interface\u2014that is, it is expected to understand\nall the methods that interface specifies. It assumes that a promise made between the designer of\nthe interface and its eventual implementors has been kept. Although this is a rather abstract\nnotion, it allows, for example, the previous code to be written long before any classes that qualify\nare actually implemented (or even created!). In traditional object-oriented programming, you\nare forced to create a class with \u201cstub\u201d implementations to get the same effect.\nHere\u2019s a more complicated example:\nOrange anOrange = getAnOrange();\nFruit aFruit = (Fruit) getAnOrange();\nFruitlike aFruitlike = (Fruitlike) getAnOrange();\nSpherelike aSpherelike = (Spherelike) getAnOrange();\naFruit.decay(); \/\/ fruits decay\naFruitlike.squish(); \/\/ and squish\naFruitlike.toss(); \/\/ not OK\naSpherelike.toss(); \/\/ OK\nanOrange.decay(); \/\/ oranges can do it all\nanOrange.squish();\nanOrange.toss();\nanOrange.rotate();\nDeclarations and casts are used in this example to restrict an orange to act more like a mere fruit\nor sphere, simply to demonstrate the flexibility of the structure built previously. If the second\nstructure built (the one with the new Sphere class) were being used instead, most of this code\nwould still work. (In the line bearing Fruit, all instances of Fruit need to be replaced by Sphere.\nThe later use of aFruit.decay() could be replaced by, for example, aSphere.rotate().\nEverything else is the same.)\nNote: The direct use of (implementation) class names is for demonstration pur-\nposes only. Normally, you would use only interface names in those declarations\nand casts so that none of the code in the example would have to change to support\nthe new structure.\n336\n030-4s CH16.i 336 1\/29\/96, 11:13 AM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12\/28\/95 Ch 16 LP#3 Sams.net Learning\nCenter\nabcd\nInterfaces are implemented and used throughout the Java class library, whenever a behavior is\nexpected to be implemented by a number of disparate classes. In Appendix B you\u2019ll find, for\nexample, the interfaces java.lang.Runnable, java.util.Enumeration, java.util.Observable,\njava.awt.image.ImageConsumer, and java.awt.image.ImageProducer. Let\u2019s use one of these\ninterfaces, Enumeration, to revisit the LinkedList example\u2014and to tie together today\u2019s lesson\u2014\nby demonstrating a good use of packages and interfaces together:\npackage collections; 16\npublic class LinkedList {\nprivate Node root;\n. . .\npublic Enumeration enumerate() {\nreturn new LinkedListEnumerator(root);\n}\n}\nclass Node {\nprivate Object contents;\nprivate Node next;\n. . .\npublic Object contents() {\nreturn contents;\n}\npublic Node next() {\nreturn next;\n}\n}\nclass LinkedListEnumerator implements Enumeration {\nprivate Node currentNode;\nLinkedListEnumerator(Node root) {\ncurrentNode = root;\n}\npublic boolean hasMoreElements() {\nreturn currentNode != null;\n}\npublic Object nextElement() {\nObject anObject = currentNode.contents();\ncurrentNode = currentNode.next();\nreturn anObject;\n}\n}\n337\n030-4s CH16.i 337 1\/29\/96, 11:14 AM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12\/28\/95 Ch 16 LP#3 MTWRFSS\nDDAAYY\n16 Packages and Interfaces\nHere is a typical use of the enumerator:\ncollections.LinkedList aLinkedList = createLinkedList();\njava.util.Enumeration e = aLinkedList.enumerate();\nwhile (e.hasMoreElements()) {\nObject anObject = e.nextElement();\n\/\/ do something useful with anObject\n}\nNotice that although you are using the Enumeration e as though you know what it is, you actually\ndo not. In fact, it is an instance of a hidden class (LinkedListEnumerator) that you cannot see\nor use directly. By a combination of packages and interfaces, the LinkedList class has managed\nto provide a transparent public interface to some of its most important behavior (via the already\ndefined interface java.util.Enumeration) while still encapsulating (hiding) its two implemen-\ntation (support) classes.\nHanding out an object like this is sometime called vending. Often, the \u201cvendor\u201d gives out an\nobject that a receiver can\u2019t create itself, but that it knows how to use. By giving it back to the\nvendor, the receiver can prove it has a certain capability, authenticate itself, or do any number\nof useful tasks\u2014all without knowing much about the vended object. This is a powerful\nmetaphor that can be applied in a broad range of situations.\nSummary\nToday, you learned how packages can be used to collect and categorize classes into meaningful\ngroups. Packages are arranged in a hierarchy, which not only better organizes your programs,\nbut allows you and the millions of Java programmers out on the Net to name and share their\nprojects uniquely with one another.\nYou also learned how to use packages, both your own and the many preexisting ones in the Java\nclass library.\nYou then discovered how to declare and use interfaces, a powerful mechanism for extending the\ntraditional single-inheritance of Java\u2019s classes and for separating the design inheritance from the\nimplementation inheritance in your programs. Interfaces are often used to call shared methods\nwhen the exact class involved is not known. You\u2019ll see further uses of interfaces tomorrow and\nthe day after.\nFinally, packages and interfaces can be combined to provide useful abstractions, such as\nEnumeration, that appear simple yet are actually hiding almost all their (complex) implementa-\ntion from their users. This is a powerful technique.\n338\n030-4s CH16.i 338 1\/29\/96, 11:14 AM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12\/28\/95 Ch 16 LP#3 Sams.net Learning\nCenter\nabcd\nQ&A\nQ What will happen to package\/directory hierarchies when some sort of archiving\nis added to Java?\nA Being able to download over the Net a whole archive of packages, classes, and re-\nsources is something that Java systems may soon be able to do. When this happens,\nthe simple mapping between directory hierarchy and package hierarchy will break\n16\ndown, and you will not be able to tell as easily where each class is stored (that is, in\nwhich archive). Presumably these new, advanced Java systems will provide tools that\nmake this task (and compiling and linking your program in general) much easier.\nQ Can you say import some.package.B* to import all the classes in that package that\nbegin with B?\nA No, the import asterisk (*) does not act like a command-line asterisk.\nQ Then what exactly does import-ing with an * mean?\nA Combining everything said previously, this precise definition emerges: it imports all\nthe public classes that are directly inside the package named, and not inside one of its\nsubpackages. (You can only import exactly this set of classes, or exactly one explicitly\nnamed class, from a given package.) By the way, Java only \u201cloads\u201d the information for\na class when you actually refer to that class in your code, so the * form of import is no\nless efficient than naming each class individually.\nQ Is there any way that a hidden (package) class can somehow be forced out of\nhiding?\nA A bizarre case in which a hidden class can be forced into visibility occurs if it has a\npublic superclass and someone casts an instance of it to the superclass. Any public\nmethods of that superclass can now be called via your hidden class instance, even if\nthose methods were not thought of by you as public when overridden in the hidden\nclass. Usually, these public methods are ones you don\u2019t mind having your instances\nperform, or you wouldn\u2019t have declared them to have that public superclass. This isn\u2019t\nalways the case. Many of the system\u2019s built-in classes are public\u2014you may have no\nchoice. Luckily, this is a rare event.\nQ Why is full multiple-inheritance so complex that Java abandoned it?\nA It\u2019s not so much that it is too complex, but that it makes the language overly compli-\ncated\u2014and as you\u2019ll learn on the final day, this can cause larger systems to be less\ntrustworthy and thus less secure. For example, if you were to inherit from two\ndifferent parents, each having an instance variable with the same name, you would be\nforced to allow the conflict and explain how the exact same references to that variable\nname in each of your superclasses, and in you (all three), are now different. Instead of\n339\n030-4s CH16.i 339 1\/29\/96, 11:15 AM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12\/28\/95 Ch 16 LP#3 MTWRFSS\nDDAAYY\n16 Packages and Interfaces\nbeing able to call \u201csuper\u201d methods to get more abstract behavior accomplished, you\nwould always need to worry about which of the (possibly many) identical methods\nyou actually wished to call in which parent. Java\u2019s run-time method dispatching would\nhave to be more complex as well. Finally, because so many people would be providing\nclasses for reuse on the Net, the normally manageable conflicts that would arise in\nyour own program would be confounded by millions of users mixing and matching\nthese fully multi-inherited classes at will. In the future, if all these issues are resolved,\nmore powerful inheritance may be added to Java, but its current capabilities are\nalready sufficient for 99 percent of your programs.\nQ abstract classes don\u2019t have to implement all the methods in an interface them-\nselves, but do all their subclasses have to?\nA Actually, no. Because of inheritance, the precise rule is that an implementation must\nbe provided by some class for each method, but it doesn\u2019t have to be your class. This is\nanalogous to when you are the subclass of a class that implements an interface for you.\nWhatever the abstract class doesn\u2019t implement, the first nonabstract class below it\nmust implement. Then, any further subclasses need do nothing further.\nQ You didn\u2019t mention callbacks. Aren\u2019t they an important use of interfaces?\nA Yes, but I didn\u2019t mention them because a good example would be too bulky in the\ntext. These callbacks are often used in user interfaces (such as window systems) to\nspecify what set of methods are going to be sent whenever the user does a certain set of\nthings (such as clicking the mouse somewhere, typing, and so forth). Because the user\ninterface classes should not \u201cknow\u201d anything about the classes using them, an\ninterface\u2019s ability to specify a set of methods separate from the class tree is crucial in\nthis case. Callbacks using interfaces are not as general as using, for example, the\nperform: method of Smalltalk, however, because a given object can request that a user\ninterface object \u201ccall it back\u201d only by using a single method name. Suppose that object\nwanted two user interfaces objects of the same class to call it back, using different\nnames to tell them apart? It cannot do this in Java, and it is forced to use special state\nand tests to tell them apart. (I warned you that it was complicated!). So, although\ninterfaces are quite valuable in this case, they are not the ideal callback facility.\n340\n030-4s CH16.i 340 1\/29\/96, 11:15 AM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12\/28\/95 Ch 16 LP#3 Sams.net Learning\nCenter\nabcd\n17\n17\n17\nS\nS\nWEEK\nF 3\nR\nW\nExceptions\nT\nM\nby Charles L. Perkins\n341\n030-4s CH17.i 341 1\/29\/96, 11:18 AM\nP2\/V4\/SQC 4 TY Java in 21 Days 030-4 Casey 12.28.95 Ch17 LP#3 MTWRFSS\nDDAAYY\n17 Exceptions\nToday, you\u2019ll learn about exceptional conditions in Java:\nnn How to declare when you are expecting one\nnn How to handle them in your code\nnn How to create them\nnn How your code is limited, yet made more robust by them\nLet\u2019s begin by motivating why new ways of handling exceptions were invented.\nProgramming languages have long labored to solve the following common problem:\nint status = callSomethingThatAlmostAlwaysWorks();\nif (status == FUNNY_RETURN_VALUE) {\n. . . \/\/ something unusual happened, handle it\nswitch(someGlobalErrorIndicator) {\n. . . \/\/ handle more specific problems\n}\n} else {\n. . . \/\/ all is well, go your merry way\n}\nSomehow this seems like a lot of work to do to handle a rare case. What\u2019s worse, if the function\ncalled returns an int as part of its normal answer, you must distinguish one special integer\n(FUNNY_RETURN_VALUE) to indicate an error. What if that function really needs all the integers?\nYou must do something even more ugly.\nEven if you manage to find a distinguished value (such as NULL in C for pointers, -1 for integers,\nand so forth), what if there are multiple errors that must be produced by the same function?\nOften, some global variable is used as an error indicator. The function stores a value in it and\nprays that no one else changes it before the caller gets to handle the error. Multiple errors\npropagate badly, if at all, and there are numerous problems with generalizing this to large\nprograms, complex errors, and so forth.\nLuckily, there is an alternative: using exceptions to help you handle exceptional conditions in\nyour program, making the normal, nonexceptional code cleaner and easier to read.\nNEW* An exception is any object that is an instance of the class Throwable (or any of\nTERM its subclasses).\nProgramming in the Large\nWhen you begin to build complex programs in Java, you discover that after designing the classes\nand interfaces, and their methods descriptions, you still have not defined all the behavior of your\nobjects. After all, an interface describes the normal way to use an object and doesn\u2019t include any\n342\n030-4s CH17.i 342 1\/29\/96, 11:18 AM\nP2\/V4\/SQC 4 TY Java in 21 Days 030-4 Casey 12.28.95 Ch17 LP#3 Sams.net Learning\nCenter\nabcd\nstrange, exceptional cases. In many systems, the documentation takes care of this problem by\nexplicitly listing the distinguished values used in \u201chacks\u201d like the previous example. Because the\nsystem knows nothing about these hacks, it cannot check them for consistency. In fact, the\ncompiler can do nothing at all to help you with these exceptional conditions, in contrast to the\nhelpful warnings and errors it produces if a method is used incorrectly.\nMore importantly, you have not captured in your design this important aspect of your program.\nInstead, you are forced to make up a way to describe it in the documentation and hope you have\nnot made any mistakes when you implement it later. What\u2019s worse, everyone else makes up a\ndifferent way of describing the same thing. Clearly, you need some uniform way of declaring the\nintentions of classes and methods with respect to these exceptional conditions. Java provides just\nsuch a way:\npublic class MyFirstExceptionalClass { 17\npublic void anExceptionalMethod() throws MyFirstException {\n. . .\n}\n}\nHere, you warn the reader (and the compiler) that the code . . . may throw an exception called\nMyFirstException.\nYou can think of a method\u2019s description as a contract between the designer of that method (or\nclass) and you, the caller of the method. Usually, this description tells the types of a method\u2019s\narguments, what it returns, and the general semantics of what it normally does. You are now\nbeing told, as well, what abnormal things it can do. This is a promise, just like the method\npromises to return a value of a certain type, and you can count on it when writing your code.\nThese new promises help to tease apart and make explicit all the places where exceptional\nconditions should be handled in your program, and that makes large-scale design easier.\nBecause exceptions are instances of classes, they can be put into a hierarchy that can naturally\ndescribe the relationships among the different types of exceptions. In fact, if you take a moment\nto glance in Appendix B at the diagrams for java.lang-errors and java.lang-exceptions, you\u2019ll\nsee that the class Throwable actually has two large hierarchies of classes beneath it. The roots of\nthese two hierarchies are subclasses of Throwable called Exception and Error. These hierarchies\nembody the rich set of relationships that exist between exceptions and errors in the Java run-time\nenvironment.\nWhen you know that a particular kind of error or exception can occur in your method, you are\nsupposed to either handle it yourself or explicitly warn potential callers about the possibility via\nthe throws clause. Not all errors and exceptions must be listed; instances of either class Error or\nRuntimeException (or any of their subclasses) do not have to be listed in your throws clause. They\nget special treatment because they can occur anywhere within a Java program and are usually\nconditions that you, as the programmer, did not directly cause. One good example is the\nOutOfMemoryError, which can happen anywhere, at any time, and for any number of reasons.\n343\n030-4s CH17.i 343 1\/29\/96, 11:19 AM\nP2\/V4\/SQC 4 TY Java in 21 Days 030-4 Casey 12.28.95 Ch17 LP#3 MTWRFSS\nDDAAYY\n17 Exceptions\nNote: You can, of course, choose to list these errors and run-time exceptions if you\nlike, and the callers of your methods will be forced to handle them, just like a non-\nrun-time exception.\nWhenever you see the word \u201cexception\u201d by itself, it almost always means \u201cexcep-\ntion or error\u201d (that is, an instance of Throwable). The previous discussion makes it\nclear that Exceptions and Errors actually form two separate hierarchies, but except\nfor the throws clause rule, they act exactly the same.\nIf you examine the diagrams in Appendix B more carefully, you\u2019ll notice that there are only five\ntypes of exceptions (in java.lang) that must be listed in a throws clause (remember that all\nErrors and RuntimeExceptions are exempt):\nnn\nClassNotFoundException\nnn\nIllegalAccessException\nnn\nInstantiationException\nnn\nInterrupedException\nnn\nNoSuchMethodException\nEach of these names suggests something that is explicitly caused by the programmer, not some\nbehind-the-scenes event such as OutOfMemoryError.\nIf you look further in Appendix B, near the bottom of the diagrams for java.util and java.io,\nyou\u2019ll see that each package adds some new exceptions. The former is adding two exceptions\nsomewhat akin to ArrayStoreException and IndexOutOfBoundsException, and so decides to\nplace them under RuntimeException. The latter is adding a whole new tree of IOExceptions,\nwhich are more explicitly caused by the programmer, and so they are rooted under Exception.\nThus, IOExceptions must be described in throws clauses. Finally, package java.awt defines one\nof each style, implicit and explicit.\nThe Java class library uses exceptions everywhere, and to good effect. If you examine the detailed\nAPI documentation in your Java release, you see that many of the methods in the library have\nthrows clauses, and some of them even document (when they believe it will make something\nclearer to the reader) when they may throw one of the implicit errors or exceptions. This is just\na nicety on the documenter\u2019s part, because you are not required to catch conditions like that.\nIf it wasn\u2019t obvious that such a condition could happen there, and for some reason you really\ncared about catching it, this would be useful information.\n344\n030-4s CH17.i 344 1\/29\/96, 11:19 AM\nP2\/V4\/SQC 4 TY Java in 21 Days 030-4 Casey 12.28.95 Ch17 LP#3 Sams.net Learning\nCenter\nabcd\nProgramming in the Small\nNow that you have a feeling for how exceptions can help you design a program and a class library\nbetter, how do you actually use exceptions? Let\u2019s try to use anExceptionalMethod() defined in\ntoday\u2019s first example:\npublic void anotherExceptionalMethod() throws MyFirstException {\nMyFirstExceptionalClass aMFEC = new MyFirstExceptionalClass();\naMFEC.anExceptionalMethod();\n}\nLet\u2019s examine this example more closely. If you assume that MyFirstException is a subclass of\nException, it means that if you don\u2019t handle it in anotherExceptionalMethod()\u2019s code, you must\nwarn your callers about it. Because your code simply calls anExceptionalMethod() without doing\n17\nanything about the fact that it may throw MyFirstException, you must add that exception to\nyour throws clause. This is perfectly legal, but it does defer to your caller something that perhaps\nyou should be responsible for doing yourself. (It depends on the circumstances, of course.)\nSuppose that that you feel responsible today and decide to handle the exception. Because you\u2019re\nnow declaring a method without a throws clause, you must \u201ccatch\u201d the expected exception and\ndo something useful with it:\npublic void responsibleMethod() {\nMyFirstExceptionalClass aMFEC = new MyFirstExceptionalClass();\ntry {\naMFEC.anExceptionalMethod();\n} catch (MyFirstException m) {\n. . . \/\/ do something terribly significant and responsible\n}\n}\nThe try statement says basically: \u201cTry running the code inside these braces, and if there are\nexceptions thrown, I will attach handlers to take care of them.\u201d (You first heard about these on\nDay 10.) You can have as many catch clauses at the end of a try as you need. Each allows you\nto handle any and all exceptions that are instances: of the class listed in parentheses, of any of\nits subclasses, or of a class that implements the interface listed in parentheses. In the catch in this\nexample, exceptions of the class MyFirstException (or any of its subclasses) are being handled.\nWhat if you want to combine both the approaches shown so far? You\u2019d like to handle the\nexception yourself, but also reflect it up to your caller. This can be done, by explicitly rethrowing\nthe exception:\npublic void responsibleExceptionalMethod() throws MyFirstException {\nMyFirstExceptionalClass aMFEC = new MyFirstExceptionalClass();\ntry {\naMFEC.anExceptionalMethod();\n345\n030-4s CH17.i 345 1\/29\/96, 11:19 AM\nP2\/V4\/SQC 4 TY Java in 21 Days 030-4 Casey 12.28.95 Ch17 LP#3 MTWRFSS\nDDAAYY\n17 Exceptions\n} catch (MyFirstException m) {\n. . . \/\/ do something responsible\nthrow m; \/\/ re-throw the exception\n}\n}\nThis works because exception handlers can be nested. You handle the exception by doing\nsomething responsible with it, but decide that it is too important to not give an exception\nhandler that might be in your caller a chance to handle it as well. Exceptions float all the way\nup the chain of method callers this way (usually not being handled by most of them) until at last,\nthe system itself handles any uncaught ones by aborting your program and printing an error\nmessage. In a stand-alone program, this is not such a bad idea; but in an applet, it can cause the\nbrowser to crash. Most browsers protect themselves from this disaster by catching all exceptions\nthemselves whenever they run an applet, but you can never tell. If it\u2019s possible for you to catch\nan exception and do something intelligent with it, you should.\nLet\u2019s see what throwing a new exception looks like. How about fleshing out today\u2019s first example:\npublic class MyFirstExceptionalClass {\npublic void anExceptionalMethod() throws MyFirstException {\n. . .\nif (someThingUnusualHasHappened()) {\nthrow new MyFirstException();\n\/\/ execution never reaches here\n}\n}\n}\nNote: throw is a little like a break statement\u2014nothing \u201cbeyond it\u201d is executed.\nThis is the fundamental way that all exceptions are generated; someone, somewhere, had to\ncreate an exception object and throw it. In fact, the whole hierarchy under the class Throwable\nwould be worth much less if there were not throw statements scattered throughout the code in\nthe Java library at just the right places. Because exceptions propagate up from any depth down\ninside methods, any method call you make might generate a plethora of possible errors and\nexceptions. Luckily, only the ones listed in the throws clause of that method need be thought\nabout; the rest travel silently past on their way to becoming an error message (or being caught\nand handled higher in the system).\nHere\u2019s an unusual demonstration of this, where the throw, and the handler that catches it, are\nvery close together:\nSystem.out.print(\u201cNow \u201c);\ntry {\nSystem.out.print(\u201cis \u201c);\nthrow new MyFirstException();\n346\n030-4s CH17.i 346 1\/29\/96, 11:20 AM\nP2\/V4\/SQC 4 TY Java in 21 Days 030-4 Casey 12.28.95 Ch17 LP#3 Sams.net Learning\nCenter\nabcd\nSystem.out.print(\u201ca \u201c);\n} catch (MyFirstException m) {\nSystem.out.print(\u201cthe \u201c);\n}\nSystem.out.print(\u201ctime.\u201d);\nIt prints out Now is the time.\nExceptions are really a quite powerful way of partitioning the space of all possible error\nconditions into manageable pieces. Because the first catch clause that matches is executed, you\ncan build chains such as the following:\ntry {\nsomeReallyExceptionalMethod();\n} catch (NullPointerException n) { \/\/ a subclass of RuntimeException\n. . .\n} catch (RuntimeException r) { \/\/ a subclass of Exception 17\n. . .\n} catch (IOException i) { \/\/ a subclass of Exception\n. . .\n} catch (MyFirstException m) { \/\/ our subclass of Exception\n. . .\n} catch (Exception e) { \/\/ a subclass of Throwable\n. . .\n} catch (Throwable t) {\n. . . \/\/ Errors, plus anything not caught above are caught here\n}\nBy listing subclasses before their parent classes, the parent catches anything it would normally\ncatch that\u2019s also not one of the subclasses above it. By juggling chains like these, you can express\nalmost any combination of tests. If there\u2019s some really obscure case you can\u2019t handle, perhaps\nyou can use an interface to catch it instead. That allows you to design your (peculiar) exceptions\nhierarchy using multiple inheritance. Catching an interface rather than a class can also be used\nto test for a property that many exceptions share but that cannot be expressed in the single-\ninheritance tree alone.\nSuppose, for example, that a scattered set of your exception classes require a reboot after being\nthrown. You create an interface called NeedsReboot, and all these classes implement the interface.\n(None of them needs to have a common parent exception class.) Then, the highest level of\nexception handler simply catches classes that implement NeedsReboot and performs a reboot:\npublic interface NeedsReboot { } \/\/ needs no contents at all\ntry {\nsomeMethodThatGeneratesExceptionsThatImplementNeedsReboot();\n} catch (NeedsReboot n) { \/\/ catch an interface\n. . . \/\/ cleanup\nSystemClass.reboot(); \/\/ reboot using a made-up system class\n}\nBy the way, if you need really unusual behavior during an exception, you can place the behavior\ninto the exception class itself! Remember that an exception is also a normal class, so it can contain\n347\n030-4s CH17.i 347 1\/29\/96, 11:20 AM\nP2\/V4\/SQC 4 TY Java in 21 Days 030-4 Casey 12.28.95 Ch17 LP#3 MTWRFSS\nDDAAYY\n17 Exceptions\ninstance variables and methods. Although using them is a little peculiar, it might be valuable on\na few bizarre occasions. Here\u2019s what this might look like:\ntry {\nsomeExceptionallyStrangeMethod();\n} catch (ComplexException e) {\nswitch (e.internalState()) { \/\/ probably an instance variable value\ncase e.COMPLEX_CASE: \/\/ a class variable of the exception\ne.performComplexBehavior(myState, theContext, etc);\nbreak;\n. . .\n}\n}\nThe Limitations Placed\non the Programmer\nAs powerful as all this sounds, isn\u2019t it a little limiting, too? For example, suppose you want to\noverride one of the standard methods of the Object class, toString(), to be smarter about how\nyou print yourself:\npublic class MyIllegalClass {\npublic String toString() {\nsomeReallyExceptionalMethod();\n. . . \/\/ returns some String\n}\n}\nBecause the superclass (Object) defined the method declaration for toString() without a throws\nclause, any implementation of it in any subclass must obey this restriction. In particular, you\ncannot just call someReallyExceptionalMethod(), as you did previously, because it will generate\na host of errors and exceptions, some of which are not exempt from being listed in a throws clause\n(such as IOException and MyFirstException). If all the exceptions thrown were exempt, you\nwould have no problem, but because some are not, you have to catch at least those few exceptions\nfor this to be legal Java:\npublic class MyLegalClass {\npublic String toString() {\ntry {\nsomeReallyExceptionalMethod();\n} catch (IOException e) {\n} catch (MyFirstException m) {\n}\n. . . \/\/ returns some String\n}\n}\nIn both cases, you elect to catch the exceptions and do absolutely nothing with them. Although\nthis is legal, it is not always the right thing to do. You may need to think for a while to come up\nwith the best, nontrivial behavior for any particular catch clause. This extra thought and care\n348\n030-4s CH17.i 348 1\/29\/96, 11:20 AM\nP2\/V4\/SQC 4 TY Java in 21 Days 030-4 Casey 12.28.95 Ch17 LP#3 Sams.net Learning\nCenter\nabcd\nmakes your program more robust, better able to handle unusual input, and more likely to work\ncorrectly when used by multiple threads (you\u2019ll see this tomorrow).\nMyIllegalClass\u2019s toString() method produces a compiler error to remind you to reflect on\nthese issues. This extra care will richly reward you as you reuse your classes in later projects and\nin larger and larger programs. Of course, the Java class library has been written with exactly this\ndegree of care, and that\u2019s one of the reasons it\u2019s robust enough to be used in constructing all your\nJava projects.\nThe finally Clause\nFinally, for finally. Suppose there is some action that you absolutely must do, no matter what\nhappens. Usually, this is to free some external resource after acquiring it, to close a file after 17\nopening it, or so forth. To be sure that \u201cno matter what\u201d includes exceptions as well, you use\na clause of the try statement designed for exactly this sort of thing, finally:\nSomeFileClass f = new SomeFileClass();\nif (f.open(\u201c\/a\/file\/name\/path\u201d)) {\ntry {\nsomeReallyExceptionalMethod();\n} finally {\nf.close();\n}\n}\nThis use of finally behaves very much like the following:\nSomeFileClass f = new SomeFileClass();\nif (f.open(\u201c\/a\/file\/name\/path\u201d)) {\ntry {\nsomeReallyExceptionalMethod();\n} catch (Throwable t) {\nf.close();\nthrow t;\n}\n}\nexcept that finally can also be used to clean up not only after exceptions but after return, break,\nand continue statements as well. Here\u2019s a complex demonstration:\npublic class MyFinalExceptionalClass extends ContextClass {\npublic static void main(String argv[]) {\nint mysteriousState = getContext();\nwhile (true) {\nSystem.out.print(\u201cWho \u201c);\ntry {\nSystem.out.print(\u201cis \u201c);\nif (mysteriousState == 1)\n349\n030-4s CH17.i 349 1\/29\/96, 11:21 AM\nP2\/V4\/SQC 4 TY Java in 21 Days 030-4 Casey 12.28.95 Ch17 LP#3 MTWRFSS\nDDAAYY\n17 Exceptions\nreturn;\nSystem.out.print(\u201cthat \u201c);\nif (mysteriousState == 2)\nbreak;\nSystem.out.print(\u201cstrange \u201c);\nif (mysteriousState == 3)\ncontinue;\nSystem.out.print(\u201cbut kindly \u201c);\nif (mysteriousState == 4)\nthrow new UncaughtException();\nSystem.out.print(\u201cnot at all \u201c);\n} finally {\nSystem.out.print(\u201camusing \u201c);\n}\nSystem.out.print(\u201cyet compelling \u201c);\n}\nSystem.out.print(\u201cman?\u201d);\n}\n}\nHere is the output produced depending on the value of mysteriousState:\n1 Who is amusing\n2 Who is that amusing man?\n3 Who is that strange amusing Who is that strange amusing . . .\n4 Who is that strange but kindly amusing\n5 Who is that strange but kindly not at all amusing yet compelling man?\nNote: In case 3, the output never ends until you press Ctrl+C. In 4, an error\nmessage generated by the UncaughtException is also printed.\nSummary\nToday, you learned about how exceptions aid your program\u2019s design, robustness, and\nmultithreading capability (more on this tomorrow).\nYou also learned about the vast array of exceptions defined and thrown in the Java class library,\nand how to try methods while catch-ing any of a hierarchically ordered set of possible exceptions\nand errors. Java\u2019s reliance on strict exception handling does place some restrictions on the\nprogrammer, but you learned that these restrictions are light compared to the rewards.\nFinally, the finally clause was discussed, which provides a fool-proof way to be certain that\nsomething is accomplished, no matter what.\n350\n030-4s CH17.i 350 1\/29\/96, 11:21 AM\nP2\/V4\/SQC 4 TY Java in 21 Days 030-4 Casey 12.28.95 Ch17 LP#3 Sams.net Learning\nCenter\nabcd\nQ&A\nQ I\u2019d like to test the last example you gave, but where does getContext() come\nfrom?\nA That example wasn\u2019t meant to be an executable program as it stands, but you can turn\nit into one as follows. First, remove the clause extends ContextClass from line one.\nThen, replace getContext() in the third line with\nInteger.parseInt(args[0]). You can now compile, then run, the example via the\nfollowing:\njava MyFinalExceptionClass N\nwhere N is the mysterious state you want.\nQ I\u2019m still not sure I understand the differences between Exceptions, Errors, and 17\nRuntimeExceptions. Is there another way of looking at them?\nA Errors are caused by dynamic linking, or virtual machine problems, and are thus too\nlow-level for most programs to care about (although sophisticated development\nlibraries and environments probably care a great deal about them).\nRuntimeExceptions are generated by the normal execution of Java code, and though\nthey occasionally reflect a condition you will want to handle explicitly, more often\nthey reflect a coding mistake by the programmer and simply need to print an error to\nhelp flag that mistake. Exceptions that are not RuntimeExceptions (IOExceptions, for\nexample) are conditions that, because of their nature, should be explicitly handled by\nany robust and well-thought-out code. The Java class library has been written using\nonly a few of these, but they are extremely important to using the system safely and\ncorrectly. The compiler helps you handle these exceptions properly via its throws\nclause checks and restrictions.\nQ Is there any way to \u201cget around\u201d the strict restrictions placed on methods by the\nthrows clause?\nA Yes. Suppose you thought long and hard and have decided that you need to circum-\nvent this restriction. This is almost never the case, because the right solution is to go\nback and redesign your methods to reflect the exceptions that you need to throw.\nImagine, however, that for some reason a system class has you in a straitjacket. Your\nfirst solution is to subclass RuntimeException to make up a new, exempt exception of\nyour own. Now you can throw it to your heart\u2019s content, because the throws clause\nthat was annoying you does not need to include this new exception. If you need a lot\nof such exceptions, an elegant approach is to mix in some novel exception interfaces to\nyour new Runtime classes. You\u2019re free to choose whatever subset of these new interfaces\nyou want to catch (none of the normal Runtime exceptions need be caught), while any\nleftover (new) Runtime exceptions are (legally) allowed to go through that otherwise\nannoying standard method in the library.\n351\n030-4s CH17.i 351 1\/29\/96, 11:22 AM\nP2\/V4\/SQC 4 TY Java in 21 Days 030-4 Casey 12.28.95 Ch17 LP#3 MTWRFSS\nDDAAYY\n17 Exceptions\nQ I\u2019m still a little confused by long chains of catch clauses. Can you label the\nprevious example with which exceptions are handled by each line of code?\nA Certainly, here it is:\ntry {\nsomeReallyExceptionalMethod();\n} catch (NullPointerException n) {\n. . . \/\/ handles NullPointerExceptions\n} catch (RuntimeException r) {\n. . . \/\/ handles RuntimeExceptions that are not NullPointerExceptions\n} catch (IOException i) {\n. . . \/\/ handles IOExceptions\n} catch (MyFirstException m) {\n. . . \/\/ handles MyFirstExceptions\n} catch (Exception e) { \/\/ handles Exceptions that are not RuntimeExceptions\n. . . \/\/ nor IOExceptions nor MyFirstExceptions\n} catch (Throwable t) {\n. . . \/\/ handles Throwables that are not Exceptions (i.e., Errors)\n}\nQ Given how annoying it can sometimes be to handle exceptional conditions\nproperly, what\u2019s stopping me from surrounding any method with a throws clause\nas follows:\ntry { thatAnnoyingMethod(); } catch (Throwable t) { }\nand simply ignoring all exceptions?\nA Nothing, other than your own conscience. In some cases, you should do nothing,\nbecause it is the correct thing to do for your method\u2019s implementation. Otherwise,\nyou should struggle through the annoyance and gain experience. Good style is a\nstruggle even for the best programmer, but the rewards are rich indeed.\n352\n030-4s CH17.i 352 1\/29\/96, 11:22 AM\nP2\/V4\/SQC 4 TY Java in 21 Days 030-4 Casey 12.28.95 Ch17 LP#3 Sams.net Learning\nCenter\nabcd\n18\n18\nS\nS\nWEEK\n18\nF 3\nR\nW\nMultithreading\nT\nM\nby Charles L. Perkins\n353\n030-4s CH18.i 353 1\/29\/96, 11:46 AM\nP2\/V4\/SQC5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch 18 LP#3 MTWRFSS\nDDAAYY\n18 Multithreading\nToday, you\u2019ll learn more about the threads mentioned briefly in Week 2:\nnn How to \u201cthink multithreaded\u201d\nnn How to protect your methods and variables from unintended thread conflicts\nnn How to create, start, and stop threads and threaded classes\nnn How the scheduler works in Java\nFirst, let\u2019s begin by motivating the need for threads.\nThreads are a relatively recent invention in the computer science world. Although processes,\ntheir larger parent, have been around for decades, threads have only recently been accepted into\nthe mainstream. What\u2019s odd about this is that they are very valuable, and programs written with\nthem are noticeably better, even to the casual user. In fact, some of the best individual, Herculean\nefforts over the years have involved implementing a threads-like facility by hand to give a\nprogram a more friendly feel to its users.\nImagine that you\u2019re using your favorite text editor on a large file. When it starts up, does it need\nto examine the entire file before it lets you edit? Does it need to make a copy of the file? If the\nfile is huge, this can be a nightmare. Wouldn\u2019t it be nicer for it to show you the first page, enabling\nyou to begin editing, and somehow (in the background) complete the slower tasks necessary for\ninitialization? Threads allow exactly this kind of within-the-program parallelism.\nPerhaps the best example of threading (or lack of it) is a WWW browser. Can your browser\ndownload an indefinite number of files and Web pages at once while still enabling you to\ncontinue browsing? While these pages are downloading, can your browser download all the\npictures, sounds, and so forth in parallel, interleaving the fast and slow download times of\nmultiple Internet servers? HotJava can do all of these things\u2014and more\u2014by using the built-\nin threading of the Java language.\nThe Problem with Parallelism\nIf threading is so wonderful, why doesn\u2019t every system have it? Many modern operating systems\nhave the basic primitives needed to create and run threads, but they are missing a key ingredient.\nThe rest of their environment is not thread-safe. Imagine that you are in a thread, one of many,\nand each of you is sharing some important data managed by the system. If you were managing\nthat data, you could take steps to protect it (as you\u2019ll see later today), but the system is managing\nit. Now visualize a piece of code in the system that reads some crucial value, thinks about it for\na while, and then adds 1 to the value:\nif (crucialValue > 0) {\n. . . \/\/ think about what to do\ncrucialValue += 1;\n}\n354\n030-4s CH18.i 354 1\/29\/96, 11:47 AM\nP2\/V4\/SQC5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch 18 LP#3 Sams.net Learning\nCenter\nabcd\nRemember that any number of threads may be calling upon this part of the system at once. The\ndisaster occurs when two threads have both executed the if test before either has incremented\nthe crucialValue. In that case, the value is clobbered by them both with the same crucialValue\n+ 1, and one of the increments has been lost. This may not seem so bad to you, but imagine\ninstead that the crucial value affects the state of the screen as it is being displayed. Now,\nunfortunate ordering of the threads can cause the screen to be updated incorrectly. In the same\nway, mouse or keyboard events can be lost, databases can be inaccurately updated, and so forth.\nThis disaster is inescapable if any significant part of the system has not been written with threads\nin mind. Therein lies the barrier to a mainstream threaded environment\u2014the large effort\nrequired to rewrite existing libraries for thread safety. Luckily, Java was written from scratch with\nthis is mind, and every Java class in its library is thread-safe. Thus, you now have to worry only\nabout your own synchronization and thread-ordering problems, because you can assume that\nthe Java system will do the right thing.\nNEW* Atomic operations are operations that appear to happen \u201call at once\u201d\u2014exactly\nTERM at the same time\u2014to other threads.\n18\nNote: Some readers may wonder what the fundamental problem really is. Can\u2019t\nyou just make the \u2026 area in the example smaller and smaller to reduce or eliminate\nthe problem? Without atomic operations, the answer is no. Even if the\n\u2026 took zero time, you must first look at the value of some variable to make any\ndecision and then change something to reflect that decision. These two steps can\nnever be made to happen at the same time without an atomic operation. Unless\nyou\u2019re given one by the system, it\u2019s literally impossible to create your own.\nEven the one line crucialValue += 1 involves three steps: get the current value, add\none to it, and store it back. (Using ++crucialValue doesn\u2019t help either.) All three\nsteps need to happen \u201call at once\u201d (atomically) to be safe. Special Java primitives, at\nthe lowest levels of the language, provide you with the basic atomic operations you\nneed to build safe, threaded programs.\nThinking Multithreaded\nGetting used to threads takes a little while and a new way of thinking. Rather than imagining\nthat you always know exactly what\u2019s happening when you look at a method you\u2019ve written, you\nhave to ask yourself some additional questions. What will happen if more than one thread calls\n355\n030-4s CH18.i 355 1\/29\/96, 11:47 AM\nP2\/V4\/SQC5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch 18 LP#3 MTWRFSS\nDDAAYY\n18 Multithreading\ninto this method at the same time? Do you need to protect it in some way? What about your\nclass as a whole? Are you assuming that only one of its methods is running at the same time?\nOften you make such assumptions, and a local instance variable will be messed up as a result.\nLet\u2019s make a few mistakes and then try to correct them. First, the simplest case:\npublic class ThreadCounter {\nint crucialValue;\npublic void countMe() {\ncrucialValue += 1;\n}\npublic int howMany() {\nreturn crucialValue;\n}\n}\nThis code suffers from the most pure form of the \u201csynchronization problem:\u201d the += takes more\nthan one step, and you may miscount the number of threads as a result. (Don\u2019t worry about how\nthreads are created yet, just imagine that a whole bunch of them are able to call countMe(), at\nonce, at slightly different times.) Java allows you to fix this:\npublic class SafeThreadCounter {\nint crucialValue;\npublic synchronized void countMe() {\ncrucialValue += 1;\n}\npublic int howMany() {\nreturn crucialValue;\n}\n}\nThe synchronized keyword tells Java to make the block of code in the method thread safe. Only\none thread will be allowed inside this method at once, and others have to wait until the currently\nrunning thread is finished with it before they can begin running it. This implies that\nsynchronizing a large, long-running method is almost always a bad idea. All your threads would\nend up stuck at this bottleneck, waiting in single file to get their turn at this one slow method.\nIt\u2019s even worse than you might think for most unsynchronized variables. Because the compiler\ncan keep them around in registers during computations, and a thread\u2019s registers can\u2019t be seen\nby other threads (especially if they\u2019re on another processor in a true multiprocessor computer),\na variable can be updated in such a way that no possible order of thread updates could have\nproduced the result. This is completely incomprehensible to the programmer. To avoid this\nbizarre case, you can label a variable volatile, meaning that you know it will be updated\nasynchronously by multiprocessor-like threads. Java then loads and stores it each time it\u2019s\nneeded and does not use registers.\n356\n030-4s CH18.i 356 1\/29\/96, 11:48 AM\nP2\/V4\/SQC5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch 18 LP#3 Sams.net Learning\nCenter\nabcd\nNote: In earlier releases, variables that were safe from these bizarre effects were\nlabeled threadsafe. Because most variables are safe to use, however, they are now\nassumed to be thread-safe unless you mark them volatile. Using volatile is an\nextremely rare event. In fact, in the beta release, the Java library does not use\nvolatile anywhere.\nPoints About Points\nThe method howMany() in the last example doesn\u2019t need to be synchronized, because it simply\nreturns the current value of an instance variable. Someone higher in the call chain may need to\nbe synchronized, though\u2014someone who uses the value returned from the method. Here\u2019s an\nexample:\npublic class Point {\nprivate float x, y;\npublic float x() { \/\/ needs no synchronization 18\nreturn x;\n}\npublic float y() { \/\/ ditto\nreturn y;\n}\n. . . \/\/ methods to set and change x and y\n}\npublic class UnsafePointPrinter {\npublic void print(Point p) {\nSystem.out.println(\u201cThe point\u2019s x is \u201c + p.x()\n+ \u201c and y is \u201c + p.y() + \u201c.\u201d);\n}\n}\nThe analogous methods to howMany() are x() and y(). They need no synchronization, because\nthey just return the values of instance variables. It is the responsibility of the caller of x() and\ny() to decide whether it needs to synchronize itself\u2014and in this case, it does. Although the\nmethod print() simply reads values and prints them out, it reads two values. This means that\nthere is a chance that some other thread, running between the call to p.x() and the call to p.y(),\ncould have changed the value of x and y stored inside the Point p. Remember, you don\u2019t know\nhow many other threads have a way to reach and call methods in this Point object! \u201cThinking\nmultithreaded\u201d comes down to being careful any time you make an assumption that something\nhas not happened between two parts of your program (even two parts of the same line, or the\nsame expression, such as the string + expression in this example).\n357\n030-4s CH18.i 357 1\/29\/96, 11:49 AM\nP2\/V4\/SQC5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch 18 LP#3 MTWRFSS\nDDAAYY\n18 Multithreading\nTryAgainPointPrinter\nYou could try to make a safe version of print() by simply adding the synchronized keyword\nmodifier to it, but instead, let\u2019s try a slightly different approach:\npublic class TryAgainPointPrinter {\npublic void print(Point p) {\nfloat safeX, safeY;\nsynchronized(this) {\nsafeX = p.x(); \/\/ these two lines now\nsafeY = p.y(); \/\/ happen atomically\n}\nSystem.out.print(\u201cThe point\u2019s x is \u201c + safeX\n+ \u201c y is \u201c + safeY);\n}\n}\nThe synchronized statement takes an argument that says what object you would like to lock to\nprevent more than one thread from executing the enclosed block of code at the same time. Here,\nyou use this (the instance itself), which is exactly the object that would have been locked by the\nsynchronized method as a whole if you had changed print() to be like your safe countMe()\nmethod. You have an added bonus with this new form of synchronization: you can specify\nexactly what part of a method needs to be safe, and the rest can be left unsafe.\nNotice how you took advantage of this freedom to make the protected part of the method as\nsmall as possible, while leaving the String creations, concatenations, and printing (which\ntogether take a small but nonzero amount of time) outside the \u201cprotected\u201d area. This is both\ngood style (as a guide to the reader of your code) and more efficient, because fewer threads get\nstuck waiting to get into protected areas.\nSafePointPrinter\nThe astute reader, though, may still be worried by the last example. It seems as if you made sure\nthat no one executes your calls to x() and y() out of order, but have you prevented the Point p\nfrom changing out from under you? The answer is no, you still have not solved the problem. You\nreally do need the full power of the synchronized statement:\npublic class SafePointPrinter {\npublic void print(Point p) {\nfloat safeX, safeY;\nsynchronized(p) { \/\/ no one can change p\nsafeX = p.x(); \/\/ while these two lines\nsafeY = p.y(); \/\/ are happening atomically\n}\nSystem.out.print(\u201cThe point\u2019s x is \u201c + safeX\n+ \u201c y is \u201c + safeY);\n}\n}\n358\n030-4s CH18.i 358 1\/29\/96, 11:49 AM\nP2\/V4\/SQC5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch 18 LP#3 Sams.net Learning\nCenter\nabcd\nNow you\u2019ve got it. You actually needed to protect the Point p to protect from changes, so you\nlock it by giving it as the argument to your synchronized statement. Now when x() and y()\nhappen together, they can be sure to get the current x and y of the Point p, without any other\nthread being able to call a modifying method between. You\u2019re still assuming, however, that the\nPoint p has properly protected itself. (You can always assume this about system classes\u2014but you\nwrote this Point class.) You can make sure by writing the only method that can change x and\ny inside p yourself:\npublic class Point {\nprivate float x, y;\n. . . \/\/ the x() and y() methods\npublic synchronized void setXAndY(float newX, float newY) {\nx = newX;\ny = newY;\n}\n}\nBy making the only \u201cset\u201d method in Point synchronized, you guarantee that any other thread\ntrying to grab the Point p and change it out from under you has to wait: you\u2019ve locked the Point\np with your synchronized(p) statement, and any other thread has to try to lock the same Point 18\np via the implicit synchronized(this) statement p now executes when entering setXAndY().\nThus, at last, you are thread-safe.\nNote: By the way, if Java had some way of returning more than one value at once,\nyou could write a synchronized getXAndY() method for Points that returns both\nvalues safely. In the current Java language, such a method could return a new,\nunique Point to guarantee to its callers that no one else has a copy that might be\nchanged. This sort of trick can be used to minimize the parts of the system that\nneed to worry about synchronization.\nReallySafePoint\nAn added benefit of the use of the synchronized modifier on methods (or of synchronized(this)\n{. . .}) is that only one of these methods (or blocks of code) can run at once. You can use that\nknowledge to guarantee that only one of several crucial methods in a class will run at once:\npublic class ReallySafePoint {\nprivate float x, y;\npublic synchronized Point getUniquePoint() {\nreturn new Point(x, y); \/\/ can be a less safe Point\n} \/\/ because only the caller has it\n359\n030-4s CH18.i 359 1\/29\/96, 11:50 AM\nP2\/V4\/SQC5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch 18 LP#3 MTWRFSS\nDDAAYY\n18 Multithreading\npublic synchronized void setXAndY(float newX, float newY) {\nx = newX;\ny = newY;\n}\npublic synchronized void scale(float scaleX, float scaleY) {\nx *= scaleX;\ny *= scaleY;\n}\npublic synchronized void add(ReallySafePoint aRSP) {\nPoint p = aRSP.getUniquePoint();\nx += p.x();\ny += p.y();\n} \/\/ Point p is soon thrown away by GC; no one else ever saw it\n}\nThis example combines several of the ideas mentioned previously. To avoid a caller\u2019s having to\nsynchronize(p) whenever getting your x and y, you give them a synchronized way to get a\nunique Point (like returning multiple values). Each method that modifies the object\u2019s instance\nvariables is also synchronized to prevent it from running between the x and y references in\ngetUniquePoint() and from stepping on the others as they each modify the local x and y. Note\nthat add() itself uses getUniquePoint() to avoid having to say synchronized(aRSP).\nClasses that are this safe are a little unusual; it is more often your responsibility to protect yourself\nfrom other threads\u2019 use of commonly held objects (such as Points). Only when you know for\ncertain that you\u2019re the only one that knows about an object, can you fully relax. Of course, if\nyou created the object and gave it to no one else, you can be that certain.\nProtecting a Class Variable\nFinally, suppose you want a class variable to collect some information across all a class\u2019s instances:\npublic class StaticCounter {\nprivate static int crucialValue;\npublic synchronized void countMe() {\ncrucialValue += 1;\n}\n}\nIs this safe? If crucialValue were an instance variable, it would be. Because it\u2019s a class variable,\nhowever, and there is only one copy of it for all instances, you can still have multiple threads\nmodifying it by using different instances of the class. (Remember, the synchronized modifier\nlocks the object this\u2014an instance.) Luckily, you already know the tools you need to solve this:\npublic class StaticCounter {\nprivate static int crucialValue;\n360\n030-4s CH18.i 360 1\/29\/96, 11:51 AM\nP2\/V4\/SQC5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch 18 LP#3 Sams.net Learning\nCenter\nabcd\npublic void countMe() {\nsynchronized(getClass()) { \/\/ can\u2019t directly reference StaticCounter\ncrucialValue += 1; \/\/ the (shared) class is now locked\n}\n}\n}\nThe trick is to \u201clock\u201d on a different object\u2014not on an instance of the class, but on the class itself.\nBecause a class variable is \u201cinside\u201d a class, just as an instance variable is inside an instance, this\nshouldn\u2019t be all that unexpected. In a similar way, classes can provide global resources that any\ninstance (or other class) can access directly by using the class name, and lock by using that same\nclass name. In this example, crucialValue is used from within an instance of StaticCounter, but\nif crucialValue were declared public instead, from anywhere in the program, it would be safe\nto say the following:\nsynchronized(new StaticCounter().getClass()) {\nStaticCounter.crucialValue += 1;\n}\nNote: The direct use of another object\u2019s variable is really bad style\u2014it\u2019s used here\n18\nsimply to demonstrate a point quickly. StaticCounter normally provides a\ncountMe()-like class method of its own to do this sort of dirty work.\nYou can appreciate how much work the Java team has done for you by thinking all these hard\nthoughts for each and every class (and method!) in the Java class library.\nCreating and Using Threads\nNow that you understand the power (and the dangers) of having many threads running at once,\nhow are those threads actually created?\n!\nWarning: The system itself always has a few so-called daemon threads running, one\n!\nof which is constantly doing the tedious task of garbage collection for you in the\nbackground. There is also a main user thread that listens for events from your\nmouse and keyboard. If you\u2019re not careful, you can sometimes lock out this main\nthread. If you do, no events are sent to your program and it appears to be dead. A\ngood rule of thumb is that whenever you\u2019re doing something that can be done in a\nseparate thread, it probably should be. Threads in Java are relatively cheap to create,\nrun, and destroy, so don\u2019t use them too sparingly.\n361\n030-4s CH18.i 361 1\/29\/96, 11:51 AM\nP2\/V4\/SQC5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch 18 LP#3 MTWRFSS\nDDAAYY\n18 Multithreading\nBecause there is a class java.lang.Thread, you might guess that you could create a thread of your\nown by subclassing it\u2014and you are right:\npublic class MyFirstThread extends Thread { \/\/ a.k.a., java.lang.Thread\npublic void run() {\n. . . \/\/ do something useful\n}\n}\nYou now have a new type of Thread called MyFirstThread, which does something useful\n(unspecified) when its run() method is called. Of course, no one has created this thread or called\nits run() method, so it does absolutely nothing at the moment. To actually create and run an\ninstance of your new thread class, you write the following:\nMyFirstThread aMFT = new MyFirstThread();\naMFT.start(); \/\/ calls our run() method\nWhat could be simpler? You create a new instance of your thread class and then ask it to start\nrunning. Whenever you want to stop the thread, you use this:\naMFT.stop();\nBesides responding to start() and stop(), a thread can also be temporarily suspended and later\nresumed:\nThread t = new Thread();\nt.suspend();\n. . . \/\/ do something special while t isn\u2019t running\nt.resume();\nA thread will automatically suspend() and then resume() when it\u2019s first blocked at a synchro-\nnized point and then later unblocked (when it\u2019s that thread\u2019s \u201cturn\u201d to run).\nThe Runnable Interface\nThis is all well and good if every time you want to create a Thread you have the luxury of being\nable to place it under the Thread class in the single-inheritance class tree. What if it more naturally\nbelongs under some other class, from which it needs to get most of its implementation? The\ninterfaces of Day 16 come to the rescue:\npublic class MySecondThread extends ImportantClass implements Runnable {\npublic void run() {\n. . . \/\/ do something useful\n}\n}\nBy implementing the interface Runnable, you declare your intention to run in a separate thread.\nIn fact, the class Thread itself implements this interface, as you might expect from the design\ndiscussions on Day 16. As you also might guess from the example, the interface Runnable\n362\n030-4s CH18.i 362 1\/29\/96, 11:52 AM\nP2\/V4\/SQC5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch 18 LP#3 Sams.net Learning\nCenter\nabcd\nspecifies only one method: run(). As in MyFirstThread, you expect someone to create an instance\nof a thread and somehow call your run() method. Here\u2019s how this is accomplished:\nMySecondThread aMST = new MySecondThread();\nThread aThread = new Thread(aMST);\naThread.start(); \/\/ calls our run() method, indirectly\nFirst, you create an instance of MySecondThread. Then, by passing this instance to the constructor\nmaking the new Thread, you make it the target of that Thread. Whenever that new Thread starts\nup, its run() method calls the run() method of the target it was given (assumed by the Thread\nto be an object that implements the Runnable interface). When start() is called, aThread\n(indirectly) calls your run() method. You can stop aThread with stop(). If you don\u2019t need to talk\nto the Thread explicitly or to the instance of MySecondThread, here\u2019s a one line shortcut:\nnew Thread(new MySecondThread()).start();\nNote: As you can see, the class name, MySecondThread, is a bit of a misnomer\u2014it\ndoes not descend from Thread, nor is it actually the thread that you start() and\n18\nstop(). It probably should have been called MySecondThreadedClass or\nImportantRunnableClass.\nThreadTester\nHere\u2019s a longer example:\npublic class SimpleRunnable implements Runnable {\npublic void run() {\nSystem.out.println(\u201cin thread named \u2018\u201c\n+ Thread.currentThread().getName() + \u201c\u2018\u201c);\n} \/\/ any other methods run() calls are in current thread as well\n}\npublic class ThreadTester {\npublic static void main(String argv[]) {\nSimpleRunnable aSR = new SimpleRunnable();\nwhile (true) {\nThread t = new Thread(aSR);\nSystem.out.println(\u201cnew Thread() \u201c + (t == null ?\n\u201cfail\u201d : \u201csucceed\u201d) + \u201ced.\u201d);\nt.start();\ntry { t.join(); } catch (InterruptedException ignored) { }\n\/\/ waits for thread to finish its run() method\n}\n}\n}\n363\n030-4s CH18.i 363 1\/29\/96, 11:53 AM\nP2\/V4\/SQC5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch 18 LP#3 MTWRFSS\nDDAAYY\n18 Multithreading\nNote: You may be worried that only one instance of the class SimpleRunnable is\ncreated, but many new Threads are using it. Don\u2019t they get confused? Remember to\nseparate in your mind the aSR instance (and the methods it understands) from the\nvarious threads of execution that can pass through it. aSR\u2019s methods provide a\ntemplate for execution, and the multiple threads created are sharing that template.\nEach remembers where it is executing and whatever else it needs to make it distinct\nfrom the other running threads. They all share the same instance and the same\nmethods. That\u2019s why you need to be so careful, when adding synchronization, to\nimagine numerous threads running rampant over each of your methods.\nThe class method currentThread() can be called to get the thread in which a method is currently\nexecuting. If the SimpleRunnable class were a subclass of Thread, its methods would know the\nanswer already (it is the thread running). Because SimpleRunnable simply implements the\ninterface Runnable, however, and counts on someone else (ThreadTester\u2019s main()) to create the\nthread, its run() method needs another way to get its hands on that thread. Often, you\u2019ll be deep\ninside methods called by your run() method when suddenly you need to get the current thread.\nThe class method shown in the example works, no matter where you are.\n!\n! Warning: You can do some reasonably disastrous things with your knowledge of\nthreads. For example, if you\u2019re running in the main thread of the system and,\nbecause you think you are in a different thread, you accidentally say the following:\nThread.currentThread().stop();\nit has unfortunate consequences for your (soon-to-be-dead) program!\nThe example then calls on getName(), the current thread to get the thread\u2019s name (usually\nsomething helpful, such as Thread-23) so it can tell the world in which thread run() is running.\nThe final thing to note is the use of the method join(), which, when sent to a thread, means\n\u201cI\u2019m planning to wait forever for you to finish your run() method.\u201d You don\u2019t want to do this\nlightly: if you have anything else important you need to get done in your thread any time soon,\nyou can\u2019t count on how long the join()ed thread may take to finish. In the example, its run()\nmethod is short and finishes quickly, so each loop can safely wait for the previous thread to die\nbefore creating the next one. (Of course, in this example, you didn\u2019t have anything else you\nwanted to do while waiting for join() anyway.) Here\u2019s the output produced:\nnew Thread() succeeded.\n364\n030-4s CH18.i 364 1\/29\/96, 11:53 AM\nP2\/V4\/SQC5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch 18 LP#3 Sams.net Learning\nCenter\nabcd\nin thread named \u2018Thread-1\u2019\nnew Thread() succeeded.\nin thread named \u2018Thread-2\u2019\nnew Thread() succeeded.\nin thread named \u2018Thread-3\u2019\n^C\nCtrl+C was pressed to interrupt the program, because it otherwise would continue forever.\nNamedThreadTester\nIf you want your threads to have particular names, you can assign them yourself by using a two-\nargument form of Thread\u2019s constructor:\npublic class NamedThreadTester {\npublic static void main(String argv[]) {\nSimpleRunnable aSR = new SimpleRunnable();\nfor (int i = 1; true; ++i) {\nThread t = new Thread(aSR, \u201c\u201d + (100 - i)\n+ \u201c threads on the wall...\u201d);\nSystem.out.println(\u201cnew Thread() \u201c + (t == null ? 18\n\u201cfail\u201d : \u201csucceed\u201d) + \u201ced.\u201d);\nt.start();\ntry { t.join(); } catch (InterruptedException ignored) { }\n}\n}\n}\nwhich takes a target object, as before, and a String, which names the new thread. Here\u2019s the\noutput:\nnew Thread() succeeded.\nin thread named \u201999 threads on the wall...\u2019\nnew Thread() succeeded.\nin thread named \u201998 threads on the wall...\u2019\nnew Thread() succeeded.\nin thread named \u201997 threads on the wall...\u2019\n^C\nNaming a thread is one easy way to pass it some information. This information flows from the\nparent thread to its new child. It\u2019s also useful, for debugging purposes, to give threads meaningful\nnames (such as network input) so that when they appear during an error\u2014in a stack trace, for\nexample\u2014you can easily identify which thread caused the problem. You might also think of\nusing names to help group or organize your threads, but Java actually provides you with a\nThreadGroup class to perform this function. A ThreadGroup allows you to group threads, to\ncontrol them all as a unit, and to keep them from being able to affect other threads (useful for\nsecurity).\n365\n030-4s CH18.i 365 1\/29\/96, 11:54 AM\nP2\/V4\/SQC5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch 18 LP#3 MTWRFSS\nDDAAYY\n18 Multithreading\nKnowing When a Thread has Stopped\nLet\u2019s imagine a different version of the last example, one that creates a thread and then hands\nthe thread off to other parts of the program. Suppose it would then like to know when that thread\ndies so that it can perform some cleanup operation. If SimpleRunnable were a subclass of Thread,\nyou might try to catch stop() whenever it\u2019s sent\u2014but look at Thread\u2019s declaration of the stop()\nmethod:\npublic final void stop(); { . . . }\nThe final here means that you can\u2019t override this method in a subclass. In any case,\nSimpleRunnable is not a subclass of Thread, so how can this imagined example possibly catch the\ndeath of its thread? The answer is to use the following magic:\npublic class SingleThreadTester {\npublic static void main(String argv[]) {\nThread t = new Thread(new SimpleRunnable());\ntry {\nt.start();\nsomeMethodThatMightStopTheThread(t);\n} catch (ThreadDeath aTD) {\n. . . \/\/ do some required cleanup\nthrow aTD; \/\/ re-throw the error\n}\n}\n}\nYou understand most of this magic from yesterday\u2019s lesson. All you need to know is that if the\nthread created in the example dies, it throws an error of class ThreadDeath. The code catches that\nerror and performs the required cleanup. It then rethrows the error, allowing the thread to die.\nThe cleanup code is not called if the thread exits normally (its run() method completes), but\nthat\u2019s fine; you posited that the cleanup was needed only when stop() was used on the thread.\nNote: Threads can die in other ways\u2014for example, by throwing exceptions that no\none catches. In these cases, stop() is never called, and the previous code is not\nsufficient. (If the cleanup always has to occur, even at the normal end of a thread\u2019s\nlife, you can put it in a finally clause.) Because unexpected exceptions can come\nout of nowhere to kill a thread, multithreaded programs that carefully catch and\nhandle all their exceptions are more predictable, robust, and easier to debug.\n366\n030-4s CH18.i 366 1\/29\/96, 11:55 AM\nP2\/V4\/SQC5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch 18 LP#3 Sams.net Learning\nCenter\nabcd\nThread Scheduling\nYou might wonder exactly what order your threads will be run in, and how you can control that\norder. Unfortunately, the current implementations of the Java system cannot precisely answer\nthe former, though with a lot of work, you can always do the latter.\nNEW* The part of the system that decides the real-time ordering of threads is called the\nTERM scheduler.\nPreemptive Versus Nonpreemptive\nNormally, any scheduler has two fundamentally different ways of looking at its job: non-\npreemptive scheduling and preemptive time-slicing.\nNEW* With non-preemptive scheduling, the scheduler runs the current thread forever,\nTERM requiring that thread explicitly to tell it when it is safe to start a different thread.\nWith preemptive time-slicing, the scheduler runs the current thread until it has used up a certain\ntiny fraction of a second, and then \u201cpreempts\u201d it, suspend()s it, and resume()s another thread\nfor the next tiny fraction of a second. 18\nNon-preemptive scheduling is very courtly, always asking for permission to schedule, and is\nquite valuable in extremely time-critical, real-time applications where being interrupted at the\nwrong moment, or for too long, could mean crashing an airplane.\nMost modern schedulers use preemptive time-slicing, because, except for a few time-critical\ncases, it has turned out to make writing multithreaded programs much easier. For one thing, it\ndoes not force each thread to decide exactly when it should \u201cyield\u201d control to another thread.\nInstead, every thread can just run blindly on, knowing that the scheduler will be fair about giving\nall the other threads their chance to run.\nIt turns out that this approach is still not the ideal way to schedule threads. You\u2019ve given a little\ntoo much control to the scheduler. The final touch many modern schedulers add is to allow you\nto assign each thread a priority. This creates a total ordering of all threads, making some threads\nmore \u201cimportant\u201d than others. Being higher priority often means that a thread gets run more\noften (or gets more total running time), but it always means that it can interrupt other, lower-\npriority threads, even before their \u201ctime-slice\u201d has expired.\nThe current Java release does not precisely specify the behavior of its scheduler. Threads can be\nassigned priorities, and when a choice is made between several threads that all want to run, the\nhighest-priority thread wins. However, among threads that are all the same priority, the behavior\nis not well-defined. In fact, the different platforms on which Java currently runs have different\nbehaviors\u2014some behaving more like a preemptive scheduler, and some more like a non-\npreemptive scheduler.\n367\n030-4s CH18.i 367 1\/29\/96, 11:55 AM\nP2\/V4\/SQC5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch 18 LP#3 MTWRFSS\nDDAAYY\n18 Multithreading\nNote: This incomplete specification of the scheduler is terribly annoying and,\npresumably, will be corrected in later releases. Not knowing the fine details of how\nscheduling occurs is perfectly all right, but not knowing whether equal priority\nthreads must explicitly yield or face running forever, is not all right. For example,\nall the threads you have created so far are equal priority threads, so you don\u2019t know\ntheir basic scheduling behavior!\nTesting Your Scheduler\nTo find out what kind of scheduler you have on your system, try the following:\npublic class RunnablePotato implements Runnable {\npublic void run() {\nwhile (true)\nSystem.out.println(Thread.currentThread().getName());\n}\n}\npublic class PotatoThreadTester {\npublic static void main(String argv[]) {\nRunnablePotato aRP = new RunnablePotato();\nnew Thread(aRP, \u201cone potato\u201d).start();\nnew Thread(aRP, \u201ctwo potato\u201d).start();\n}\n}\nFor a non-preemptive scheduler, this prints the following:\none potato\none potato\none potato\n. . .\nforever, until you interrupt the program. For a preemptive scheduler that time-slices, it repeats\nthe line one potato a few times, followed by the same number of two potato lines, over and over:\none potato\none potato\n...\none potato\ntwo potato\ntwo potato\n...\ntwo potato\n. . .\n368\n030-4s CH18.i 368 1\/29\/96, 11:56 AM\nP2\/V4\/SQC5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch 18 LP#3 Sams.net Learning\nCenter\nabcd\nuntil you interrupt the program. What if you want to be sure the two threads will take turns,\nno matter what the system scheduler wants to do? You rewrite RunnablePotato as follows:\npublic class RunnablePotato implements Runnable {\npublic void run() {\nwhile (true) {\nSystem.out.println(Thread.currentThread().getName());\nThread.yield(); \/\/ let another thread run for a while\n}\n}\n}\nTip: Normally you have to say Thread.currentThread().yield() to get your hands\non the current thread, and then call yield(). Because this pattern is so common,\nhowever, the Thread class provides a shortcut.\nThe yield() method explicitly gives any other threads that want to run a chance to begin\nrunning. (If there are no threads waiting to run, the thread that made the yield() simply\n18\ncontinues.) In our example, there\u2019s another thread that\u2019s just dying to run, so when you now run\nthe class ThreadTester, it should output the following:\none potato\ntwo potato\none potato\ntwo potato\none potato\ntwo potato\n. . .\neven if your system scheduler is non-preemptive, and would never normally run the second\nthread.\nPriorityThreadTester\nTo see whether priorities are working on your system, try this:\npublic class PriorityThreadTester {\npublic static void main(String argv[]) {\nRunnablePotato aRP = new RunnablePotato();\nThread t1 = new Thread(aRP, \u201cone potato\u201d);\nThread t2 = new Thread(aRP, \u201ctwo potato\u201d);\nt2.setPriority(t1.getPriority() + 1);\nt1.start();\nt2.start(); \/\/ at priority Thread.NORM_PRIORITY + 1\n}\n}\n369\n030-4s CH18.i 369 1\/29\/96, 11:57 AM\nP2\/V4\/SQC5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch 18 LP#3 MTWRFSS\nDDAAYY\n18 Multithreading\nTip: The values representing the lowest, normal, and highest priorities that threads\ncan be assigned are stored in class variables of the Thread class:\nThread.MIN_PRIORITY, Thread.NORM_PRIORITY, and Thread.MAX_PRIORITY. The\nsystem assigns new threads, by default, the priority Thread.NORM_PRIORITY. Priori-\nties in Java are currently defined in a range from 1 to 10, with 5 being normal, but\nyou shouldn\u2019t depend on these values; use the class variables, or tricks like the one\nshown in this example.\nIf one potato is the first line of output, your system does not preempt using priorities.\nWhy? Imagine that the first thread (t1) has just begun to run. Even before it has a chance to print\nanything, along comes a higher-priority thread (t2) that wants to run right away. That higher-\npriority thread should preempt (interrupt) the first, and get a chance to print two potato before\nt1 finishes printing anything. In fact, if you use the RunnablePotato class that never yield()s,\nt2 stays in control forever, printing two potato lines, because it\u2019s a higher priority than t1 and\nit never yields control. If you use the latest RunnablePotato class (with yield()), the output is\nalternating lines of one potato and two potato as before, but starting with two potato.\nHere\u2019s a good, illustrative example of how complex threads behave:\npublic class ComplexThread extends Thread {\nprivate int delay;\nComplexThread(String name, float seconds) {\nsuper(name);\ndelay = (int) seconds * 1000; \/\/ delays are in milliseconds\nstart(); \/\/ start up ourself!\n}\npublic void run() {\nwhile (true) {\nSystem.out.println(Thread.currentThread().getName());\ntry {\nThread.sleep(delay);\n} catch (InterruptedException ignored) {\nreturn;\n}\n}\n}\npublic static void main(String argv[]) {\nnew ComplexThread(\u201cone potato\u201d, 1.1F);\nnew ComplexThread(\u201ctwo potato\u201d, 0.3F);\nnew ComplexThread(\u201cthree potato\u201d, 0.5F);\nnew ComplexThread(\u201cfour\u201d, 0.7F);\n}\n}\n370\n030-4s CH18.i 370 1\/29\/96, 11:57 AM\nP2\/V4\/SQC5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch 18 LP#3 Sams.net Learning\nCenter\nabcd\nThis example combines the thread and its tester into a single class. Its constructor takes care of\nnaming (itself) and of starting (itself), because it is now a Thread. The main() method creates new\ninstances of its own class, because that class is a subclass of Thread. run() is also more\ncomplicated, because it now uses, for the first time, a method that can throw an unexpected\nexception.\nThe Thread.sleep() method forces the current thread to yield() and then waits for at least the\nspecified amount of time to elapse before allowing the thread to run again. It might be\ninterrupted, however, while sleeping by another thread. In such a case, it throws an\nInterruptedException. Now, because run() is not defined as throwing this exception, you must\n\u201chide\u201d the fact by catching and handling it yourself. Because interruptions are usually requests\nto stop, you should exit the thread, which you can do by simply returning from the run()\nmethod.\nThis program should output a repeating but complex pattern of four different lines, where every\nonce in a while you see the following:\n. . .\none potato\ntwo potato 18\nthree potato\nfour\n. . .\nYou should study the pattern output to prove to yourself that true parallelism is going on inside\nJava programs. You may also begin to appreciate that, if even this simple set of four threads can\nproduce such complex behavior, many more threads must be capable of producing near chaos\nif not carefully controlled. Luckily, Java provides the synchronization and thread-safe libraries\nyou need to control that chaos.\nSummary\nToday, you learned that parallelism is desirable and powerful, but introduces many new\nproblems\u2014methods and variables now need to be protected from thread conflicts\u2014that can\nlead to chaos if not carefully controlled.\nBy \u201cthinking multithreaded,\u201d you can detect the places in your programs that require\nsynchronized statements (or modifiers) to make them thread-safe. A series of Point examples\ndemonstrated the various levels of safety you can achieve and showed how subclasses of Thread,\nor classes that implement the Runnable interface, are created and run() to generate multithreaded\nprograms.\nYou also learned how to yield(), how to start(), stop(), suspend(), and resume() your threads,\nand how to catch ThreadDeath whenever it happens.\n371\n030-4s CH18.i 371 1\/29\/96, 11:58 AM\nP2\/V4\/SQC5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch 18 LP#3 MTWRFSS\nDDAAYY\n18 Multithreading\nFinally, you learned about preemptive and non-preemptive scheduling, both with and without\npriorities, and how to test your Java system to see which of them your scheduler is using.\nThis wraps up the description of threads. You now know enough to write the most complex of\nprograms: multithreaded ones. As you get more comfortable with threads, you may begin to use\nthe ThreadGroup class or to use the enumeration methods of Thread to get your hands on all the\nthreads in the system and manipulate them. Don\u2019t be afraid to experiment; you can\u2019t\npermanently break anything, and you learn only by trying.\nQ&A\nQ If they\u2019re so important to Java, why haven\u2019t threads appeared throughout the\nentire book?\nA Actually, they have. Every stand-alone program written so far has \u201ccreated\u201d at least\none thread, the one in which it is running. (Of course the system created that Thread\nfor it automatically.)\nQ How exactly do these threads get created and run? What about applets?\nA When a simple, stand-alone Java program starts up, the system creates a main thread,\nand its run() method calls your main() method to start your program\u2014you do\nnothing to get that Thread. Likewise, when a simple applet loads into a Java-aware\nbrowser, a Thread has already been created by the browser, and its run() method calls\nyour init() and start() methods to start your program. In either case, a new Thread()\nof some kind was done somewhere, by the Java environment itself.\nQ The ThreadTester class had an infinite loop that created Threads and then\njoin()ed with them. Is it really infinite?\nA In theory, yes. In actuality, how far the loop runs determines the resource limits of\n(and tests the stability of) the threads package and garbage collector in your Java\nrelease. Over time, all Java releases will converge on making the loop truly infinite.\nQ I know Java releases are still a little fuzzy about the scheduler\u2019s behavior, but\nwhat\u2019s the current story?\nA Here are the gruesome details for the beta release, relayed by Arthur van Hoff at Sun:\nthe way Java schedules threads \u201c...depends on the platform. It is usually preemptive,\nbut not always time-sliced. Priorities are not always observed, depending on the\nunderlying implementation.\u201d This final clause gives you a hint that all this confusion\nis an implementation problem, and that someday soon, the design and implementa-\ntion will both be clear about scheduling behavior.\n372\n030-4s CH18.i 372 1\/29\/96, 11:59 AM\nP2\/V4\/SQC5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch 18 LP#3 Sams.net Learning\nCenter\nabcd\nQ Does Java support more complex multithreaded concepts, such as semaphores?\nA The class Object in Java provides methods that can be used to build up condition\nvariables, semaphores, and any higher-level parallel construct you might need. The\nmethod wait() (and its two variants with a timeout) causes the current thread to wait\nuntil some condition has been satisfied. The method notify() (or notifyAll()),\nwhich must be called from within a synchronized method or block, tells the thread (or\nall threads) to wake up and check that condition again, because something has\nchanged. By careful combinations of these two primitive methods, any data structure\ncan be manipulated safely by a set of threads, and all the classical parallel primitives\nneeded to implement published parallel algorithms can be built.\nQ My parallel friends tell me I should worry about something called \u201cdeadlock.\u201d\nShould I?\nA Not for simple multithreaded programs. However, in more complicated programs,\none of the biggest worries does become one of avoiding a situation in which one\nthread has locked an object and is waiting for another thread to finish, while that\nother thread is waiting for the first thread to release that same object before it can\nfinish. That\u2019s a deadlock\u2014both threads will be stuck forever. Mutual dependencies\n18\nlike this involving more than two threads can be quite intricate, convoluted, and\ndifficult to locate, much less rectify. They are one of the main challenges in writing\ncomplex multithreaded programs.\n373\n030-4s CH18.i 373 1\/29\/96, 11:59 AM\nP2\/V4\/SQC5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch 18 LP#3 Sams.net Learning\nCenter\nabcd\n19\n19\nS\nS\nWEEK\nF 3\nR\nW 19\nStreams\nT\nM\nby Charles L. Perkins\n375\n030-4s CH19.i 375 1\/29\/96, 12:04 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#3 MTWRFSS\nDDAAYY\n19 Streams\nToday, you\u2019ll explore Java\u2019s streams:\nnn Input streams\u2014and how to create, use, and detect the end of them\u2014and filtered\ninput streams, which can be nested to great effect\nnn Output streams, that are mostly analogous to (but the inverse of) input streams\nYou\u2019ll also learn about two stream interfaces that make the reading and writing of typed streams\nmuch easier (as well as about several utility classes used to access the file system). Let\u2019s begin with\na little history behind the invention of streams.\nOne of the early inventions of the UNIX operating system was the pipe. By unifying all these\ndisparate ways of communicating into a single metaphor, UNIX paved the way for a whole series\nof related inventions, culminating in the abstraction known as streams.\nNEW* A pipe is an uninterpreted stream of bytes that can be used for communicating between\nTERM programs (or other \u201cforked\u201d copies of your own program) or for reading and writing to\nperipheral devices and files.\nA stream is a path of communication between the source of some information and its destination.\nThat information, an uninterpreted byte stream, can come from any \u201cpipe source,\u201d the\ncomputer\u2019s memory, or even from the Internet. In fact, the source and destination of a stream\nare completely arbitrary producers and consumers of bytes, respectively. Therein lies the power\nof the abstraction. You don\u2019t need to know about the source of the information when reading\nfrom a stream, and you don\u2019t need to know about the final destination when writing to one.\nGeneral-purpose methods that can read from any source accept a stream argument to specify\nthat source; general methods for writing accept a stream to specify the destination. Arbitrary\nprocessors (or filters) of data have two stream arguments. They read from the first, process the data,\nand write the results to the second. These processors have no idea of either the source or the\ndestination of the data they are processing. Sources and destinations can vary widely: from two\nmemory buffers on the same local computer, to the ELF transmissions to and from a submarine\nat sea, to the real-time data streams of a NASA probe in deep space.\nBy decoupling the consuming, processing, or producing of data from the sources and\ndestinations of that data, you can mix and match any combination of them at will as you write\nyour program. In the future, when new, previously nonexistent forms of source or destination\n(or consumer, processor, or producer) appear, they can be used within the same framework, with\nno changes to your classes. New stream abstractions, supporting higher levels of interpretation\n\u201con top of\u201d the bytes, can be written completely independently of the underlying transport\nmechanisms for the bytes themselves.\n376\n030-4s CH19.i 376 1\/29\/96, 12:04 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#4 Sams.net Learning\nCenter\nabcd\nAt the pinnacle of this stream framework are the two abstract classes, InputStream and\nOutputStream. If you turn briefly to the diagram for java.io in Appendix B, you\u2019ll see that below\nthese classes is a virtual cornucopia of categorized classes, demonstrating the wide range of\nstreams in the system, but also demonstrating an extremely well-designed hierarchy of\nrelationships between these streams, one well worth learning from. Let\u2019s begin with the parents\nand then work our way down this bushy tree.\nInput Streams\nAll the methods you will explore today are declared to throw IOExceptions. This new subclass\nof Exception conceptually embodies all the possible I\/O errors that might occur while using\nstreams. Several subclasses of it define a few, more specific exceptions that can be thrown as well.\nFor now, it is enough to know that you must either catch an IOException, or be in a method\nthat can \u201cpass it along,\u201d to be a well-behaved user of streams.\nThe abstract Class InputStream\nInputStream is an abstract class that defines the fundamental ways in which a destination\nconsumer reads a stream of bytes from some source. The identity of the source, and the manner\nof the creation and transport of the bytes, is irrelevant. When using an input stream, you are the\ndestination of those bytes, and that\u2019s all you need to know.\n19\nread()\nThe most important method to the consumer of an input stream is the one that reads bytes from\nthe source. This method, read(), comes in many flavors, and each is demonstrated in an example\nin today\u2019s lesson.\nEach of these read() methods is defined to \u201cblock\u201d (wait) until all the input requested becomes\navailable. Don\u2019t worry about this limitation; because of multithreading, you can do as many\nother things as you like while this one thread is waiting for input. In fact, it is a common idiom\nto assign a thread to each stream of input (and for each stream of output) that is solely responsible\nfor reading from it (or writing to it). These input threads might then \u201chand off\u201d the information\nto other threads for processing. This naturally overlaps the I\/O time of your program with its\ncompute time.\nHere\u2019s the first form of read():\nInputStream s = getAnInputStreamFromSomewhere();\nbyte[] buffer = new byte[1024]; \/\/ any size will do\nif (s.read(buffer) != buffer.length)\nSystem.out.println(\u201cI got less than I expected.\u201d);\n377\n030-4s CH19.i 377 1\/29\/96, 12:05 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#3 MTWRFSS\nDDAAYY\n19 Streams\nNote: Here, and throughout the rest of today\u2019s lesson, assume that either an import\njava.io appears before all the examples or that you mentally prefix all references to\njava.io classes with the prefix java.io.\nThis form of read() attempts to fill the entire buffer given. If it cannot (usually due to reaching\nthe end of the input stream), it returns the actual number of bytes that were read into the buffer.\nAfter that, any further calls to read() return -1, indicating that you are at the end of the stream.\nNote that the if statement still works even in this case, because -1 != 1024 (this corresponds\nto an input stream with no bytes in it all).\nNote: Don\u2019t forget that, unlike in C, the -1 case in Java is not used to indicate an\nerror. Any I\/O errors throw instances of IOException (which you\u2019re not catching\nyet). You learned on Day 17 that all uses of distinguished values can be replaced by\nthe use of exceptions, and so they should. The -1 in the last example is a bit of a\nhistorical anachronism. You\u2019ll soon see a better approach to indicating end of the\nstream using the class DataInputStream.\nYou can also read into a \u201cslice\u201d of your buffer by specifying the offset into the buffer, and the\nlength desired, as arguments to read():\ns.read(buffer, 100, 300);\nThis example tries to fill in bytes 100 through 399 and behaves otherwise exactly the same as the\nprevious read() method. In fact, in the current release, the default implementation of the former\nversion of read() uses the latter:\npublic int read(byte[] buffer) throws IOException {\nreturn read(buffer, 0, buffer.length);\n}\nFinally, you can read in bytes one at a time:\nInputStream s = getAnInputStreamFromSomewhere();\nbyte b;\nint byteOrMinus1;\nwhile ((byteOrMinus1 = s.read()) != -1) {\nb = (byte) byteOrMinus1;\n. . . \/\/ process the byte b\n}\n. . . \/\/ reached end of stream\n378\n030-4s CH19.i 378 1\/29\/96, 12:05 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#4 Sams.net Learning\nCenter\nabcd\nNote: Because of the nature of integer promotion in Java in general, and because in\nthis case the read() method returns an int, using the byte type in your code may\nbe a little frustrating. You\u2019ll find yourself constantly having explicitly to cast the\nresult of arithmetic expressions, or of int return values, back to your size. Because\nread() really should be returning a byte in this case, I feel justified in declaring and\nusing it as such (despite the pain)\u2014it makes the size of the data being read clearer.\nIn cases wherein you feel the range of a variable is naturally limited to a byte (or a\nshort) rather than an int, please take the time to declare it that way and pay the\nsmall price necessary to gain the added clarity. By the way, a lot of the Java class\nlibrary code simply stores the result of read() in an int. This proves that even the\nJava team is human\u2014everyone makes style mistakes.\nskip()\nWhat if you want to skip over some of the bytes in a stream, or start reading a stream from other\nthan its beginning? A method similar to read() does the trick:\nif (s.skip(1024) != 1024)\nSystem.out.println(\u201cI skipped less than I expected.\u201d);\nThis skips over the next 1024 bytes in the input stream. skip() takes and returns a long integer,\nbecause streams are not required to be limited to any particular size. The default implementation\n19\nof skip in this release simply uses read():\npublic long skip(long n) throws IOException {\nbyte[] buffer = new byte[(int) n];\nreturn read(buffer);\n}\nNote: This implementation does not support large skips correctly, because its long\nargument is cast to an int. Subclasses must override this default implementation if\nthey want to handle this more properly. This won\u2019t be as easy as you might think,\nbecause the current release of the Java system does not allow integer types larger\nthan int to act as array subscripts.\n379\n030-4s CH19.i 379 1\/29\/96, 12:06 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#3 MTWRFSS\nDDAAYY\n19 Streams\navailable()\nIf for some reason you would like to know how many bytes are in the stream right now, you can\nask:\nif (s.available() < 1024)\nSystem.out.println(\u201cToo little is available right now.\u201d);\nThis tells you the number of bytes that you can read() without blocking. Because of the abstract\nnature of the source of these bytes, streams may or may not be able to tell you a reasonable answer\nto this question. For example, some streams always return 0. Unless you use specific subclasses\nof InputStream that you know provide a reasonable answer to this question, it\u2019s not a good idea\nto rely upon this method. Remember, multithreading eliminates many of the problems\nassociated with blocking while waiting for a stream to fill again. Thus, one of the strongest\nrationales for the use of available() goes away.\nmark() and reset()\nSome streams support the notion of marking a position in the stream, and then later resetting\nthe stream to that position to reread the bytes there. Clearly, the stream would have to\n\u201cremember\u201d all those bytes, so there is a limitation on how far apart in a stream the mark and\nits subsequent reset can occur. There\u2019s also a method that asks whether or not the stream\nsupports the notion of marking at all. Here\u2019s an example:\nInputStream s = getAnInputStreamFromSomewhere();\nif (s.markSupported()) { \/\/ does s support the notion?\n. . . \/\/ read the stream for a while\ns.mark(1024);\n. . . \/\/ read less than 1024 more bytes\ns.reset();\n. . . \/\/ we can now re-read those bytes\n} else {\n. . . \/\/ no, perform some alternative\n}\nWhen marking a stream, you specify the maximum number of bytes you intend to allow to pass\nbefore resetting it. This allows the stream to limit the size of its byte \u201cmemory.\u201d If this number\nof bytes goes by and you have not yet reset(), the mark becomes invalid, and attempting to\nreset() will throw an exception.\nMarking and resetting a stream is most valuable when you are attempting to identify the type\nof the stream (or the next part of the stream), but to do so, you must consume a significant piece\nof it in the process. Often, this is because you have several black-box parsers that you can hand\nthe stream to, but they will consume some (unknown to you) number of bytes before making\nup their mind about whether the stream is of their type. Set a large size for the read limit above,\nand let each parser run until it either throws an error or completes a successful parse. If an error\nis thrown, reset() and try the next parser.\n380\n030-4s CH19.i 380 1\/29\/96, 12:07 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#4 Sams.net Learning\nCenter\nabcd\nclose()\nBecause you don\u2019t know what resources an open stream represents, nor how to deal with them\nproperly when you\u2019re finished reading the stream, you must usually explicitly close down a\nstream so that it can release these resources. Of course, garbage collection and a finalization\nmethod can do this for you, but what if you need to reopen that stream or those resources before\nthey have been freed by this asynchronous process? At best, this is annoying or confusing; at\nworst, it introduces an unexpected, obscure, and difficult-to-track-down bug. Because you\u2019re\ninteracting with the outside world of external resources, it\u2019s safer to be explicit about when you\u2019re\nfinished using them:\nInputStream s = alwaysMakesANewInputStream();\ntry {\n. . . \/\/ use s to your heart\u2019s content\n} finally {\ns.close();\n}\nGet used to this idiom (using finally); it\u2019s a useful way to be sure something (such as closing\nthe stream) always gets done. Of course, you\u2019re assuming that the stream is always successfully\ncreated. If this is not always the case, and null is sometimes returned instead, here\u2019s the correct\nway to be safe:\nInputStream s = tryToMakeANewInputStream();\nif (s != null) {\ntry {\n19\n. . .\n} finally {\ns.close();\n}\n}\nAll input streams descend from the abstract class InputStream. All share in common the few\nmethods described so far. Thus, stream s in the previous examples could have been any of the\nmore complex input streams described in the next few sections.\nByteArrayInputStream\nThe \u201cinverse\u201d of some of the previous examples would be to create an input stream from an array\nof bytes. This is exactly what ByteArrayInputStream does:\nbyte[] buffer = new byte[1024];\nfillWithUsefulData(buffer);\nInputStream s = new ByteArrayInputStream(buffer);\n381\n030-4s CH19.i 381 1\/29\/96, 12:08 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#3 MTWRFSS\nDDAAYY\n19 Streams\nReaders of the new stream s see a stream 1024 bytes long, containing the bytes in the array buffer.\nJust as read() has a form that takes an offset and a length, so does this class\u2019s constructor:\nInputStream s = new ByteArrayInputStream(buffer, 100, 300);\nHere, the stream is 300 bytes long and consists of bytes 100-399 from the array buffer.\nNote: Finally, you\u2019ve seen your first examples of the creation of a stream. These\nnew streams are attached to the simplest of all possible sources of data, an array of\nbytes in the memory of the local computer.\nByteArrayInputStreams only implement the standard set of methods that all input streams do.\nHere, however, the available() method has a particularly simple job\u2014it returns 1024 and 300,\nrespectively, for the two instances of ByteArrayInputStream you created previously, because it\nknows exactly how many bytes are available. Finally, calling reset() on a ByteArrayInputStream\nresets it to the beginning of the stream (buffer), no matter where the mark is set.\nFileInputStream\nOne of the most common uses of streams, and historically the earliest, is to attach them to files\nin the file system. Here, for example, is the creation of such an input stream on a UNIX system:\nInputStream s = new FileInputStream(\u201c\/some\/path\/and\/fileName\u201d);\n!\n! Caution: Applets attempting to open, read, or write streams based on files in the\nfile system can cause security violations (depending on the paranoia level set by the\nuser of the browser). Try to create applets that do not depend on files at all, by\nusing servers to hold shared information. If that\u2019s impossible, limit your applet\u2019s\nI\/O to a single file or directory to which the user can easily assign file access permis-\nsion. (Stand-alone Java programs have none of these problems, of course.)\nYou also can create the stream from a previously opened file descriptor:\nint fd = openInputFileInTraditionalUNIXWays();\nInputStream s = new FileInputStream(fd);\nIn either case, because it\u2019s based on an actual (finite length) file, the input stream created can\nimplement available() precisely and can skip() like a champ (just as ByteArrayInputStream\ncan, by the way). In addition, FileInputStream knows a few more tricks:\n382\n030-4s CH19.i 382 1\/29\/96, 12:09 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#4 Sams.net Learning\nCenter\nabcd\nFileInputStream aFIS = new FileInputStream(\u201caFileName\u201d);\nint myFD = aFIS.getFD();\n\/* aFIS.finalize(); *\/ \/\/ will call close() when automatically called by GC\nTip: To call the new methods, you must declare the stream variable aFIS to be of\ntype FileInputStream, because plain InputStreams don\u2019t know about them.\nThe first is obvious: getFD() returns the file descriptor of the file on which the stream is based.\nThe second, though, is an interesting shortcut that allows you to create FileInputStreams\nwithout worrying about closing them later. FileInputStream\u2019s implementation of finalize(),\na protected method, closes the stream. Unlike in the previous contrived example in comments,\nyou almost never can nor should call a finalize() method directly. The garbage collector calls\nit after noticing that the stream is no longer in use, but before actually destroying the stream.\nThus, you can go merrily along using the stream, never closing it, and all will be well. The system\ntakes care of closing it (eventually).\nYou can get away with this because streams based on files tie up very few resources, and these\nresources cannot be accidentally reused before garbage collection (these were the things worried\nabout in the previous discussion of finalization and close()). Of course, if you were also writing\nto the file, you would have to be more careful. (Reopening the file too soon after writing might\nmake it appear in an inconsistent state because the finalize()\u2014and thus the close()\u2014 19\nmight not have happened yet). Just because you don\u2019t have to close the stream doesn\u2019t mean\nyou might not want to do so anyway. For clarity, or if you don\u2019t know precisely what type of\nan InputStream you were handed, you might choose to call close() yourself.\nFilterInputStream\nThis \u201cabstract\u201d class simply provides a \u201cpass-through\u201d for all the standard methods of\nInputStream. It holds inside itself another stream, by definition one further \u201cdown\u201d the chain\nof filters, to which it forwards all method calls. It implements nothing new but allows itself to\nbe nested:\nInputStream s = getAnInputStreamFromSomewhere();\nFilterInputStream s1 = new FilterInputStream(s);\nFilterInputStream s2 = new FilterInputStream(s1);\nFilterInputStream s3 = new FilterInputStream(s2);\n... s3.read() ...\n383\n030-4s CH19.i 383 1\/29\/96, 12:10 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#3 MTWRFSS\nDDAAYY\n19 Streams\nWhenever a read is performed on the filtered stream s3, it passes along the request to s2; then\ns2 does the same to s1, and finally s is asked to provide the bytes. Subclasses of FilterInputStream\nwill, of course, do some nontrivial processing of the bytes as they flow past. The rather verbose\nform of \u201cchaining\u201d in the previous example can be made more elegant:\ns3 = new FilterInputStream(new FilterInputStream(new FilterInputStream(s)));\nYou should use this idiom in your code whenever you can. It clearly expresses the nesting of\nchained filters, and can easily be parsed and \u201cread aloud\u201d by starting at the innermost stream s\nand reading outward\u2014each filter stream applying to the one within\u2014until you reach the\noutermost stream s3.\nNote: FilterInputStream is called \u201cabstract,\u201d rather than abstract, because it is not\nactually declared to be abstract. This means that, as useless as they are, you can\ncreate instances of FilterInputStream directly. The same will hold for its output\nstream \u201cbrother\u201d class, described later today.\nNow let\u2019s examine each of the subclasses of FilterInputStream in turn.\nBufferedInputStream\nThis is one of the most valuable of all streams. It implements the full complement of\nInputStream\u2019s methods, but it does so by using a buffered array of bytes that acts as a cache for\nfuture reading. This decouples the rate and the size of the \u201cchunks\u201d you\u2019re reading from the more\nregular, larger block sizes in which streams are most efficiently read (from, for example,\nperipheral devices, files in the file system, or the network). It also allows smart streams to read\nahead when they expect that you will want more data soon.\nBecause the buffering of BufferedInputStream is so valuable, and it\u2019s also the only class to handle\nmark() and reset() properly, you might wish that every input stream could somehow share its\nvaluable capabilities. Normally, because those stream classes do not implement them, you would\nbe out of luck. Fortunately, you already saw a way that filter streams can wrap themselves\n\u201caround\u201d other streams. Suppose that you would like a buffered FileInputStream that can\nhandle marking and resetting correctly. Et voil\u00e0:\nInputStream s = new BufferedInputStream(new FileInputStream(\u201cfoo\u201d));\nYou have a buffered input stream based on the file \u201cfoo\u201d that can mark() and reset().\nNow you can begin to see the power of nesting streams. Any capability provided by a filter input\nstream (or output stream, as you\u2019ll see soon) can be used by any other, basic stream via nesting.\nOf course, any combination of these capabilities, and in any order, can be as easily accomplished\nby nesting the filter streams themselves.\n384\n030-4s CH19.i 384 1\/29\/96, 12:11 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#4 Sams.net Learning\nCenter\nabcd\nDataInputStream\nAll the methods that instances of this class understand are defined in a separate interface, which\nboth DataInputStream and RandomAccessFile (another class in java.io) implement. This\ninterface is general-purpose enough that you might want to use it yourself in the classes you\ncreate. It is called DataInput.\nThe DataInput Interface\nWhen you begin using streams to any degree, you\u2019ll quickly discover that byte streams are not\na really helpful format into which to force all data. In particular, the primitive types of the Java\nlanguage embody a rather nice way of looking at data, but with the streams you\u2019ve been defining\nthus far in this book, you could not read data of these types. The DataInput interface specifies\na higher-level set of methods that, when used for both reading and writing, can support a more\ncomplex, typed stream of data. Here are the set of methods this interface defines:\nvoid readFully(byte[] buffer) throws IOException;\nvoid readFully(byte[] buffer, int offset, int length) throws IOException;\nint skipBytes(int n) throws IOException;\nboolean readBoolean() throws IOException;\nbyte readByte() throws IOException;\nint readUnsignedByte() throws IOException;\nshort readShort() throws IOException;\nint readUnsignedShort() throws IOException;\nchar readChar() throws IOException;\nint readInt() throws IOException;\nlong readLong() throws IOException;\n19\nfloat readFloat() throws IOException;\ndouble readDouble() throws IOException;\nString readLine() throws IOException;\nString readUTF() throws IOException;\nThe first three methods are simply new names for skip() and the two forms of read() you\u2019ve\nseen previously. Each of the next ten methods reads in a primitive type, or its unsigned\ncounterpart (useful for using every bit efficiently in a binary stream). These latter methods must\nreturn an integer of a wider size than you might think; because integers are signed in Java, the\nunsigned value does not fit in anything smaller. The final two methods read a newline (\u2018\\r\u2019,\n\u2018\\n\u2019, or \u201c\\r\\n\u201d) terminated string of characters from the stream\u2014the first in ASCII, and the\nsecond in Unicode.\nNow that you know what the interface that DataInputStream implements looks like, let\u2019s see it\nin action:\nDataInputStream s = new DataInputStream(getNumericInputStream());\nlong size = s.readLong(); \/\/ the number of items in the stream\nwhile (size-- > 0) {\nif (s.readBoolean()) { \/\/ should I process this item?\n385\n030-4s CH19.i 385 1\/29\/96, 12:11 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#3 MTWRFSS\nDDAAYY\n19 Streams\nint anInteger = s.readInt();\nint magicBitFlags = s.readUnsignedShort();\ndouble aDouble = s.readDouble();\nif ((magicBitFlags & 0100000) != 0) {\n. . . \/\/ high bit set, do something special\n}\n. . . \/\/ process anInteger and aDouble\n}\n}\nBecause the class implements an interface for all its methods, you can also use the following\ninterface:\nDataInput d = new DataInputStream(new FileInputStream(\u201canything\u201d));\nString line;\nwhile ((line = d.readLine()) != null) {\n. . . \/\/ process the line\n}\nThe EOFException\nOne final point about most of DataInputStream\u2019s methods: when the end of the stream is\nreached, they throw an EOFException. This is tremendously useful and, in fact, allows you to\nrewrite all the kludgy uses of -1 you saw earlier today in a much nicer fashion:\nDataInputStream s = new DataInputStream(getAnInputStreamFromSomewhere());\ntry {\nwhile (true) {\nbyte b = (byte) s.readByte();\n. . . \/\/ process the byte b\n}\n} catch (EOFException e) {\n. . . \/\/ reached end of stream\n}\nThis works just as well for all but the last two of the read methods of DataInputStream.\n!\n! Caution: skipBytes() does nothing at all on end of stream, readLine() returns\nnull, and readUTF() might throw a UTFDataFormatException, if it notices the\nproblem at all.\nLineNumberInputStream\nIn an editor or a debugger, line numbering is crucial. To add this valuable capability to your\nprograms, use the filter stream LineNumberInputStream, which keeps track of line numbers as its\n386\n030-4s CH19.i 386 1\/29\/96, 12:12 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#4 Sams.net Learning\nCenter\nabcd\nstream \u201cflows through\u201d it. It\u2019s even smart enough to remember a line number and later restore\nit, during a mark() and reset(). You might use this class as follows:\nLineNumberInputStream aLNIS;\naLNIS = new LineNumberInputStream(new FileInputStream(\u201csource\u201d));\nDataInputStream s = new DataInputStream(aLNIS);\nString line;\nwhile ((line = s.readLine()) != null) {\n. . . \/\/ process the line\nSystem.out.println(\u201cDid line number: \u201c + aLNIS.getLineNumber());\n}\nHere, two filter streams are nested around the FileInputStream actually providing the data\u2014\nthe first to read lines one at a time and the second to keep track of the line numbers of these lines\nas they go by. You must explicitly name the intermediate filter stream, aLNIS, because if you did\nnot, you couldn\u2019t call getLineNumber() later. Note that if you invert the order of the nested\nstreams, reading from the DataInputStream does not cause the LineNumberInputStream to \u201csee\u201d\nthe lines.\nYou must put any filter streams acting as \u201cmonitors\u201d in the middle of the chain and \u201cpull\u201d the\ndata from the outermost filter stream so that the data will pass through each of the monitors in\nturn. In the same way, buffering should occur as far inside the chain as possible, because it won\u2019t\nbe able to do its job properly unless most of the streams that need buffering come after it in the\nflow. For example, here\u2019s a doubly silly order:\nnew BufferedInputStream(new LineNumberInputStream( 19\n(cid:229) new DataInputStream(new FileInputStream(\u201cfoo\u201d));\nand here\u2019s a much better order:\nnew DataInputStream(new LineNumberInputStream(\n(cid:229) new BufferedInputStream(new FileInputStream(\u201cfoo\u201d));\nLineNumberInputStreams can also be told to setLineNumber(), for those few times when you\nknow more than they do.\nPushbackInputStream\nThe filter stream class PushbackInputStream is commonly used in parsers, to \u201cpush back\u201d a single\ncharacter in the input (after reading it) while trying to determine what to do next\u2014a simplified\nversion of the mark() and reset() utility you learned about earlier. Its only addition to the\nstandard set of InputStream methods is unread(), which as you might guess, pretends that it\nnever read the byte passed in as its argument, and then gives that byte back as the return value\nof the next read().\nThe following is a simple implementation of readLine() using this class:\npublic class SimpleLineReader {\nprivate FilterInputStream s;\n387\n030-4s CH19.i 387 1\/29\/96, 12:13 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#3 MTWRFSS\nDDAAYY\n19 Streams\npublic SimpleLineReader(InputStream anIS) {\ns = new DataInputStream(anIS);\n}\n. . . \/\/ other read() methods using stream s\npublic String readLine() throws IOException {\nchar[] buffer = new char[100];\nint offset = 0;\nbyte thisByte;\ntry {\nloop: while (offset < buffer.length) {\nswitch (thisByte = (byte) s.read()) {\ncase \u2018\\n\u2019:\nbreak loop;\ncase \u2018\\r\u2019:\nbyte nextByte = (byte) s.read();\nif (nextByte != \u2018\\n\u2019) {\nif (!(s instanceof PushbackInputStream)) {\ns = new PushbackInputStream(s);\n}\n((PushbackInputStream) s).unread(nextByte);\n}\nbreak loop;\ndefault:\nbuffer[offset++] = (char) thisByte;\nbreak;\n}\n}\n} catch (EOFException e) {\nif (offset == 0)\nreturn null;\n}\nreturn String.copyValueOf(buffer, 0, offset);\n}\n}\nThis demonstrates numerous things. For the purpose of this example, readLine() is restricted\nto reading the first 100 characters of the line. In this respect, it demonstrates how not to write\na general-purpose line processor (you should be able to read any size line). It also reminds you\nhow to break out of an outer loop, and how to produce a String from an array of characters (in\nthis case, from a \u201cslice\u201d of the array of characters). This example also includes standard uses of\nInputStream\u2019s read() for reading bytes one at a time, and of determining the end of the stream\nby enclosing it in a DataInputStream and catching EOFException.\nOne of the more unusual aspects of the example is the way PushbackInputStream is used. To be\nsure that \u2018\\n\u2019 is ignored following \u2018\\r\u2019 you have to \u201clook ahead\u201d one character; but if it is not\na \u2018\\n\u2019, you must push back that character. Look at the next two lines as if you didn\u2019t know much\nabout the stream s. The general technique used is instructive. First, you see whether s is already\nan instanceof some kind of PushbackInputStream. If so, you can simply use it. If not, you enclose\n388\n030-4s CH19.i 388 1\/29\/96, 12:13 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#4 Sams.net Learning\nCenter\nabcd\nthe current stream (whatever it is) inside a new PushbackInputStream and use this new stream.\nNow, let\u2019s jump back into the context of the example.\nThe line following wants to call the method unread(). The problem is that s has a \u201ccompile-time\ntype\u201d of FilterInputStream, and thus doesn\u2019t understand that method. The previous two lines\nhave guaranteed, however, that the run-time type of the stream in s is PushbackInputStream, so\nyou can safely cast it to that type and then safely call unread().\nNote: This example was done in an unusual way for demonstration purposes. You\ncould have simply declared a PushbackInputStream variable and always enclosed the\nDataInputStream in it. (Conversely, SimpleLineReader\u2019s constructor could have\nchecked whether its argument was already of the right class, the way\nPushbackInputStream did, before creating a new DataInputStream.) The interesting\nthing about this approach of \u201cwrapping a class only when needed\u201d is that it works\nfor any InputStream that you hand it, and it does additional work only if it needs\nto. Both of these are good general design principles.\nAll the subclasses of FilterInputStream have now been described. It\u2019s time to return to the direct\nsubclasses of InputStream.\nPipedInputStream\n19\nThis class, along with its \u201cbrother\u201d class PipedOutputStream, are covered later today (they need\nto be understood and demonstrated together). For now, all you need to know is that together\nthey create a simple, two-way communication conduit between threads.\nSequenceInputStream\nSuppose you have two separate streams, and you would like to make a composite stream that\nconsists of one stream followed by the other (like appending two Strings together). This is\nexactly what SequenceInputStream was created for:\nInputStream s1 = new FileInputStream(\u201ctheFirstPart\u201d);\nInputStream s2 = new FileInputStream(\u201ctheRest\u201d);\nInputStream s = new SequenceInputStream(s1, s2);\n... s.read() ... \/\/ reads from each stream in turn\nYou could have \u201cfaked\u201d this example by reading each file in turn\u2014but what if you had to hand\nthe composite stream s to some other method that was expecting only a single InputStream?\n389\n030-4s CH19.i 389 1\/29\/96, 12:14 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#3 MTWRFSS\nDDAAYY\n19 Streams\nHere\u2019s an example (using s) that line-numbers the two previous files with a common numbering\nscheme:\nLineNumberInputStream aLNIS = new LineNumberInputStream(s);\n... aLNIS.getLineNumber() ...\nNote: Stringing together streams this way is especially useful when the streams are\nof unknown length and origin, and were just handed to you by someone else.\nWhat if you want to string together more than two streams? You could try the following:\nVector v = new Vector();\n. . . \/\/ set up all the streams and add each to the Vector\nInputStream s1 = new SequenceInputStream(v.elementAt(0), v.elementAt(1));\nInputStream s2 = new SequenceInputStream(s1, v.elementAt(2));\nInputStream s3 = new SequenceInputStream(s2, v.elementAt(3));\n. . .\nNote: A Vector is a growable array of objects that can be filled, referenced (with\nelementAt()) and enumerated.\nHowever, it\u2019s much easier to use a different constructor that SequenceInputStream provides:\nInputStream s = new SequenceInputStream(v.elements());\nIt takes an enumeration of all the sequences you wish to combine and returns a single stream that\nreads through the data of each in turn.\nStringBufferInputStream\nStringBufferInputStream is exactly like ByteArrayInputStream, but instead of being based on\na byte array, it\u2019s based on an array of characters (a String):\nString buffer = \u201cNow is the time for all good men to come...\u201d;\nInputStream s = new StringBufferInputStream(buffer);\nAll comments that were made about ByteArrayInputStream apply here as well. (See the earlier\nsection on that class.)\n390\n030-4s CH19.i 390 1\/29\/96, 12:15 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#4 Sams.net Learning\nCenter\nabcd\nNote: StringBufferInputStream is a bit of a misnomer, because this input stream is\nactually based on a String. It should really be called StringInputStream.\nOutput Streams\nOutput streams are, in almost every case, paired with a \u201cbrother\u201d InputStream that you\u2019ve\nalready learned. If an InputStream performs a certain operation, the \u201cbrother\u201d OutputStream\nperforms the inverse operation. You\u2019ll see more of what this means soon.\nThe abstract Class OutputStream\nOutputStream is the abstract class that defines the fundamental ways in which a source\n(producer) writes a stream of bytes to some destination. The identity of the destination, and the\nmanner of the transport and storage of the bytes, is irrelevant. When using an output stream,\nyou are the source of those bytes, and that\u2019s all you need to know.\nwrite()\nThe most important method to the producer of an output stream is the one that writes bytes\nto the destination. This method, write(), comes in many flavors, each demonstrated in an\n19\nexample below.\nNote: Every one of these write() methods is defined to \u201cblock\u201d (wait) until all\nthe output requested has been written. You don\u2019t need to worry about this\nlimitation\u2014see the note under InputStream\u2019s read() method if you don\u2019t\nremember why.\nOutputStream s = getAnOutputStreamFromSomewhere();\nbyte[] buffer = new byte[1024]; \/\/ any size will do\nfillInData(buffer); \/\/ the data we want to output\ns.write(buffer);\nYou also can write a \u201cslice\u201d of your buffer by specifying the offset into the buffer, and the length\ndesired, as arguments to write():\ns.write(buffer, 100, 300);\n391\n030-4s CH19.i 391 1\/29\/96, 12:17 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#3 MTWRFSS\nDDAAYY\n19 Streams\nThis writes out bytes 100 through 399 and behaves otherwise exactly the same as the previous\nwrite() method. In fact, in the current release, the default implementation of the former version\nof write() uses the latter:\npublic void write(byte[] buffer) throws IOException {\nwrite(buffer, 0, buffer.length);\n}\nFinally, you can write out bytes one at a time:\nwhile (thereAreMoreBytesToOutput()) {\nbyte b = getNextByteForOutput();\ns.write(b);\n}\nflush()\nBecause you don\u2019t know what an output stream is connected to, you might be required to \u201cflush\u201d\nyour output through some buffered cache to get it to be written (in a timely manner, or at all).\nOutputStream\u2019s version of this method does nothing, but it is expected that subclasses that\nrequire flushing (for example, BufferedOutputStream and PrintStream) will override this version\nto do something nontrivial.\nclose()\nJust like for an InputStream, you should (usually) explicitly close down an OutputStream so that\nit can release any resources it may have reserved on your behalf. (All the same notes and examples\nfrom InputStream\u2019s close() method apply here, with the prefix In replaced everywhere by Out.)\nAll output streams descend from the abstract class OutputStream. All share the previous few\nmethods in common.\nByteArrayOutputStream\nThe inverse of ByteArrayInputStream, which creates an input stream from an array of bytes, is\nByteArrayOutputStream, which directs an output stream into an array of bytes:\nOutputStream s = new ByteArrayOutputStream();\ns.write(123);\n. . .\nThe size of the (internal) byte array grows as needed to store a stream of any length. You can\nprovide an initial capacity as an aid to the class, if you like:\nOutputStream s = new ByteArrayOutputStream(1024 * 1024); \/\/ 1 Megabyte\n392\n030-4s CH19.i 392 1\/29\/96, 12:18 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#4 Sams.net Learning\nCenter\nabcd\nNote: You\u2019ve just seen your first examples of the creation of an output stream.\nThese new streams were attached to the simplest of all possible destinations of data,\nan array of bytes in the memory of the local computer.\nOnce the ByteArrayOutputStream s has been \u201cfilled,\u201d it can be output to another output stream:\nOutputStream anotherOutputStream = getTheOtherOutputStream();\nByteArrayOutputStream s = new ByteArrayOutputStream();\nfillWithUsefulData(s);\ns.writeTo(anotherOutputStream);\nIt also can be extracted as a byte array or converted to a String:\nbyte[] buffer = s.toByteArray();\nString bufferString = s.toString();\nString bufferUnicodeString = s.toString(upperByteValue);\nNote: The last method allows you to \u201cfake\u201d Unicode (16-bit) characters by filling\nin their lower bytes with ASCII and then specifying a common upper byte (usually\n0) to create a Unicode String result.\nByteArrayOutputStreams have two utility methods: one simply returns the current number of 19\nbytes stored in the internal byte array, and the other resets the array so that the stream can be\nrewritten from the beginning:\nint sizeOfMyByteArray = s.size();\ns.reset(); \/\/ s.size() would now return 0\ns.write(123);\n. . .\nFileOutputStream\nOne of the most common uses of streams is to attach them to files in the file system. Here, for\nexample, is the creation of such an output stream on a UNIX system:\nOutputStream s = new FileOutputStream(\u201c\/some\/path\/and\/fileName\u201d);\n!\n! Caution: Applets attempting to open, read, or write streams based on files in the\nfile system can cause security violations. See the note under FileInputStream for\nmore details.\n393\n030-4s CH19.i 393 1\/29\/96, 12:19 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#3 MTWRFSS\nDDAAYY\n19 Streams\nYou also can create the stream from a previously opened file descriptor:\nint fd = openOutputFileInTraditionalUNIXWays();\nOutputStream s = new FileOutputStream(fd);\nFileOutputStream is the inverse of FileInputStream, and it knows the same tricks:\nFileOutputStream aFOS = new FileOutputStream(\u201caFileName\u201d);\nint myFD = aFOS.getFD();\n\/* aFOS.finalize(); *\/ \/\/ will call close() when automatically called by GC\nNote: To call the new methods, you must declare the stream variable aFOS to be of\ntype FileOutputStream, because plain OutputStreams don\u2019t know about them.\nThe first is obvious. getFD() simply returns the file descriptor for the file on which the stream\nis based. The second, commented, contrived call to finalize() is there to remind you that you\ndon\u2019t have to worry about closing the stream\u2014it is done for you automatically. (See the\ndiscussion under FileInputStream for more.)\nFilterOutputStream\nThis \u201cabstract\u201d class simply provides a \u201cpass-through\u201d for all the standard methods of\nOutputStream. It holds inside itself another stream, by definition one further \u201cdown\u201d the chain\nof filters, to which it forwards all method calls. It implements nothing new but allows itself to\nbe nested:\nOutputStream s = getAnOutputStreamFromSomewhere();\nFilterOutputStream s1 = new FilterOutputStream(s);\nFilterOutputStream s2 = new FilterOutputStream(s1);\nFilterOutputStream s3 = new FilterOutputStream(s2);\n... s3.write(123) ...\nWhenever a write is performed on the filtered stream s3, it passes along the request to s2. Then\ns2 does the same to s1, and finally s is asked to output the bytes. Subclasses ofF ilterOutputStream,\nof course, do some nontrivial processing of the bytes as they flow past. This chain can be tightly\nnested\u2014see its \u201cbrother\u201d class, FilterInputStream for more.\nNow let\u2019s examine each of the subclasses of FilterOutputStream in turn.\nBufferedOutputStream\nBufferedOutputStream is one of the most valuable of all streams. All it does is implement the full\ncomplement of OutputStream\u2019s methods, but it does so by using a buffered array of bytes that\n394\n030-4s CH19.i 394 1\/29\/96, 12:20 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#4 Sams.net Learning\nCenter\nabcd\nacts as a cache for writing. This decouples the rate and the size of the \u201cchunks\u201d you\u2019re writing\nfrom the more regular, larger block sizes in which streams are most efficiently written (to\nperipheral devices, files in the file system, or the network, for example).\nBufferedOutputStream is one of two classes in the Java library to implement flush(), which\npushes the bytes you\u2019ve written through the buffer and out the other side. Because buffering is\nso valuable, you might wish that every output stream could somehow be buffered. Fortunately,\nyou can surround any output stream in such a way as to achieve just that:\nOutputStream s = new BufferedOutputStream(new FileOutputStream(\u201cfoo\u201d));\nYou now have a buffered output stream based on the file \u201cfoo\u201d that can be flush()ed.\nJust as for filter input streams, any capability provided by a filter output stream can be used by\nany other basic stream via nesting and any combination of these capabilities, in any order, can\nbe as easily accomplished by nesting the filter streams themselves.\nDataOutputStream\nAll the methods that instances of this class understand are defined in a separate interface, which\nboth DataOutputStream and RandomAccessFile implement. This interface is general-purpose\nenough that you might want use it yourself in the classes you create. It is called DataOutput.\nThe DataOutput Interface\nIn cooperation with its \u201cbrother\u201d inverse interface, DataInput, DataOutput provides a higher- 19\nlevel, typed-stream approach to the reading and writing of data. Rather than dealing with bytes,\nthis interface deals with writing the primitive types of the Java language directly:\nvoid write(int i) throws IOException;\nvoid write(byte[] buffer) throws IOException;\nvoid write(byte[] buffer, int offset, int length) throws IOException;\nvoid writeBoolean(boolean b) throws IOException;\nvoid writeByte(int i) throws IOException;\nvoid writeShort(int i) throws IOException;\nvoid writeChar(int i) throws IOException;\nvoid writeInt(int i) throws IOException;\nvoid writeLong(long l) throws IOException;\nvoid writeFloat(float f) throws IOException;\nvoid writeDouble(double d) throws IOException;\nvoid writeBytes(String s) throws IOException;\nvoid writeChars(String s) throws IOException;\nvoid writeUTF(String s) throws IOException;\nMost of these methods have counterparts in the interface DataInput.\nThe first three methods mirror the three forms of write() you saw previously. Each of the next\neight methods write out a primitive type. The final three methods write out a string of bytes or\n395\n030-4s CH19.i 395 1\/29\/96, 12:21 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#3 MTWRFSS\nDDAAYY\n19 Streams\ncharacters to the stream: the first one as 8-bit bytes; the second, as 16-bit Unicode characters;\nand the last, as a special Unicode stream (readable by DataInput\u2019s readUTF()).\nNote: The unsigned read methods in DataInput have no counterparts here. You\ncan write out the data they need via DataOutput\u2019s signed methods because they\naccept int arguments and also because they write out the correct number of bits for\nthe unsigned integer of a given size as a side effect of writing out the signed integer\nof that same size. It is the method that reads this integer that must interpret the\nsign bit correctly; the writer\u2019s job is easy.\nNow that you know what the interface that DataOutputStream implements looks like, let\u2019s see\nit in action:\nDataOutputStream s = new DataOutputStream(getNumericOutputStream());\nlong size = getNumberOfItemsInNumericStream();\ns.writeLong(size);\nfor (int i = 0; i < size; ++i) {\nif (shouldProcessNumber(i)) {\ns.writeBoolean(true); \/\/ should process this item\ns.writeInt(theIntegerForItemNumber(i));\ns.writeShort(theMagicBitFlagsForItemNumber(i));\ns.writeDouble(theDoubleForItemNumber(i));\n} else\ns.writeBoolean(false);\n}\nThis is the exact inverse of the example that was given for DataInput. Together, they form a pair\nthat can communicate a particular array of structured primitive types across any stream (or\n\u201ctransport layer\u201d). Use this pair as a jumping-off point whenever you need to do something\nsimilar.\nIn addition to the interface above, the class itself implements one (self-explanatory) utility\nmethod:\nint theNumberOfBytesWrittenSoFar = s.size();\nProcessing a File\nOne of the most common idioms in file I\/O is to open a file, read and process it line-by-line,\nand output it again to another file. Here\u2019s a prototypical example of how that would be done\nin Java:\nDataInput aDI = new DataInputStream(new FileInputStream(\u201csource\u201d));\nDataOutput aDO = new DataOutputStream(new FileOutputStream(\u201cdest\u201d));\nString line;\n396\n030-4s CH19.i 396 1\/29\/96, 12:22 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#4 Sams.net Learning\nCenter\nabcd\nwhile ((line = aDI.readLine()) != null) {\nStringBuffer modifiedLine = new StringBuffer(line);\n. . . \/\/ process modifiedLine in place\naDO.writeBytes(modifiedLine.toString());\n}\naDI.close();\naDO.close();\nIf you want to process it byte-by-byte, use this:\ntry {\nwhile (true) {\nbyte b = (byte) aDI.readByte();\n. . . \/\/ process b in place\naDO.writeByte(b);\n}\n} finally {\naDI.close();\naDO.close();\n}\nHere\u2019s a cute two-liner that just copies the file:\ntry { while (true) aDO.writeByte(aDI.readByte()); }\nfinally { aDI.close(); aDO.close(); }\n!\n! Caution: Many of the examples in today\u2019s lesson (and the last two) assume that\nthey appear inside a method that has IOException in its throws clause, so they don\u2019t 19\nhave to \u201cworry\u201d about catching those exceptions and handling them more reason-\nably. Your code should be a little less cavalier.\nPrintStream\nYou may not realize it, but you\u2019re already intimately familiar with the use of two methods of the\nPrintStream class. That\u2019s because whenever you use these method calls:\nSystem.out.print(. . .)\nSystem.out.println(. . .)\nyou are actually using a PrintStream instance located in the System\u2019s class variable out to perform\nthe output. System.err is also a PrintStream, and System.in is an InputStream.\nNote: On UNIX systems, these three streams will be attached to standard output,\nstandard error, and standard input.\n397\n030-4s CH19.i 397 1\/29\/96, 12:23 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#3 MTWRFSS\nDDAAYY\n19 Streams\nPrintStream is uniquely an output stream class (it has no \u201cbrother\u201d). Because it is usually\nattached to a screen output device of some kind, it provides an implementation of flush(). It\nalso provides the familiar close() and write() methods, as well as a plethora of choices for\noutputting the primitive types and Strings of Java:\npublic void write(int b);\npublic void write(byte[] buffer, int offset, int length);\npublic void flush();\npublic void close();\npublic void print(Object o);\npublic void print(String s);\npublic void print(char[] buffer);\npublic void print(char c);\npublic void print(int i);\npublic void print(long l);\npublic void print(float f);\npublic void print(double d);\npublic void print(boolean b);\npublic void println(Object o);\npublic void println(String s);\npublic void println(char[] buffer);\npublic void println(char c);\npublic void println(int i);\npublic void println(long l);\npublic void println(float f);\npublic void println(double d);\npublic void println(boolean b);\npublic void println(); \/\/ output a blank line\nPrintStream can also be wrapped around any output stream, just like a filter class:\nPrintStream s = PrintStream(new FileOutputStream(\u201cfoo\u201d));\ns.println(\u201cHere\u2019s the first line of text in the file foo.\u201d);\nIf you provide a second argument to the constructor for PrintStream, it is a boolean that specifies\nwhether the stream should auto-flush. If true, a flush() is sent after each character is written\n(or for the three-argument form of write(), after a whole group of characters has been written.)\nHere\u2019s a simple example program that operates like the UNIX command cat, taking the\nstandard input, line-by-line, and outputting it to the standard output:\nimport java.io.*; \/\/ the one time in the chapter we\u2019ll say this\npublic class Cat {\npublic static void main(String args[]) {\nDataInput d = new DataInputStream(System.in);\nString line;\ntry { while ((line = d.readLine()) != null)\nSystem.out.println(line);\n398\n030-4s CH19.i 398 1\/29\/96, 12:23 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#4 Sams.net Learning\nCenter\nabcd\n} catch (IOException ignored) { }\n}\n}\nPipedOutputStream\nAlong with PipedInputStream, this pair of classes supports a UNIX-pipe-like connection\nbetween two threads, implementing all the careful synchronization that allows this sort of\n\u201cshared queue\u201d to operate safely. To set up the connection:\nPipedInputStream sIn = PipedInputStream();\nPipedOutputStream sOut = PipedOutputStream(sIn);\nOne thread writes to sOut, and the other reads from sIn. By setting up two such pairs, the threads\ncan communicate safely in both directions.\nRelated Classes\nThe other classes and interfaces in java.io supplement the streams to provide a complete I\/O\nsystem.\nThe File class abstracts \u201cfile\u201d in a platform-independent way. Given a filename, it can respond\nto queries about the type, status, and properties of a file or directory in the file system.\nA RandomAccessFile is created given a file, a filename, or a file descriptor. It combines in one class\nimplementations of the DataInput and DataOutput interfaces, both tuned for \u201crandom access\u201d 19\nto a file in the file system. In addition to these interfaces, RandomAccessFile provides certain\ntraditional UNIX-like facilities, such as seek()ing to a random point in the file.\nFinally, the StreamTokenizer class takes an input stream and produces a sequence of tokens. By\noverriding its various methods in your own subclasses, you can create powerful lexical parsers.\nYou can learn more about any and all of these classes from the full (online) API descriptions in\nyour Java release.\nSummary\nToday, you learned about the general idea of streams and met input streams based on byte arrays,\nfiles, pipes, sequences of other streams, and string buffers, as well as input filters for buffering,\ntyping data, line numbering, and pushing-back characters.\nYou also met the analogous \u201cbrother\u201d output streams for byte arrays, files, and pipes, and output\nfilters for buffering and typing data, and the unique output filter used for printing.\n399\n030-4s CH19.i 399 1\/29\/96, 12:24 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#3 MTWRFSS\nDDAAYY\n19 Streams\nAlong the way, you became familiar with the fundamental methods all streams understand (such\nas read() and write()), as well as the unique methods many streams add to this repertoire. You\nlearned about catching IOExceptions\u2014especially the most useful of them, EOFException.\nFinally, the twice-useful DataInput and DataOutput interfaces formed the heart of RandomAccessFile,\none of the several utility classes that round out Java\u2019s I\/O facilities.\nJava streams provide a powerful base on which you can build multithreaded, streaming\ninterfaces of the most complex kinds, and the programs (such as HotJava) to interpret them. The\nhigher-level Internet protocols and services of the future that your applets can build upon this\nbase are really limited only by your imagination.\nQ&A\nQ In an early read() example, you did something with the variable byteOrMinus1\nthat seemed a little clumsy. Isn\u2019t there a better way? If not, why recommend the\ncast later?\nA Yes, there is something a little odd about those statements. You might be tempted to\ntry something like this instead:\nwhile ((b = (byte) s.read()) != -1) {\n. . . \/\/ process the byte b\n}\nThe problem with this short-cut occurs when read() returns the value 0xFF (0377).\nSince this value is signed-extended before the test gets executed, it will appear to be\nidentical to the integer value -1 that indicates end of stream. Only saving that value in\na separate integer variable, and then casting it later, will accomplish the desired result.\nThe cast to byte is recommended in the note for orthogonal reasons\u2014storing integer\nvalues in correctly sized variables is always good style (and besides, read() really\nshould be returning something of byte size here and throwing an exception for end of\nstream).\nQ What input streams in java.io actually implement mark(), reset(), and\nmarkSupported()?\nA InputStream itself does\u2014and in their default implementations, markSupported()\nreturns false, mark() does nothing, and reset() throws an exception. The only input\nstream in the current release that correctly supports marking is BufferedInputStream,\nwhich overrides these defaults. LineNumberInputStream actually implements mark()\nand reset(), but in the current release, it doesn\u2019t answer markSupported() correctly, so\nit looks as if it does not.\n400\n030-4s CH19.i 400 1\/29\/96, 12:25 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#4 Sams.net Learning\nCenter\nabcd\nQ Why is available() useful, if it sometimes gives the wrong answer?\nA First, for many streams, it gives the right answer. Second, for some network streams,\nits implementation might be sending a special query to discover some information you\ncouldn\u2019t get any other way (for example, the size of a file being transferred by ftp). If\nyou were displaying a \u201cprogress bar\u201d for network or file transfers, for example,\navailable() would often give you the total size of the transfer, and if it did not\u2014\nusually by returning 0\u2014it would be obvious to you (and your users).\nQ What\u2019s a good example use of the DataInput\/DataOutput pair of interfaces?\nA One common use of such a pair is when objects want to \u201cpickle\u201d themselves for\nstorage or movement over a network. Each object implements read and write methods\nusing these interfaces, effectively converting itself to a stream that can later be recon-\nstituted \u201con the other end\u201d into a copy of the original object.\n19\n401\n030-4s CH19.i 401 1\/29\/96, 12:26 PM\nP2\/V4\/sqc5 TY Java in 21 Days 030-4 Casey 12.28.95 Ch19 LP#3 Sams.net Learning\nCenter\nabcd\n20\n20\nS\nS\nWEEK\nF 3\nR\nW\nNative Methods\nT\nand Libraries\nM 20\nby Charles L. Perkins\n403\n030-4s CH20.i 403 1\/29\/96, 12:29 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.28.95 Ch20 LP#3 MTWRFSS\nDDAAYY\n20 Native Methods and Libraries\nToday, you\u2019ll learn all the reasons you might (or might not) want to write native methods in\nJava, about all of Java\u2019s built-in optimizations, and about the tricks you can use to make your\nprograms faster. You\u2019ll also learn the procedure for creating, making headers and stubs for, and\nlinking native methods into a dynamically loadable library.\nLet\u2019s begin, however, with the reasons that you might want to implement native methods in\nthe first place.\nThere are only two reasons that you might need to declare some of your methods native, that\nis, implemented by a language other than Java.\nThe first, and by far the best reason to do so, is because you need to utilize a special capability\nof your computer or operating system that the Java class library does not already provide for you.\nSuch capabilities include interfacing to new peripheral devices or plug-in cards, accessing a\ndifferent type of networking, or using a unique, but valuable feature of your particular operating\nsystem. Two more concrete examples are acquiring real-time audio input from a microphone\nor using 3D \u201caccelerator\u201d hardware in a 3D library. Neither of these is provided to you by the\ncurrent Java environment, so you must implement them outside Java, in some other language\n(currently C or any language that can link with C).\nThe second, and often illusory reason to implement native methods, is speed\u2014illusory, because\nyou rarely need the raw speeds gained by this approach. It\u2019s even more rare to not be able to gain\nthat speed-up in other ways (as you\u2019ll see later today). Using native methods in this case takes\nadvantage of the fact that, at present, the Java release does not perform as well as, for example,\nan optimized C program on many tasks. For those tasks, you can write the \u201cneeds to be fast\u201d part\n(critical, inner loops, for example) in C, and still use a larger Java shell of classes to hide this\n\u201ctrick\u201d from your users. In fact, the Java class library uses this approach for certain critical system\nclasses to raise the overall level of efficiency in the system. As a user of the Java environment, you\ndon\u2019t even know (or see) any results of this (except, perhaps, a few classes or methods that are\nfinal that might not be otherwise).\nDisadvantages of native Methods\nOnce you decide you\u2019d like to, or must, use native methods in your program, this choice costs\nyou dearly. Although you gain the advantages mentioned earlier, you lose the portability of your\nJava code.\nBefore, you had a program (or applet) that could travel to any Java environment in the world,\nnow and forever. Any new architectures created\u2014or new operating systems written\u2014were\nirrelevant to your code. All it required was that the (tiny) Java Virtual Machine (or a browser\nthat had one inside it) be available, and it could run anywhere, anytime\u2014now and in the future.\n404\n030-4s CH20.i 404 1\/29\/96, 12:30 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.28.95 Ch20 LP#3 Sams.net Learning\nCenter\nabcd\nNow, however, you\u2019ve created a library of native code that must be linked with your program\nto make it work properly. The first thing you lose is the ability to \u201ctravel\u201d as an applet; you simply\ncan\u2019t be one! No Java-aware browser currently in existence allows native code to be loaded with\nan applet, for security reasons (and these are good reasons). The Java team has struggled to place\nas much as possible into the java packages because they are the only environment you can count\non as an applet. (The sun packages, shipped primarily for use with stand-alone Java programs,\nare not always available to applets.)\nNote: Actually, any classes that anyone writes without native code should be able to\nbe loaded with an applet, as long as they depend only on the java packages.\nUnfortunately, many of the sun packages contain classes that must use native code\nto provide crucial, missing functionality from the java packages. All these missing\npieces, and some additional multimedia and sound capabilities, will be added to the\njava packages in the future. (This has been informally promised in discussions I\u2019ve\nhad with the Java team.)\nLosing the ability to travel anywhere across the Net, into any browser written now or in the\nfuture, is bad enough. What\u2019s worse, now that you can\u2019t be an applet, you have further limited\nyourself to only those machines that have had the Java Virtual Machine ported to their operating\nsystem. (Applets automatically benefit from the wide number of machines and operating\nsystems that any Java-aware browser is ported to, but now you do not.)\nEven worse, you have assumed something about that machine and operating system by the\nimplementation of your native methods. This often means that you have to write different\nsource code for some (or all) of the machines and operating systems on which you want to be able\nto run. You\u2019re already forced, by using native methods, to produce a separate binary library for\nevery machine and operating system pair in the world (or at least, wherever you plan to run), 20\nand you must continue to do so forever. If changing the source is also necessary, you can see that\nthis is not a pleasant situation for you and your Java program.\nThe Illusion of Required Efficiency\nIf, even after the previous discussion, you must use native methods anyway, there\u2019s help for you\nlater in today\u2019s lesson\u2014but what if you\u2019re still thinking you need to use them for efficiency\nreasons?\nYou are in a grand tradition of programmers throughout the (relatively few) ages of computing.\nIt is exciting, and intellectually challenging, to program with constraints. If you believe\nefficiency is always required, it makes your job a little more interesting\u2014you get to consider all\n405\n030-4s CH20.i 405 1\/29\/96, 12:32 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.28.95 Ch20 LP#3 MTWRFSS\nDDAAYY\n20 Native Methods and Libraries\nsorts of baroque ways to accomplish tasks, because it is the efficient way to do it. I myself was\ncaught up in this euphoria of creativity when I first began programming, but it is creativity\nmisapplied.\nWhen you design your program, all that energy and creativity should be directed at the design\nof a tight, concise, minimal set of classes and methods that are maximally general, abstract, and\nreusable. (If you think that is easy, look around for a few years and see how bad most software\nis.) If you spend most of your programming time on thinking and rethinking these fundamental\ngoals and how to achieve them, you are preparing for the future. A future where software is\nassembled as needed from small components swimming in a sea of network facilities, and anyone\ncan write a component seen by millions (and reused in their programs) in minutes. If, instead,\nyou spend your energy worrying about the speed your software will run right now on some\ncomputer, you will be irrelevant after the 18 to 36 months it will take hardware to be fast enough\nto hide that minor inefficiency in your program.\nAm I saying that you should ignore efficiency altogether? Of course not! Some of the great\nalgorithms of computer science deal with solving hard or \u201cimpossible\u201d problems in reasonable\namounts of time\u2014and writing your programs carelessly can lead to remarkably slow results.\nThis, however, can as easily lead to incorrect, fragile, or nonreusable results. If you achieve all\nthose other goals first, the resulting software will be clean, will naturally reflect the structure of\nthe problem you\u2019re trying to solve, and thus will be amenable to \u201cspeeding up\u201d later.\nNote: There are always cases where you must be fanatical about efficiency in many\nparts of a set of classes. The Java class library itself is such a case, as is anything that\nmust run in real-time for some critical real-world application (such as flying a\nplane). Such applications are rare, however.\nWhen speaking of a new kind of programming that must soon emerge, Bill Joy, a\nfounder at Sun, likes to invoke the four S\u2019s of Java: small, simple, safe, and secure.\nThe \u201cfeel\u201d of the Java language itself encourages the pursuit of clarity and the\nreduction of complexity. The intense pursuit of efficiency, which increases com-\nplexity and reduces clarity, is antithetical to these goals.\nOnce you build a solid foundation, debug your classes, and your program (or applet) works as\nyou\u2019d like it to, then it\u2019s time to begin optimizing it. If it\u2019s just a user interface applet, you may\nneed to do nothing at all. The user is very slow compared to modern computers (and getting\nrelatively slower every 18 months). The odds are that your applet is already fast enough\u2014but\nsuppose it isn\u2019t.\n406\n030-4s CH20.i 406 1\/29\/96, 12:33 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.28.95 Ch20 LP#3 Sams.net Learning\nCenter\nabcd\nBuilt-In Optimizations\nYour next job is to see whether your release supports turning on the \u201cjust-in-time\u201d compiler, or\nusing the java2c tool.\nThe first of these is an experimental technology that, while a method\u2019s bytecodes are running\nin the Java Virtual Machine, translates each bytecode into the native binary code equivalent for\nthe local computer, and then keeps this native code around as a cache for the next time that\nmethod is run. This trick is completely transparent to the Java code you write. You need know\nnothing about whether or not it\u2019s being done\u2014your code can still \u201ctravel\u201d anywhere, anytime.\nOn any system with \u201cjust-in-time\u201d technology in place, however, it runs a lot faster. Experience\nwith experimental versions of this technology shows that, after paying a small cost the first time\na method is run, this technique can reach the speed of compiled C code.\nNote: More details on this technique, and the java2c tool, will be presented\ntomorrow. As of the beta release, neither of these tools are in the Java environment,\nbut both are expected in the final release.\nThe java2c translator takes a whole .class file full of the bytecodes for a class and translates them\n(all at once) into a portable C source code version. This version can then be compiled by a\ntraditional C compiler on your computer to produce a native-method-like cached library of fast\ncode. This large cache of native code will be used whenever the class\u2019s methods are called, but\nonly on the local computer. Your original Java code can still travel as bytecodes and run on any\nother computer system. If the virtual machine automatically takes these steps whenever it makes\nsense for a given class, this can be as transparent as the \u201cjust-in-time\u201d technology. Experience\nwith an experimental version of this tool shows that fully optimized C performance is achievable.\n(This is the best anyone can hope to do!) 20\nSo you see, even without taking any further steps to optimize your program, you may discover\nthat for your release of Java (or for releases elsewhere or coming in the near future), your code\nis already fast enough. If it is not, remember that the world craves speed. Java will only get faster,\nthe tools will only get better. Your code is the only permanent thing in this new world\u2014it should\nbe the best you can make it, with no compromises.\nSimple Optimization Tricks\nSuppose that these technologies aren\u2019t available or don\u2019t optimize your program far enough for\nyour taste. You can profile your applet or program as it runs, to see in which methods it spends\nthe most time. Once you know this crucial information, you can begin to make targeted changes\nto your classes.\n407\n030-4s CH20.i 407 1\/29\/96, 12:34 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.28.95 Ch20 LP#3 MTWRFSS\nDDAAYY\n20 Native Methods and Libraries\nTip: Use java -prof ... to produce this profile information. In an early release\n(and, presumably, the final release) the javaprof tool can \u201cpretty-print\u201d this\ninformation in a more readable format. (javaprof is not in the beta release\u2014but try\nthe latest Java release\u2019s documentation for details.)\nBefore you begin making optimizations, you also may want to save a copy of your\n\u201cclean\u201d classes. As soon as computer speeds allow it (or a major rewrite necessitates\nit), you can revert to these classes, which embody the \u201cbest\u201d implementation of\nyour program.\nFirst, identify the crucial few methods that take most of the time (there are almost always just\na few, and often just one, that take up the majority of your program\u2019s time). If they contain loops,\nexamine the inner loops to see whether they: call methods that can be made final, call a group\nof methods that can be collapsed into a single method, or create objects that can be reused rather\nthan created anew each loop.\nIf you notice that a long chain of, for example, four or more method calls is needed to reach a\ndestination method\u2019s code, and this execution path is in one of the critical sections of the\nprogram, you can \u201cshort-circuit\u201d directly to that destination method in the topmost method.\nThis may require adding a new instance variable to reference the object for that method call\ndirectly. This quite often violates layering or encapsulation constraints. This violation, and any\nadded complexity, is the price you pay for efficiency.\nIf, after all these tricks (and the numerous others you should try that have been collected over\nthe years into various programming books), your Java code is still just too slow, you will have\nto use native methods after all.\nWriting native Methods\nFor whatever reasons, you\u2019ve decided to add native methods to your program. You\u2019ve already\ndecided which methods need to be native, and in which classes, and you\u2019re rarin\u2019 to go.\nFirst, on the Java side, all you do is delete the method bodies (all the code between the brackets\n{ and } and the brackets themselves) of each method you picked and replace them with a single\nsemicolon (;). Then add the modifier native to the method\u2019s existing modifiers. Finally, add\na static (class) initializer to each class that now contains native methods to load the native code\nlibrary you\u2019re about to build. (You can pick any name you like for this library\u2014details follow.)\nYou\u2019re done!\n408\n030-4s CH20.i 408 1\/29\/96, 12:35 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.28.95 Ch20 LP#3 Sams.net Learning\nCenter\nabcd\nThat\u2019s all you need to do in Java to specify a native method. Subclasses of any class containing\nyour new native methods can still override them, and these new methods are called for instances\nof the new subclasses (just as you\u2019d expect).\nUnfortunately, what needs to be done in your native language environment is not so simple.\nNote: The following discussion assumes that C and UNIX are your language and\nenvironment. This means that some of the steps may differ slightly on your actual\nsystem, but such differences will be outlined in the notes surrounding the native\nmethod documentation in your release (in the document called Implementing\nNative Methods in the alpha, but folded into the programmer\u2019s tutorial in the\nbeta). The following discussion is purposely parallel to this documentation.\nThe Example Class\nImagine a version of the Java environment that does not provide file I\/O. Any Java program\nneeding to use the file system would first have to write native methods to get access to the\noperating system primitives needed to do file I\/O.\nThis example combines simplified versions of two actual Java library classes, java.io.File and\njava.io.RandomAccessFile, into a single new class, SimpleFile:\npublic class SimpleFile {\npublic static final char separatorChar = \u2018>\u2019;\nprotected String path;\nprotected int fd;\npublic SimpleFile(String s) {\npath = s; 20\n}\npublic String getFileName() {\nint index = path.lastIndexOf(separatorChar);\nreturn (index < 0) ? path : path.substring(index + 1);\n}\npublic String getPath() {\nreturn path;\n}\npublic native boolean open();\npublic native void close();\npublic native int read(byte[] buffer, int length);\npublic native int write(byte[] buffer, int length);\n409\n030-4s CH20.i 409 1\/29\/96, 12:36 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.28.95 Ch20 LP#3 MTWRFSS\nDDAAYY\n20 Native Methods and Libraries\nstatic {\nSystem.loadLibrary(\u201csimple\u201d); \/\/ runs when class first loaded\n}\n}\nNote: The unusual separatorChar (\u2018>\u2019) is used simply to demonstrate what an\nimplementation might look like on some strange computer whose file system didn\u2019t\nuse any of the more common path separator conventions. Early Xerox computers\nused \u2018>\u2019 as a separator, and several existing computer systems still use strange\nseparators today, so this is not all that farfetched.\nSimpleFiles can be created and used by other methods in the usual way:\nSimpleFile f = new SimpleFile(\u201c>some>path>and>fileName\u201d);\nf.open();\nf.read(...);\nf.write(...);\nf.close();\nThe first thing you notice about SimpleFile\u2019s implementation is how unremarkable the first\ntwo-thirds of its Java code is! It looks just like any other class, with a class and an instance variable,\na constructor, and two normal method implementations. Then there are four native method\ndeclarations. You\u2019ll recognize these, from previous discussions, as being just a normal method\ndeclaration with the code block replaced by a semicolon and the modifier native added. These\nare the methods you have to implement in C code later.\nFinally, there is a somewhat mysterious code fragment at the very end of the class. You should\nrecognize the general construct here as a static initializer. Any code between the brackets { and\n} is executed exactly once, when the class is first loaded into the system. You take advantage of\nthat fact to run something you want to run only once\u2014the loading of the native code library\nyou\u2019ll create later today. This ties together the loading of the class itself with the loading of its\nnative code. If either fails for some reason, the other fails as well, guaranteeing that no \u201chalf-set-\nup\u201d version of the class can ever be created.\nGenerating Header and Stub Files\nIn order to get your hands on Java objects and data types, and to be able to manipulate them\nin your C code, you need to include some special .h files. Most of these will be located in your\nrelease directory under the subdirectory called include. (In particular, look at native.h in that\ndirectory, and all the headers it points to, if you\u2019re a glutton for detail punishment.)\n410\n030-4s CH20.i 410 1\/29\/96, 12:36 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.28.95 Ch20 LP#3 Sams.net Learning\nCenter\nabcd\nSome of the special forms you need must be tailored to fit your class\u2019s methods precisely. That\u2019s\nwhere the javah tool comes in.\nUsing javah\nTo generate the headers you need for your native methods, first compile SimpleFile with javac,\njust as you normally would. This produces a file named SimpleFile.class. This file must be fed\nto the javah tool, which then generates the header file you need (SimpleFile.h).\nTip: If the class handed to javah is inside a package, it prepends the package name\nto the header file name (and to the structure names it generates inside that file),\nafter replacing all the dots (.) with underscores (_) in the package\u2019s full name.\nThus, if SimpleFile is contained in a hypothetical package called\nacme.widgets.files, javah generates a header file named\nacme_widgets_files_SimpleFile.h, and the various names within are renamed in a\nsimilar manner.\nWhen running javah, you should pass it only the class name itself, and not the\nfilename, which has .class on the end.\nThe Header File\nHere\u2019s the output of javah SimpleFile:\n\/* DO NOT EDIT THIS FILE - it is machine generated *\/\n#include <native.h>\n\/* Header for class SimpleFile *\/\n#ifndef _Included_SimpleFile 20\n#define _Included_SimpleFile\nstruct Hjava_lang_String;\ntypedef struct ClassSimpleFile {\n#define SimpleFile_separatorChar 62L\nstruct Hjava_lang_String *path;\nlong fd;\n} ClassSimpleFile;\nHandleTo(SimpleFile);\nextern \/*boolean*\/ long SimpleFile_open(struct HSimpleFile *);\nextern void SimpleFile_close(struct HSimpleFile *);\nextern long SimpleFile_read(struct HSimpleFile *,HArrayOfByte *,long);\nextern long SimpleFile_write(struct HSimpleFile *,HArrayOfByte *,long); #endif\n411\n030-4s CH20.i 411 1\/29\/96, 12:38 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.28.95 Ch20 LP#3 MTWRFSS\nDDAAYY\n20 Native Methods and Libraries\nNote: HandleTo() is a \u201cmagic\u201d macro that uses the structures created at run-time by\nthe stubs you\u2019ll generate later today.\nThe members of the struct generated above are in a one-to-one correspondence with the\nvariables of your class.\nIn order to \u201cmassage\u201d an instance of your class gently into the land of C, use the macro unhand()\n(as in \u201cunhand that Object!\u201d). For example, the this pseudo-variable in Java appears as a struct\nHSimpleFile * in the land of C, and to use any variables inside this instance (you), you must\nunhand() yourself first. You\u2019ll see some examples of this in a later section today.\nUsing javah -stubs\nTo \u201crun interference\u201d between the Java world of Objects, arrays, and other high-level constructs\nand the lower-level world of C, you need stubs.\nNEW* Stubs are pieces of \u201cglue\u201d code that automatically translate arguments and return values\nTERM back and forth between the worlds of Java and C.\nStubs can be automatically generated by javah, just like the headers. There isn\u2019t much you need\nto know about the stubs file, just that it has to be compiled and linked with the C code you write\nto allow it to interface with Java properly. A stubs file (SimpleFile.c) is created by running javah\non your class by using the option -stubs.\nNote: One interesting side-effect of stub generation is the creation of method\nsignatures, informally called method descriptions elsewhere. These signatures are\nquite useful\u2014they can be passed to special C functions that allow you to call back\ninto the Java world from C. You can use stub generation to learn what these\nsignatures look like for different method arguments and return values, and then use\nthat knowledge to call arbitrary Java methods from within your C code. (Brief\ndescriptions of these special C functions, along with further details, appear later\ntoday.)\nThe Stubs File\nHere\u2019s the result of running javah -stubs SimpleFile:\n\/* DO NOT EDIT THIS FILE - it is machine generated *\/\n#include <StubPreamble.h>\n412\n030-4s CH20.i 412 1\/29\/96, 12:39 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.28.95 Ch20 LP#3 Sams.net Learning\nCenter\nabcd\n\/* Stubs for class SimpleFile *\/\n\/* SYMBOL: \u201cSimpleFile\/open()Z\u201d, Java_SimpleFile_open_stub *\/\nstack_item *Java_SimpleFile_open_stub(stack_item *_P_,struct execenv *_EE_) {\nextern long SimpleFile_open(void *);\n_P_[0].i = SimpleFile_open(_P_[0].p);\nreturn _P_ + 1;\n}\n\/* SYMBOL: \u201cSimpleFile\/close()V\u201d, Java_SimpleFile_close_stub *\/\nstack_item *Java_SimpleFile_close_stub(stack_item *_P_,struct execenv *_EE_) {\nextern void SimpleFile_close(void *);\n(void) SimpleFile_close(_P_[0].p);\nreturn _P_;\n}\n\/* SYMBOL: \u201cSimpleFile\/read([BI)I\u201d, Java_SimpleFile_read_stub *\/\nstack_item *Java_SimpleFile_read_stub(stack_item *_P_,struct execenv *_EE_) {\nextern long SimpleFile_read(void *,void *,long);\n_P_[0].i = SimpleFile_read(_P_[0].p,((_P_[1].p)),((_P_[2].i)));\nreturn _P_ + 1;\n}\n\/* SYMBOL: \u201cSimpleFile\/write([BI)I\u201d, Java_SimpleFile_write_stub *\/\nstack_item *Java_SimpleFile_write_stub(stack_item *_P_,struct execenv *_EE_) {\nextern long SimpleFile_write(void *,void *,long);\n_P_[0].i = SimpleFile_write(_P_[0].p,((_P_[1].p)),((_P_[2].i)));\nreturn _P_ + 1;\n}\nEach comment line contains the method signature for one of the four native methods you\u2019re\nimplementing. You can use one of these signatures to call into Java and run, for example, a\nsubclass\u2019s overriding implementation of one of your native methods. More often, you\u2019d learn\nand use a signature to call some useful Java method from within C to get something done in the\nJava world.\nYou do this by calling a special C function in the Java run-time called\nexecute_java_dynamic_method(). Its arguments include the target object of the method call and\nthe method\u2019s signature. The general form of a fully qualified method signature is any\/package\/\nname\/ClassName\/methodName(...)X. (You can see several in the last example, where SimpleFile\n20\nis the class name and there is no package name.) The X is a letter (or string) that represents the\nreturn type, and the ... contains a string that represents each of the argument\u2019s types in turn.\nHere are the letters (and strings) used, and the types they represent, in the example: [T is array\nof type T, B is byte, I is int, V is void, and Z is boolean.\nThe method close(), which takes no arguments and returns void, is represented by the string\n\u201cSimpleFile\/close()V\u201d and its inverse, open(), that returns a boolean instead, is represented by\n\u201cSimpleFile\/open()Z.\u201d Finally, read(), which takes an array of bytes and an int as its two\narguments and returns an int, is \u201cSimpleFile\/read([BI)I.\u201d (See the \u201cMethod Signatures\u201d\nsection in tomorrow\u2019s lesson for the full details.)\n413\n030-4s CH20.i 413 1\/29\/96, 12:40 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.28.95 Ch20 LP#3 MTWRFSS\nDDAAYY\n20 Native Methods and Libraries\nCreating SimpleFileNative.c\nNow you can, at last, write the C code for your Java native methods.\nThe header file generated by javah, SimpleFile.h, gives you the prototypes of the four C\nfunctions you need to implement to make your native code complete. You then write some C\ncode that provides the native facilities that your Java class needs (in this case, some low-level file\nI\/O routines). Finally, you assemble all the C code into a new file, include a bunch of required\n(or useful) .h files, and name it SimpleFileNative.c. Here\u2019s the result:\n#include \u201cSimpleFile.h\u201d \/* for unhand(), among other things *\/\n#include <sys\/param.h> \/* for MAXPATHLEN *\/\n#include <fcntl.h> \/* for O_RDWR and O_CREAT *\/\n#define LOCAL_PATH_SEPARATOR \u2018\/\u2019 \/* UNIX *\/\nstatic void fixSeparators(char *p) {\nfor (; *p != \u2018\\0\u2019; ++p)\nif (*p == SimpleFile_separatorChar)\n*p = LOCAL_PATH_SEPARATOR;\n}\nlong SimpleFile_open(struct HSimpleFile *this) {\nint fd;\nchar buffer[MAXPATHLEN];\njavaString2CString(unhand(this)->path, buffer, sizeof(buffer));\nfixSeparators(buffer);\nif ((fd = open(buffer, O_RDWR | O_CREAT, 0664)) < 0) \/* UNIX open *\/\nreturn(FALSE); \/* or, SignalError() could throw an exception *\/\nunhand(this)->fd = fd; \/* save fd in the Java world *\/\nreturn(TRUE);\n}\nvoid SimpleFile_close(struct HSimpleFile *this) {\nclose(unhand(this)->fd);\nunhand(this)->fd = -1;\n}\nlong SimpleFile_read(struct HSimpleFile *this, HArrayOfByte *buffer,\nl o ng co u n t) { (cid:229)\nchar *data = unhand(buffer)->body; \/* get array data *\/\nint len = obj_length(buffer); \/* get array length *\/\nint numBytes = (len < count ? len : count);\nif ((numBytes = read(unhand(this)->fd, data, numBytes)) == 0)\nreturn(-1);\nreturn(numBytes); \/* the number of bytes actually read *\/\n}\n414\n030-4s CH20.i 414 1\/29\/96, 12:40 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.28.95 Ch20 LP#3 Sams.net Learning\nCenter\nabcd\nlong SimpleFile_write(struct HSimpleFile *this, HArrayOfByte *buffer,\nl o ng co u n t) { (cid:229)\nchar *data = unhand(buffer)->body;\nint len = obj_length(buffer);\nreturn(write(unhand(this)->fd, data, (len < count ? len : count)));\n}\nOnce you finish writing your .c file, compile it by using your local C compiler (usually called\ncc or gcc). On some systems, you may need to specify special compilation flags that mean \u201cmake\nit relocatable and dynamically linkable.\u201d\nNote: If you don\u2019t have a C compiler on your computer, you can always buy one.\nYou also could get a copy of the GNU C compiler (gcc), one of the best C compil-\ners in the world, which runs on almost every machine and operating system on the\nplanet. The best way to get gcc is to buy the \u201cGNU release\u201d on CD-ROM, the\nprofits of which go to support the Free Software Foundation. You can find both\nthe GNU CD-ROM and the Linux CD-ROM (which includes GNU) in select\nplaces that sell software or technical books, or you can contact the F.S.F. directly.\nThe GNU CD-ROM is a bit pricey, and, though the Linux CD-ROM is very\ninexpensive, if you can\u2019t afford either, or want the latest version and already own a\nCD-ROM, you can download the gzip file ftp:\/\/prep.ai.mit.edu\/pub\/gnu\/gcc-\n2.7.0.tar.gz, which contains all 7M of the latest gcc release. (If you\u2019d like to make\na donation to, or buy gcc or its manual from, the F.S.F., you can e-mail them at\ngnu@prep.ai.mit.edu or call 617.542.5942.)\nSome Useful Functions\n20\nWhen writing the C code for native implementations, a whole set of useful (internal) macros\nand functions are available for accessing Java run-time structures. (Several of them were used in\nSimpleFileNative.c.)\nLet\u2019s take a brief digression to understand some of them a little better.\n!\n! Warning: Don\u2019t rely on the exact form given for any of the following macros and\nfunctions. Because they\u2019re all internal to the Java run-time, they\u2019re subject to change\nat any moment. Check to see what the latest versions of them look like in your Java\nrelease before using them.\n415\n030-4s CH20.i 415 1\/29\/96, 12:41 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.28.95 Ch20 LP#3 MTWRFSS\nDDAAYY\n20 Native Methods and Libraries\nNote: The following brief descriptions are taken from an alpha release of Java,\nbecause descriptions of them for the beta release were not available as of this\nwriting. How Java data types map into C types, and vice versa, is detailed in the\ndocumentation there. Refer to it for more details on that or on any of the sparsely\ndocumented items below. (Many are listed just to give you a taste of the capabilities\nof the available functions.)\nThe following example:\nObject *unhand(Handle *)\nint obj_length(HArray *)\nreturns a pointer to the data portion of an object and returns the length of an array. The actual\npointer type returned is not always Object *, but varies, depending on the type of Handle (or\nHArray).\nThis example:\nClassClass *FindClass(struct execenv *e, char *name, bool_t resolve)\nHArrayOfChar *MakeString(char *string, long length)\nHandle *ArrayAlloc(int type, int length)\nfinds a class (given its name), makes an array of characters of length length and allocates an array\nof the given length and type.\nUse the function:\nlong execute_java_dynamic_method(ExecEnv *e, HObject *obj, char *method_name,\nch a r * s i g na t u re , .. . ) ; (cid:229)\nto call a Java method from C. e is NULL to use the current environment. The target of the method\ncall is obj. The method method_name has the given method signature. It can have any number\nof arguments and returns a 32-bit value (int, Handle *, or any 32-bit C type).\nUse the following:\nHObject *execute_java_constructor(ExecEnv *e, char *classname, ClassClass *c,\nch a r * s i g na t u re , .. . ) ; (cid:229)\nlong execute_java_static_method(ExecEnv *e, ClassClass *c, char *method_name,\nch a r * s i g na t u re , .. . ) ; (cid:229)\nto call a Java constructor from C and call a class method from C. c is the target class; the rest are\nas in executemethod().\nCalling this:\nSignalError(0, JAVAPKG \u201cExceptionClassName\u201d, \u201cmessage\u201d);\n416\n030-4s CH20.i 416 1\/29\/96, 12:42 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.28.95 Ch20 LP#3 Sams.net Learning\nCenter\nabcd\nposts a Java exception that will be thrown when your native method returns. It is somewhat like\nthe Java code:\nthrow new ExceptionClassName(\u201cmessage\u201d);\nFinally, here are some useful string conversion functions:\nvoid javaStringPrint(Hjava_lang_String *s)\nint javaStringLength(Hjava_lang_String *s)\nHjava_lang_String *makeJavaString(char *string, int length)\nchar *makeCString(Hjava_lang_String *s)\nchar *allocCString(Hjava_lang_String *s)\nunicode *javaString2unicode(Hjava_lang_String *s, unicode *buf, int len)\nchar *javaString2CString(Hjava_lang_String *s, char *buf, int len)\nThe first two methods print a Java String (like System.out.print()), and get its length,\nrespectively. The third makes a Java String out of a C string. The fourth and fifth do the reverse,\nturning a Java String into a C string (allocated from temporary or heap storage, respectively).\nThe final two methods copy Java Strings into preexisting Unicode or ASCII C buffers.\nCompiling the Stubs File\nThe final step you need to take in the C world is to compile the stubs file SimpleFile.c by using\nthe same compilation flags you used for SimpleFileNative.c.\nNote: If you have several classes with native methods, you can include all their\nstubs in the same .c file, if you like. Of course you might want to name it some-\nthing else, such as Stubs.c, in that case.\n20\nYou\u2019re now finished with all the C code that must be written (and compiled) to make your\nloadable native library.\nA Native Library\nNow you\u2019ll finally be able to tie everything together and create the native library, simple, that\nwas assumed to exist at the beginning of today\u2019s lesson.\n417\n030-4s CH20.i 417 1\/29\/96, 12:43 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.28.95 Ch20 LP#3 MTWRFSS\nDDAAYY\n20 Native Methods and Libraries\nLinking It All\nIt\u2019s time to link everything you\u2019ve done into a single library file. This looks a little different on\neach system that Java runs on, but here\u2019s the basic idea, in UNIX syntax:\ncc -G SimpleFile.o SimpleFileNative.o -o simple\nThe -G flag tells the linker that you\u2019re creating a dynamically linkable library; the details differ\nfrom system to system.\nNote: By naming the library simple, you\u2019re disobeying a UNIX convention that\ndynamic library names should have the prefix lib and the suffix .so (on your system,\nthese prefixes and suffixes may differ). You can call your library libsimple.so to\nobey the convention, if you like, but just for the clarity of this example, the simpler\nname is used.\nUsing Your Library\nNow, when the Java class SimpleFile is first loaded into your program, the System class attempts\nto load the library named simple, which (luckily) you just created. Look back at the Java code\nfor SimpleFile to remind yourself.\nHow does it locate it? It calls the dynamic linker, which consults an environment variable named\nLD_LIBRARY_PATH that tells it which sequence of directories to search when loading new libraries\nof native code. Because the current directory is in Java\u2019s load path by default, you can leave\n\u201csimple\u201d in the current directory, and it will work just fine.\nSummary\nToday, you learned about the numerous disadvantages of using native methods, about the\nmany ways that Java (and you) can make your programs run faster, and also about the often\nillusory need for efficiency.\nFinally, you learned the procedure for creating native methods, from both the Java and the C\nsides, in detail\u2014by generating header files and stubs, and by compiling and linking a full\nexample.\nAfter working your way through today\u2019s difficult material, you\u2019ve mastered one of the most\ncomplex parts of the Java language. You now know how the Java run-time environment itself\nwas created, and how to extend that powerful environment yourself, at its lowest levels.\n418\n030-4s CH20.i 418 1\/29\/96, 12:44 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.28.95 Ch20 LP#3 Sams.net Learning\nCenter\nabcd\nAs a reward, tomorrow you look \u201cunder the hood\u201d to see some of the hidden power of Java, and\nyou can just sit back and enjoy the ride.\nQ&A\nQ What can I use to supplement the \u201cImplementing Native Methods\u201d document\nyou recommended?\nA Looking online is highly recommended. Nearby and within \u201cImplementing Native\nMethods\u201d is a Makefile, other related build information, and a more detailed version\nof both the next example in this book and its explanation. This following discussion\nwill be enough to get you started on your first native methods.\nQ Does the Java class library need to call System.loadLibrary() to load the built-in\nclasses?\nA No, you won\u2019t see any loadLibrary() calls in the implementation of any classes in the\nJava class library. That\u2019s because the Java team had the luxury of being able to stati-\ncally link most of their code into the Java environment, something that really makes\nsense only when you\u2019re in the unique position of providing an entire system, as they\nare. Your classes must dynamically link their libraries into an already-running copy of\nthe Java system. This is, by the way, more flexible than static linking; it allows you to\nunlink old and relink new versions of your classes at any time, making updating them\ntrivial.\nQ Can I statically link my own classes into Java like the Java team did?\nA Yes. You can, if you like, ask Sun Microsystems for the sources to the Java run-time\nenvironment itself, and, as long as you obey the (relatively straightforward) legal\nrestrictions on using that code, you can relink the entire Java system plus your classes.\nYour classes are then statically linked into the system, but you have to give everyone\nwho wants to use your program this special version of the Java environment. Some- 20\ntimes, if you have strong enough requirements, this is the only way to go, but most of\nthe time, dynamic linking is not only good enough, but preferable.\nQ My applet needs some key functionality, missing from the Java library. Given\ntheir many disadvantages, I\u2019d like to avoid using native methods. Do I have any\nalternatives?\nA Because it\u2019s still early in the history of Java, a valid alternative to native methods is to\ntry to convince the Java team that your needed capability is of interest to a broad\nrange of future Java programmers; then they may include it directly into the java\npackages. There are already plans to do this with certain \u201cmissing\u201d pieces of function-\nality, so this may not be as hard a sell as you might think. Start by posting some\nmessages to the comp.lang.java newsgroup, to be sure no one else at Sun or elsewhere\nis already doing it, and then see what happens. This is a young, vibrant community of\nenthusiasts; you are not alone.\n419\n030-4s CH20.i 419 1\/29\/96, 12:46 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.28.95 Ch20 LP#3 Sams.net Learning\nCenter\nabcd\n21\n21\nS\nS\nWEEK\nF 3\nR\nW\nUnder the Hood\nT\nM\nby Charles L. Perkins\n21\n421\n030-4s CH21.i 421 1\/29\/96, 12:47 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nOn today, your final day, the inner workings of the Java system will be revealed.\nYou\u2019ll find out all about Java\u2019s vision, Java\u2019s virtual machine, those bytecodes you\u2019ve heard so\nmuch about, that mysterious garbage collector, and why you might worry about security but\ndon\u2019t have to.\nLet\u2019s begin, however, with the big picture.\nThe Big Picture\nThe Java team is very ambitious. Their ultimate goal is nothing less than to revolutionize the way\nsoftware is written and distributed. They\u2019ve started with the Internet, where they believe much\nof the interesting software of the future will live.\nTo achieve such an ambitious goal, a large fraction of the Internet programming community\nitself must be marshalled behind a similar goal and given the tools to help achieve it. The Java\nlanguage, with its four S\u2019s (small, simple, safe, secure), and its flexible, net-oriented environ-\nment, hopes to become the focal point for the rallying of this new legion of programmers.\nTo this end, Sun Microsystems has done something rather gutsy. What was originally a secret,\ntens-of-millions-of-dollars research and development project, and 100 percent proprietary, has\nbecome a free, open, and relatively unencumbered technology standard upon which anyone can\nbuild. They are literally giving it away and reserving only the rights they need to maintain and\ngrow the standard.\nNote: Actually, as Sun\u2019s lawyers have more and more time to think, the original\nintentions of the Java team get further obscured by legal details. It is still relatively\nunencumbered, but its earlier releases were completely unencumbered. Let\u2019s hope\nthat this is not a pattern that will continue.\nAny truly open standard must be supported by at least one excellent, freely available \u201cdemon-\nstration\u201d implementation. Sun has already shipped an alpha, and now a beta, of one to the\nInternet and plans on a final release soon. In parallel, several universities, companies, and\nindividuals have already expressed their intention to duplicate the Java environment, based on\nthe open API that Sun has created.\nSeveral other languages are even contemplating compiling down to Java bytecodes, to help\nsupport them in becoming a more robust and commonplace standard for moving executable\ncontent around on the Net.\n422\n030-4s CH21.i 422 1\/29\/96, 12:48 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\nWhy It\u2019s a Powerful Vision\nOne of the reasons this brilliant move on Sun\u2019s part has a real chance of success is the pent-up\nfrustration of literally a whole generation of programmers who desperately want to share their\ncode with one another. Right now, the computer science world is balkanized into factions at\nuniversities and companies all over the world, with hundreds of languages, dozens of them\nwidely used, dividing and separating us all. It\u2019s the worst sort of Tower of Babel. Java hopes to\nbuild some bridges and help tear down that tower. Because it is so simple, because it\u2019s so useful\nfor programming over the Internet, and because the Internet is so \u201chot\u201d right now\u2014this\nconfluence of forces should help propel Java onto centerstage.\nIt deserves to be there. It is the natural outgrowth of ideas that, since the early 1970s inside the\nSmalltalk group at Xerox PARC, have lain relatively dormant in the mainstream. Smalltalk, in\nfact, invented the first object-oriented bytecode interpreter and pioneered many of the deep\nideas that Java builds on today. Those efforts were not embraced over the intervening decades\nas a solution to the general problems of software, however. Today, with those problems\nbecoming so much more obvious, and with the Net crying out for a new kind of programming,\nthe soil is fertile to grow something stronger from those old roots, something that just might\nspread like wildfire. (Is it a coincidence that Java\u2019s previous internal names were Green and\nOAK?)\nThis new vision of software is one in which the Net becomes an ocean of objects, classes, and\nthe open APIs between them. Traditional applications have vanished, replaced by skeletal\nframeworks like the Eiffel tower, into which can be fitted any parts from this ocean, on demand,\nto suit any purpose. User interfaces will be mixed and matched, built in pieces and constructed\nto taste, whenever the need arises, by their own users. Menus of choices will be filled by dynamic\nlists of all the choices available for that function, at that exact moment, across the entire ocean\n(of the Net).\nIn such a world, software distribution is no longer an issue. Software will be everywhere and will\nbe paid for via a plethora of new micro-accounting models, which charge tiny fractions of cents\nfor the parts as they are assembled and used. Frameworks will come into existence to support\nentertainment, business, and the social (cyber-)spaces of the near future.\nThis is a dream that many of us have waited all our lives to be a part of. There are tremendous\nchallenges to making it all come true, but the powerful winds of change we all feel must stir us 21\ninto action, because, at last, there is a base on which to build that dream\u2014Java.\nThe Java Virtual Machine\nTo make visions like this possible, Java must be ubiquitous. It must be able to run on any\ncomputer and any operating system\u2014now, and in the future. In order to achieve this level of\nportability, Java must be very precise not only about the language itself, but about the\n423\n030-4s CH21.i 423 1\/29\/96, 12:49 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nenvironment in which the language lives. You can see, from earlier in the book and Appendix\nB, that the Java environment includes a generally useful set of packages of classes and a freely\navailable implementation of them. This takes care of a part of what is needed, but it is crucial\nalso to specify exactly how the run-time environment of Java behaves.\nThis final requirement is what has stymied many attempts at ubiquity in the past. If you base\nyour system on any assumptions about what is \u201cbeneath\u201d the run-time system, you lose. If you\ndepend in any way on the computer or operating system below, you lose. Java solves this problem\nby inventing an abstract computer of its own and running on that.\nThis \u201cvirtual\u201d machine runs a special set of \u201cinstructions\u201d called bytecodes that are simply a\nstream of formatted bytes, each of which has a precise specification of exactly what each bytecode\ndoes to this virtual machine. The virtual machine is also responsible for certain fundamental\ncapabilities of Java, such as object creation and garbage collection.\nFinally, in order to be able to move bytecodes safely across the Internet, you need a bulletproof\nmodel of security\u2014and how to maintain it\u2014and a precise format for how this stream of\nbytecodes can be sent from one virtual machine to another.\nEach of these requirements is addressed in today\u2019s lesson.\nNote: This discussion blurs the distinction between the run-time and the virtual\nmachine of Java. This is intentional but a little unconventional. Think of the\nvirtual machine as providing all the capabilities, even those that are conventionally\nassigned to the run-time. This book uses the words \u201crun-time\u201d and \u201cvirtual\nmachine\u201d interchangeably. Equating the two highlights the single environment that\nmust be created to support Java.\nMuch of the following description is based closely on the alpha \u201cVirtual Machine\nSpecifications\u201d documents (and the beta bytecodes), so if you delve more deeply\ninto the details online, you will cover some familiar ground.\nAn Overview\nIt is worth quoting the introduction to the Java virtual machine documentation here, because\nit is so relevant to the vision outlined earlier:\nThe Java virtual machine specification has a purpose that is both like and unlike\nequivalent documents for other languages and abstract machines. It is intended to\npresent an abstract, logical machine design free from the distraction of inconsequential\n424\n030-4s CH21.i 424 1\/29\/96, 12:50 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\ndetails of any implementation. It does not anticipate an implementation technology,\nor an implementation host. At the same time it gives a reader sufficient information to\nallow implementation of the abstract design in a range of technologies.\nHowever, the intent of the [...] Java project is to create a language [...] that will allow\nthe interchange over the Internet of \u201cexecutable content,\u201d which will be embodied by\ncompiled Java code. The project specifically does not want Java to be a proprietary\nlanguage and does not want to be the sole purveyor of Java language implementations.\nRather, we hope to make documents like this one, and source code for our implemen-\ntation, freely available for people to use as they choose.\nThis vision [...] can be achieved only if the executable content can be reliably shared\nbetween different Java implementations. These intentions prohibit the definition of\nthe Java virtual machine from being fully abstract. Rather, relevant logical elements of\nthe design have to be made sufficiently concrete to allow the interchange of compiled\nJava code. This does not collapse the Java virtual machine specification to a descrip-\ntion of a Java implementation; elements of the design that do not play a part in the\ninterchange of executable content remain abstract. But it does force us to specify, in\naddition to the abstract machine design, a concrete interchange format for compiled\nJava code.\nThe Java virtual machine specification consists of the following:\nnn The bytecode syntax, including opcode and operand sizes, values, and types, and their\nalignment and endian-ness\nnn The values of any identifiers (for example, type identifiers) in bytecodes or in support-\ning structures\nnn The layout of the supporting structures that appear in compiled Java code (for\nexample, the constant pool)\nnn The Java .class file format\nEach of these is covered today.\nDespite this degree of specificity, there are still several elements of the design that remain\n(purposely) abstract, including the following:\nnn The layout and management of the run-time data areas 21\nnn The particular garbage-collection algorithms, strategies, and constraints used\nnn The compiler, development environment, and run-time extensions (apart from the\nneed to generate and read valid Java bytecodes)\nnn Any optimizations performed, once valid bytecodes are received\nThese places are where the creativity of a virtual machine implementor has full rein.\n425\n030-4s CH21.i 425 1\/29\/96, 12:50 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nThe Fundamental Parts\nThe Java virtual machine can be deconstructed into five fundamental pieces:\nnn A bytecode instruction set\nnn A set of registers\nnn A stack\nnn A garbage-collected heap\nnn An area for storing methods\nThese might be implemented by using an interpreter, a native binary code compiler, or even a\nhardware chip\u2014but all these logical, abstract components of the virtual machine must be\nsupplied in some form in every Java system.\nNote: The memory areas used by the Java virtual machine are not required to be at\nany particular place in memory, to be in any particular order, or even to use\ncontiguous memory. However, all but the method area must be able to represent\n32-bit values (for example, the Java stack is 32 bits wide).\nThe virtual machine, and its supporting code, is often referred to as the run-time environment,\nand when this book refers to something being done at run-time, the virtual machine is what\u2019s\ndoing it.\nJava Bytecodes\nThe Java virtual machine instruction set is optimized to be small and compact. It is designed to\ntravel across the Net, and so has traded off speed-of-interpretation for space. (Given that both\nNet bandwidth and mass storage speeds increase less rapidly than CPU speed, this seems like\nan appropriate trade-off.)\nAs mentioned, Java source code is \u201ccompiled\u201d into bytecodes and stored in a .class file. On Sun\u2019s\nJava system, this is performed using the javac tool. It is not exactly a traditional \u201ccompiler,\u201d\nbecause javac translates source code into bytecodes, a lower-level format that cannot be run\ndirectly, but must be further interpreted by each computer. Of course, it is exactly this level of\n\u201cindirection\u201d that buys you the power, flexibility, and extreme portability of Java code.\n426\n030-4s CH21.i 426 1\/29\/96, 12:51 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\nNote: Quotation marks are used around the word \u201ccompiler\u201d when talking about\njavac because later today you will also learn about the \u201cjust-in-time\u201d compiler,\nwhich acts more like the back end of a traditional compiler. The use of the same\nword \u201ccompiler\u201d for these two different pieces of Java technology is unfortunate,\nbut somewhat reasonable, because each is really one-half (either the front or the\nback end) of a more traditional compiler.\nA bytecode instruction consists of a one-byte opcode that serves to identify the instruction\ninvolved and zero or more operands, each of which may be more than one byte long, that encode\nthe parameters the opcode requires.\nNote: When operands are more than one byte long, they are stored in big-endian\norder, high-order byte first. These operands must be assembled from the byte\nstream at run-time. For example, a 16-bit parameter appears in the stream as two\nbytes so that its value is first_byte * 256 + second_byte. The bytecode instruc-\ntion stream is only byte-aligned, and alignment of any larger quantities is not\nguaranteed (except for \u201cwithin\u201d the special bytecodes lookupswitch and\ntableswitch, which have special alignment rules of their own).\nBytecodes interpret data in the run-time\u2019s memory areas as belonging to a fixed set of types: the\nprimitive types you\u2019ve seen several times before, consisting of several signed integer types (8-bit\nbyte, 16-bit short, 32-bit int, 64-bit long), one unsigned integer type (16-bit char), and two\nsigned floating-point types (32-bit float, 64-bit double), plus the type \u201creference to an object\u201d\n(a 32-bit pointer-like type). Some special bytecodes (for example, the dup instructions), treat\nrun-time memory areas as raw data, without regard to type. This is the exception, however, not\nthe rule.\nThese primitive types are distinguished and managed by the compiler, javac, not by the Java\nrun-time environment. These types are not \u201ctagged\u201d in memory, and thus cannot be distin-\nguished at run-time. Different bytecodes are designed to handle each of the various primitive\n21\ntypes uniquely, and the compiler carefully chooses from this palette based on its knowledge of\nthe actual types stored in the various memory areas. For example, when adding two integers, the\ncompiler generates an iadd bytecode; for adding two floats, fadd is generated. (You\u2019ll see all this\nin gruesome detail later.)\n427\n030-4s CH21.i 427 1\/29\/96, 12:52 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nRegisters\nThe registers of the Java virtual machine are just like the registers inside a \u201creal\u201d computer.\nNEW* Registers hold the machine\u2019s state, affect its operation, and are updated after each\nTERM bytecode is executed.\nThe following are the Java registers:\nnn pc, the program counter, which indicates what bytecode is being executed\nnn optop, a pointer to the top of the operand stack, which is used to evaluate all arith-\nmetic expressions\nnn frame, a pointer to the execution environment of the current method, which includes\nan activation record for this method call and any associated debugging information\nnn vars, a pointer to the first local variable of the currently executing method\nThe virtual machine defines these registers to be 32 bits wide.\nNote: Because the virtual machine is primarily stack-based, it does not use any\nregisters for passing or receiving arguments. This is a conscious choice skewed\ntoward bytecode simplicity and compactness. It also aids efficient implementation\non register-poor architectures, which most of today\u2019s computers, unfortunately, are.\nPerhaps when the majority of CPUs out there are a little more sophisticated, this\nchoice will be reexamined, though simplicity and compactness may still be reason\nenough!\nBy the way, the pc register is also used when the run-time handles exceptions; catch\nclauses are (ultimately) associated with ranges of the pc within a method\u2019s\nbytecodes.\nThe Stack\nThe Java virtual machine is stack-based. A Java stack frame is similar to the stack frame of a\nconventional programming language\u2014it holds the state for a single method call. Frames for\nnested method calls are stacked on top of this frame.\nNEW* The stack is used to supply parameters to bytecodes and methods, and to\nTERM receive results back from them.\n428\n030-4s CH21.i 428 1\/29\/96, 12:54 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\nEach stack frame contains three (possibly empty) sets of data: the local variables for the method\ncall, its execution environment, and its operand stack. The sizes of these first two are fixed at the\nstart of a method call, but the operand stack varies in size as bytecodes are executed in the\nmethod.\nLocal variables are stored in an array of 32-bit slots, indexed by the register vars. Most types take\nup one slot in the array, but the long and double types each take up two slots.\nNote: long and double values, stored or referenced via an index N, take up the (32-\nbit) slots N and N + 1. These 64-bit values are thus not guaranteed to be 64-bit-\naligned. Implementors are free to decide the appropriate way to divide these values\namong the two slots.\nThe execution environment in a stack frame helps to maintain the stack itself. It contains a\npointer to the previous stack frame, a pointer to the local variables of the method call, and\npointers to the stack\u2019s current \u201cbase\u201d and \u201ctop.\u201d Additional debugging information can also be\nplaced into the execution environment.\nThe operand stack, a 32-bit first-in-first-out (FIFO) stack, is used to store the parameters and\nreturn values of most bytecode instructions. For example, the iadd bytecode expects two integers\nto be stored on the top of the stack. It pops them, adds them together, and pushes the resulting\nsum back onto the stack.\nEach primitive data type has unique instructions that know how to extract, operate, and push\nback operands of that type. For example, long and double operands take two \u201cslots\u201d on the stack,\nand the special bytecodes that handle these operands take this into account. It is illegal for the\ntypes on the stack and the instruction operating on them to be incompatible (javac outputs\nbytecodes that always obey this rule).\nNote: The top of the operand stack and the top of the overall Java stack are almost\nalways the same. Thus, \u201cthe stack,\u201d refers to both stacks, collectively.\n21\nThe Heap\nThe heap is that part of memory from which newly created instances (objects) are allocated.\nIn Java, the heap is often assigned a large, fixed size when the Java run-time system is started,\nbut on systems that support virtual memory, it can grow as needed, in a nearly unbounded\nfashion.\n429\n030-4s CH21.i 429 1\/29\/96, 12:55 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nBecause objects are automatically garbage-collected in Java, programmers do not have to\n(and, in fact, cannot) manually free the memory allocated to an object when they are finished\nusing it.\nJava objects are referenced indirectly in the run-time, via handles, which are a kind of pointer\ninto the heap.\nBecause objects are never referenced directly, parallel garbage collectors can be written that\noperate independently of your program, moving around objects in the heap at will. You\u2019ll learn\nmore about garbage collection later.\nThe Method Area\nLike the compiled code areas of conventional programming language environments, or the\nTEXT segment in a UNIX process, the method area stores the Java bytecodes that implement\nalmost every method in the Java system. (Remember that some methods might be native, and\nthus implemented, for example, in C.) The method area also stores the symbol tables needed\nfor dynamic linking, and any other additional information debuggers or development environ-\nments which might want to associate with each method\u2019s implementation.\nBecause bytecodes are stored as byte streams, the method area is aligned on byte boundaries.\n(The other areas are all aligned on 32-bit word boundaries.)\nThe Constant Pool\nIn the heap, each class has a constant pool \u201cattached\u201d to it. Usually created by javac, these\nconstants encode all the names (of variables, methods, and so forth) used by any method in a\nclass. The class contains a count of how many constants there are and an offset that specifies how\nfar into the class description itself the array of constants begins. These constants are typed by\nusing specially coded bytes and have a precisely defined format when they appear in the .class\nfile for a class. Later today, a little of this file format is covered, but everything is fully specified\nby the virtual machine specifications in your Java release.\nLimitations\nThe virtual machine, as currently defined, places some restrictions on legal Java programs by\nvirtue of the choices it has made (some were previously described, and more will be detailed later\ntoday).\nThese limitations and their implications are\nnn 32-bit pointers, which imply that the virtual machine can address only 4G of memory\n(this may be relaxed in later releases)\n430\n030-4s CH21.i 430 1\/29\/96, 12:56 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\nnn Unsigned 16-bit indicies into the exception, line number, and local variable tables,\nwhich limit the size of a method\u2019s bytecode implementation to 64K (this limitation\nmay be eliminated in the final release)\nnn Unsigned 16-bit indices into the constant pool, which limits the number of constants\nin a class to 64K (a limit on the complexity of a class)\nIn addition, Sun\u2019s implementation of the virtual machine uses so-called _quick bytecodes, which\nfurther limit the system. Unsigned 8-bit offsets into objects may limit the number of methods\nin a class to 256 (this limit may not exist in the final release), and unsigned 8-bit argument counts\nlimit the size of the argument list to 255 32-bit words. (Although this means that you can have\nup to 255 arguments of most types, you can have only 127 of them if they\u2019re all long or double.)\nBytecodes in More Detail\nOne of the main tasks of the virtual machine is the fast, efficient execution of the Java bytecodes\nin methods. Unlike in the discussion yesterday about generality in Java programs, this is a case\nwhere speed is of the upmost importance. Every Java program suffers from a slow implemen-\ntation here, so the run-time must use as many \u201ctricks\u201d as possible to make bytecodes run fast.\nThe only other goal (or limitation) is that Java programmers must not be able to see these tricks\nin the behavior of their programs.\nA Java run-time implementer must be extremely clever to satisfy both these goals.\nThe Bytecode Interpreter\nA bytecode interpreter examines each opcode byte (bytecode) in a method\u2019s bytecode stream,\nin turn, and executes a unique action for that bytecode. This might consume further bytes for\nthe operands of the bytecode and might affect which bytecode will be examined next. It operates\nlike the hardware CPU in a computer, which examines memory for instructions to carry out in\nexactly the same manner. It is the software CPU of the Java virtual machine.\nYour first, naive attempt to write such a bytecode interpreter will almost certainly be disastrously\nslow. The inner loop, which dispatches one bytecode each time through the loop, is notoriously\ndifficult to optimize. In fact, smart people have been thinking about this problem, in one form\n21\nor another, for more than 20 years. Luckily, they\u2019ve gotten results, all of which can be applied\nto Java.\nThe final result is that the interpreter shipped in the current release of Java has an extremely fast\ninner loop. In fact, on even a relatively slow computer, this interpreter can perform more than\n330,000 bytecodes per second! This is really quite good, because the CPU in that computer does\nonly about 30 times better using hardware.\n431\n030-4s CH21.i 431 1\/29\/96, 12:56 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nThis interpreter is fast enough for most Java programs (and for those requiring more speed, they\ncan always use native methods\u2014see yesterday\u2019s discussion)\u2014but what if a smart implementor\nwants to do better?\nThe \u201cJust-in-Time\u201d Compiler\nAbout a decade ago, a really clever trick was discovered by Peter Deutsch while trying to make\nSmalltalk run faster. He called it \u201cdynamic translation\u201d during interpretation. Sun calls it \u201cjust-\nin-time\u201d compiling.\nThe trick is to notice that the really fast interpreter you\u2019ve just written\u2014in C, for example\u2014\nalready has a useful sequence of native binary code for each bytecode that it interprets: the binary\ncode that the interpreter itself is executing. Because the interpreter has already been compiled from\nC into native binary code, for each bytecode that it interprets, it passes through a sequence of\nnative code instructions for the hardware CPU on which it is running. By saving a copy of each\nbinary instruction as it \u201cgoes by,\u201d the interpreter can keep a running log of the binary code it\nitself has run to interpret a bytecode. It can just as easily keep a log of the set of bytecodes\nthat it ran to interpret an entire method.\nYou take that log of instructions and \u201cpeephole-optimize\u201d it, just as a smart compiler does. This\neliminates redundant or unnecessary instructions from the log, and makes it look just like the\noptimized binary code that a good compiler might have produced.\nNote: This is where the name compiler comes from, in \u201cjust-in-time\u201d compiler,\nbut it\u2019s really only the back end of a traditional compiler\u2014the part that does code\ngeneration. By the way, the front end here is javac.\nHere\u2019s where the trick comes in. The next time that method is run (in exactly the same way),\nthe interpreter can now simply execute directly the stored log of binary native code. Because this\noptimizes out the inner-loop overhead of each bytecode, as well as any other redundancies\nbetween the bytecodes in a method, it can gain a factor of 10 or more in speed. In fact, an\nexperimental version of this technology at Sun has shown that Java programs using it can run\nas fast as compiled C programs.\n432\n030-4s CH21.i 432 1\/29\/96, 12:58 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\nNote: The parenthetical in the last paragraph is needed because if anything is\ndifferent about the input to the method, it takes a different path through the\ninterpreter and must be relogged. (There are sophisticated versions of this technol-\nogy that solve this, and other, difficulties.) The cache of native code for a method\nmust be invalidated whenever the method has changed, and the interpreter must\npay a small cost up front each time a method is run for the first time. However,\nthese small bookkeeping costs are far outweighed by the amazing gains in speed\npossible.\nThe java2c Translator\nAnother, simpler, trick, which works well whenever you have a good, portable C compiler on\neach system that runs your program, is to translate the bytecodes into C and then compile the\nC into binary native code. If you wait until the first use of a method or class, and then perform\nthis as an \u201cinvisible\u201d optimization, it gains you an additional speedup over the approach outlined\npreviously, without the Java programmer needing to know about it.\nOf course, this does limit you to systems with a C compiler, but as you learned yesterday, there\nare extremely good, freely available C compilers. In theory, your Java code might be able to travel\nwith its own C compiler, or know where to pull one from the Net as needed, for each new\ncomputer and operating system it faced. (Because this violates some of the rules of normal Java\ncode movement over the Net, though, it should be used sparingly.)\nIf you\u2019re using Java, for example, to write a server that lives only on your computer, it might be\nappropriate to use Java for its flexibility in writing and maintaining the server (and for its\ncapability of dynamically linking new Java code on the fly), and then to run java2c by hand to\ntranslate the basic server itself entirely into native code. You\u2019d link the Java run-time\nenvironment into that code so that your server remains a fully capable Java program, but it\u2019s now\nan extremely fast one.\nIn fact, an experimental version of the java2c translator inside Sun shows that it can reach the\nspeed of compiled and optimized C code. This is the best that you can hope to do!\n21\nNote: Unfortunately, as of the beta release, there is still no publicly available java2c\ntool, and Sun\u2019s virtual machine does not perform \u201cjust-in-time\u201d compilation. Both\nof these have been promised in a later release.\n433\n030-4s CH21.i 433 1\/29\/96, 12:59 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nThe Bytecodes Themselves\nLet\u2019s look at a (progressively less and less) detailed description of each class of bytecodes.\nFor each bytecode, some brief text describes its function, and a textual \u201cpicture\u201d of the stack,\nboth before and after the bytecode has been executed, is shown. This text picture will look like\nthe following:\n..., value1, value2 => ..., value3\nThis means that the bytecode expects two operands\u2014value1 and value2\u2014to be on the top of\nthe stack, pops them both off the stack, operates on them to produce value3, and pushes value3\nback onto the top of the stack. You should read each stack from right to left, with the rightmost\nvalue being the top of the stack. The ... is read as \u201cthe rest of the stack below,\u201d which is irrelevant\nto the current bytecode. All operands on the stack are 32-bit wide.\nBecause most bytecodes take their arguments from the stack and place their results back there,\nthe brief text descriptions that follow only say something about the source or destination of\nvalues if they are not on the stack. For example, the description Load integer from local\nvariable. means that the integer is loaded onto the stack, and Integer add. intends its integers\nto be taken from\u2014and the result returned to\u2014the stack.\nBytecodes that don\u2019t affect control flow simply move the pc onto the next bytecode that follows\nin sequence. Those that do affect the pc say so explicitly. Whenever you see byte1, byte2, and\nso forth, it refers to the first byte, second byte, and so on, that follow the opcode byte itself. After\nsuch a bytecode is executed, the pc automatically advances over these operand bytes to start the\nnext bytecode in sequence.\nNote: The next few sections are in \u201creference manual style,\u201d presenting each\nbytecode separately in all its (often redundant) detail. Later sections begin to\ncollapse and coalesce this verbose style into something shorter, and more readable.\nThe verbose form is shown at first because the online reference manuals will look\nmore like it, and because it drives home the point that each bytecode \u201cfunction\u201d\ncomes in many, nearly identical bytecodes, one for each primitive type in Java.\nPushing Constants onto the Stack\nbipush ... => ..., value\nPush one-byte signed integer. byte1 is interpreted as a signed 8-bit value. This value is expanded\nto an int and pushed onto the operand stack.\n434\n030-4s CH21.i 434 1\/29\/96, 1:00 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\nsipush ... => ..., value\nPush two-byte signed integer. byte1 and byte2 are assembled into a signed 16-bit value. This\nvalue is expanded to an int and pushed onto the operand stack.\nldc1 ... => ..., item\nPush item from constant pool. byte1 is used as an unsigned 8-bit index into the constant pool\nof the current class. The item at that index is resolved and pushed onto the stack.\nldc2 ... => ..., item\nPush item from constant pool. byte1 and byte2 are used to construct an unsigned 16-bit index\ninto the constant pool of the current class. The item at that index is resolved and pushed onto\nthe stack.\nldc2w ... => ..., constant-word1, constant-word2\nPush long or double from constant pool. byte1 and byte2 are used to construct an unsigned 16-\nbit index into the constant pool of the current class. The two-word constant at that index is\nresolved and pushed onto the stack.\naconst_null ... => ..., null\nPush the null object reference onto the stack.\niconst_m1 ... => ..., -1\nPush the int -1 onto the stack.\niconst_<I> ... => ..., <I>\nPush the int <I> onto the stack. There are six of these bytecodes, one for each of the integers\n0-5: iconst_0, iconst_1, iconst_2, iconst_3, iconst_4, and iconst_5.\nlconst_<L> ... => ..., <L>-word1, <L>-word2\nPush the long <L> onto the stack. There are two of these bytecodes, one for each of the integers\n0 and 1: lconst_0, and lconst_1.\nfconst_<F> ... => ..., <F>\n21\nPush the float <F> onto the stack. There are three of these bytecodes, one for each of the integers\n0-2: fconst_0, fconst_1, and fconst_2.\ndconst_<D> ... => ..., <D>-word1, <D>-word2\nPush the double <D> onto the stack. There are two of these bytecodes, one for each of the integers\n0 and 1: dconst_0, and dconst_1.\n435\n030-4s CH21.i 435 1\/29\/96, 1:01 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nLoading Local Variables onto the Stack\niload ... => ..., value\nLoad int from local variable. Local variable byte1 in the current Java frame must contain an int.\nThe value of that variable is pushed onto the operand stack.\niload_<I> ... => ..., value\nLoad int from local variable. Local variable <I> in the current Java frame must contain an int.\nThe value of that variable is pushed onto the operand stack. There are four of these bytecodes,\none for each of the integers 0-3: iload_0, iload_1, iload_2, and iload_3.\nlload ... => ..., value-word1, value-word2\nLoad long from local variable. Local variables byte1 and byte1 + 1 in the current Java frame must\ntogether contain a long integer. The values contained in those variables are pushed onto the\noperand stack.\nlload_<L> ... => ..., value-word1, value-word2\nLoad long from local variable. Local variables <L> and <L> + 1 in the current Java frame must\ntogether contain a long integer. The value contained in those variables is pushed onto the\noperand stack. There are four of these bytecodes, one for each of the integers 0-3: lload_0,\nlload_1, lload_2, and lload_3.\nfload ... => ..., value\nLoad float from local variable. Local variable byte1 in the current Java frame must contain a\nsingle precision floating-point number. The value of that variable is pushed onto the operand\nstack.\nfload_<F> ... => ..., value\nLoad float from local variable. Local variable <F> in the current Java frame must contain a single\nprecision floating-point number. The value of that variable is pushed onto the operand stack.\nThere are four of these bytecodes, one for each of the integers 0-3: fload_0, fload_1, fload_2,\nand fload_3.\ndload ... => ..., value-word1, value-word2\nLoad double from local variable. Local variables byte1 and byte1 + 1 in the current Java frame\nmust together contain a double precision floating-point number. The value contained in those\nvariables is pushed onto the operand stack.\n436\n030-4s CH21.i 436 1\/29\/96, 1:02 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\ndload_<D> ... => ..., value-word1, value-word2\nLoad double from local variable. Local variables <D> and <D> + 1 in the current Java frame must\ntogether contain a double precision floating-point number. The value contained in those\nvariables is pushed onto the operand stack There are four of these bytecodes, one for each of the\nintegers 0-3: dload_0, dload1, dload_2, and dload_3.\naload ... => ..., value\nLoad object reference from local variable. Local variable byte1 in the current Java frame must\ncontain a return address or reference to an object or array. The value of that variable is pushed\nonto the operand stack.\naload_<A> ... => ..., value\nLoad object reference from local variable. Local variable <A> in the current Java frame must\ncontain a return address or reference to an object. The array value of that variable is pushed onto\nthe operand stack. There are four of these bytecodes, one for each of the integers 0-3: aload_0,\naload_1, aload_2, and aload_3.\nStoring Stack Values into Local Variables\nistore ..., value => ...\nStore int into local variable. value must be an int. Local variable byte1 in the current Java frame\nis set to value.\nistore_<I> ..., value => ...\nStore int into local variable. value must be an int. Local variable <I> in the current Java frame\nis set to value. There are four of these bytecodes, one for each of the integers 0-3: istore_0,\nistore_1, istore_2, and istore_3.\nlstore ..., value-word1, value-word2 => ...\nStore long into local variable. value must be a long integer. Local variables byte1 and byte1 +\n1 in the current Java frame are set to value.\nlstore_<L> ..., value-word1, value-word2 => ...\n21\nStore long into local variable. value must be a long integer. Local variables <L> and <L> + 1 in\nthe current Java frame are set to value. There are four of these bytecodes, one for each of the\nintegers 0-3: lstore_0, lstore_1, lstore_2, and lstore_3.\nfstore ..., value => ...\nStore float into local variable. value must be a single precision floating-point number. Local\nvariables byte1 and byte1 + 1 in the current Java frame are set to value.\n437\n030-4s CH21.i 437 1\/29\/96, 1:02 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nfstore_<F> ..., value => ...\nStore float into local variable. value must be a single precision floating-point number. Local\nvariables <F> and <F> + 1 in the current Java frame are set to value. There are four of these\nbytecodes, one for each of the integers 0-3: fstore_0, fstore_1, fstore_2, and fstore_3.\ndstore ..., value-word1, value-word2 => ...\nStore double into local variable. value must be a double precision floating-point number. Local\nvariables byte1 and byte1 + 1 in the current Java frame are set to value.\ndstore_<D> ..., value-word1, value-word2 => ...\nStore double into local variable. value must be a double precision floating-point number. Local\nvariables <D> and <D> + 1 in the current Java frame are set to value. There are four of these\nbytecodes, one for each of the integers 0-3: dstore_0, dstore_1, dstore_2, and dstore_3.\nastore ..., handle => ...\nStore object reference into local variable. handle must be a return address or a reference to an\nobject. Local variable byte1 in the current Java frame is set to value.\nastore_<A> ..., handle => ...\nStore object reference into local variable. handle must be a return address or a reference to an\nobject. Local variable <A> in the current Java frame is set to value. There are four of these\nbytecodes, one for each of the integers 0-3: astore_0, astore_1, astore_2, and astore_3.\niinc -no change-\nIncrement local variable by constant. Local variable byte1 in the current Java frame must contain\nan int. Its value is incremented by the value byte2, where byte2 is treated as a signed 8-bit\nquantity.\nManaging Arrays\nnewarray ..., size => result\nAllocate new array. size must be an int. It represents the number of elements in the new array.\nbyte1 is an internal code that indicates the type of array to allocate. Possible values for byte1 are\nas follows: T_BOOLEAN (4), T_CHAR (5), T_FLOAT (6), T_DOUBLE (7), T_BYTE (8), T_SHORT (9), T_INT\n(10), and T_LONG (11).\nAn attempt is made to allocate a new array of the indicated type, capable of holding size\nelements. This will be the result. If size is less than zero, a NegativeArraySizeException is\nthrown. If there is not enough memory to allocate the array, an OutOfMemoryError is thrown. All\nelements of the array are initialized to their default values.\n438\n030-4s CH21.i 438 1\/29\/96, 1:03 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\nanewarray ..., size => result\nAllocate new array of objects. size must be an int. It represents the number of elements in the\nnew array. byte1 and byte2 are used to construct an index into the constant pool of the current\nclass. The item at that index is resolved. The resulting entry must be a class.\nAn attempt is made to allocate a new array of the indicated class type, capable of holding size\nelements. This will be the result. If size is less than zero, a NegativeArraySizeException is\nthrown. If there is not enough memory to allocate the array, an OutOfMemoryError is thrown. All\nelements of the array are initialized to null.\nNote: anewarray is used to create a single dimension of an array of objects. For\nexample, the request new Thread[7] generates the following bytecodes:\nbipush 7\nanewarray <Class \u201cjava.lang.Thread\u201d>\nanewarray can also be used to create the outermost dimension of a multidimen-\nsional array. For example, the array declaration new int[6][] generates this:\nbipush 6\nanewarray <Class \u201c[I\u201d>\n(See the section \u201cMethod Signatures\u201d for more information on strings such as [I.)\nmultianewarray ..., size1 size2...sizeN => result\nAllocate new multidimensional array. Each size<I> must be an int. Each represents the number\nof elements in a dimension of the array. byte1 and byte2 are used to construct an index into the\nconstant pool of the current class. The item at that index is resolved. The resulting entry must\nbe an array class of one or more dimensions.\nbyte3 is a positive integer representing the number of dimensions being created. It must be less\nthan or equal to the number of dimensions of the array class. byte3 is also the number of elements\nthat are popped off the stack. All must be ints greater than or equal to zero. These are used as\nthe sizes of the dimensions. An attempt is made to allocate a new array of the indicated class type, 21\ncapable of holding size<1> * size<2> * ... * <sizeN> elements. This will be the result. If any\nof the size<I> arguments on the stack is less than zero, a NegativeArraySizeException is thrown.\nIf there is not enough memory to allocate the array, an OutOfMemoryError is thrown.\n439\n030-4s CH21.i 439 1\/29\/96, 1:04 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nNote: new int[6][3][] generates these bytecodes:\nbipush 6\nbipush 3\nmultianewarray <Class \u201c[[[I\u201d> 2\nIt\u2019s more efficient to use newarray or anewarray when creating arrays of single\ndimension.\narraylength ..., array => ..., length\nGet length of array. array must be a reference to an array object. The length of the array is\ndetermined and replaces array on the top of the stack. If array is null, a NullPointerException\nis thrown.\niaload ..., array, index => ..., value\nlaload ..., array, index => ..., value-word1, value-word2\nfaload ..., array, index => ..., value\ndaload ..., array, index => ..., value-word1, value-word2\naaload ..., array, index => ..., value\nbaload ..., array, index => ..., value\ncaload ..., array, index => ..., value\nsaload ..., array, index => ..., value\nLoad <type> from array. array must be an array of <type>s. index must be an int. The <type>\nvalue at position number index in array is retrieved and pushed onto the top of the stack. If\narray is null, a NullPointerException is thrown. If index is not within the bounds of array, an\nArrayIndexOutOfBoundsException is thrown. <type> is, in turn, int, long, float, double, object\nreference, byte, char, and short. <type>s long and double have two word values, as you\u2019ve seen\nin previous load bytecodes.\niastore ..., array, index, value => ...\nlastore ..., array, index, value-word1, value-word2 => ...\nfastore ..., array, index, value => ...\ndastore ..., array, index, value-word1, value-word2 => ...\naastore ..., array, index, value => ...\nbastore ..., array, index, value => ...\ncastore ..., array, index, value => ...\nsastore ..., array, index, value => ...\nStore into <type> array. array must be an array of <type>s, index must be an integer, and value\na <type>. The <type> value is stored at position index in array. If array is null, a\nNullPointerException is thrown. If index is not within the bounds of array, an\nArrayIndexOutOfBoundsException is thrown. <type> is, in turn, int, long, float, double, object\nreference, byte, char, and short. <type>s long and double have two word values, as you\u2019ve seen\nin previous store bytecodes.\n440\n030-4s CH21.i 440 1\/29\/96, 1:07 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\nStack Operations\nnop -no change-\nDo nothing.\npop ..., any => ...\nPop the top word from the stack.\npop2 ..., any2, any1 => ...\nPop the top two words from the stack.\ndup ..., any => ..., any, any\nDuplicate the top word on the stack.\ndup2 ..., any2, any1 => ..., any2, any1, any2,any1\nDuplicate the top two words on the stack.\ndup_x1 ..., any2, any1 => ..., any1, any2,any1\nDuplicate the top word on the stack and insert the copy two words down in the stack.\ndup2_x1 ..., any3, any2, any1 => ..., any2, any1, any3,any2,any1\nDuplicate the top two words on the stack and insert the copies two words down in the stack.\ndup_x2 ..., any3, any2, any1 => ..., any1, any3,any2,any1\nDuplicate the top word on the stack and insert the copy three words down in the stack.\ndup2_x2 ..., any4, any3, any2, any1 => ..., any2, any1, any4,any3,any2,any1\nDuplicate the top two words on the stack and insert the copies three words down in the stack.\nswap ..., any2, any1 => ..., any1, any2\nSwap the top two elements on the stack.\nArithmetic Operations\n21\niadd ..., v1, v2 => ..., result\nladd ..., v1-word1, v1-word2, v2-word1, v2-word2 => ..., r-word1, r-word2\nfadd ..., v1, v2 => ..., result\ndadd ..., v1-word1, v1-word2, v2-word1, v2-word2 => ..., r-word1, r-word2\nv1 and v2 must be <type>s. The vs are added and are replaced on the stack by their <type> sum.\n<type> is, in turn, int, long, float, and double.\n441\n030-4s CH21.i 441 1\/29\/96, 1:09 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nisub ..., v1, v2 => ..., result\nlsub ..., v1-word1, v1-word2, v2-word1, v2-word2 => ..., r-word1, r-word2\nfsub ..., v1, v2 => ..., result\ndsub ..., v1-word1, v1-word2, v2-word1, v2-word2 => ..., r-word1, r-word2\nv1 and v2 must be <type>s. v2 is subtracted from v1, and both vs are replaced on the stack by\ntheir <type> difference. <type> is, in turn, int, long, float, and double.\nimul ..., v1, v2 => ..., result\nlmul ..., v1-word1, v1-word2, v2-word1, v2-word2 => ..., r-word1, r-word2\nfmul ..., v1, v2 => ..., result\ndmul ..., v1-word1, v1-word2, v2-word1, v2-word2 => ..., r-word1, r-word2\nv1 and v2 must be <type>s. Both vs are replaced on the stack by their <type> product. <type> is,\nin turn, int, long, float, and double.\nidiv ..., v1, v2 => ..., result\nldiv ..., v1-word1, v1-word2, v2-word1, v2-word2 => ..., r-word1, r-word2\nfdiv ..., v1, v2 => ..., result\nddiv ..., v1-word1, v1-word2, v2-word1, v2-word2 => ..., r-word1, r-word2\nv1 and v2 must be <type>s. v2 is divided by v1, and both vs are replaced on the stack by their\n<type> quotient. An attempt to divide by zero results in an ArithmeticException being thrown.\n<type> is, in turn, int, long, float, and double.\nirem ..., v1, v2 => ..., result\nlrem ..., v1-word1, v1-word2, v2-word1, v2-word2 => ..., r-word1, r-word2\nfrem ..., v1, v2 => ..., result\ndrem ..., v1-word1, v1-word2, v2-word1, v2-word2 => ..., r-word1, r-word2\nv1 and v2 must be <type>s. v2 is divided by v1, and both vs are replaced on the stack by their\n<type> remainder. An attempt to divide by zero results in an ArithmeticException being\nthrown. <type> is, in turn, int, long, float, and double.\nineg ..., value => ..., result\nlneg ..., value-word1, value-word2 => ..., result-word1, result-word2\nfneg ..., value => ..., result\ndneg ..., value-word1, value-word2 => ..., result-word1, result-word2\nvalue must be a <type>. It is replaced on the stack by its arithmetic negation. <type> is, in turn,\nint, long, float, and double.\nNote: Now that you\u2019re familiar with the look of the bytecodes, the summaries that\nfollow will become shorter and shorter (for space reasons). You can always get any\ndesired level of detail from the full virtual machine specification in the latest Java\nrelease.\n442\n030-4s CH21.i 442 1\/29\/96, 1:13 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\nLogical Operations\nishl ..., v1, v2 => ..., result\nlshl ..., v1-word1, v1-word2, v2 => ..., r-word1, r-word2\nishr ..., v1, v2 => ..., result\nlshr ..., v1-word1, v1-word2, v2 => ..., r-word1, r-word2\niushr ..., v1, v2 => ..., result\nlushr ..., v1-word1, v1-word2, v2-word1, v2-word2 => ..., r-word1, r-word2\nFor types int and long: arithmetic shift-left, shift-right, and logical shift-right.\niand ..., v1, v2 => ..., result\nland ..., v1-word1, v1-word2, v2-word1, v2-word2 => ..., r-word1, r-word2\nior ..., v1, v2 => ..., result\nlor ..., v1-word1, v1-word2, v2-word1, v2-word2 => ..., r-word1, r-word2\nixor ..., v1, v2 => ..., result\nlxor ..., v1-word1, v1-word2, v2-word1, v2-word2 => ..., r-word1, r-word2\nFor types int and long: bitwise AND, OR, and XOR.\nConversion Operations\ni2l ..., value => ..., result-word1, result-word2\ni2f ..., value => ..., result\ni2d ..., value => ..., result-word1, result-word2\nl2i ..., value-word1, value-word2 => ..., result\nl2f ..., value-word1, value-word2 => ..., result\nl2d ..., value-word1, value-word2 => ..., result-word1, result-word2\nf2i ..., value => ..., result\nf2l ..., value => ..., result-word1, result-word2\nf2d ..., value => ..., result-word1, result-word2\nd2i ..., value-word1, value-word2 => ..., result\nd2l ..., value-word1, value-word2 => ..., result-word1, result-word2\nd2f ..., value-word1, value-word2 => ..., result\nint2byte ..., value => ..., result\nint2char ..., value => ..., result\nint2short ..., value => ..., result\nThese bytecodes convert from a value of type <lhs> to a result of type <rhs>. <lhs> and <rhs>\ncan be any of i, l, f,and d, which represent int, long, float, and double, respectively. The final\nthree bytecodes have types that are self-explanatory.\nTransfer of Control\n21\nifeq ..., value => ...\nifne ..., value => ...\niflt ..., value => ...\nifgt ..., value => ...\nifle ..., value => ...\nifge ..., value => ...\nif_icmpeq ..., value1, value2 => ...\nif_icmpne ..., value1, value2 => ...\nif_icmplt ..., value1, value2 => ...\n443\n030-4s CH21.i 443 1\/29\/96, 1:15 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nif_icmpgt ..., value1, value2 => ...\nif_icmple ..., value1, value2 => ...\nif_icmpge ..., value1, value2 => ...\nifnull ..., value => ...\nifnonnull ..., value => ...\nWhen value <rel> 0 is true in the first set of bytecodes, value1 <rel> value2 is true in the second\nset, or value is null (or not null) in the third, byte1 and byte2 are used to construct a signed\n16-bit offset. Execution proceeds at that offset from the pc. Otherwise, execution proceeds at\nthe bytecode following. <rel> is one of eq, ne, lt, gt, le, and ge, which represent equal, not equal,\nless than, greater than, less than or equal, and greater than or equal, respectively.\nlcmp ..., v1-word1, v1-word2, v2-word1, v2-word2 => ..., result\nfcmpl ..., v1, v2 => ..., result\ndcmpl ..., v1-word1, v1-word2, v2-word1, v2-word2 => ..., result\nfcmpg ..., v1, v2 => ..., result\ndcmpg ..., v1-word1, v1-word2, v2-word1, v2-word2 => ..., result\nv1 and v2 must be long, float, or double. They are both popped from the stack and compared.\nIf v1 is greater than v2, the int value 1 is pushed onto the stack. If v1 is equal to v2, 0 is pushed\nonto the stack. If v1 is less than v2, -1 is pushed onto the stack. For floating-point, if either v1\nor v2 is NaN, -1 is pushed onto the stack for the first pair of bytecodes, +1 for the second pair.\nif_acmpeq ..., value1, value2 => ...\nif_acmpne ..., value1, value2 => ...\nBranch if object references are equal\/not equal. value1 and value2 must be references to objects.\nThey are both popped from the stack. If value1 is equal\/not equal to value2, byte1 and byte2\nare used to construct a signed 16-bit offset. Execution proceeds at that offset from the pc.\nOtherwise, execution proceeds at the bytecode following.\ngoto -no change-\ngoto_w -no change-\nBranch always. byte1 and byte2 (plus byte3 and byte4 for goto_w) are used to construct a signed\n16-bit (32-bit) offset. Execution proceeds at that offset from the pc.\njsr ... => ..., return-address\njsr\u2013w ... => ..., return-address\nJump subroutine. The address of the bytecode immediately following the jsr is pushed onto the\nstack. byte1 and byte2 (plus byte3 and byte4 for goto_w) are used to construct a signed 16-bit\n(32-bit) offset. Execution proceeds at that offset from the pc.\nret -no change-\nret2_w -no change-\nReturn from subroutine. Local variable byte1 (plus byte2 are assembled into a 16-bit index for\nret_w) in the current Java frame must contain a return address. The contents of that local variable\n444\nare written into the pc.\n030-4s CH21.i 444 1\/29\/96, 1:17 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\nNote: jsr pushes the address onto the stack, and ret gets it out of a local variable.\nThis asymmetry is intentional. The jsr and ret bytecodes are used in the imple-\nmentation of Java\u2019s finally keyword.\nMethod Return\nreturn ... => [empty]\nReturn (void) from method. All values on the operand stack are discarded. The interpreter then\nreturns control to its caller.\nireturn ..., value => [empty]\nlreturn ..., value-word1, value-word2 => [empty]\nfreturn ..., value => [empty]\ndreturn ..., value-word1, value-word2 => [empty]\nareturn ..., value => [empty]\nReturn <type> from method. value must be a <type>. The value is pushed onto the stack of the\nprevious execution environment. Any other values on the operand stack are discarded. The\ninterpreter then returns control to its caller. <type> is, in turn, int, long, float, double, and\nobject reference.\nNote: The stack behavior of the \u201creturn\u201d bytecodes may be confusing to anyone\nexpecting the Java operand stack to be just like the C stack. Java\u2019s operand stack\nactually consists of a number of discontiguous segments, each corresponding to a\nmethod call. A return bytecode empties the Java operand stack segment corre-\nsponding to the frame of the returning call, but does not affect the segment of any\nparent calls.\nTable Jumping\ntableswitch ..., index => ... 21\ntableswitch is a variable-length bytecode. Immediately after the tableswitch opcode, zero to\nthree 0 bytes are inserted as padding so that the next byte begins at an address that is a multiple\nof four. After the padding are a series of signed 4-byte quantities: default-offset, low, high, and\n445\n030-4s CH21.i 445 1\/29\/96, 1:18 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nthen (high - low + 1) further signed 4-byte offsets. These offsets are treated as a 0-based jump\ntable.\nThe index must be an int. If index is less than low or index is greater than high, default-offset\nis added to the pc. Otherwise, the (index - low)\u2019th element of the jump table is extracted and\nadded to the pc.\nlookupswitch ..., key => ...\nlookupswitch is a variable-length bytecode. Immediately after the lookupswitch opcode, zero to\nthree 0 bytes are inserted as padding so that the next byte begins at an address that is a multiple\nof four. Immediately after the padding is a series of pairs of signed 4-byte quantities. The first\npair is special; it contains the default-offset and the number of pairs that follow. Each\nsubsequent pair consists of a match and an offset.\nThe key on the stack must be an int. This key is compared to each of the matches. If it is equal\nto one of them, the corresponding offset is added to the pc. If the key does not match any of\nthe matches, the default-offset is added to the pc.\nManipulating Object Fields\nputfield ..., handle, value => ...\nputfield ..., handle, value-word1, value-word2 => ...\nSet field in object. byte1 and byte2 are used to construct an index into the constant pool of the\ncurrent class. The constant pool item is a field reference to a class name and a field name. The\nitem is resolved to a field block pointer containing the field\u2019s width and offset (both in bytes).\nThe field at that offset from the start of the instance pointed to by handle will be set to the value\non the top of the stack. The first stack picture is for 32-bit, and the second for 64-bit wide fields.\nThis bytecode handles both. If handle is null, a NullPointerException is thrown. If the specified\nfield is a static field, an IncompatibleClassChangeError is thrown.\ngetfield ..., handle => ..., value\ngetfield ..., handle => ..., value-word1, value-word2\nFetch field from object. byte1 and byte2 are used to construct an index into the constant pool\nof the current class. The constant pool item will be a field reference to a class name and a field\nname. The item is resolved to a field block pointer containing the field\u2019s width and offset (both\nin bytes).\nhandle must be a reference to an object. The value at offset into the object referenced by handle\nreplaces handle on the top of the stack. The first stack picture is for 32-bit, and the second for\n64-bit wide fields. This bytecode handles both. If the specified field is a static field, an\nIncompatibleClassChangeError is thrown.\n446\n030-4s CH21.i 446 1\/29\/96, 1:19 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\nputstatic ..., value => ...\nputstatic ..., value-word1, value-word2 => ...\nSet static field in class. byte1 and byte2 are used to construct an index into the constant pool of\nthe current class. The constant pool item will be a field reference to a static field of a class. That\nfield will be set to have the value on the top of the stack. The first stack picture is for 32-bit, and\nthe second for 64-bit wide fields. This bytecode handles both. If the specified field is not a static\nfield, an IncompatibleClassChangeError is thrown.\ngetstatic ..., => ..., value_\ngetstatic ..., => ..., value-word1, value-word2\nGet static field from class. byte1 and byte2 are used to construct an index into the constant pool\nof the current class. The constant pool item will be a field reference to a static field of a class. The\nvalue of that field is placed on the top of the stack. The first stack picture is for 32-bit, and the\nsecond for 64-bit wide fields. This bytecode handles both. If the specified field is not a static\nfield, an IncompatibleClassChangeError is thrown.\nMethod Invocation\ninvokevirtual ..., handle, [arg1, arg2, ...]], ... => ...\nInvoke instance method based on run\/time. The operand stack must contain a reference to an\nobject and some number of arguments. byte1 and byte2 are used to construct an index into the\nconstant pool of the current class. The item at that index in the constant pool contains the\ncomplete method signature. A pointer to the object\u2019s method table is retrieved from the object\nreference. The method signature is looked up in the method table. The method signature is\nguaranteed to exactly match one of the method signatures in the table.\nThe result of the lookup is an index into the method table of the named class that\u2019s used to look\nin the method table of the object\u2019s run\/time type, where a pointer to the method block for the\nmatched method is found. The method block indicates the type of method (native, synchro-\nnized, and so on) and the number of arguments (nargs) expected on the operand stack.\nIf the method is marked synchronized, the monitor associated with handle is entered.\nThe base of the local variables array for the new Java stack frame is set to point to handle on the\nstack, making handle and the supplied arguments (arg1, arg2, ...) the first nargs local variables\nof the new frame. The total number of local variables used by the method is determined, and 21\nthe execution environment of the new frame is pushed after leaving sufficient room for the locals.\nThe base of the operand stack for this method invocation is set to the first word after the\nexecution environment. Finally, execution continues with the first bytecode of the matched\nmethod.\nIf handle is null, a NullPointerException is thrown. If during the method invocation a stack\noverflow is detected, a StackOverflowError is thrown.\n447\n030-4s CH21.i 447 1\/29\/96, 1:20 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\ninvokenonvirtual ..., handle, [arg1, arg2, ...]] ... => ...\nInvoke instance method based on compile-time type. The operand stack must contain a\nreference (handle) to an object and some number of arguments. byte1 and byte2 are used to\nconstruct an index into the constant pool of the current class. The item at that index in the\nconstant pool contains the complete method signature and class. The method signature is\nlooked up in the method table of the class indicated. The method signature is guaranteed to\nexactly match one of the method signatures in the table.\nThe result of the lookup is a method block. The method block indicates the type of method\n(native, synchronized, and so on) and the number of arguments (nargs) expected on the\noperand stack. (The last three paragraphs are identical to the previous bytecode.)\ninvokestatic ..., , [arg1, arg2, ...]] ... => ...\nInvoke class (static) method. The operand stack must contain some number of arguments.\nbyte1 and byte2 are used to construct an index into the constant pool of the current class. The\nitem at that index in the constant pool contains the complete method signature and class. The\nmethod signature is looked up in the method table of the class indicated. The method signature\nis guaranteed to match one of the method signatures in the class\u2019s method table exactly.\nThe result of the lookup is a method block. The method block indicates the type of method\n(native, synchronized, and so on) and the number of arguments (nargs) expected on the\noperand stack.\nIf the method is marked synchronized, the monitor associated with the class is entered. (The last\ntwo paragraphs are identical to those in invokevirtual, except that no NullPointerException\ncan be thrown.)\ninvokeinterface ..., handle, [arg1, arg2, ...] => ...\nInvoke interface method. The operand stack must contain a reference (handle) to an object and\nsome number of arguments. byte1 and byte2 are used to construct an index into the constant\npool of the current class. The item at that index in the constant pool contains the complete\nmethod signature. A pointer to the object\u2019s method table is retrieved from the object reference.\nThe method signature is looked up in the method table. The method signature is guaranteed\nto exactly match one of the method signatures in the table.\nThe result of the lookup is a method block. The method block indicates the type of method\n(native, synchronized, and so on) but, unlike the other \u201cinvoke\u201d bytecodes, the number of\navailable arguments (nargs) is taken from byte3; byte4 is reserved for future use. (The last three\nparagraphs are identical to those in invokevirtual.)\n448\n030-4s CH21.i 448 1\/29\/96, 1:20 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\nException Handling\nathrow ..., handle => [undefined]\nThrow exception. handle must be a handle to an exception object. That exception, which must\nbe a subclass of Throwable, is thrown. The current Java stack frame is searched for the most recent\ncatch clause that handles the exception. If a matching \u201ccatch-list\u201d entry is found, the pc is reset\nto the address indicated by the catch-list pointer, and execution continues there.\nIf no appropriate catch clause is found in the current stack frame, that frame is popped and the\nexception is rethrown, starting the process all over again in the parent frame. If handle is null,\nthen a NullPointerException is thrown instead.\nMiscellaneous Object Operations\nnew ... => ..., handle\nCreate new object. byte1 and byte2 are used to construct an index into the constant pool of the\ncurrent class. The item at that index should be a class name that can be resolved to a class pointer,\nclass. A new instance of that class is then created and a reference (handle) for the instance is placed\non the top of the stack.\ncheckcast ..., handle => ..., [handle|...]\nMake sure object is of given type. handle must be a reference to an object. byte1 and byte2 are\nused to construct an index into the constant pool of the current class. The string at that index\nof the constant pool is presumed to be a class name that can be resolved to a class pointer, class.\ncheckcast determines whether handle can be cast to a reference to an object of that class. (A null\nhandle can be cast to any class.) If handle can be legally cast, execution proceeds at the next\nbytecode, and the handle for handle remains on the stack. If not, a ClassCastException is\nthrown.\ninstanceof ..., handle => ..., result\nDetermine whether object is of given type. handle must be a reference to an object. byte1 and\nbyte2 are used to construct an index into the constant pool of the current class. The string at that\nindex of the constant pool is presumed to be a class name that can be resolved to a class pointer,\nclass. 21\nIf handle is null, the result is (false). Otherwise, instanceof determines whether handle can\nbe cast to a reference to an object of that class. The result is 1 (true) if it can, and 0 (false)\notherwise.\n449\n030-4s CH21.i 449 1\/29\/96, 1:21 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nMonitors\nmonitorenter ..., handle => ...\nEnter monitored region of code. handle must be a reference to an object. The interpreter\nattempts to obtain exclusive access via a lock mechanism to handle. If another thread already has\nhandle locked, the current thread waits until the handle is unlocked. If the current thread already\nhas handle locked, execution continues normally. If handle has no lock on it, this bytecode\nobtains an exclusive lock.\nmonitorexit ..., handle => ...\nExit monitored region of code. handle must be a reference to an object. The lock on handle is\nreleased. If this is the last lock that this thread has on that handle (one thread is allowed to have\nmultiple locks on a single handle), other threads that are waiting for handle are allowed to\nproceed. (A null in either bytecode throws NullPointerException.)\nDebugging\nbreakpoint -no change-\nCall breakpoint handler. The breakpoint bytecode is used to overwrite a bytecode to force\ncontrol temporarily back to the debugger prior to the effect of the overwritten bytecode. The\noriginal bytecode\u2019s operands (if any) are not overwritten, and the original bytecode is restored\nwhen the breakpoint bytecode is removed.\nThe _quick Bytecodes\nThe following discussion, straight out of the Java virtual machine documentation, shows you\nan example of the cleverness mentioned earlier that\u2019s needed to make a bytecode interpreter fast:\nThe following set of pseudo-bytecodes, suffixed by _quick, are all variants of standard\nJava bytecodes. They are used by the run-time to improve the execution speed of the\nbytecode interpreter. They aren\u2019t officially part of the virtual machine specification\nand are invisible outside a Java virtual machine implementation. However, inside that\nimplementation they have proven to be an effective optimization.\nFirst, you should know that javac still generates only non-_quick bytecodes. Second,\nall bytecodes that have a _quick variant reference the constant pool. When _quick\noptimization is turned on, each non-_quick bytecode (that has a _quick variant)\nresolves the specified item in the constant pool, signals an error if the item in the\nconstant pool could not be resolved for some reason, turns itself into the _quick\nvariant of itself, and then performs its intended operation.\n450\n030-4s CH21.i 450 1\/29\/96, 1:22 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\nThis is identical to the actions of the non-_quick bytecode, except for the step of\noverwriting itself with its _quick variant. The _quick variant of a bytecode assumes\nthat the item in the constant pool has already been resolved, and that this resolution\ndid not produce any errors. It simply performs the intended operation on the resolved\nitem.\nThus, as your bytecodes are being interpreted, they are automatically getting faster and faster!\nHere are all the _quick variants in the current Java run-time:\nldc1_quick\nldc2_quick\nldc2w_quick\nanewarray_quick\nmultinewarray_quick\nputfield_quick\nputfield2_quick\ngetfield_quick\ngetfield2_quick\nputstatic_quick\nputstatic2_quick\ngetstatic_quick\ngetstatic2_quick\ninvokevirtual_quick\ninvokevirtualobject_quick\ninvokenonvirtual_quick\ninvokestatic_quick\ninvokeinterface_quick\nnew_quick\ncheckcast_quick\ninstanceof_quick\nIf you\u2019d like to go back in today\u2019s lesson and look at what each of these does, you can find the\nname of the original bytecode on which a _quick variant is based by simply removing the _quick\nfrom its name. The bytecodes putstatic, getstatic, putfield, and getfield have two _quick\nvariants each, one for each stack picture in their original descriptions. invokevirtual has two\nvariants: one for objects and one for arrays to do fast lookups in javala.Object).\n21\nNote: One last note on the _quick optimization, regarding the unusual handling of\nthe constant pool (for detail fanatics only):\nWhen a class is read in, an array constant_pool[] of size nconstants is created and\nassigned to a field in the class. constant_pool[0] is set to point to a dynamically\nallocated array that indicates which fields in the constant_pool have already been\nresolved. constant_pool[1] through constant_pool[nconstants - 1] are set to\npoint at the \u201ctype\u201d field that corresponds to this constant item.\n451\n030-4s CH21.i 451 1\/29\/96, 1:23 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nWhen a bytecode is executed that references the constant pool, an index is gener-\nated, and constant_pool[0] is checked to see whether the index has already been\nresolved. If so, the value of constant_pool[index] is returned. If not, the value of\nconstant_pool[index] is resolved to be the actual pointer or data, and overwrites\nwhatever value was already in constant_pool[index].\nThe .class File Format\nYou won\u2019t be given the entire .class file format here, only a taste of what it\u2019s like. (You can read\nall about it in the release documentation.) It\u2019s mentioned here because it is one of the parts of\nJava that needs to be specified carefully if all Java implementations are to be compatible with one\nanother, and if Java bytes are expected to travel across arbitrary networks\u2014to and from arbitrary\ncomputers and operating systems\u2014and yet arrive safely.\nThe rest of this section paraphrases, and extensively condenses, the latest (alpha) release of the\n.class documentation.\n.class files are used to hold the compiled versions of both Java classes and Java interfaces.\nCompliant Java interpreters must be capable of dealing with all .class files that conform to the\nfollowing specification.\nA Java .class file consists of a stream of 8-bit bytes. All 16-bit and 32-bit quantities are\nconstructed by reading in two or four 8-bit bytes, respectively. The bytes are joined together in\nbig-endian order. (Use java.io.DataInput and java.io.DataOutput to read and write class files.)\nThe class file format is presented below as a series of C-struct-like structures. However, unlike\na C struct, there is no padding or alignment between pieces of the structure, each field of the\nstructure may be of variable size, and an array may be of variable size (in this case, some field prior\nto the array gives the array\u2019s dimension). The types u1, u2, and u4 represent an unsigned\none-, two-, or four-byte quantity, respectively.\nAttributes are used at several different places in the .class format. All attributes have the following\nformat:\nGenericAttribute_info {\nu2 attribute_name;\nu4 attribute_length;\nu1 info[attribute_length];\n}\nThe attribute_name is a 16-bit index into the class\u2019s constant pool; the value of\nconstant_pool[attribute_name] is a string giving the name of the attribute. The field\nattribute_length gives the length of the subsequent information in bytes. This length does not\n452\n030-4s CH21.i 452 1\/29\/96, 1:24 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\ninclude the four bytes needed to store attribute_name and attribute_length. In the following\ntext, whenever an attribute is required, names of all the attributes that are currently understood\nare listed. In the future, more attributes will be added. Class file readers are expected to skip over\nand ignore the information in any attributes that they do not understand.\nThe following pseudo-structure gives a top-level description of the format of a class file:\nClassFile {\nu4 magic;\nu2 minor_version\nu2 major_version\nu2 constant_pool_count;\ncp_info constant_pool[constant_pool_count - 1];\nu2 access_flags;\nu2 this_class;\nu2 super_class;\nu2 interfaces_count;\nu2 interfaces[interfaces_count];\nu2 fields_count;\nfield_info fields[fields_count];\nu2 methods_count;\nmethod_info methods[methods_count];\nu2 attributes_count;\nattribute_info attributes[attribute_count];\n}\nHere\u2019s one of the smaller structures used:\nmethod_info {\nu2 access_flags;\nu2 name_index;\nu2 signature_index;\nu2 attributes_count;\nattribute_info attributes[attribute_count];\n}\nFinally, here\u2019s a sample of one of the later structures in the .class file description:\nCode_attribute {\nu2 attribute_name_index;\nu2 attribute_length;\nu1 max_stack;\nu1 max_locals;\nu2 code_length;\nu1 code[code_length];\nu2 exception_table_length; 21\n{ u2_ start_pc;\nu2_ end_pc;\nu2_ handler_pc;\nu2_ catch_type;\n} exception_table[exception_table_length];\nu2 attributes_count;\nattribute_info attributes[attribute_count];\n}\n453\n030-4s CH21.i 453 1\/29\/96, 1:25 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nNone of this is meant to be completely comprehensible (though you might be able to guess at\nwhat a lot of the structure members are for), but just suggestive of the sort of structures that live\ninside .class files. Because the compiler and run-time sources are available, you can always begin\nwith them if you actually have to read or write .class files yourself. Thus, you don\u2019t need to have\na deep understanding of the details, even in that case.\nMethod Signatures\nBecause method signatures are used in .class files, now is an appropriate time to explore them\nin the detail promised on earlier days\u2014but they\u2019re probably most useful to you when writing\nthe native methods of yesterday\u2019s lesson.\nNEW* A signature is a string representing the type of a method, field, or array.\nTERM\nA field signature represents the value of an argument to a method or the value of a variable and\nis a series of bytes in the following grammar:\n<field signature> := <field_type>\n<field type> := <base_type> | <object_type> | <array_type>\n<base_type> := B | C | D | F | I | J | S | Z\n<object_type> := L <full.ClassName> ;\n<array_type> := [ <optional_size> <field_type>\n<optional_size> := [0-9]*\nHere are the meanings of the base types: B (byte), C (char), D (double), F (float), I (int), J (long),\nS (short), and Z (boolean).\nA return-type signature represents the return value from a method and is a series of bytes in the\nfollowing grammar:\n<return signature> := <field type> | V\nThe character V (void) indicates that the method returns no value. Otherwise, the signature\nindicates the type of the return value. An argument signature represents an argument passed to\na method:\n<argument signature> := <field type>\nFinally, a method signature represents the arguments that the method expects, and the value that\nit returns:\n<method_signature> := (<arguments signature>) <return signature>\n<arguments signature> := <argument signature>*\n454\n030-4s CH21.i 454 1\/29\/96, 1:26 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\nLet\u2019s try out the new rules: a method called complexMethod() in the class\nmy.package.name.ComplexClass takes three arguments\u2014a long, a boolean, and a two-\ndimensional array of shorts\u2014and returns this. Then, (JZ[[S)Lmy.package.name.ComplexClass;\nis its method signature.\nA method signature is often prefixed by the name of the method, or by its full package (using\nan underscore in the place of dots) and its class name followed by a slash \/ and the name of the\nmethod, to form a complete method signature. (You saw several of these generated in stub\ncomments yesterday.) Now, at last, you have the full story! Thus, the following:\nmy_package_name_ComplexClass\/complexMethod(JZ[[S)Lmy.package.name.ComplexClass;\nis the full, complete method signature of method complexMethod(). (Phew!)\nThe Garbage Collector\nDecades ago, programmers in both the Lisp and the Smalltalk community realized how\nextremely valuable it is to be able to ignore memory deallocation. They realized that, although\nallocation is fundamental, deallocation is forced on the programmer by the laziness of the\nsystem\u2014it should be able to figure out what is no longer useful, and get rid of it. In relative\nobscurity, these pioneering programmers developed a whole series of garbage collectors to\nperform this job, each getting more sophisticated and efficient as the years went by. Finally, now\nthat the mainstream programming community has begun to recognize the value of this\nautomated technique, Java can become the first really widespread application of the technology\nthose pioneers developed.\nThe Problem\nImagine that you\u2019re a programmer in a C-like language (probably not too difficult for you,\nbecause these languages are the dominant ones right now). Each time you create something,\nanything, dynamically in such a language, you are completely responsible for tracking the life of\nthis object throughout your program and mentally deciding when it will be safe to deallocate\nit. This can be quite a difficult (sometime impossible) task, because any of the other libraries or\nmethods you\u2019ve called might have \u201csquirreled away\u201d a pointer to the object, unbeknownst to\nyou. When it becomes impossible to know, you simply choose never to deallocate the object, or 21\nat least to wait until every library and method call involved has completed, which could be nearly\nas long.\nThe uneasy feeling you get when writing such code is a natural, healthy response to what is\ninherently an unsafe and unreliable style of programming. If you have tremendous discipline\u2014\nand so does everyone who writes every library and method you call\u2014you can, in principle,\n455\n030-4s CH21.i 455 1\/29\/96, 1:27 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nsurvive this responsibility without too many mishaps. But aren\u2019t you human? Aren\u2019t they? There\nmust be some small slips in this perfect discipline due to error. What\u2019s worse, such errors are\nvirtually undetectable, as anyone who\u2019s tried to hunt down a stray pointer problem in C will tell\nyou. What about the thousands of programmers who don\u2019t have that sort of discipline?\nAnother way to ask this question is: Why should any programmers be forced to have this\ndiscipline, when it is entirely possible for the system to remove this heavy burden from their\nshoulders?\nSoftware engineering estimates have recently shown that for every 55 lines of production C-like\ncode in the world, there is one bug. This means that your electric razor has about 80 bugs, and\nyour TV, 400. Soon they will have even more, because the size of this kind of embedded\ncomputer software is growing exponentially. When you begin to think of how much C-like code\nis in your car\u2019s engine, it should give you pause.\nMany of these errors are due to the misuse of pointers, by misunderstanding or by accident, and\nto the early, incorrect freeing of allocated objects in memory. Java addresses both of these\u2014the\nformer, by eliminating explicit pointers from the Java language altogether and the latter, by\nincluding, in every Java system, a garbage collector that solves the problem.\nThe Solution\nImagine a run-time system that tracks each object you create, notices when the last reference to\nit has vanished, and frees the object for you. How could such a thing actually work?\nOne brute-force approach, tried early in the days of garbage collecting, is to attach a reference\ncounter to every object. When the object is created, the counter is set to 1. Each time a new\nreference to the object is made, the counter is incremented, and each time such a reference\ndisappears, the counter is decremented. Because all such references are controlled by the\nlanguage\u2014as variables and assignments, for example\u2014the compiler can tell whenever an object\nreference might be created or destroyed, just as it does in handling the scoping of local variables,\nand thus it can assist with this task. The system itself \u201cholds onto\u201d a set of root objects that are\nconsidered too important to be freed. The class Object is one example of such a V.I.P. object.\n(V.I.O.?) Finally, all that\u2019s needed is to test, after each decrement, whether the counter has hit\n0. If it has, the object is freed.\nIf you think carefully about this approach, you can soon convince yourself that it is definitely\ncorrect when it decides to free anything. It is so simple that you can immediately tell that it will\nwork. The low-level hacker in you might also feel that if it\u2019s that simple, it\u2019s probably not fast\nenough to run at the lowest level of the system\u2014and you\u2019d be right.\nThink about all the stack frames, local variables, method arguments, return values, and local\nvariables created in the course of even a few hundred milliseconds of a program\u2019s life. For each\n456\n030-4s CH21.i 456 1\/29\/96, 1:28 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\nof these tiny, nano-steps in the program, an extra increment\u2014at best\u2014or decrement, test, and\ndeallocation\u2014at worst\u2014will be added to the running time of the program. In fact, the first\ngarbage collectors were slow enough that many predicted they could never be used at all!\nLuckily, a whole generation of smart programmers has invented a big bag of tricks to solve these\noverhead problems. One trick is to introduce special \u201ctransient object\u201d areas that don\u2019t need to\nbe reference counted. The best of these generational scavenging garbage collectors today can take\nless than 3 percent of the total time of your program\u2014a remarkable feat if you realize that many\nother language features, such as loop overheads, can be as large or larger!\nThere are other problems with garbage collection. If you are constantly freeing and reclaiming\nspace in a program, won\u2019t the heap of objects soon become fragmented, with small holes\neverywhere and no room to create new, large objects? Because the programmer is now free from\nthe chains of manual deallocation, won\u2019t they create even more objects than usual?\nWhat\u2019s worse, there is another way that this simple reference counting scheme is inefficient, in\nspace rather than time. If a long chain of object references eventually comes full circle, back to\nthe starting object, each object\u2019s reference count remains at least 1 forever. None of these objects\nwill ever be freed!\nTogether, these problems imply that a good garbage collector must, every once in a while, step\nback to compact or to clean up wasted memory.\nNEW* Compaction occurs when a garbage collector steps back and reorganizes\nTERM memory, eliminating the holes created by fragmentation. Compacting\nmemory is simply a matter of repositioning objects one-by-one into a new,\ncompact grouping that places them all in a row, leaving all the free memory in the\nheap in one big piece.\nCleaning up the circular garbage still lying around after reference counting is called\nmarking and sweeping. A mark-and-sweep of memory involves first marking every root\nobject in the system and then following all the object references inside those objects to\nnew objects to mark, and so on, recursively. Then, when you have no more references\nto follow, you \u201csweep away\u201d all the unmarked objects, and compact memory as\nbefore.\n21\nThe good news is that this solves the space problems you were having. The bad news is that when\nthe garbage collector \u201csteps back\u201d and does these operations, a nontrivial amount of time passes\nduring which your program is unable to run\u2014all its objects are being marked, swept, rearranged,\nand so forth, in what seems like an uninterruptible procedure. Your first hint to a solution is the\nword \u201cseems.\u201d\n457\n030-4s CH21.i 457 1\/29\/96, 1:29 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nGarbage collecting can actually be done a little at a time, between or in parallel with normal\nprogram execution, thus dividing up the large time needed to \u201cstep back\u201d into numerous so-\nsmall-you-don\u2019t-notice-them chunks of time that happen between the cracks. (Of course, years\nof smart thinking went into the abstruse algorithms that make all this possible!)\nOne final problem that might worry you a little has to do with these object references. Aren\u2019t\nthese \u201cpointers\u201d scattered throughout your program and not just buried in objects? Even if\nthey\u2019re only in objects, don\u2019t they have to be changed whenever the object they point to is moved\nby these procedures? The answer to both of these questions is a resounding yes, and overcoming\nthem is the final hurdle to making an efficient garbage collector.\nThere are really only two choices. The first, brute force, assumes that all the memory containing\nobject references needs to be searched on a regular basis, and whenever the object references\nfound by this search match objects that have moved, the old reference is changed. This assumes\nthat there are \u201chard\u201d pointers in the heap\u2019s memory\u2014ones that point directly to other objects.\nBy introducing various kinds of \u201csoft\u201d pointers, including pointers that are like forwarding\naddresses, the algorithm improves greatly. Although these brute-force approaches sound slow,\nit turns out that modern computers can do them fast enough to be useful.\nNote: You might wonder how the brute-force techniques identify object references.\nIn early systems, references were specially tagged with a \u201cpointer bit,\u201d so they could\nbe unambiguously located. Now, so-called conservative garbage collectors simply\nassume that if it looks like an object reference, it is\u2014at least for the purposes of the\nmark and sweep. Later, when actually trying to update it, they can find out\nwhether it really is an object reference or not.\nThe final approach to handling object references, and the one Java currently uses, is also one of\nthe very first ones tried. It involves using 100 percent \u201csoft\u201d pointers. An object reference is\nactually a handle, sometimes call an \u201cOOP,\u201d to the real pointer, and a large object table exists\nto map these handles into the actual object reference. Although this does introduce extra\noverhead on almost every object reference (some of which can be eliminated by clever tricks, as\nyou might guess), it\u2019s not too high a price to pay for this incredibly valuable level of indirection.\nThis indirection allows the garbage collector, for example, to mark, sweep, move, or examine\none object at a time. Each object can be independently moved \u201cout from under\u201d a running Java\nprogram by changing only the object table entries. This not only allows the \u201cstep back\u201d phase\nto happen in the tiniest steps, but it makes a garbage collector that runs literally in parallel with\nyour program much easier to write. This is what the Java garbage collector does.\n458\n030-4s CH21.i 458 1\/29\/96, 1:30 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\n!\n! Warning: You need to be very careful about garbage collection when you\u2019re doing\ncritical, real-time programs (such as those mentioned yesterday that legitimately\nrequire native methods)\u2014but how often will your Java code be flying a commercial\nairliner in real-time, anyway?\nJava\u2019s Parallel Garbage Collector\nJava applies almost all these advanced techniques to give you a fast, efficient, parallel garbage\ncollector. Running in a separate thread, it cleans up the Java environment of almost all trash (it\nis conservative), silently and in the background, is efficient in both space and time, and never\nsteps back for more than an unnoticeably small amount of time. You should never need to know\nit\u2019s there.\nBy the way, if you want to force a full mark-and-sweep garbage collection to happen soon, you\ncan do so simply by calling the System.gc() method. You might want to do this if you just freed\nup a majority of the heap\u2019s memory in circular garbage, and want it all taken away quickly. You\nmight also call this whenever you\u2019re idle, as a hint to the system about when it would be best to\ncome and collect the garbage. This \u201cmeta knowledge\u201d is rarely needed by the system, however.\nIdeally, you\u2019ll never notice the garbage collector, and all those decades of programmers beating\ntheir brains out on your behalf will simply let you sleep better at night\u2014and what\u2019s wrong with\nthat?\nThe Security Story\nSpeaking of sleeping well at night, if you haven\u2019t stepped back yet and said, \u201cYou mean Java\nprograms will be running rampant on the Internet!?!\u201d you better do so now, for it is a legitimate\nconcern. In fact, it is one of the major technical stumbling blocks (the others being mostly social\nand economic) to achieving the dream of ubiquity and code sharing mentioned earlier in today\u2019s\nlesson.\n21\nWhy You Should Worry\nAny powerful, flexible technology can be abused. As the Net becomes mainstream and\nwidespread, it, too, will be abused. Already, there have been many blips on the security radar\nscreens of those of us who worry about such things, warning that (at least until today), not\nenough attention has been paid by the computer industry (or the media) to solving some of the\n459\n030-4s CH21.i 459 1\/29\/96, 1:31 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nproblems constructively that this new world brings with it. One of the benefits of solving security\nonce and for all will be a flowering unseen before in the virtual communities of the Net; whole\nnew economies based on people\u2019s attention and creativity will spring to life, rapidly transforming\nour world in new and positive ways.\nThe downside to all this new technology, is that we (or someone!) must worry long and hard\nabout how to make the playgrounds of the future safe for our children, and for us. Fortunately,\nJava is a big part of the answer.\nWhy You Might Not Have To\nWhat gives me any confidence that the Java language and environment will be safe, that it will\nsolve the technically daunting and extremely thorny problems inherent in any good form of\nsecurity, especially for networks?\nOne simple reason is the history of the people, and the company, that created Java. Many of them\nare the very smart programmers referred to throughout the book, who helped pioneer many of\nthe ideas that make Java great and who have worked hard over the decades to make techniques\nsuch as garbage collection a mainstream reality. They are technically capable of tackling and\nsolving the hard problems that need to be solved. In particular, from discussions with Chuck\nMcManis, one of Java\u2019s security gurus, I have confidence that he has thought through these hard\nproblems deeply, and that he knows what needs to be done.\nSun Microsystems, the company, has been pushing networks as the central theme of all its\nsoftware for more than a decade. Sun has the engineers and the commitment needed to solve\nthese hard problems, because these same problems are at the very center of both its future\nbusiness and its vision of the future, in which networking is the center of everything\u2014and global\nnetworks are nearly useless without good security. Just this year, Sun has advanced the state of\nthe art in easy-to-use Internet security with its new SunScreen products, and it has assigned\nWhitfield Diffie to oversee them, who is the man who discovered the underlying ideas on which\nessentially all interesting forms of modern encryption are based.\nEnough on \u201cdeep background.\u201d What does the Java environment provide right now that helps\nus feel secure?\nJava\u2019s Security Model\nJava protects you against potential \u201cnasty\u201d Java code via a series of interlocking defenses that,\ntogether, form an imposing barrier to any and all such attacks.\n460\n030-4s CH21.i 460 1\/29\/96, 1:32 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\n!\n! Caution: Of course, no one can protect you from your own ignorance or careless-\nness. If you\u2019re the kind of person who blindly downloads binary executables from\nyour Internet browser and runs them, you need read no further! You are already in\nmore danger than Java will ever pose.\nAs a user of this powerful new medium, the Internet, you should educate yourself to\nthe possible threats this new and exciting world entails. In particular, downloading\n\u201cauto running macros\u201d or reading e-mail with \u201cexecutable attachments\u201d is just as\nmuch a threat as downloading binaries from the Net and running them.\nJava does not introduce any new dangers here, but by being the first mainstream use\nof executable and mobile code on the Net, it is responsible for making people\nsuddenly aware of the dangers that have always been there. Java is already, as you\nwill soon see, much less dangerous than any of these common activities on the Net,\nand can be made safer still over time. Most of these other (dangerous) activities can\nnever be made safe. So please, do not do them!\nA good rule of thumb on the Net is: Don\u2019t download anything that you plan to\nexecute (or that will be automatically executed for you) except from someone (or\nsome company) you know well and with whom you\u2019ve had positive, personal\nexperience. If you don\u2019t care about losing all the data on your hard drive, or about\nyour privacy, you can do anything you like, but for most of us, this rule should be\nlaw.\nFortunately, Java allows you to relax that law. You can run Java applets from\nanyone, anywhere, in complete safety.\nJava\u2019s powerful security mechanisms act at four different levels of the system architecture. First,\nthe Java language itself was designed to be safe, and the Java compiler ensures that source code\ndoesn\u2019t violate these safety rules. Second, all bytecodes executed by the run-time are screened\nto be sure that they also obey these rules. (This layer guards against having an altered compiler\nproduce code that violates the safety rules.) Third, the class loader ensures that classes don\u2019t\nviolate name space or access restrictions when they are loaded into the system. Finally, API-\nspecific security prevents applets from doing destructive things. This final layer depends on the 21\nsecurity and integrity guarantees from the other three layers.\nLet\u2019s now examine each of these layers in turn.\n461\n030-4s CH21.i 461 1\/29\/96, 1:33 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nThe Language and the Compiler\nThe Java language and its compiler are the first line of defense. Java was designed to be a safe\nlanguage.\nMost other C-like languages have facilities to control access to \u201cobjects,\u201d but also have ways to\n\u201cforge\u201d access to objects (or to parts of objects), usually by (mis-)using pointers. This introduces\ntwo fatal security flaws to any system built on these languages. One is that no object can protect\nitself from outside modification, duplication, or \u201cspoofing\u201d (others pretending to be that\nobject). Another is that a language with powerful pointers is more likely to have serious bugs that\ncompromise security. These pointer bugs, where a \u201crunaway pointer\u201d starts modifying some\nother object\u2019s memory, were responsible for most of the public (and not-so-public) security\nproblems on the Internet this past decade.\nJava eliminates these threats in one stroke by eliminating pointers from the language altogether.\nThere are still pointers of a kind\u2014object references\u2014but these are carefully controlled to be safe:\nthey are unforgeable, and all casts are checked for legality before being allowed. In addition,\npowerful new array facilities in Java not only help to offset the loss of pointers, but add additional\nsafety by strictly enforcing array bounds, catching more bugs for the programmer (bugs that, in\nother languages, might lead to unexpected and, thus, bad-guy-exploitable problems).\nThe language definition, and the compilers that enforce it, create a powerful barrier to any\n\u201cnasty\u201d Java programmer.\nBecause an overwhelming majority of the \u201cnet-savvy\u201d software on the Internet may soon be Java,\nits safe language definition and compilers help to guarantee that most of this software has a solid,\nsecure base. With fewer bugs, Net software will be more predictable\u2014a property that thwarts\nattacks.\nVerifying the Bytecodes\nWhat if that \u201cnasty\u201d programmer gets a little more determined, and rewrites the Java compiler\nto suit his nefarious purposes? The Java run-time, getting the lion\u2019s share of its bytecodes from\nthe Net, can never tell whether those bytecodes were generated by a \u201ctrustworthy\u201d compiler.\nTherefore, it must verify that they meet all the safety requirements.\nBefore running any bytecodes, the run-time subjects them to a rigorous series of tests that vary\nin complexity from simple format checks all the way to running a theorem prover, to make\ncertain that they are playing by the rules. These tests verify that the bytecodes do not forge\npointers, violate access restrictions, access objects as other than what they are (InputStreams are\nalways used as InputStreams, and never as anything else), call methods with inappropriate\nargument values or types, nor overflow the stack.\n462\n030-4s CH21.i 462 1\/29\/96, 1:34 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\nConsider the following Java code sample:\npublic class VectorTest {\npublic int array[];\npublic int sum() {\nint[] localArray = array;\nint sum = 0;\nfor (int i = localArray.length; --i >= 0; )\nsum += localArray[i];\nreturn sum;\n}\n}\nThe bytecodes generated when this code is compiled look something like the following:\naload_0 Load this\ngetfield #10 Load this.array\nastore_1 Store in localArray\niconst_0 Load 0\nistore_2 Store in sum\naload_1 Load localArray\narraylength Gets its length\nistore_3 Store in i\nA: iinc 3 -1 Subtract 1 from i\niload_3 Load i\niflt B Exit loop if < 0\niload_2 Load sum\naload_1 Load localArray\niload_3 Load i\niaload Load localArray[i]\niadd Add sum\nistore_2 Store in sum\n21\ngoto A Do it again\nB: iload_2 Load sum\nireturn Return it\n463\n030-4s CH21.i 463 1\/29\/96, 1:35 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nNote: The excellent examples and descriptions in this section of the book are\nparaphrased from the tremendously informative security paper in the (alpha) Java\nrelease. I\u2019d encourage you to read whatever the latest version of this document is in\nnewer releases, if you want to follow the ongoing Java security story.\nExtra Type Information and Requirements\nJava bytecodes encode more type information than is strictly necessary for the interpreter. Even\nthough, for example, the aload and iload opcodes do exactly the same thing, aload is always used\nto load an object reference and iload used to load an integer. Some bytecodes (such as getfield)\ninclude a symbol table reference\u2014and that symbol table has even more type information. This\nextra type information allows the run-time system to guarantee that Java objects and data aren\u2019t\nillegally manipulated.\nConceptually, before and after each bytecode is executed, every slot in the stack and every local\nvariable has some type. This collection of type information\u2014all the slots and local variables\u2014\nis called the type state of the execution environment. An important requirement of the Java type\nstate is that it must be determinable statically by induction\u2014that is, before any program code\nis executed. As a result, as the run-time systems reads bytecodes, each is required to have the\nfollowing inductive property: given only the type state before the execution of the bytecode, the\ntype state afterward must be fully determined.\nGiven \u201cstraight-line\u201d bytecodes (no branches), and starting with a known stack state, the state\nof each slot in the stack is therefore always known. For example, starting with an empty stack:\niload_1 Load integer variable. Stack type state is I.\niconst 5 Load integer constant. Stack type state is II.\niadd Add two integers, producing an integer. Stack type state is I.\nNote: Smalltalk and PostScript bytecodes do not have this restriction. Their more\ndynamic type behavior does create additional flexibility in those systems, but Java\nneeds to provide a secure execution environment. It must therefore know all types\nat all times, in order to guarantee a certain level of security.\n464\n030-4s CH21.i 464 1\/29\/96, 1:36 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\nAnother requirement made by the Java run-time is that when a set of bytecodes can take more\nthan one path to arrive at the same point, all such paths must arrive there with exactly the same\ntype state. This is a strict requirement, and implies, for example, that compilers cannot generate\nbytecodes that load all the elements of an array onto the stack. (Because each time through such\na loop the stack\u2019s type state changes, the start of the loop\u2014\u201cthe same point\u201d in multiple paths\u2014\nwould have more than one type state, which is not allowed).\nThe Verifier\nBytecodes are checked for compliance with all these requirements, using the extra type\ninformation in a .class file, by a part of the run-time called the verifier. It examines each bytecode\nin turn, constructing the full type state as it goes, and verifies that all the types of parameters,\narguments, and results are correct. Thus, the verifier acts as a gatekeeper to your run-time\nenvironment, letting in only those bytecodes that pass muster.\n!\n! Warning: The verifier is the crucial piece of Java\u2019s security, and it depends on your\nhaving a correctly implemented (no bugs, intentional or otherwise) run-time\nsystem. As of this writing, only Sun is producing Java run-times, and theirs are\nsecure. In the future, however, you should be careful when downloading or buying\nanother company\u2019s (or individual\u2019s) version of the Java run-time environment.\nEventually, Sun will implement validation suites for run-times, compilers, and so\nforth to be sure that they are safe and correct. In the meantime, caveat emptor! Your\nrun-time is the base on which all the rest of Java\u2019s security is built, so make sure it is\na good, solid, secure base.\nWhen bytecodes have passed the verifier, they are guaranteed not to: cause any operand stack\nunder- or overflows; use parameter, argument, or return types incorrectly; illegally convert data\nfrom one type to another (from an integer to a pointer, for example); nor access any object\u2019s fields\nillegally (that is, the verifier checks that the rules for public, private, package, and protected\nare obeyed).\nAs an added bonus, because the interpreter can now count on all these facts being true, it can\nrun much faster than before. All the required checks for safety have been done up front, so it can 21\nrun at full throttle. In addition, object references can now be treated as capabilities, because they\nare unforgeable\u2014capabilities allow, for example, advanced security models for file I\/O and\nauthentication to be safely built on top of Java.\n465\n030-4s CH21.i 465 1\/29\/96, 1:38 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nNote: Because you can now trust that a private variable really is private, and that\nno bytecode can perform some magic with casts to extract information from it\n(such as your credit card number), many of the security problems that might arise\nin other, less safe environments simply vanish! These guarantees also make erecting\nbarriers against destructive applets possible, and easier. Because the Java system\ndoesn\u2019t have to worry about \u201cnasty\u201d bytecodes, it can get on with creating the other\nlevels of security it wants to provide to you.\nThe Class Loader\nThe class loader is another kind of gatekeeper, albeit a higher-level one. The verifier was the\nsecurity of last resort. The class loader is the security of first resort.\nWhen a new class is loaded into the system, it must come from one of several different \u201crealms.\u201d\nIn the current release, there are three possible realms: your local computer, the firewall-guarded\nlocal network on which your computer is located, and the Internet (the global Net). Each of\nthese realms is treated differently by the class loader.\nNote: Actually, there can be as many realms as your desired level of security (or\nparanoia) requires. This is because the class loader is under your control. As a\nprogrammer, you can make your own class loader that implements your own\npeculiar brand of security. (This is a radical step: you may have to give the users of\nyour program a whole bunch of classes\u2014and they give you a whole lot of trust\u2014to\naccomplish this.)\nAs a user, you can tell your Java-aware browser, or Java system, what realm of\nsecurity (of the three) you\u2019d like it to implement for you right now or from now\non.\nAs a system administrator, Java has global security policies that you can set up to\nhelp guide your users to not \u201cgive away the store\u201d (that is, set all their preferences\nto be unrestricted, promiscuous, \u201churt me please!\u201d).\nIn particular, the class loader never allows a class from a \u201cless protected\u201d realm to replace a class\nfrom a more protected realm. The file system\u2019s I\/O primitives, about which you should be very\nworried (and rightly so), are all defined in a local Java class, which means that they all live in the\nlocal-computer realm. Thus, no class from outside your computer (from either the supposedly\ntrustworthy local network or from the Internet) can take the place of these classes and \u201cspoof\u201d\n466\n030-4s CH21.i 466 1\/29\/96, 1:39 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\nJava code into using \u201cnasty\u201d versions of these primitives. In addition, classes in one realm cannot\ncall upon the methods of classes in other realms, unless those classes have explicitly declared those\nmethods public. This implies that classes from other than your local computer cannot even see\nthe file system I\/O methods, much less call them, unless you or the system wants them to.\nIn addition, every new applet loaded from the network is placed into a separate package-like\nnamespace. This means that applets are protected even from each other! No applet can access\nanother\u2019s methods (or variables) without its cooperation. Applets from inside the firewall can\neven be treated differently from those outside the firewall, if you like.\nNote: Actually, it\u2019s all a little more complex than this. In the current release, an\napplet is in a package \u201cnamespace\u201d along with any other applets from that source.\nThis source, or origin, is most often a host (domain name) on the Internet. This\nspecial \u201csubrealm\u201d is used extensively in the next section. Depending on where the\nsource is located, outside the firewall (or inside), further restrictions may apply (or\nbe removed entirely). This model is likely to be extended in future releases of Java,\nproviding an even finer degree of control over which classes get to do what.\nThe class loader essentially partitions the world of Java classes into small, protected little groups,\nabout which you can safely make assumptions that will always be true. This type of predictability\nis the key to well-behaved and secure programs.\nYou\u2019ve now seen the full lifetime of a method. It starts as source code on some computer, is\ncompiled into bytecodes on some (possibly different) computer, and can then travel (as a .class\nfile) into any file system or network anywhere in the world. When you run an applet in a Java-\naware browser (or download a class and run it by hand using java), the method\u2019s bytecodes are\nextracted from its .class file and carefully looked over by the verifier. Once they are declared safe,\nthe interpreter can execute them for you (or a code generator can generate native binary code\nfor them using either the \u201cjust-in-time\u201d compiler or java2c, and then run that native code\ndirectly).\nAt each stage, more and more security is added. The final level of that security is the Java class\nlibrary itself, which has several carefully designed classes and APIs that add the final touches to\n21\nthe security of the system.\nThe Security Manager\nSecurityManager is an abstract class that was recently added to the Java system to collect, in one\nplace, all the security policy decisions that the system has to make as bytecodes run. You learned\nbefore that you can create your own class loader. In fact, you may not have to, because you can\nsubclass SecurityManager to perform most of the same customizations.\n467\n030-4s CH21.i 467 1\/29\/96, 1:41 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nAn instance of some subclass of SecurityManager is always installed as the current security\nmanager. It has complete control over which of a well-defined set of \u201cdangerous\u201d methods are\nallowed to be called by any given class. It takes the realms from the last section into account, the\nsource (origin) of the class, and the type of the class (stand-alone, or loaded by an applet). Each\nof these can be separately configured to have the effect you (the programmer) like on your Java\nsystem. For nonprogrammers, the system provides several levels of default security policies from\nwhich you can choose.\nWhat is this \u201cwell-defined set\u201d of methods that are protected?\nFile I\/O is a part of the set, for obvious reasons. Applets, by default, can open, read, or write files\nonly with the express permission of the user\u2014and even then, only in certain restricted\ndirectories. (Of course, users can always be stupid about this, but that\u2019s what system adminis-\ntrators are for!)\nAlso in this protected set are the methods that create and use network connections, both\nincoming and outgoing.\nThe final members of the set are those methods that allow one thread to access, control, and\nmanipulate other threads. (Of course, additional methods can be protected as well, by creating\na new subclass of SecurityManager that handles them.)\nFor both file and network access, the user of a Java-aware browser can choose between three\nrealms (and one subrealm) of protection:\nnn unrestricted (allows applets to do anything)\nnn firewall (allows applets within the firewall to do anything)\nnn source (allows applets to do things only with their origin {Internet} host, or with other\napplets from there)\nnn local (disallows all file and network access)\nFor file access, the source subrealm is not meaningful, so it really has only three realms of\nprotection. (As a programmer, of course, you have full access to the security manager and can\nset up your own peculiar criteria for granting and revoking privileges to your heart\u2019s content.)\nFor network access, you can imagine wanting many more realms. For example, you might\nspecify different groups of trusted domains (companies), each of which is allowed added\nprivileges when applets from that group are loaded. Some groups can be more trusted than\nothers, and you might even allow groups to grow automatically by allowing existing members\nto recommend new members for admission. (The Java seal of approval?)\nIn any case, the possibilities are endless, as long as there is a secure way of recognizing the original\ncreator of an applet.\n468\n030-4s CH21.i 468 1\/29\/96, 1:41 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\nYou might think this problem has already been solved, because classes are tagged with their\norigin. In fact, the Java run-time goes far out of its way to be sure that that origin information\nis never lost\u2014any executing method can be dynamically restricted by this information anywhere\nin the call chain. So why isn\u2019t this enough?\nBecause what you\u2019d really like to be able to do is permanently \u201ctag\u201d an applet with its original\ncreator (its true origin), and no matter where it has traveled, a browser could verify the integrity\nand authenticate the creator of that applet. Just because you don\u2019t know the company or\nindividual that operates a particular server machine doesn\u2019t mean that you want to mistrust every\napplet stored on that machine. It\u2019s just that, currently, to be really safe, you should mistrust those\napplets, however.\nIf somehow those applets were irrevocably tagged with a digital signature by their creator, and\nthat signature could also guarantee that the applet had not been tampered with, you\u2019d be golden.\nNote: Luckily, Sun is planning to do exactly that for Java, as soon as export\nrestrictions can be resolved.\nHere\u2019s a helpful hint of where the team would like to go, from the security docu-\nmentation: \u201c...a mechanism exists whereby public keys and cryptographic message\ndigests can be securely attached to code fragments that not only identify who\noriginated the code, but guarantee its integrity as well. This latter mechanism will\nbe implemented in future releases.\u201d\nLook for these sorts of features in every release of Java; they will be a key part of the\nfuture of the Internet!\nOne final note about security. Despite the best efforts of the Java team, there is always a trade-\noff between useful functionality and absolute security. For example, Java applets can create\nwindows, an extremely useful capability, but a \u201cnasty\u201d applet could use this to spoof the user into\ntyping private password information, by showing a familiar program (or operating system)\nwindow and then asking an expected, legitimate-looking question in it. (The beta release adds\na special banner to applet-created windows to solve this problem.)\n21\nFlexibility and security can\u2019t both be maximized. Thus far on the Net, people have chosen\nmaximum flexibility, and have lived with the minimal security the Net now provides. Let\u2019s hope\nthat Java can help tip the scales a bit, enabling much better security, while sacrificing only a\nminimal amount of the flexibility that has drawn so many to the Net.\n469\n030-4s CH21.i 469 1\/29\/96, 1:42 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 MTWRFSS\nDDAAYY\n21 Under the Hood\nSummary\nToday, you learned about the grand vision that some of us have for Java, and about the exciting\nfuture it promises.\nUnder the hood, the inner workings of the virtual machine, the bytecode interpreter (and all its\nbytecodes), the garbage collector, the class loader, the verifier, the security manager, and the\npowerful security features of Java were all revealed.\nYou now know almost enough to write a Java run-time environment of your own\u2014but luckily,\nyou don\u2019t have to. You can simply download the latest release of Java\u2014or use a Java-aware\nbrowser to enjoy most of the benefits of Java right away.\nI hope that Java ends up opening new roads in your mind, as it has in mine.\nQ&A\nQ I\u2019m still a little unclear about why the Java language and compiler make the Net\nsafer. Can\u2019t they just be \u201cside-stepped\u201d by nasty bytecodes?\nA Yes, they can\u2014but don\u2019t forget that the whole point of using a safe language and\ncompiler was to make the Net as a whole safer as more Java code is written. An\noverwhelming majority of this Java code will be written by \u201chonest\u201d Java program-\nmers, who will produce safe bytecodes. This makes the Net more predictable over\ntime, and thus more secure.\nQ I know you said that garbage collection is something I don\u2019t have to worry\nabout, but what if I want (or need) to?\nA So, you are planning to fly a plane with Java. Cool! For just such cases, there is a way\nto ask the Java run-time, during startup (java -noasyncgc), not to run garbage\ncollection unless forced to, either by an explicit call (System.gc()) or by running out\nof memory. (This can be quite useful if you have multiple threads that are messing\neach other up and want to \u201cget the gc thread out of the way\u201d while testing them.)\nDon\u2019t forget that turning garbage collection off means that any object you create will\nlive a long, long time. If you\u2019re real-time, you never want to \u201cstep back\u201d for a full gc\u2014\nso be sure to reuse objects often, and don\u2019t create too many of them!\nQ I like the control above; is there anything else I can do to the garbage collector?\nA You can also force the finalize() methods of any recently freed objects to be called\nimmediately via System.runFinalization(). You might want to do this if you\u2019re about\nto ask for some resources that you suspect might still be tied up by objects that are\n\u201cgone but not forgotten\u201d (waiting for finalize()). This is even rarer than starting a gc\nby hand, but it\u2019s mentioned here for completeness.\n470\n030-4s CH21.i 470 1\/29\/96, 1:45 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\nQ What\u2019s the last word on Java?\nA Java adds much more than it can ever take away. It has always done so for me, and\nnow, I hope it will for you, as well.\nThe future of the Net is filled with as-yet-undreamt horizons, and the road is long and\nhard, but Java is a great traveling companion.\n21\n471\n030-4s CH21.i 471 1\/29\/96, 1:46 PM\nP2\/V4 \/sqc7 TY Java in 21 Days 030-4 Casey 12.29.95 Ch21 LP#4 Sams.net Learning\nCenter\nabcd\nA\nA\nA\nS\nS\nF\nR\nW\nLanguage\nT\nSummary\nM\nby Laura Lemay\n473\n030-4s App A.i 473 1\/29\/96, 8:18 PM\nP2\/V4 \/sqc6 TY Java in 21 Days 030-4 al 12.28.95 App A LP#3 MTWRFSS\nA Language Summary\nThis appendix contains a summary or quick reference for the Java language, as described in this\nbook.\nTechnical Note: This is not a grammar overview, nor is it a technical overview of\nthe language itself. It\u2019s a quick reference to be used after you already know the\nbasics of how the language works. If you need a technical description of the\nlanguage, your best bet is to visit the Java Web Site (http:\/\/java.sun.com) and\ndownload the actual specification, which includes a full BNF grammar.\nLanguage keywords and symbols are shown in a monospace font. Arguments and other parts to\nbe substituted are in italic monospace.\nOptional parts are indicated by brackets (except in the array syntax section). If there are several\noptions that are mutually exclusive, they are shown separated by pipes ([|]) like this:\n[ public | private | protected ] type varname\nReserved Words\nThe following words are reserved for use by the Java language itself (some of them are reserved\nbut not currently used). You cannot use these words to refer to classes, methods, or variable\nnames:\nabstract do implements package throw\nboolean double import private throws\nbreak else inner protected transient\nbyte extends instanceof public try\ncase final int rest var\ncast finally interface return void\ncatch float long short volatile\nchar for native static while\nclass future new sure\nconst generic null switch\ncontinue goto operator synchronized\ndefault if outer this\n474\n030-4s App A.i 474 1\/29\/96, 8:18 PM\nP2\/V4 \/sqc6 TY Java in 21 Days 030-4 al 12.28.95 App A LP#3 Sams.net Learning\nCenter\nabcd\nComments\nA\n\/* this is a multiline comment *\/\n\/\/ this is a single-line comment\n\/** Javadoc comment *\/\nLiterals\nnumber Type int\nnumber[l [|] L] Type long\n0xhex Hex integer\n0Xhex Hex integer\n0octal Octal integer\n[ number ].number Type double\nnumber[ f [|] f] Type float\nnumber[ d [|] D] Type double\n[ + [|] - ] number Signed\nnumberenumber Exponent\nnumberEnumber Exponent\n\u2018character\u2019 Single character\n\u201ccharacters\u201d String\n\u201c\u201d Empty string\n\\b Backspace\n\\t Tab\n\\n Line feed\n\\f Form feed\n\\r Carriage return\n\\\u201d Double quote\n\\\u2019 Single quote\n\\\\ Backslash\n\\uNNNN Unicode escape (NNNN is hex)\ntrue Boolean\nfalse Boolean\n475\n030-4s App A.i 475 1\/29\/96, 8:19 PM\nP2\/V4 \/sqc6 TY Java in 21 Days 030-4 al 12.28.95 App A LP#3 MTWRFSS\nA Language Summary\nVariable Declaration\n[ byte | short | int | long ] varname Integers (pick one type)\n[ float | double ] varname Floats (pick one type)\nchar varname; Characters\nboolean varname Boolean\nclassname varname; Class types\ninterfacename varname Interface types\ntype varname, varname, varname; Multiple variables\nThe following options are available only for class and instance variables. Any of these options\ncan be used with a variable declaration\n[ static ] variableDeclaration Class variable\n[ final ] variableDeclaration Constants\n[ public | private | protected ] variableDeclaration Access control\n[volatile] varname Modified asynchro-\nnously\n[transient] varname Not persistent\n(not yet implemented)\nVariable Assignment\nvariable = value Assignment\nvariable++ Postfix Increment\n++variable Prefix Increment\nvariable\u2013\u2013 Postfix Decrement\n\u2013\u2013variable Prefix Decrement\nvariable += value Add and assign\nvariable \u2013= value Subtract and assign\nvariable *= value Multiply and assign\nvariable \u201a = value Divide and assign\nvariable %= value Modulus and assign\nvariable &= value AND and assign\nvariable |= value OR and assign\n476\n030-4s App A.i 476 1\/29\/96, 8:19 PM\nP2\/V4 \/sqc6 TY Java in 21 Days 030-4 al 12.28.95 App A LP#3 Sams.net Learning\nCenter\nabcd\nvariable ^= value XOR and assign\nvariable <<= value Left-shift and assign A\nvariable >>= value Right-shift and assign\nvariable >>>= value Zero-fill right-shift and assign\nOperators\narg + arg Addition\narg \u2013 arg Subtraction\narg * arg Multiplication\narg \u201a arg Division\narg % arg Modulus\narg < arg Less than\narg > arg Greater than\narg \u00a3 arg Less than or equal to\narg \u2021 arg Greater than or equal to\narg == arg Equal\narg \u201e arg Not equal\narg && arg Logical AND\narg || arg Logical OR\n! arg Logical NOT\narg & arg AND\narg | arg OR\narg ^ arg XOR\narg << arg Left-shift\narg >> arg Right-shift\narg >>> arg Zero-fill right-shift\n~ arg Complement\n(type)thing Casting\narg instanceof class Instance of\ntest ? trueOp : falseOp Tenary (if) operator\n477\n030-4s App A.i 477 1\/29\/96, 8:20 PM\nP2\/V4 \/sqc6 TY Java in 21 Days 030-4 al 12.28.95 App A LP#3 MTWRFSS\nA Language Summary\nObjects\nnew class() Create new instance\nnew class(arg,arg,arg...) New instance with parameters\nobject.variable Instance variable\nobject.classvar Class variable\nClass.classvar Class variable\nobject.method() Instance method (no args)\nobject.method(arg,arg,arg...) Instance method\nobject.classmethod() Class method (no args)\nobject.classmethod(arg,arg,arg...) Class method\nClass.classmethod() Class method (no args)\nClass.classmethod(arg,arg,arg...) Class method\nArrays\nNote: The brackets in this section are parts of the array creation or access\nstatements. They do not denote optional parts as they do in other parts of this\nappendix.\ntype varname[] Array variable\ntype[] varname Array variable\nnew type[numElements] New array object\narray[index] Element access\narray.length Length of array\nLoops and Conditionals\nif ( test) block Conditional\nif ( test ) block\n478\n030-4s App A.i 478 1\/29\/96, 8:21 PM\nP2\/V4 \/sqc6 TY Java in 21 Days 030-4 al 12.28.95 App A LP#3 Sams.net Learning\nCenter\nabcd\nelse block Conditional with else\nswitch (test) { switch (only with integer or char types) A\ncase value : statement\ncase value : statement\n...\ndefault : statement\n}\nfor (initializer, test, change ) block for loop\nwhile ( test ) block while loop\ndo block do loop\nwhile (test)\nbreak [ label ] break from loop or switch\ncontinue [ label ] continue loops\nlabel: Labeled loops\nClass Definitions\nclass classname block Simple Class definition\nAny of the following optional modifiers can be added to the class definition:\n[ final ] class classname block Cannot be subclassed\n[ abstract ] class classname block Cannot be instantiated\n[ public ] class classname block Accessible outside\npackage\nclass classname [ extends Superclass ] block Define superclass\nclass classname [ implements interfaces ] block Implement one or more\ninterfaces\nMethod and Constructor Definitions\nThe basic method looks like this, where returnType is a type name, a class name, or void.\nreturnType methodName() block Basic method\nreturnType methodName(parameter, parameter, ...) block Method with parameters\n479\n030-4s App A.i 479 1\/29\/96, 8:21 PM\nP2\/V4 \/sqc6 TY Java in 21 Days 030-4 al 12.28.95 App A LP#3 MTWRFSS\nA Language Summary\nMethod parameters look like this:\ntype parameterName\nMethod variations can include any of the following optional keywords:\n[ abstract ] returnType methodName() block Abstract method\n[ static ] returnType methodName() block Class method\n[ native ] returnType methodName() block Native method\n[ final ] returnType methodName() block final method\n[ synchronized ] returnType methodName() block Thread lock before\nexecuting\n[ public | private | protected ] returnType methodName() Block access control\nConstructors look like this:\nclassname() block basic constructor\nclassname(parameter, parameter, parameter...) block constructor with\nparameters\n[ public | private | protected] classname()block Access control\nIn the method\/constructor body you can use these references and methods:\nthis Refers to current object\nsuper Refers to superclass\nsuper.methodName() Call a superclass\u2019s method\nthis(...) Calls class\u2019s constructor\nsuper(...) Calls superclass\u2019s constructor\nreturn [ value ] Returns a value\nPackages, Interfaces, and Importing\nimport package.className Imports specific class name\nimport package.* Imports all public classes in\npackage\npackage packagename Classes in this file belong\nto this package\n480\n030-4s App A.i 480 1\/29\/96, 8:22 PM\nP2\/V4 \/sqc6 TY Java in 21 Days 030-4 al 12.28.95 App A LP#3 Sams.net Learning\nCenter\nabcd\ninterface interfaceName [ extends anotherInterface ] block A\n[ public ] interface interfaceName block\n[ abstract ] interface interfaceName block\nExceptions and Guarding\nsynchronized ( object ) block Waits for lock on object\ntry block Guarded statements\ncatch ( exception ) block Executed if exception is thrown\n[ finally block ] Cleanup code\ntry block Same as previous example (can\n[ catch ( exception ) block ] use optional catch or finally,\nfinally block but not both)\n481\n030-4s App A.i 481 1\/29\/96, 8:22 PM\nP2\/V4 \/sqc6 TY Java in 21 Days 030-4 al 12.28.95 App A LP#3 Sams.net Learning\nCenter\nabcd\nB\nB\nB\nS\nS\nF\nR\nW\nClass Hierarchy\nT\nDiagrams\nM\nby Charles L. Perkins\n483\nP2\/V4\/sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 App B LP#3 MTWRFSS\nB Class Hierarchy Diagrams\n484\nP2\/V4\/sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 App B LP#3 Sams.net Learning\nCenter\nabcd\nB\n485\nP2\/V4\/sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 App B LP#3 MTWRFSS\nB Class Hierarchy Diagrams\n486\nP2\/V4\/sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 App B LP#3 Sams.net Learning\nCenter\nabcd\nB\n487\nP2\/V4\/sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 App B LP#3 MTWRFSS\nB Class Hierarchy Diagrams\n488\nP2\/V4\/sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 App B LP#3 Sams.net Learning\nCenter\nabcd\nB\n489\nP2\/V4\/sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 App B LP#3 MTWRFSS\nB Class Hierarchy Diagrams\n490\nP2\/V4\/sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 App B LP#3 Sams.net Learning\nCenter\nabcd\nB\n491\nP2\/V4\/sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 App B LP#3 MTWRFSS\nB Class Hierarchy Diagrams\n492\nP2\/V4\/sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 App B LP#3 Sams.net Learning\nCenter\nabcd\nB\n493\nP2\/V4\/sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 App B LP#3 MTWRFSS\nB Class Hierarchy Diagrams\n494\nP2\/V4\/sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 App B LP#3 Sams.net Learning\nCenter\nabcd\nAbout These Diagrams\nThe diagrams in this appendix are class hierarchy diagrams for the package java and for all the\nsubpackages recursively below it in the Java beta binary release.\nEach page contains the class hierarchy for one package (or a subtree of a particularly large\npackage) with all its interfaces included, and each class in this tree is shown attached to its\nsuperclasses, even if they are on another page. A detailed key is located on the first page of this B\nappendix.\nNote: Win32Process and UNIXProcess appear in their respective distributions of\nJava, but both implement (essentially) the same protocol as their common abstract\nsuperclass\u2014Process\u2014so only it was included. This means that are no platform-\ndependent classes in the diagrams. (Of course, each release actually has some such\nclasses in its .class directories.) Several abstract classes have no subclasses in the\ndocumented library, but any concrete implementation of Java would define\nsubclasses of them.\nI supplemented the (incomplete) API documentation by looking through all the source files\n(below src\/java) to find all the (missing) package classes and their relationships.\nI\u2019ve heard there are various programs that auto-layout hierarchies for you, but I did these the old-\nfashioned way (in other words, I earned it, as J.H. used to say). One nice side effect is that these\ndiagrams should be more readable than a computer would produce, though you will have to live\nwith my aesthetic choices (sorry). I chose, for example, to attach lines through the center of each\nclass node, something which I think looks and feels better overall (to me) but which on occasion\ncan be a little confusing. Follow lines through the center of the classes (not at the corners, nor\nalong any line not passing through the center) to connect the dots mentally.\n495\nP2\/V4\/sqc 6 TY Java in 21 Days 030-4 ayanna 12.28.95 App B LP#3 Sams.net Learning\nCenter\nabcd\nC\nC\nC\nS\nS\nF\nR\nW\nThe Java Class\nT\nLibrary\nM\nby Laura Lemay\n497\n030-4s App C.i 497 1\/29\/96, 8:30 PM\nP2\/V4\/sqc6 TY Java in 21 Days 030-4 ayanna 12.28.95 App C LP#3\/4 MTWRFSS\nC The Java Class Library\nThis appendix provides a general overview of the classes available in the standard Java packages\n(that is, the classes that are guaranteed to be available in any Java implementation). This\nappendix is intended for general reference; for more information about class inheritance and the\nexceptions defined for each package, see Appendix B. For more specific information about each\nvariable and the methods within each class, see the API documentation from Sun at http:\/\/\njava.sun.com.\njava.lang\nThe java.lang package contains the classes and interfaces that make up the core Java language.\nInterfaces\nRunnable Methods for classes that want to run as threads\nClasses\nBoolean Object wrapper for boolean values\nCharacter Object wrapper for char values\nClass Run-time representations of classes\nClassLoader Abstract behavior for handling loading of classes\nDouble Object wrapper for double values\nFloat Object wrapper for float values\nInteger Object wrapper for int values\nLong Object wrapper for long values\nMath Utility class for math operations\nNumber Abstract superclass of all number classes (Integer,\nFloat, and so on)\nObject Generic Object class, at top of inheritance hierarchy\nProcess Abstract behavior for processes such as those spawned\nusing methods in the System class\nRuntime Access to the Java run-time\nSecurityManager Abstract behavior for implementing security policies\nString Character strings\nStringBuffer Mutable strings\nSystem Access to Java\u2019s system-level behavior, provided in a\nplatform-independent way\n498\n030-4s App C.i 498 1\/29\/96, 8:30 PM\nP2\/V4\/sqc6 TY Java in 21 Days 030-4 ayanna 12.28.95 App C LP#3\/4 Sams.net Learning\nCenter\nabcd\nThread Methods for managing threads and classes that run in\nthreads\nThreadGroup A group of threads\nThrowable Generic Exception class; all objects thrown must be a\nThrowable\njava.util\nThe java.util package contains various utility classes and interfaces, including random\nnumbers, system properties, and other useful classes.\nC\nInterfaces\nEnumeration Methods for enumerating sets of values\nObserver Methods for allowing classes to observe Observable\nobjects\nClasses\nBitSet A set of bits\nDate The current system date, as well as methods for\ngenerating and parsing dates\nDictionary An abstract class that maps between keys and values\n(superclass of HashTable)\nHashtable A hash table\nObservable An abstract class for observable objects\nProperties A hashtable that contains behavior for setting and\nretrieving persistent properties of the system or of a\nclass\nRandom Utilities for generating random numbers\nStack A stack (a last-in-first-out queue)\nStringTokenizer Utilities for splitting strings into a sequence of\nindividual \u201ctokens\u201d\nVector A growable array of Objects\n499\n030-4s App C.i 499 1\/29\/96, 8:30 PM\nP2\/V4\/sqc6 TY Java in 21 Days 030-4 ayanna 12.28.95 App C LP#3\/4 MTWRFSS\nC The Java Class Library\njava.io\nThe java.io package provides input and output classes and interfaces for streams and files.\nInterfaces\nDataInput Methods for reading machine-independent typed\ninput streams\nDataOutput Methods for writing machine-independent typed\noutput streams\nFilenameFilter Methods for filtering file names\nClasses\nBufferedInputStream A buffered input stream\nBufferedOutputStream A buffered output stream\nByteArrayInputStream An input stream from a byte array\nByteArrayOutputStream An output stream to a byte array\nDataInputStream Enables you to read primitive Java types\n(ints, chars, booleans, and so on) from a\nstream in a machine-independent way\nDataOutputStream Enables you to write primitive Java data\ntypes (ints, chars, booleans, and so on) to a\nstream in a machine-independent way\nFile Represents a file on the host\u2019s file system\nFileInputStream An input stream from a file, constructed\nusing a filename or descriptor\nFileOutputStream An output stream to a file, constructed using\na filename or descriptor\nFilterInputStream Abstract class which provides a filter for\ninput streams (and for adding stream\nfunctionality such as buffering)\nFilterOutputStream Abstract class which provides a filter for\noutput streams (and for adding stream\nfunctionality such as buffering)\nInputStream An abstract class representing an input\nstream of bytes; the parent of all input\nstreams in this package\n500\n030-4s App C.i 500 1\/29\/96, 8:31 PM\nP2\/V4\/sqc6 TY Java in 21 Days 030-4 ayanna 12.28.95 App C LP#3\/4 Sams.net Learning\nCenter\nabcd\nLineNumberInputStream An input stream that keeps track of line\nnumbers\nOutputStream An abstract class representing an output\nstream of bytes; the parent of all output\nstreams in this package\nPipedInputStream A piped input stream, which should be\nconnected to a PipedOutputStream to be\nuseful\nPipedOutputStream A piped output stream, which should be\nconnected to a PipedInputStream to be\nuseful (together they provide safe communi-\ncation between threads) C\nPrintStream An output stream for printing (used by\nSystem.out.printIn(...))\nPushbackInputStream An input stream with a 1-byte push back\nbuffer\nRandomAccessFile Provides random-access to a file, constructed\nfrom filenames, descriptors, or objects\nSequenceInputStream Converts a sequence of input streams into a\nsingle input steam\nStreamTokenizer Converts an input stream into a sequence of\nindividual tokens\nStringBufferInputStream An input stream from a StringBuffer object\njava.net\nThe java.net package contains classes and interfaces for performing network operations, such\nas sockets and URLs.\nInterfaces\nContentHandlerFactory Methods for creating ContentHandler objects\nSocketImplFactory Methods for creating socket implementa-\ntions (instance of the SocketImpl class)\nURLStreamHandlerFactory Methods for creating URLStreamHandler\nobjects\n501\n030-4s App C.i 501 1\/29\/96, 8:31 PM\nP2\/V4\/sqc6 TY Java in 21 Days 030-4 ayanna 12.28.95 App C LP#3\/4 MTWRFSS\nC The Java Class Library\nClasses\nContentHandler Abstract behavior for reading data from a URL\nconnection and constructing the appropriate local\nobject, based on MIME types\nInetAddress An object representation of an Internet host (host\nname, IP address)\nServerSocket A server-side socket\nSocket A socket\nSocketImpl An abstract class for specific socket implementations\nURL An object representation of a URL\nURLConnection Abstract behavior for a socket that can handle various\nWeb-based protocols (http, ftp, and so on)\nURLStreamHandler Abstract class for managing streams to object refer-\nenced by URLs\njava.awt\nThe java.awt package contains the classes and interfaces that make up the Abstract Windowing\nToolkit.\nInterfaces\nLayoutManager Methods for laying out containers\nMenuContainer Methods for menu-related containers\nClasses\nBorderLayout A layout manager for arranging items in border\nformation\nButton A UI pushbutton\nCanvas A canvas for drawing and performing other graphics\noperations\nCardLayout A layout manager for HyperCard-like metaphors\nCheckbox A checkbox\nCheckboxGroup A group of exclusive checkboxes (radio buttons)\nCheckboxMenuItem A toggle menu item\n502\n030-4s App C.i 502 1\/29\/96, 8:31 PM\nP2\/V4\/sqc6 TY Java in 21 Days 030-4 ayanna 12.28.95 App C LP#3\/4 Sams.net Learning\nCenter\nabcd\nChoice A popup menu of choices\nColor An abstract representation of a color\nComponent The abstract generic class for all UI components\nContainer Abstract behavior for a component that can hold\nother components or containers\nDialog A window for brief interactions with users\nDimension Width and height\nEvent An object representing events caused by the system or\nbased on user input\nFileDialog A dialog for getting file names from the local file\nsystem C\nFlowLayout A layout manager that lays out objects from left to\nright in rows\nFont An abstract representation of a font\nFontMetrics Abstract class for holding information about a specific\nfont\u2019s character shapes and height and width infor-\nmation\nFrame A top-level window with a title\nGraphics Abstract behavior for representing a graphics context,\nand for drawing and painting shapes and objects\nGridBagConstraints Constraints for components laid out using\nGridBagLayout\nGridBagLayout A layout manager that aligns components horizon-\ntally and vertically based on their values from\nGridBagConstraints\nGridLayout A layout manager with rows and columns; elements\nare added to each cell in the grid\nImage An abstract representation of a bitmap image\nInsets Distances from the outer border of the window; used\nto lay out components\nLabel A text label for UI components\nList A scrolling list\nMediaTracker A way to keep track of the status of media objects\nbeing loaded over the net\nMenu A menu, which can contain menu items and is a\ncontainer on a menubar\n503\n030-4s App C.i 503 1\/29\/96, 8:31 PM\nP2\/V4\/sqc6 TY Java in 21 Days 030-4 ayanna 12.28.95 App C LP#3\/4 MTWRFSS\nC The Java Class Library\nMenuBar A menubar (container for menus)\nMenuComponent The abstract superclass of all menu elements\nMenuItem An individual menu item\nPanel A container that is displayed\nPoint x and y coordinates\nPolygon A set of points\nRectangle x and y coordinates for the top corner, plus width and\nheight\nScrollbar A UI scrollbar object\nTextArea A multiline, scrollable, editable text field\nTextComponent The superclass of all editable text components\nTextField A fixed-size editable text field\nToolkit Abstract behavior for binding the abstract AWT\nclasses to a platform-specific toolkit implementation\nWindow A top-level window, and the superclass of the Frame\nand Dialog classes\njava.awt.image\nThe java.awt.image package is a subpackage of the AWT that provides classes for managing\nbitmap images.\nInterfaces\nImageConsumer Methods for receiving image data created by an\nImageProducer\nImageObserver Methods to track the loading and construction of an\nimage\nImageProducer Methods to construct or filter image data\nClasses\nColorModel An abstract class for managing color information for\nimages\nCropImageFilter A filter for cropping images to a particular size\nDirectColorModel A specific color model for managing and translating\npixel color values\n504\n030-4s App C.i 504 1\/29\/96, 8:31 PM\nP2\/V4\/sqc6 TY Java in 21 Days 030-4 ayanna 12.28.95 App C LP#3\/4 Sams.net Learning\nCenter\nabcd\nFilteredImageSource An ImageProducer that takes an image and an\nImageFilter object and produces an image for an\nImageConsumer\nImageFilter A filter that takes image data from an ImageProducer,\nmodifies it in some way, and hands it off to a\nImageConsumer\nIndexColorModel A specific color model for managing and translating\ncolor values in a fixed-color map\nMemoryImageSource An image producer that gets its image from memory;\nused to construct an image by hand\nRGBImageFilter Abstract behavior for a filter that modifies the RGB\nvalues of pixels in RGB images C\njava.awt.peer\nThe java.awt.peer package is a subpackage of AWT that provides the (hidden) platform-\nspecific AWT classes (for example, for Motif, Macintosh, or Windows 95) with platform-\nindependent interfaces to implement. Thus, callers using these interfaces need not know which\nplatform\u2019s window system these hidden AWT classes are currently implementing.\nEach class in the AWT that inherits from either Component or MenuComponent has a corresponding\npeer class. Each of those classes is the name of the Component with -Peer added (for example,\nButtonPeer, DialogPeer, and WindowPeer). Because each one provides similar behavior, they are\nnot enumerated here.\njava.applet\nThe java.applet package provides applet-specific behavior.\nInterfaces\nAppletContext Methods to refer to the applet\u2019s context\nAppletStub Methods for nonbrowser applet viewers\nAudioClip Methods for playing audio files\nClasses\nApplet The base applet class\n505\n030-4s App C.i 505 1\/29\/96, 8:31 PM\nP2\/V4\/sqc6 TY Java in 21 Days 030-4 ayanna 12.28.95 App C LP#3\/4 Sams.net Learning\nCenter\nabcd\nD\nD\nS\nS\nD\nF\nR\nW\nHow Java Differs\nT\nfrom C and C++\nM\nby Laura Lemay\n507\n030-4s App D.i 507 1\/29\/96, 8:32 PM\nP2\/V4\/SQC6 TY Java in 21 Days 030-4 ayanna 12.28.95 App D LP#3 MTWRFSS\nD How Java Differs from C and C++\nThis appendix contains a description of most of the major differences between C, C++ , and the\nJava language. If you are a programmer familiar with either C or C++, you may want to review\nthis appendix to catch some of the common mistakes and assumptions programmers make when\nusing Java.\nPointers\nJava does not have an explicit pointer type. Instead of pointers, all references to objects\u2014\nincluding variable assignments, arguments passed into methods, and array elements\u2014are\naccomplished by using implicit references. References and pointers are essentially the same thing\nexcept that you can\u2019t do pointer arithmetic on references (nor do you need to).\nReference semantics also enable structures such as linked lists to be created easily in Java without\nexplicit pointers; merely create a linked list node with variables that point to the next and the\nprevious node. Then, to insert items in the list, assign those variables to other node objects.\nArrays\nArrays in Java are first class objects, and references to arrays and their contents are accomplished\nthrough explicit references rather than via point arithmetic. Array boundaries are strictly\nenforced; attempting to read past the ends of an array is a compile or run-time error. As with\nother objects, passing an array to a method passes a reference to the original array, so changing\nthe contents of that array reference changes the original array object.\nArrays of objects are arrays of references that are not automatically initialized to contain actual\nobjects. Using the following Java code produces an array of type MyObject with ten elements, but\nthat array initially contains only nulls:\nMyObject arrayofobjs[] = new MyObject[10];\nYou must now add actual MyObject objects to that array:\nfor (int i; i< arrayofobjs.length. i++) {\narrayofobjs[i] = new MyObject();\nJava does not support multidimensional arrays as in C and C++. In Java, you must create arrays\nthat contain other arrays.\nStrings\nStrings in C and C++ are arrays of characters, terminated by a null character (\\0). To operate\non and manage strings, you treat them as you would any other array, with all the inherent\ndifficulties of keeping track of pointer arithmetic and being careful not to stray off the end of\nthe array.\n508\n030-4s App D.i 508 1\/29\/96, 8:33 PM\nP2\/V4\/SQC6 TY Java in 21 Days 030-4 ayanna 12.28.95 App D LP#3 Sams.net Learning\nCenter\nabcd\nStrings in Java are objects, and all methods that operate on strings can treat the string as a\ncomplete entity. Strings are not terminated by a null, nor can you accidentally overstep the end\nof a string (like arrays, string boundaries are strictly enforced).\nMemory Management\nAll memory management in Java is automatic; memory is allocated automatically when an\nobject is created, and a run-time garbage collector (the \u201cGC\u201d) frees that memory when the object\nis no longer in use. C\u2019s malloc and free functions do not exist in Java.\nTo \u201cforce\u201d an object to be freed, remove all references to that object (assign variables holding\nit to null, remove it from arrays, and so on). The next time the Java GC runs, that object is\nreclaimed.\nData Types\nAs mentioned in the early part of this book, all Java primitive data types (char, int, long, and\nso on) have consistent sizes and behavior across platforms and operating systems. There are no D\nunsigned data types as in C and C++ (except for char, which is a 16-bit unsigned integer).\nThe boolean primitive data type can have two values: true or false. Boolean is not an integer,\nnor can it be treated as one, although you cannot cast 0 or 1 (integers) to boolean types in Java.\nComposite data types are accomplished in Java exclusively through the use of class definitions.\nThe struct, union, and typedef keywords have all been removed in favor of classes.\nCasting between data types is much more controlled in Java; automatic casting occurs only when\nthere will be no loss of information. All other casts must be explicit. The primitive data types\n(int, float, long, char, boolean, and so on) cannot be cast to objects or vice versa; there are\nmethods and special \u201cwrapper\u201d classes to convert values between objects and primitive types.\nOperators\nOperator precedence and association behaves as it does in C. Note, however, that the new\nkeyword (for creating a new object) binds tighter than dot notation (.), which is different\nbehavior from C++. In particular, note the following expression:\nnew foo().bar;\nThis expression operates as if it were written like this:\n(new foo()).bar;\nOperator overloading, as in C++, cannot be accomplished in Java. The , operator of C has been\ndeleted.\n509\n030-4s App D.i 509 1\/29\/96, 8:33 PM\nP2\/V4\/SQC6 TY Java in 21 Days 030-4 ayanna 12.28.95 App D LP#3 MTWRFSS\nD How Java Differs from C and C++\nThe >>> operator produces an unsigned logical right shift (remember, there are no unsigned data\ntypes).\nThe + operator can be used to concatenate strings.\nControl Flow\nAlthough the if, while, for, and do statements in Java are syntactically the same as they are in\nC and C++, there is one significant difference. The test expression for each control flow construct\nmust return an actual boolean value (true or false). In C and C++, the expression can return\nan integer.\nArguments\nJava does not support mechanisms for optional arguments or for variable-length argument lists\nto functions as in C and C++. All method definitions must have a specific number of arguments.\nCommand-line arguments in Java behave differently from those in C and C++. The first element\nin the argument vector (argv[0]) in C and C++ is the name of the program itself; in Java, that\nfirst argument is the first of the additional arguments. In other words, in Java, argv[0] is argv[1]\nin C and C++; there is no way to get hold of the actual name of the Java program.\nOther Differences\nThe following other minor differences from C and C++ exist in Java:\nnn Java does not have a preprocessor, and as such, does not have #defines or macros.\nConstants can be created by using the final modifier when declaring class and instance\nvariables.\nnn Java does not have template classes as in C++.\nnn Java does not include C\u2019s const keyword or the ability to pass by const reference\nexplicitly.\nnn Java classes are singly inherited, with some multiple-inheritance features provided\nthrough interfaces.\nnn All functions are implemented as methods. There are no functions that are not tied to\nclasses.\nnn The goto keyword does not exist in Java (it\u2019s a reserved word, but currently\nunimplemented). You can, however, use labeled breaks and continues to break out of\nand continue executing complex switch or loop constructs.\n510\n030-4s App D.i 510 1\/29\/96, 8:33 PM\nP2\/V4\/SQC6 TY Java in 21 Days 030-4 ayanna 12.28.95 App D LP#3 "}